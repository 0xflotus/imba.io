/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

// imba$inlineHelpers=1

var TOK = exports.TOK = {};
var TTERMINATOR = TOK.TERMINATOR = 1;
var TIDENTIFIER = TOK.IDENTIFIER = TOK.IVAR = 2;
var CONST = TOK.CONST = 3;
var VAR = TOK.VAR = 4;
var IF = TOK.IF = 5;
var ELSE = TOK.ELSE = 6;
var DEF = TOK.DEF = 7;

function Token(type,value,loc,len){
	this._type = type;
	this._value = value;
	this._loc = (loc != null) ? loc : (-1);
	this._len = len || 0;
	this._meta = null;
	this.generated = false;
	this.newLine = false;
	this.spaced = false;
	this.call = false;
	return this;
};

exports.Token = Token; // export class 
Token.prototype.type = function (){
	return this._type;
};

Token.prototype.value = function (){
	return this._value;
};

Token.prototype.traverse = function (){
	return;
};

Token.prototype.c = function (){
	return "" + this._value;
};

Token.prototype.toString = function (){
	return this._value;
};

Token.prototype.charAt = function (i){
	return this._value.charAt(i);
};

Token.prototype.slice = function (i){
	return this._value.slice(i);
};

Token.prototype.region = function (){
	return [this._loc,this._loc + (this._len || this._value.length)];
};

Token.prototype.sourceMapMarker = function (){
	return (this._loc == -1) ? ':' : (("%$" + (this._loc) + "$%"));
	// @col == -1 ? '' : "%%{@line}${@col}%%"
};


function lex(){
	var token = this.tokens[this.pos++];
	var ttag;
	
	if (token) {
		ttag = token._type;
		this.yytext = token;
	} else {
		ttag = '';
	};
	
	return ttag;
}; exports.lex = lex;


// export def token typ, val, line, col, len do Token.new(typ,val,line, col or 0, len or 0) # [null,typ,val,loc]
function token(typ,val){
	return new Token(typ,val,-1,0);
}; exports.token = token;

function typ(tok){
	return tok._type;
}; exports.typ = typ;
function val(tok){
	return tok._value;
}; exports.val = val; // tok[offset + 1]
function line(tok){
	return tok._line;
}; exports.line = line; // tok[offset + 2]
function loc(tok){
	return tok._loc;
}; exports.loc = loc; // tok[offset + 2]

function setTyp(tok,v){
	return tok._type = v;
}; exports.setTyp = setTyp;
function setVal(tok,v){
	return tok._value = v;
}; exports.setVal = setVal;
function setLine(tok,v){
	return tok._line = v;
}; exports.setLine = setLine;
function setLoc(tok,v){
	return tok._loc = v;
}; exports.setLoc = setLoc;


var LBRACKET = exports.LBRACKET = new Token('{','{',0,0,0);
var RBRACKET = exports.RBRACKET = new Token('}','}',0,0,0);

var LPAREN = exports.LPAREN = new Token('(','(',0,0,0);
var RPAREN = exports.RPAREN = new Token(')',')',0,0,0);

LBRACKET.generated = true;
RBRACKET.generated = true;
LPAREN.generated = true;
RPAREN.generated = true;

var INDENT = exports.INDENT = new Token('INDENT','2',0,0,0);
var OUTDENT = exports.OUTDENT = new Token('OUTDENT','2',0,0,0);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };

function brace(str){
	var lines = str.match(/\n/);
	// what about indentation?
	
	if (lines) {
		return '{' + str + '\n}';
	} else {
		return '{\n' + str + '\n}';
	};
}; exports.brace = brace;

function normalizeIndentation(str){
	var m;
	var reg = /\n+([^\n\S]*)/g;
	var ind = null;
	
	var length_;while (m = reg.exec(str)){
		var attempt = m[1];
		if (ind == null || 0 < (length_ = attempt.length) && length_ < ind.length) {
			ind = attempt;
		};
	};
	
	if (ind) { str = str.replace(RegExp(("\\n" + ind),"g"),'\n') };
	return str;
}; exports.normalizeIndentation = normalizeIndentation;


function flatten(arr){
	var out = [];
	arr.forEach(function(v) { return (v instanceof Array) ? out.push.apply(out,flatten(v)) : out.push(v); });
	return out;
}; exports.flatten = flatten;


function pascalCase(str){
	return str.replace(/(^|[\-\_\s])(\w)/g,function(m,v,l) { return l.toUpperCase(); });
}; exports.pascalCase = pascalCase;

function camelCase(str){
	str = String(str);
	// should add shortcut out
	return str.replace(/([\-\_\s])(\w)/g,function(m,v,l) { return l.toUpperCase(); });
}; exports.camelCase = camelCase;

function dashToCamelCase(str){
	str = String(str);
	if (str.indexOf('-') >= 0) {
		// should add shortcut out
		str = str.replace(/([\-\s])(\w)/g,function(m,v,l) { return l.toUpperCase(); });
	};
	return str;
}; exports.dashToCamelCase = dashToCamelCase;

function snakeCase(str){
	var str = str.replace(/([\-\s])(\w)/g,'_');
	return str.replace(/()([A-Z])/g,"_$1",function(m,v,l) { return l.toUpperCase(); });
}; exports.snakeCase = snakeCase;

function setterSym(sym){
	return dashToCamelCase(("set-" + sym));
}; exports.setterSym = setterSym;

function quote(str){
	return '"' + str + '"';
}; exports.quote = quote;

function singlequote(str){
	return "'" + str + "'";
}; exports.singlequote = singlequote;

function symbolize(str){
	str = String(str);
	var end = str.charAt(str.length - 1);
	
	if (end == '=') {
		str = 'set' + str[0].toUpperCase() + str.slice(1,-1);
	};
	
	if (str.indexOf("-") >= 0) {
		str = str.replace(/([\-\s])(\w)/g,function(m,v,l) { return l.toUpperCase(); });
	};
	
	return str;
}; exports.symbolize = symbolize;


function indent(str){
	return String(str).replace(/^/g,"\t").replace(/\n/g,"\n\t").replace(/\n\t$/g,"\n");
}; exports.indent = indent;

function bracketize(str,ind){
	if(ind === undefined) ind = true;
	if (ind) { str = "\n" + indent(str) + "\n" };
	return '{' + str + '}';
}; exports.bracketize = bracketize;

function parenthesize(str){
	return '(' + String(str) + ')';
}; exports.parenthesize = parenthesize;

function unionOfLocations(){
	var $0 = arguments, j = $0.length;
	var locs = new Array(j>0 ? j : 0);
	while(j>0) locs[j-1] = $0[--j];
	var a = Infinity;
	var b = -Infinity;
	
	for (var i = 0, ary = iter$(locs), len = ary.length, loc; i < len; i++) {
		loc = ary[i];
		if (loc && loc._loc != undefined) {
			loc = loc._loc;
		};
		
		if (loc && (loc.loc instanceof Function)) {
			loc = loc.loc();
		};
		
		if (loc instanceof Array) {
			if (a > loc[0]) { a = loc[0] };
			if (b < loc[0]) { b = loc[1] };
		} else if ((typeof loc=='number'||loc instanceof Number)) {
			if (a > loc) { a = loc };
			if (b < loc) { b = loc };
		};
	};
	
	return [a,b];
}; exports.unionOfLocations = unionOfLocations;



function locationToLineColMap(code){
	var lines = code.split(/\n/g);
	var map = [];
	
	var chr;
	var loc = 0;
	var col = 0;
	var line = 0;
	
	while (chr = code[loc]){
		map[loc] = [line,col];
		
		if (chr == '\n') {
			line++;
			col = 0;
		} else {
			col++;
		};
		
		loc++;
	};
	
	return map;
}; exports.locationToLineColMap = locationToLineColMap;

function markLineColForTokens(tokens,code){
	return this;
}; exports.markLineColForTokens = markLineColForTokens;

function parseArgs(argv,o){
	var env_;
	if(o === undefined) o = {};
	var aliases = o.alias || (o.alias = {});
	var groups = o.groups || (o.groups = []);
	var schema = o.schema || {};
	
	schema.main = {};
	
	var options = {};
	var explicit = {};
	argv = argv || process.argv.slice(2);
	var curr = null;
	var i = 0;
	var m;
	
	while ((i < argv.length)){
		var arg = argv[i];
		i++;
		
		if (m = arg.match(/^\-([a-zA-Z]+)$/)) {
			curr = null;
			var chars = m[1].split('');
			
			for (var i1 = 0, ary = iter$(chars), len = ary.length, item; i1 < len; i1++) {
				// console.log "parsing {item} at {i}",aliases
				item = ary[i1];
				var key = aliases[item] || item;
				chars[i1] = key;
				options[key] = true;
			};
			
			if (chars.length == 1) {
				curr = chars;
			};
		} else if (m = arg.match(/^\-\-([a-z0-9\-\_A-Z]+)$/)) {
			var val = true;
			key = m[1];
			
			if (key.indexOf('no-') == 0) {
				key = key.substr(3);
				val = false;
			};
			
			for (var j = 0, items = iter$(groups), len_ = items.length, g; j < len_; j++) {
				g = items[j];
				if (key.substr(0,g.length) == g) {
					console.log('should be part of group');
				};
			};
			
			key = dashToCamelCase(key);
			
			options[key] = val;
			curr = key;
		} else {
			if (!(curr && schema[curr])) {
				curr = 'main';
			};
			
			if (arg.match(/^\d+$/)) {
				arg = parseInt(arg);
			};
			
			val = options[curr];
			if (val == true || val == false) {
				options[curr] = arg;
			} else if ((typeof val=='string'||val instanceof String) || (typeof val=='number'||val instanceof Number)) {
				options[curr] = [val].concat(arg);
			} else if (val instanceof Array) {
				val.push(arg);
			} else {
				options[curr] = arg;
			};
		};
	};
	
	
	if ((typeof (env_ = options.env)=='string'||env_ instanceof String)) {
		options[("ENV_" + (options.env))] = true;
	};
	
	return options;
}; exports.parseArgs = parseArgs;

var ansi = exports.ansi = {
	bold: function(text) { return '\u001b[1m' + text + '\u001b[22m'; },
	red: function(text) { return '\u001b[31m' + text + '\u001b[39m'; },
	green: function(text) { return '\u001b[32m' + text + '\u001b[39m'; },
	gray: function(text) { return '\u001b[90m' + text + '\u001b[39m'; },
	white: function(text) { return '\u001b[37m' + text + '\u001b[39m'; }
};



/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 2 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

// helper for subclassing
function subclass$(obj,sup) {
	for (var k in sup) {
		if (sup.hasOwnProperty(k)) obj[k] = sup[k];
	};
	// obj.__super__ = sup;
	obj.prototype = Object.create(sup.prototype);
	obj.__super__ = obj.prototype.__super__ = sup.prototype;
	obj.prototype.initialize = obj.prototype.constructor = obj;
};

// imba$inlineHelpers=1
// create separate error-types with all the logic

var util = __webpack_require__(1);

function ImbaParseError(e,o){
	this.error = e;
	this.message = e.message;
	this.filename = e.filename;
	this.line = e.line;
	this._options = o || {};
	this;
};

subclass$(ImbaParseError,Error);
exports.ImbaParseError = ImbaParseError; // export class 
ImbaParseError.wrap = function (err){
	// what about the stacktrace?
	return new ImbaParseError(err);
};

ImbaParseError.prototype.set = function (opts){
	this._options || (this._options = {});
	for (var v, i = 0, keys = Object.keys(opts), l = keys.length, k; i < l; i++){
		k = keys[i];v = opts[k];this._options[k] = v;
	};
	return this;
};

ImbaParseError.prototype.start = function (){
	var o = this._options;
	var idx = o.pos - 1;
	var tok = o.tokens && o.tokens[idx];
	while (tok && tok._loc == -1){
		tok = o.tokens[--idx];
	};
	return tok;
};

ImbaParseError.prototype.desc = function (){
	var o = this._options;
	var msg = this.message;
	if (o.token && o.token._loc == -1) {
		return 'Syntax Error';
	} else {
		return msg;
	};
};

ImbaParseError.prototype.loc = function (){
	var start_;
	return (start_ = this.start()) && start_.region  &&  start_.region();
};

ImbaParseError.prototype.toJSON = function (){
	var o = this._options;
	var tok = this.start();
	return {warn: true,message: this.desc(),loc: this.loc()};
};

ImbaParseError.prototype.excerpt = function (pars){
	
	if(!pars||pars.constructor !== Object) pars = {};
	var gutter = pars.gutter !== undefined ? pars.gutter : true;
	var colors = pars.colors !== undefined ? pars.colors : false;
	var details = pars.details !== undefined ? pars.details : true;
	var code = this._code;
	var loc = this.loc();
	var lines = code.split(/\n/g);
	var locmap = util.locationToLineColMap(code);
	var lc = locmap[loc[0]] || [0,0];
	var ln = lc[0];
	var col = lc[1];
	var line = lines[ln];
	
	var ln0 = Math.max(0,ln - 2);
	var ln1 = Math.min(ln0 + 5,lines.length);
	var lni = ln - ln0;
	var l = ln0;
	
	var res = [];while (l < ln1){
		res.push((line = lines[l++]));
	};var out = res;
	
	if (gutter) {
		out = out.map(function(line,i) {
			var prefix = ("" + (ln0 + i + 1));
			while (prefix.length < String(ln1).length){
				prefix = (" " + prefix);
			};
			if (i == lni) {
				return ("   -> " + prefix + " | " + line);
			} else {
				return ("      " + prefix + " | " + line);
			};
		});
	};
	
	if (colors) {
		out[lni] = util.ansi.red(util.ansi.bold(out[lni]));
	};
	
	if (details) {
		out.unshift(this.message);
	};
	
	return out.join('\n');
};

ImbaParseError.prototype.prettyMessage = function (){
	var excerpt;
	return excerpt = this.excerpt();
};


/***/ }),
/* 4 */
/***/ (function(module, exports) {

function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
// imba$inlineHelpers=1
// List of the token pairs that must be balanced.
var BALANCED_PAIRS = exports.BALANCED_PAIRS = [
	['(',')'],
	['[',']'],
	['{','}'],
	['{{','}}'],
	['INDENT','OUTDENT'],
	['CALL_START','CALL_END'],
	['PARAM_START','PARAM_END'],
	['INDEX_START','INDEX_END'],
	['TAG_START','TAG_END'],
	['BLOCK_PARAM_START','BLOCK_PARAM_END']
];

// The inverse mappings of `BALANCED_PAIRS` we're trying to fix up, so we can
// look things up from either end.
var INVERSES = exports.INVERSES = {};

// The tokens that signal the start/end of a balanced pair.
// var EXPRESSION_START = []
// var EXPRESSION_END   = []

for (var i = 0, ary = iter$(BALANCED_PAIRS), len = ary.length, pair; i < len; i++) {
	pair = ary[i];
	var left = pair[0];
	var rite = pair[1];
	INVERSES[rite] = left;
	INVERSES[left] = rite;
};


var ALL_KEYWORDS = exports.ALL_KEYWORDS = [
	'true','false','null','this',
	'delete','typeof','in','instanceof',
	'throw','break','continue','debugger',
	'if','else','switch','for','while','do','try','catch','finally',
	'class','extends','super','return',
	'undefined','then','unless','until','loop','of','by',
	'when','def','tag','do','elif','begin','var','let','self','await','import',
	'and','or','is','isnt','not','yes','no','isa','case','nil','require'
];

var TOK = exports.TOK = {
	TERMINATOR: 'TERMINATOR',
	INDENT: 'INDENT',
	OUTDENT: 'OUTDENT',
	DEF_BODY: 'DEF_BODY',
	THEN: 'THEN',
	CATCH: 'CATCH'
};

var OPERATOR_ALIASES = exports.OPERATOR_ALIASES = {
	and: '&&',
	or: '||',
	is: '==',
	isnt: '!=',
	isa: 'instanceof'
};

var HEREGEX_OMIT = exports.HEREGEX_OMIT = /\s+(?:#.*)?/g;
var HEREGEX = exports.HEREGEX = /^\/{3}([\s\S]+?)\/{3}([imgy]{0,4})(?!\w)/;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var Imba = __webpack_require__(6);
/*
Imba is the namespace for all runtime related utilities
@namespace
*/

var Imba = {VERSION: '1.0.0'};

/*
True if running in client environment.
@return {bool}
*/

Imba.isClient = function (){
	return false;
};

/*
True if running in server environment.
@return {bool}
*/

Imba.isServer = function (){
	return false;
};


/*

Light wrapper around native setTimeout that expects the block / function
as last argument (instead of first). It also triggers an event to Imba
after the timeout to let schedulers update (to rerender etc) afterwards.

*/

Imba.setTimeout = function (delay,block){
	return setTimeout(function() {
		block();
		return Imba.commit();
	},delay);
};

/*

Light wrapper around native setInterval that expects the block / function
as last argument (instead of first). It also triggers an event to Imba
after every interval to let schedulers update (to rerender etc) afterwards.

*/

Imba.setInterval = function (interval,block){
	return setInterval(function() {
		block();
		return Imba.commit();
	},interval);
};

/*
Clear interval with specified id
*/

Imba.clearInterval = function (id){
	return clearInterval(id);
};

/*
Clear timeout with specified id
*/

Imba.clearTimeout = function (id){
	return clearTimeout(id);
};


Imba.subclass = function (obj,sup){
	var v;
	for (var k in sup){
		v = sup[k];if (sup.hasOwnProperty(k)) { obj[k] = v };
	};
	
	obj.prototype = Object.create(sup.prototype);
	obj.__super__ = obj.prototype.__super__ = sup.prototype;
	obj.prototype.initialize = obj.prototype.constructor = obj;
	return obj;
};

/*
Lightweight method for making an object iterable in imbas for/in loops.
If the compiler cannot say for certain that a target in a for loop is an
array, it will cache the iterable version before looping.

```imba
# this is the whole method
def Imba.iterable o
	return o ? (o:toArray ? o.toArray : o) : []

class CustomIterable
	def toArray
		[1,2,3]

# will return [2,4,6]
for x in CustomIterable.new
	x * 2

```
*/

Imba.iterable = function (o){
	return o ? ((o.toArray ? o.toArray() : o)) : [];
};

/*
Coerces a value into a promise. If value is array it will
call `Promise.all(value)`, or if it is not a promise it will
wrap the value in `Promise.resolve(value)`. Used for experimental
await syntax.
@return {Promise}
*/

Imba.await = function (value){
	if (value instanceof Array) {
		return Promise.all(value);
	} else if (value && value.then) {
		return value;
	} else {
		return Promise.resolve(value);
	};
};

var dashRegex = /-./g;

Imba.toCamelCase = function (str){
	if (str.indexOf('-') >= 0) {
		return str.replace(dashRegex,function(m) { return m.charAt(1).toUpperCase(); });
	} else {
		return str;
	};
};

Imba.indexOf = function (a,b){
	return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
};

Imba.len = function (a){
	return a && ((a.len instanceof Function) ? a.len.call(a) : a.length) || 0;
};

Imba.prop = function (scope,name,opts){
	if (scope.defineProperty) {
		return scope.defineProperty(name,opts);
	};
	return;
};

Imba.attr = function (scope,name,opts){
	if (scope.defineAttribute) {
		return scope.defineAttribute(name,opts);
	};
	
	var getName = Imba.toCamelCase(name);
	var setName = Imba.toCamelCase('set-' + name);
	
	scope.prototype[getName] = function() {
		return this.getAttribute(name);
	};
	
	scope.prototype[setName] = function(value) {
		this.setAttribute(name,value);
		return this;
	};
	return;
};

Imba.propDidSet = function (object,property,val,prev){
	var fn = property.watch;
	if (fn instanceof Function) {
		fn.call(object,val,prev,property);
	} else if ((typeof fn=='string'||fn instanceof String) && object[fn]) {
		object[fn](val,prev,property);
	};
	return;
};


// Basic events
function emit__(event,args,node){
	// var node = cbs[event]
	var prev,cb,ret;
	
	while ((prev = node) && (node = node.next)){
		if (cb = node.listener) {
			if (node.path && cb[node.path]) {
				ret = args ? cb[node.path].apply(cb,args) : cb[node.path]();
			} else {
				// check if it is a method?
				ret = args ? cb.apply(node,args) : cb.call(node);
			};
		};
		
		if (node.times && --node.times <= 0) {
			prev.next = node.next;
			node.listener = null;
		};
	};
	return;
};

// method for registering a listener on object
Imba.listen = function (obj,event,listener,path){
	var cbs,list,tail;
	cbs = obj.__listeners__ || (obj.__listeners__ = {});
	list = cbs[event] || (cbs[event] = {});
	tail = list.tail || (list.tail = (list.next = {}));
	tail.listener = listener;
	tail.path = path;
	list.tail = tail.next = {};
	return tail;
};

// register a listener once
Imba.once = function (obj,event,listener){
	var tail = Imba.listen(obj,event,listener);
	tail.times = 1;
	return tail;
};

// remove a listener
Imba.unlisten = function (obj,event,cb,meth){
	var node,prev;
	var meta = obj.__listeners__;
	if (!(meta)) { return };
	
	if (node = meta[event]) {
		while ((prev = node) && (node = node.next)){
			if (node == cb || node.listener == cb) {
				prev.next = node.next;
				// check for correct path as well?
				node.listener = null;
				break;
			};
		};
	};
	return;
};

// emit event
Imba.emit = function (obj,event,params){
	var cb;
	if (cb = obj.__listeners__) {
		if (cb[event]) { emit__(event,params,cb[event]) };
		if (cb.all) { emit__(event,[event,params],cb.all) }; // and event != 'all'
	};
	return;
};

Imba.observeProperty = function (observer,key,trigger,target,prev){
	if (prev && typeof prev == 'object') {
		Imba.unlisten(prev,'all',observer,trigger);
	};
	if (target && typeof target == 'object') {
		Imba.listen(target,'all',observer,trigger);
	};
	return this;
};

module.exports = Imba;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var Imba = __webpack_require__(6);
var Imba = __webpack_require__(5);
var activate = false;
if (typeof window !== 'undefined') {
	if (window.Imba) {
		console.warn(("Imba v" + (Imba.VERSION) + " is already loaded."));
		Imba = window.Imba;
	} else {
		window.Imba = Imba;
		activate = true;
		if (window.define && window.define.amd) {
			window.define("imba",[],function() { return Imba; });
		};
	};
};

module.exports = Imba;



if (activate) {
	Imba.EventManager.activate();
};




/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(5);

// externs;

var compiler = __webpack_require__(8);

var ImbaParseError = __webpack_require__(3).ImbaParseError;
var api = {};

function normalizeError(e,o){
	if (e.lexer && !(e instanceof ImbaParseError)) {
		e = new ImbaParseError(e,{tokens: e.lexer.tokens,pos: e.lexer.pos});
	};
	// else
	//	console.log 'error has no lexer but is parse-error',e:toJSON
	//	e = {message: e:message}
	
	if (e.toJSON) { // isa ImbaParseError
		// console.log 'converting error to json'
		e = e.toJSON();
	};
	
	if (e instanceof Error) {
		e = {message: e.message};
	};
	
	return e;
};

api.compile = function (code,o){
	if(o === undefined) o = {};
	try {
		var res = compiler.compile(code,o);
		var ret = {sourcemap: res.sourcemap,js: {body: res.toString()}};
		return ret;
	} catch (e) {
		return {error: normalizeError(e,o)};
	};
};

api.bundle = function (bundle,o){
	if(o === undefined) o = {};
	var output = {FILES: {}};
	
	for (var o1 = bundle.FILES, file, i = 0, keys = Object.keys(o1), l = keys.length, name; i < l; i++){
		name = keys[i];file = o1[name];if (name.match(/\.imba$/)) {
			var jsname = name.replace(/\.imba$/,'.js');
			var out = output.FILES[jsname] = {
				id: file.id,
				name: jsname
			};
			
			try {
				
				o.filename = name;
				o.sourcePath = name;
				o.targetPath = jsname;
				
				var res = compiler.compile(file.body,o);
				out.sourcemap = res.sourcemap;
				out.body = res.toString();
			} catch (e) {
				out.error = normalizeError(e,o);
			};
		};
	};
	return output;
};

api.analyze = function (code,o){
	if(o === undefined) o = {};
	var meta;
	try {
		var ast = compiler.parse(code,o);
		meta = ast.analyze({loglevel: 0});
	} catch (e) {
		// console.log "something wrong {e:message}",o.@tokens,e:toJSON
		e = normalizeError(e,o);
		meta = {warnings: [e]};
	};
	return {meta: meta};
};

onmessage = function onmessage(e){
	// console.log 'message to webworker',e:data
	var params = e.data;
	var id = params.id;
	var start = new Date();
	
	if (api[params[0]] instanceof Function) {
		var fn = api[params[0]];
		var result = fn.apply(api,params.slice(1));
		
		result.worker = {
			ref: id,
			action: params[0],
			elapsed: new Date() - start
		};
		
		return postMessage(result);
	};
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// imba$inlineHelpers=1
// var imba = require '../imba'
var T = __webpack_require__(0);
var util = __webpack_require__(1);
var lexer = __webpack_require__(9);
var rewriter = __webpack_require__(10);
var parser = exports.parser = __webpack_require__(11).parser;
var ast = __webpack_require__(12);

var ImbaParseError = __webpack_require__(3).ImbaParseError;

// Instantiate a Lexer for our use here.
var lex = exports.lex = new (lexer.Lexer)();
var Rewriter = exports.Rewriter = rewriter.Rewriter;
rewriter = new Rewriter();

parser.lexer = lex.jisonBridge();
parser.yy = ast; // everything is exported right here now


function tokenize(code,o){
	if(o === undefined) o = {};
	try {
		// console.log('tokenize') if o:profile
		if (o.profile) { console.time('tokenize') };
		o._source = code;
		lex.reset();
		var tokens = lex.tokenize(code,o);
		if (o.profile) { console.timeEnd('tokenize') };
		
		if (o.rewrite !== false) {
			tokens = rewriter.rewrite(tokens,o);
		};
		return tokens;
	} catch (err) {
		throw err;
	};
}; exports.tokenize = tokenize;

function rewrite(tokens,o){
	if(o === undefined) o = {};
	try {
		if (o.profile) { console.time('rewrite') };
		tokens = rewriter.rewrite(tokens,o);
		if (o.profile) { console.timeEnd('rewrite') };
	} catch (err) {
		throw err;
	};
	return tokens;
}; exports.rewrite = rewrite;


function parse(code,o){
	if(o === undefined) o = {};
	var tokens = (code instanceof Array) ? code : tokenize(code,o);
	try {
		if (tokens != code) o._source || (o._source = code);
		o._tokens = tokens;
		return parser.parse(tokens);
	} catch (err) {
		err._code = code;
		if (o.filename) { err._filename = o.filename };
		throw err;
	};
}; exports.parse = parse;


function compile(code,o){
	if(o === undefined) o = {};
	try {
		// check if code is completely blank
		if (!/\S/.test(code)) {
			return {js: ""};
		};
		
		var tokens = tokenize(code,o);
		var ast = parse(tokens,o);
		return ast.compile(o);
	} catch (err) {
		err._code = code;
		if (o.filename) { err._filename = o.filename };
		if (o.evaling) {
			console.log("error during compile",o.filename);
		};
		throw err;
	};
}; exports.compile = compile;

function analyze(code,o){
	if(o === undefined) o = {};
	var meta;
	try {
		var ast = parse(code,o);
		meta = ast.analyze(o);
	} catch (e) {
		if (!((e instanceof ImbaParseError))) {
			if (e.lexer) {
				e = new ImbaParseError(e,{tokens: e.lexer.tokens,pos: e.lexer.pos});
			} else {
				throw e;
			};
		};
		meta = {warnings: [e]};
	};
	return meta;
}; exports.analyze = analyze;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

function idx$(a,b){
	return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
// helper for subclassing
function subclass$(obj,sup) {
	for (var k in sup) {
		if (sup.hasOwnProperty(k)) obj[k] = sup[k];
	};
	// obj.__super__ = sup;
	obj.prototype = Object.create(sup.prototype);
	obj.__super__ = obj.prototype.__super__ = sup.prototype;
	obj.prototype.initialize = obj.prototype.constructor = obj;
};

// imba$inlineHelpers=1

var T = __webpack_require__(0);
var Token = T.Token;

var INVERSES = __webpack_require__(4).INVERSES;

var K = 0;

var ERR = __webpack_require__(3);

// Constants
// ---------

// Keywords that Imba shares in common with JavaScript.
var JS_KEYWORDS = [
	'true','false','null','this',
	'delete','typeof','in','instanceof',
	'throw','break','continue','debugger',
	'if','else','switch','for','while','do','try','catch','finally',
	'class','extends','super','return'
];

// new can be used as a keyword in imba, since object initing is done through
// MyObject.new. new is a very useful varname.

// We want to treat return like any regular call for now
// Must be careful to throw the exceptions in AST, since the parser
// wont

// Imba-only keywords. var should move to JS_Keywords
// some words (like tokid) should be context-specific
var IMBA_KEYWORDS = [
	'undefined','then','unless','until','loop','of','by',
	'when','def','tag','do','elif','begin','var','let','self','await','import','require'
];

var IMBA_CONTEXTUAL_KEYWORDS = ['extend','static','local','export','global','prop'];

// FixedArray for performance
// var ALL_KEYWORDS = JS_KEYWORDS.concat(IMBA_KEYWORDS)
var ALL_KEYWORDS = exports.ALL_KEYWORDS = [
	'true','false','null','this',
	'delete','typeof','in','instanceof',
	'throw','break','continue','debugger',
	'if','else','switch','for','while','do','try','catch','finally',
	'class','extends','super','return',
	'undefined','then','unless','until','loop','of','by',
	'when','def','tag','do','elif','begin','var','let','self','await','import',
	'and','or','is','isnt','not','yes','no','isa','case','nil','require'
];

// The list of keywords that are reserved by JavaScript, but not used, or are
// used by Imba internally. We throw an error when these are encountered,
// to avoid having a JavaScript error at runtime.  # 'var', 'let', - not inside here
var RESERVED = ['case','default','function','void','with','const','enum','native'];
var STRICT_RESERVED = ['case','function','void','const'];

// The superset of both JavaScript keywords and reserved words, none of which may
// be used as identifiers or properties.
var JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED);

var METHOD_IDENTIFIER = /^((([\x23]?[\$A-Za-z_\x7f-\uffff][$\-\w\x7f-\uffff]*)([\=]?))|(<=>|\|(?![\|=])))/;
// removed ~=|~| |&(?![&=])

// Token matching regexes.
// added hyphens to identifiers now - to test
var IDENTIFIER = /^((\$|@@|@|\#)[\wA-Za-z_\-\x7f-\uffff][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*|[$A-Za-z_][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*)([^\n\S]*:(?![\*\=:$\w\x7f-\uffff]))?/;

var OBJECT_KEY = /^((\$|@@|@|)[$A-Za-z_\x7f-\uffff\-][$\w\x7f-\uffff\-]*)([^\n\S\s]*:(?![\*\=:$A-Za-z\_\x7f-\uffff]))/;

var TAG = /^(\<|%)(?=[A-Za-z\#\.\{\@\>])/;

var TAG_TYPE = /^(\w[\w\d]*:)?(\w[\w\d]*)(-[\w\d]+)*/;
var TAG_ID = /^#((\w[\w\d]*)(-[\w\d]+)*)/;

var TAG_ATTR = /^([\.\:]?[\w\_]+([\-\:][\w]+)*)(\s)*\=/;

var SELECTOR = /^([%\$]{1,2})([\(\w\#\.\[])/;
var SELECTOR_PART = /^(\#|\.|:|::)?([\w]+(\-[\w]+)*)/;
var SELECTOR_COMBINATOR = /^ (\+|\>|\~)*\s*(?=[\w\.\#\:\{\*\[])/;

var SELECTOR_PSEUDO_CLASS = /^(::?)([\w]+(\-[\w]+)*)/;
var SELECTOR_ATTR_OP = /^(\$=|\~=|\^=|\*=|\|=|=|\!=)/;
var SELECTOR_ATTR = /^\[([\w\_\-]+)(\$=|\~=|\^=|\*=|\|=|=|\!=)/;

var SYMBOL = /^\:((([\*\@$\w\x7f-\uffff]+)+([\-\\\:][\w\x7f-\uffff]+)*)|==|\<=\>)/;


var NUMBER = /^0x[\da-f]+|^0b[01]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;

var HEREDOC = /^("""|''')([\s\S]*?)(?:\n[^\n\S]*)?\1/;

var OPERATOR = /^(?:[-=]=>|===|->|=>|!==|[-+*\/%<>&|^!?=]=|=<|>>>=?|([-+:])\1|([&|<>])\2=?|\?\.|\?\:|\.{2,3}|\*(?=[a-zA-Z\_]))/;

// FIXME splat should only be allowed when the previous thing is spaced or inside call?

var WHITESPACE = /^[^\n\S]+/;

var COMMENT = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)/;
// COMMENT    = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)|^(?:\s*(#\s.*|#\s*$))+/
var INLINE_COMMENT = /^(\s*)(#[ \t\!](.*)|#[ \t]?(?=\n|$))+/;

var CODE = /^[-=]=>/;

var MULTI_DENT = /^(?:\n[^\n\S]*)+/;

var SIMPLESTR = /^'[^\\']*(?:\\.[^\\']*)*'/;

var JSTOKEN = /^`[^\\`]*(?:\\.[^\\`]*)*`/;

// Regex-matching-regexes.
var REGEX = /^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/;

var HEREGEX = /^\/{3}([\s\S]+?)\/{3}([imgy]{0,4})(?!\w)/;

var HEREGEX_OMIT = /\s+(?:#.*)?/g;

// Token cleaning regexes.
var MULTILINER = /\n/g;

var HEREDOC_INDENT = /\n+([^\n\S]*)/g;

var HEREDOC_ILLEGAL = /\*\//;

// expensive?
var LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|::)/;

var TRAILING_SPACES = /\s+$/;

var CONST_IDENTIFIER = /^[A-Z]/;

var ENV_FLAG = /^\$\w+\$/;

var ARGVAR = /^\$\d$/;

// Compound assignment tokens.
var COMPOUND_ASSIGN = ['-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|=','=<'];

// Unary tokens.
var UNARY = ['!','~','NEW','TYPEOF','DELETE'];

// Logical tokens.
var LOGIC = ['&&','||','&','|','^','and','or'];

// Bit-shifting tokens.
var SHIFT = ['<<','>>','>>>'];

// Comparison tokens.
var COMPARE = ['===','!==','==','!=','<','>','<=','>=','===','!=='];

// Overideable methods
var OP_METHODS = ['<=>','<<','..'];

// Mathematical tokens.
var MATH = ['*','/','%','∪','∩','√'];

// Relational tokens that are negatable with `not` prefix.
var RELATION = ['IN','OF','INSTANCEOF','ISA'];

// Boolean tokens.
var BOOL = ['TRUE','FALSE','NULL','UNDEFINED'];

// Our list is shorter, due to sans-parentheses method calls.
var NOT_REGEX = ['NUMBER','REGEX','BOOL','TRUE','FALSE','++','--',']'];

// If the previous token is not spaced, there are more preceding tokens that
// force a division parse:
var NOT_SPACED_REGEX = ['NUMBER','REGEX','BOOL','TRUE','FALSE','++','--',']',')','}','THIS','SELF','IDENTIFIER','STRING'];

// Tokens which could legitimately be invoked or indexed. An opening
// parentheses or bracket following these tokens will be recorded as the start
// of a function invocation or indexing operation.
// really?!

var UNFINISHED = ['\\','.','?.','?:','UNARY','MATH','+','-','SHIFT','RELATION','COMPARE','LOGIC','COMPOUND_ASSIGN','THROW','EXTENDS'];

// } should not be callable anymore!!! '}', '::',
var CALLABLE = ['IDENTIFIER','STRING','REGEX',')',']','THIS','SUPER','TAG_END','IVAR','GVAR','SELF','CONST','NEW','ARGVAR','SYMBOL','RETURN'];

// optimize for FixedArray
var INDEXABLE = [
	'IDENTIFIER','STRING','REGEX',')',']','THIS','SUPER','TAG_END','IVAR','GVAR','SELF','CONST','NEW','ARGVAR','SYMBOL','RETURN',
	'NUMBER','BOOL','TAG_SELECTOR','ARGUMENTS','}','TAG_TYPE','TAGID'
];

var NOT_KEY_AFTER = ['.','?','?.','UNARY','?:','+','-','*'];

var GLOBAL_IDENTIFIERS = ['global','exports'];

// Tokens that, when immediately preceding a `WHEN`, indicate that the `WHEN`
// occurs at the start of a line. We disambiguate these from trailing whens to
// avoid an ambiguity in the grammar.
var LINE_BREAK = ['INDENT','OUTDENT','TERMINATOR'];


function LexerError(message,file,line){
	this.message = message;
	this.file = file;
	this.line = line;
	return this;
};
subclass$(LexerError,SyntaxError);
exports.LexerError = LexerError; // export class 



function last(array,back){
	if(back === undefined) back = 0;
	return array[array.length - back - 1];
};

function count(str,substr){
	return str.split(substr).length - 1;
};

function repeatString(str,times){
	var res = '';
	while (times > 0){
		if (times % 2 == 1) {
			res += str;
		};
		str += str;
		times >>= 1;
	};
	return res;
};

var tT = T.typ;
var tV = T.val;
var tTs = T.setTyp;
var tVs = T.setVal;

// The Lexer class reads a stream of Imba and divvies it up into tokidged
// tokens. Some potential ambiguity in the grammar has been avoided by
// pushing some extra smarts into the Lexer.

// Based on the original lexer.coffee from CoffeeScript
function Lexer(){
	this.reset();
	this;
};

exports.Lexer = Lexer; // export class 
Lexer.prototype.reset = function (){
	this._code = null;
	this._chunk = null; // The remainder of the source code.
	this._opts = null;
	this._state = {};
	
	this._indent = 0; // The current indentation level.
	this._indebt = 0; // The over-indentation at the current level.
	this._outdebt = 0; // The under-outdentation at the current level.
	
	this._indents = []; // The stack of all current indentation levels.
	this._ends = []; // The stack for pairing up tokens.
	this._contexts = []; // suplements @ends
	this._scopes = [];
	this._nextScope = null; // the scope to add on the next indent
	this._context = null;
	// should rather make it like a statemachine that moves from CLASS_DEF to CLASS_BODY etc
	// Things should compile differently when you are in a CLASS_BODY than when in a DEF_BODY++
	
	this._indentStyle = null;
	this._inTag = false;
	
	this._tokens = []; // Stream of parsed tokens in the form `['TYPE', value, line]`.
	this._seenFor = false;
	this._loc = 0;
	this._locOffset = 0;
	
	this._end = null;
	this._char = null;
	this._bridge = null;
	
	this._last = null;
	this._lastTyp = '';
	this._lastVal = null;
	return this;
};

Lexer.prototype.jisonBridge = function (jison){
	return this._bridge = {
		lex: T.lex,
		setInput: function(tokens) {
			this.tokens = tokens;
			return this.pos = 0;
		},
		
		upcomingInput: function() { return ""; }
	};
};


Lexer.prototype.tokenize = function (code,o){
	
	var m;
	if(o === undefined) o = {};
	if (code.length == 0) {
		return [];
	};
	
	if (!o.inline) {
		if (WHITESPACE.test(code)) {
			code = ("\n" + code);
			if (code.match(/^\s*$/g)) { return [] };
		};
		
		code = code.replace(/\r/g,'').replace(/[\t ]+$/g,'');
	};
	
	this._last = null;
	this._lastTyp = null;
	this._lastVal = null;
	
	this._code = code;
	this._opts = o;
	this._locOffset = o.loc || 0;
	this._indentStyle = o.indentation || null;
	
	// if the very first line is indented, take this as a gutter
	if (m = code.match(/^([\ \t]*)[^\n\s\t]/)) {
		this._state.gutter = m[1];
	};
	
	if (o.gutter !== undefined) {
		this._state.gutter = o.gutter;
	};
	
	o._tokens = this._tokens;
	
	this.parse(code);
	
	if (!o.inline) this.closeIndentation();
	
	if (!o.silent && this._ends.length) {
		console.log(this._ends);
		this.error(("missing " + (this._ends.pop())));
	};
	
	return this._tokens;
};

Lexer.prototype.parse = function (code){
	var i = 0;
	var pi = 0;
	this._loc = this._locOffset + i;
	
	while (this._chunk = code.slice(i)){
		if (this._context && this._context.pop) {
			if (this._context.pop.test(this._chunk)) {
				this.popEnd();
			};
		};
		
		pi = (this._end == 'TAG' && this.tagDefContextToken()) || (this._inTag && this.tagContextToken()) || this.basicContext();
		i += pi;
		this._loc = this._locOffset + i;
	};
	
	return;
};

Lexer.prototype.basicContext = function (){
	return this.selectorToken() || this.symbolToken() || this.methodNameToken() || this.identifierToken() || this.whitespaceToken() || this.lineToken() || this.commentToken() || this.heredocToken() || this.tagToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken() || 0;
};

Lexer.prototype.moveCaret = function (i){
	return this._loc += i;
};

Lexer.prototype.context = function (){
	return this._ends[this._ends.length - 1];
};

Lexer.prototype.inContext = function (key){
	var o = this._contexts[this._contexts.length - 1];
	return o && o[key];
};

Lexer.prototype.pushEnd = function (val,ctx){
	this._ends.push(val);
	this._contexts.push(this._context = (ctx || {}));
	this._end = val;
	this.refreshScope();
	
	if (ctx && ctx.id) {
		ctx.start = new Token(ctx.id + '_START',val,this._last.region()[1],0);
		this._tokens.push(ctx.start);
	};
	return this;
};

Lexer.prototype.popEnd = function (val){
	var popped = this._ends.pop();
	this._end = this._ends[this._ends.length - 1];
	
	// automatically adding a closer if this is defined
	var ctx = this._context;
	if (ctx && ctx.start) {
		ctx.end = new Token(ctx.id + '_END',popped,this._last.region()[1],0);
		ctx.end._start = ctx.start;
		ctx.start._end = ctx.end;
		this._tokens.push(ctx.end);
	};
	
	this._contexts.pop();
	this._context = this._contexts[this._contexts.length - 1];
	
	this.refreshScope();
	return this;
};

Lexer.prototype.refreshScope = function (){
	var ctx0 = this._ends[this._ends.length - 1];
	var ctx1 = this._ends[this._ends.length - 2];
	return this._inTag = ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
};



Lexer.prototype.queueScope = function (val){
	this._scopes[this._indents.length] = val;
	return this;
};

Lexer.prototype.popScope = function (val){
	this._scopes.pop();
	return this;
};

Lexer.prototype.getScope = function (){
	return this._scopes[this._indents.length - 1];
};

Lexer.prototype.scope = function (sym,opts){
	var len = this._ends.push(this._end = sym);
	this._contexts.push(opts || null);
	return sym;
};


Lexer.prototype.closeSelector = function (){
	if (this._end == '%') {
		this.token('SELECTOR_END','%',0);
		return this.pair('%');
	};
};


Lexer.prototype.openDef = function (){
	return this.pushEnd('DEF');
};


Lexer.prototype.closeDef = function (){
	if (this.context() == 'DEF') {
		var prev = last(this._tokens);
		
		if (tT(prev) == 'DEF_FRAGMENT') {
			true;
		} else if (tT(prev) == 'TERMINATOR') {
			var n = this._tokens.pop();
			this.token('DEF_BODY','DEF_BODY',0);
			this._tokens.push(n);
		} else {
			this.token('DEF_BODY','DEF_BODY',0);
		};
		
		this.pair('DEF');
	};
	return;
};

Lexer.prototype.tagContextToken = function (){
	var match;
	if (this._chunk[0] == '#') {
		this.token('#','#',1);
		return 1;
	};
	
	if (match = TAG_ATTR.exec(this._chunk)) {
		var l = match[0].length;
		
		this.token('TAG_ATTR',match[1],l - 1); // add to loc?
		this._loc += l - 1;
		this.token('=','=',1);
		this.pushEnd('TAG_ATTR',{id: 'VALUE',pop: /^[\s\n\>]/}); //  [' ','\n','>']
		return l;
	};
	return 0;
};

Lexer.prototype.tagDefContextToken = function (){
	// console.log "tagContextToken"
	var match;
	if (match = TAG_TYPE.exec(this._chunk)) {
		this.token('TAG_TYPE',match[0],match[0].length);
		return match[0].length;
	};
	
	if (match = TAG_ID.exec(this._chunk)) {
		var input = match[0];
		this.token('TAG_ID',input,input.length);
		return input.length;
	};
	
	if (this._chunk[0] == '\n') {
		this.pair('TAG');
	};
	
	return 0;
};


Lexer.prototype.tagToken = function (){
	var match, ary;
	if (!(match = TAG.exec(this._chunk))) { return 0 };
	var ary = iter$(match);var input = ary[0],type = ary[1],identifier = ary[2];
	
	if (type == '<') {
		this.token('TAG_START','<',1);
		this.pushEnd(INVERSES.TAG_START);
		
		if (match = TAG_TYPE.exec(this._chunk.substr(1,40))) {
			// special case should probably be handled in AST
			if (match[0] != 'self') {
				this.token('TAG_TYPE',match[0],match[0].length,1);
				return input.length + match[0].length;
			};
		};
		
		if (identifier) {
			if (identifier.substr(0,1) == '{') {
				return type.length;
			} else {
				this.token('TAG_NAME',input.substr(1),0);
			};
		};
	};
	
	return input.length;
};


Lexer.prototype.selectorToken = function (){
	var ary;
	var match;
	
	// special handling if we are in this context
	if (this._end == '%') {
		var chr = this._chunk[0];
		var open = this.inContext('open');
		
		// should add for +, ~ etc
		// should maybe rather look for the correct type of character?
		
		if (open && (chr == ' ' || chr == '\n' || chr == ',' || chr == '+' || chr == '~' || chr == ')' || chr == ']')) {
			// console.log "close this selector directly"
			this.token('SELECTOR_END','%',0);
			this.pair('%');
			return 0;
		};
		
		if (match = SELECTOR_COMBINATOR.exec(this._chunk)) {
			// spaces between? -- include the whole
			this.token('SELECTOR_COMBINATOR',match[1] || " ",match[0].length);
			return match[0].length;
		} else if (match = SELECTOR_PART.exec(this._chunk)) {
			var type = match[1];
			var id = match[2];
			
			switch (type) {
				case '.':
					tokid = 'SELECTOR_CLASS';break;
				
				case '#':
					tokid = 'SELECTOR_ID';break;
				
				case ':':
					tokid = 'SELECTOR_PSEUDO_CLASS';break;
				
				case '::':
					tokid = 'SELECTOR_PSEUDO_CLASS';break;
				
				default:
				
					var tokid = 'SELECTOR_TAG';
			
			};
			
			this.token(tokid,match[2],match[0].length);
			return match[0].length;
		} else if (chr == '[') {
			this.token('[','[',1);
			this.pushEnd(']');
			if (match = SELECTOR_ATTR.exec(this._chunk)) {
				// fuck this length shit
				var idoffset = match[0].indexOf(match[1]);
				var opoffset = match[0].indexOf(match[2]);
				this.token('IDENTIFIER',match[1],match[1].length,idoffset);
				this.token('SELECTOR_ATTR_OP',match[2],match[2].length,opoffset);
				return match[0].length;
			};
			return 1;
		} else if (chr == '|') {
			var tok = this._tokens[this._tokens.length - 1];
			tTs(tok,'SELECTOR_NS');
			// tok[0] = 'SELECTOR_NS' # FIX
			return 1;
		} else if (chr == ',') {
			this.token('SELECTOR_GROUP',',',1);
			return 1;
		} else if (chr == '*') {
			this.token('UNIVERSAL_SELECTOR','*',1);
			return 1;
		} else if (chr == ')') {
			this.pair('%');
			this.token('SELECTOR_END',')',1);
			return 1;
		} else if (idx$(chr,[')','}',']','']) >= 0) {
			this.pair('%');
			return 0;
		};
	};
	
	if (!(match = SELECTOR.exec(this._chunk))) { return 0 };
	
	var ary = iter$(match);var input = ary[0],id = ary[1],kind = ary[2];
	
	// this is a closed selector
	if (kind == '(') {
		// token '(','('
		this.token('SELECTOR_START',id,id.length + 1);
		this.pushEnd('%');
		return id.length + 1;
	} else if (id == '%') {
		// we are already scoped in on a selector
		if (this.context() == '%') { return 1 };
		this.token('SELECTOR_START',id,id.length);
		// this is a separate - scope. Full selector should rather be $, and keep the single selector as %
		
		this.pushEnd('%',{open: true});
		// @ends.push '%'
		// make sure a terminator breaks out
		return id.length;
	} else {
		return 0;
	};
};

// is this really needed? Should be possible to
// parse the identifiers and = etc i jison?
// what is special about methodNameToken? really?
// this whole step should be removed - it's a huge mess
Lexer.prototype.methodNameToken = function (){
	// we can optimize this by after a def simply
	// fetching all the way after the def until a space or (
	// and then add this to the def-token itself (as with fragment)
	if (this._chunk[0] == ' ') { return 0 };
	
	var match;
	
	if (this._end == ')') {
		if (this._ends.length > 1) {
			var outerctx = this._ends[this._ends.length - 2];
			if (outerctx == '%' && (match = TAG_ATTR.exec(this._chunk))) {
				this.token('TAG_ATTR_SET',match[1]);
				return match[0].length;
			};
		};
	};
	
	if (!(match = METHOD_IDENTIFIER.exec(this._chunk))) {
		return 0;
	};
	// var prev = last @tokens
	var length = match[0].length;
	
	var id = match[0];
	var ltyp = this._lastTyp;
	var typ = 'IDENTIFIER';
	var pre = id.charAt(0);
	var space = false;
	
	var m4 = match[4]; // might be out of bounds? should rather check charAt
	// drop match 4??
	
	// should this not quit here in practically all cases?
	if (!((ltyp == '.' || ltyp == 'DEF') || (m4 == '!') || match[5])) {
		return 0;
	};
	
	// again, why?
	if (id == 'self' || id == 'this' || id == 'super') { // in ['SELF','THIS']
		return 0;
	};
	
	if (id == 'new') {
		// console.log 'NEW here?'
		// this is wrong -- in the case of <div value=Date.new>
		// we are basically in a nested scope until the next space or >
		if (!(ltyp == '.' && this.inTag())) { typ = 'NEW' };
	};
	
	if (id == '...' && [',','(','CALL_START','BLOCK_PARAM_START','PARAM_START'].indexOf(ltyp) >= 0) {
		return 0;
	};
	
	if (id == '|') {
		// hacky way to implement this
		// with new lexer we'll use { ... } instead, and assume object-context,
		// then go back and correct when we see the context is invalid
		if (ltyp == '(' || ltyp == 'CALL_START') {
			this.token('DO','DO',0);
			this.pushEnd('|');
			this.token('BLOCK_PARAM_START',id,1);
			return length;
		} else if (ltyp == 'DO' || ltyp == '{') {
			this.pushEnd('|');
			this.token('BLOCK_PARAM_START',id,1);
			return length;
		} else if (this._ends[this._ends.length - 1] == '|') {
			this.token('BLOCK_PARAM_END','|',1);
			this.pair('|');
			return length;
		} else {
			return 0;
		};
	};
	
	// whaat?
	// console.log("method identifier",id)
	if ((['&','^','<<','<<<','>>'].indexOf(id) >= 0 || (id == '|' && this.context() != '|'))) {
		return 0;
	};
	
	if (OP_METHODS.indexOf(id) >= 0) {
		space = true;
	};
	
	// not even anything we should use?!?
	if (pre == '@') {
		typ = 'IVAR';
	} else if (pre == '$') {
		true;
	} else if (pre == '#') {
		typ = 'TAGID';
	} else if (CONST_IDENTIFIER.test(pre) || id == 'global' || id == 'exports') {
		// really? seems very strange
		// console.log('global!!',typ,id)
		typ = 'CONST';
	};
	
	// what is this really for?
	if (match[5] && ['IDENTIFIER','CONST','GVAR','CVAR','IVAR','SELF','THIS',']','}',')','NUMBER','STRING'].indexOf(ltyp) >= 0) {
		this.token('.','.',0);
	};
	
	this.token(typ,id,length);
	
	if (space) {
		this._last.spaced = true;
	};
	
	return length;
};


Lexer.prototype.inTag = function (){
	var len = this._ends.length;
	if (len > 0) {
		var ctx0 = this._ends[len - 1];
		var ctx1 = (len > 1) ? this._ends[len - 2] : ctx0;
		return ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
	};
	return false;
};

Lexer.prototype.isKeyword = function (id){
	if ((id == 'attr' || id == 'prop')) {
		var scop = this.getScope();
		var incls = scop == 'CLASS' || scop == 'TAG';
		if (incls) { return true };
	};
	
	if (this._lastTyp == 'ATTR' || this._lastTyp == 'PROP') {
		return false;
	};
	
	return ALL_KEYWORDS.indexOf(id) >= 0;
};

// Matches identifying literals: variables, keywords, method names, etc.
// Check to ensure that JavaScript reserved words aren't being used as
// identifiers. Because Imba reserves a handful of keywords that are
// allowed in JavaScript, we're careful not to tokid them as keywords when
// referenced as property names here, so you can still do `jQuery.is()` even
// though `is` means `===` otherwise.
Lexer.prototype.identifierToken = function (){
	var ary;
	var match;
	
	var ctx0 = (this._ends.length > 0) ? this._ends[this._ends.length - 1] : null;
	var ctx1 = (this._ends.length > 1) ? this._ends[this._ends.length - 2] : null;
	var innerctx = ctx0;
	var typ;
	var reserved = false;
	
	var addLoc = false;
	var inTag = ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
	
	// console.log ctx1,ctx0
	
	if (inTag && (match = TAG_ATTR.exec(this._chunk))) {
		// console.log 'TAG_ATTR IN tokid',match
		// var prev = last @tokens
		// if the prev is a terminator, we dont really need to care?
		if (this._lastTyp != 'TAG_NAME') {
			if (this._lastTyp == 'TERMINATOR') {
				// console.log('prev was terminator -- drop it?')
				true;
			} else {
				this.token(",",",");
			};
		};
		
		var l = match[0].length;
		
		this.token('TAG_ATTR',match[1],l - 1); // add to loc?
		this._loc += l - 1;
		this.token('=','=',1);
		return l;
	};
	
	// see if this is a plain object-key
	// way too much logic going on here?
	// the ast should normalize whether keys
	// are accessable as keys or strings etc
	if (match = OBJECT_KEY.exec(this._chunk)) {
		var id = match[1];
		typ = 'KEY';
		
		this.token(typ,id,id.length);
		this.moveCaret(id.length);
		// console.log "MATCH",match
		this.token(':',':',match[3].length);
		this.moveCaret(-id.length);
		return match[0].length;
	};
	
	if (!(match = IDENTIFIER.exec(this._chunk))) {
		return 0;
	};
	
	var ary = iter$(match);var input = ary[0],id = ary[1],typ = ary[2],m3 = ary[3],m4 = ary[4],colon = ary[5];
	var idlen = id.length;
	
	// What is the logic here?
	if (id == 'own' && this.lastTokenType() == 'FOR') {
		this.token('OWN',id,id.length);
		return id.length;
	};
	
	var prev = last(this._tokens);
	var lastTyp = this._lastTyp;
	
	if (lastTyp == '#') {
		this.token('IDENTIFIER',id,idlen);
		return idlen;
	};
	
	// should we force this to be an identifier even if it is a reserved word?
	// this should only happen for when part of object etc
	// will prev ever be @???
	var forcedIdentifier;
	
	// again
	forcedIdentifier = colon || lastTyp == '.' || lastTyp == '?.'; // in ['.', '?.'
	
	
	// temp hack! need to solve for other keywords etc as well
	// problem appears with ternary conditions.
	
	// well -- it should still be an indentifier if in object?
	// forcedIdentifier = no if id in ['undefined','break']
	
	if (colon && lastTyp == '?') { forcedIdentifier = false }; // for ternary
	
	// if we are not at the top level? -- hacky
	if (id == 'tag' && this._chunk.indexOf("tag(") == 0) { // @chunk.match(/^tokid\(/)
		forcedIdentifier = true;
	};
	
	var isKeyword = false;
	
	// console.log "match",match
	// console.log "typ is {typ}"
	// little reason to check for this right here? but I guess it is only a simple check
	if (typ == '$' && ARGVAR.test(id)) { // id.match(/^\$\d$/)
		// console.log "TYP $"
		if (id == '$0') {
			typ = 'ARGUMENTS';
		} else {
			typ = 'ARGVAR';
			id = id.substr(1);
		};
	} else if (typ == '$' && ENV_FLAG.test(id)) {
		typ = 'ENV_FLAG';
		id = id.toUpperCase().slice(1,-1);
	} else if (typ == '@') {
		typ = 'IVAR';
		// id:reserved = yes if colon
	} else if (typ == '#') {
		typ = 'TAGID';
	} else if (typ == '@@') {
		typ = 'CVAR';
	} else if (typ == '$' && !(colon)) {
		typ = 'IDENTIFIER';
		// typ = 'GVAR'
	} else if (CONST_IDENTIFIER.test(id) || id == 'global' || id == 'exports') {
		// thous should really be handled by the ast instead
		typ = 'CONST';
	} else if (id == 'elif') {
		this.token('ELSE','elif',id.length);
		this.token('IF','if');
		return id.length;
	} else {
		typ = 'IDENTIFIER';
	};
	
	
	
	// this catches all 
	if (!(forcedIdentifier) && (isKeyword = this.isKeyword(id))) {
		// (id in JS_KEYWORDS or id in IMBA_KEYWORDS)
		
		typ = id.toUpperCase();
		addLoc = true;
		
		// clumsy - but testing performance
		if (typ == 'YES') {
			typ = 'TRUE';
		} else if (typ == 'NO') {
			typ = 'FALSE';
		} else if (typ == 'NIL') {
			typ = 'NULL';
		} else if (typ == 'VAR') {
			if (this._lastVal == 'export') {
				tTs(prev,'EXPORT');
			};
		} else if (typ == 'IF' || typ == 'ELSE' || typ == 'TRUE' || typ == 'FALSE' || typ == 'NULL') {
			true;
		} else if (typ == 'TAG') {
			this.pushEnd('TAG');
		} else if (typ == 'DEF') {
			// should probably shift context and optimize this
			this.openDef();
		} else if (typ == 'DO') {
			if (this.context() == 'DEF') this.closeDef();
		} else if (typ == 'WHEN' && LINE_BREAK.indexOf(this.lastTokenType()) >= 0) {
			typ = 'LEADING_WHEN';
		} else if (typ == 'FOR') {
			this._seenFor = true;
		} else if (typ == 'UNLESS') {
			typ = 'IF'; // WARN
		} else if (UNARY.indexOf(typ) >= 0) {
			typ = 'UNARY';
		} else if (RELATION.indexOf(typ) >= 0) {
			if (typ != 'INSTANCEOF' && typ != 'ISA' && this._seenFor) {
				typ = 'FOR' + typ; // ?
				this._seenFor = false;
			} else {
				typ = 'RELATION';
				
				if (prev._type == 'UNARY') {
					prev._type = 'NOT';
				};
			};
		};
	};
	
	if (id == 'super') {
		typ = 'SUPER';
	};
	
	// do we really want to check this here
	if (!(forcedIdentifier)) {
		// should already have dealt with this
		
		if (this._lastVal == 'export' && id == 'default') {
			// console.log 'id is default!!!'
			tTs(prev,'EXPORT');
			typ = 'DEFAULT';
		};
		
		// these really should not go here?!?
		switch (id) {
			case '!':
			case 'not':
				typ = 'UNARY';break;
			
			case '==':
			case '!=':
			case '===':
			case '!==':
			case 'is':
			case 'isnt':
				typ = 'COMPARE';break;
			
			case '&&':
			case '||':
			case 'and':
			case 'or':
				typ = 'LOGIC';break;
			
			case 'break':
			case 'continue':
			case 'debugger':
			case 'arguments':
				typ = id.toUpperCase();break;
		
		};
	};
	
	// prev = last @tokens
	var len = input.length;
	
	// should be strict about the order, check this manually instead
	if (typ == 'CLASS' || typ == 'DEF' || typ == 'TAG') {
		this.queueScope(typ);
		
		var i = this._tokens.length;
		
		while (i){
			prev = this._tokens[--i];
			var ctrl = "" + tV(prev);
			if (idx$(ctrl,IMBA_CONTEXTUAL_KEYWORDS) >= 0) {
				tTs(prev,ctrl.toUpperCase());
			} else {
				break;
			};
		};
	} else if (typ == 'IF') {
		this.queueScope(typ);
	} else if (typ == 'IMPORT') {
		// could manually parse the whole ting here?
		this.pushEnd('IMPORT');
	} else if (id == 'from' && ctx0 == 'IMPORT') {
		typ = 'FROM';
		this.pair('IMPORT');
	} else if (id == 'as' && ctx0 == 'IMPORT') {
		typ = 'AS';
		this.pair('IMPORT');
	};
	
	if (typ == 'IDENTIFIER') {
		// see if previous was catch -- belongs in rewriter?
		if (lastTyp == 'CATCH') {
			typ = 'CATCH_VAR';
		};
	};
	
	if (colon) {
		// console.log 'colon',colon,typ
		if (typ == 'IDENTIFIER' && NOT_KEY_AFTER.indexOf(this._lastTyp) == -1) {
			typ = 'KEY';
		};
		
		this.token(typ,id,idlen);
		var colonOffset = colon.indexOf(':');
		
		this.moveCaret(idlen + colonOffset);
		// TODO Stop moving caret back and forth
		// console.log idlen,colon,colonOffset
		this.token(':',':',1);
		this.moveCaret(-(idlen + colonOffset));
	} else {
		this.token(typ,id,idlen);
	};
	
	return len;
};

// Matches numbers, including decimals, hex, and exponential notation.
// Be careful not to interfere with ranges-in-progress.
Lexer.prototype.numberToken = function (){
	var binaryLiteral;
	var match,number,lexedLength;
	
	if (!(match = NUMBER.exec(this._chunk))) { return 0 };
	
	number = match[0];
	lexedLength = number.length;
	
	if (binaryLiteral = /0b([01]+)/.exec(number)) {
		
		number = "" + parseInt(binaryLiteral[1],2);
	};
	
	var prev = last(this._tokens);
	
	if (match[0][0] == '.' && prev && !prev.spaced && ['IDENTIFIER',')','}',']','NUMBER'].indexOf(tT(prev)) >= 0) {
		// console.log "got here"
		this.token(".",".");
		number = number.substr(1);
	};
	
	
	this.token('NUMBER',number,lexedLength);
	return lexedLength;
};

Lexer.prototype.symbolToken = function (){
	var match,symbol,prev;
	
	if (!(match = SYMBOL.exec(this._chunk))) { return 0 };
	symbol = match[0];
	prev = last(this._tokens);
	
	// is this a property-access?
	// should invert this -- only allow when prev IS .. 
	// : should be a token itself, with a specification of spacing (LR,R,L,NONE)
	if (prev && !prev.spaced && idx$(tT(prev),['(','{','[','.','CALL_START','INDEX_START',',','=','INDENT','TERMINATOR','VALUE_START']) == -1) {
		var access = symbol.split(':')[1]; // really?
		
		this.token('.:',':',1);
		
		this.token('IDENTIFIER',access,access.length,1);
		return access.length + 1;
	} else {
		this.token('SYMBOL',symbol,match[0].length);
		return match[0].length;
	};
};

Lexer.prototype.escapeStr = function (str,heredoc,q){
	str = str.replace(MULTILINER,(heredoc ? '\\n' : ''));
	if (q) {
		var r = RegExp(("\\\\[" + q + "]"),"g");
		str = str.replace(r,q);
		str = str.replace(RegExp(("" + q),"g"),'\\$&');
	};
	return str;
	
	// str = str.replace(MULTILINER, '\\n')
	// str = str.replace(/\t/g, '\\t')
};
// Matches strings, including multi-line strings. Ensures that quotation marks
// are balanced within the string's contents, and within nested interpolations.
Lexer.prototype.stringToken = function (){
	var match,string;
	
	switch (this._chunk.charAt(0)) {
		case "'":
			if (!(match = SIMPLESTR.exec(this._chunk))) { return 0 };
			string = match[0];
			this.token('STRING',this.escapeStr(string),string.length);
			// token 'STRING', (string = match[0]).replace(MULTILINER, '\\\n'), string:length
			break;
		
		case '"':
			if (!(string = this.balancedString(this._chunk,'"'))) { return 0 };
			// what about tripe quoted strings?
			
			if (string.indexOf('{') >= 0) {
				var len = string.length;
				// if this has no interpolation?
				// we are now messing with locations - beware
				this.token('STRING_START',string.charAt(0),1);
				this.interpolateString(string.slice(1,-1));
				this.token('STRING_END',string.charAt(len - 1),1,string.length - 1);
			} else {
				len = string.length;
				// string = string.replace(MULTILINER, '\\\n')
				this.token('STRING',this.escapeStr(string),len);
			};
			break;
		
		default:
		
			return 0;
	
	};
	
	this.moveHead(string);
	return string.length;
};

// Matches heredocs, adjusting indentation to the correct level, as heredocs
// preserve whitespace, but ignore indentation to the left.
Lexer.prototype.heredocToken = function (){
	var match,heredoc,quote,doc;
	
	if (!(match = HEREDOC.exec(this._chunk))) { return 0 };
	
	heredoc = match[0];
	quote = heredoc.charAt(0);
	var opts = {quote: quote,indent: null,offset: 0};
	doc = this.sanitizeHeredoc(match[2],opts);
	// doc = match[2]
	// console.log "found heredoc {match[0]:length} {doc:length}"
	
	if (quote == '"' && doc.indexOf('{') >= 0) {
		var open = match[1];
		// console.log doc.substr(0,3),match[1]
		// console.log 'heredoc here',open:length,open
		
		this.token('STRING_START',open,open.length);
		this.interpolateString(doc,{heredoc: true,offset: (open.length + opts.offset),quote: quote,indent: opts.realIndent});
		this.token('STRING_END',open,open.length,heredoc.length - open.length);
	} else {
		this.token('STRING',this.makeString(doc,quote,true),0);
	};
	
	this.moveHead(heredoc);
	return heredoc.length;
};

Lexer.prototype.parseMagicalOptions = function (str){
	var self = this;
	if (str.indexOf('imba$') >= 0) {
		str.replace(/imba\$(\w+)\=(.*)\b/g,function(m,name,val) {
			if ((/^\d+$/).test(val)) {
				val = parseInt(val);
			};
			return self._opts[name] = val;
		});
	};
	return self;
};

// Matches and consumes comments.
Lexer.prototype.commentToken = function (){
	var match,length,comment,indent,prev;
	
	var typ = 'HERECOMMENT';
	
	if (match = INLINE_COMMENT.exec(this._chunk)) { // .match(INLINE_COMMENT)
		// console.log "match inline comment"
		length = match[0].length;
		indent = match[1];
		comment = match[2];
		
		prev = last(this._tokens);
		var pt = prev && tT(prev);
		var note = '//' + comment.substr(1);
		
		this.parseMagicalOptions(note);
		
		if (this._last && this._last.spaced) {
			note = ' ' + note;
			// console.log "the previous node was SPACED"
		};
		// console.log "comment {note} - indent({indent}) - {length} {comment:length}"
		
		if ((pt && pt != 'INDENT' && pt != 'TERMINATOR') || !(pt)) {
			// console.log "skip comment"
			// token 'INLINECOMMENT', comment.substr(2)
			// console.log "adding as terminator"
			this.token('TERMINATOR',note,length); // + '\n'
		} else {
			// console.log "add comment ({note})"
			if (pt == 'TERMINATOR') {
				tVs(prev,tV(prev) + note);
				// prev[1] += note
			} else if (pt == 'INDENT') {
				// console.log "adding comment to INDENT: {note}" # why not add directly here?
				this.addLinebreaks(1,note);
			} else {
				// console.log "comment here"
				// should we ever get here?
				this.token(typ,comment.substr(2),length); // are we sure?
			};
		};
		
		return length; // disable now while compiling
	};
	
	// should use exec?
	if (!(match = COMMENT.exec(this._chunk))) { return 0 };
	
	comment = match[0];
	var here = match[1];
	
	if (here) {
		this.token('HERECOMMENT',this.sanitizeHeredoc(here,{herecomment: true,indent: Array(this._indent + 1).join(' ')}),comment.length);
		this.token('TERMINATOR','\n');
	} else {
		this.token('HERECOMMENT',comment,comment.length);
		this.token('TERMINATOR','\n'); // auto? really?
	};
	
	this.moveHead(comment);
	return comment.length;
};

// Matches JavaScript interpolated directly into the source via backticks.
Lexer.prototype.jsToken = function (){
	var match,script;
	
	if (!(this._chunk.charAt(0) == '`' && (match = JSTOKEN.exec(this._chunk)))) { return 0 };
	this.token('JS',(script = match[0]).slice(1,-1));
	return script.length;
};

// Matches regular expression literals. Lexing regular expressions is difficult
// to distinguish from division, so we borrow some basic heuristics from
// JavaScript and Ruby.
Lexer.prototype.regexToken = function (){
	var ary;
	var match,length,prev;
	
	if (this._chunk.charAt(0) != '/') { return 0 };
	if (match = HEREGEX.exec(this._chunk)) {
		length = this.heregexToken(match);
		this.moveHead(match[0]);
		return length;
	};
	
	prev = last(this._tokens);
	// FIX
	if (prev && (idx$(tT(prev),(prev.spaced ? 
		NOT_REGEX
	 : 
		NOT_SPACED_REGEX
	)) >= 0)) { return 0 };
	if (!(match = REGEX.exec(this._chunk))) { return 0 };
	var ary = iter$(match);var m = ary[0],regex = ary[1],flags = ary[2];
	
	this.token('REGEX',("" + regex + flags),m.length);
	return m.length;
};

// Matches multiline extended regular expressions.
// The escaping should rather happen in AST - possibly as an additional flag?
Lexer.prototype.heregexToken = function (match){
	var ary;
	var ary = iter$(match);var heregex = ary[0],body = ary[1],flags = ary[2];
	this.token('REGEX',heregex,heregex.length);
	return heregex.length;
};

// Matches newlines, indents, and outdents, and determines which is which.
// If we can detect that the current line is continued onto the the next line,
// then the newline is suppressed:
//
//     elements
//       .each( ... )
//       .map( ... )
//
// Keeps track of the level of indentation, because a single outdent token
// can close multiple indents, so we need to know how far in we happen to be.
Lexer.prototype.lineToken = function (){
	var gutter;
	var match;
	
	if (!(match = MULTI_DENT.exec(this._chunk))) { return 0 };
	
	var indent = match[0];
	var brCount = this.moveHead(indent);
	
	this._seenFor = false;
	// reset column as well?
	var prev = last(this._tokens,1);
	var whitespace = indent.substr(indent.lastIndexOf('\n') + 1);
	var noNewlines = this.unfinished();
	
	if ((/^\n#\s/).test(this._chunk)) {
		this.addLinebreaks(1);
		return 0;
	};
	
	// decide the general line-prefix by the very first line with characters
	
	// if gutter is undefined - we create it on the very first chance we have
	if (this._state.gutter == undefined) {
		this._state.gutter = whitespace;
	};
	
	// if we have a gutter -- remove it
	if (gutter = this._state.gutter || this._opts.gutter) {
		if (whitespace.indexOf(gutter) == 0) {
			whitespace = whitespace.slice(gutter.length);
		} else if (this._chunk[indent.length] === undefined) {
			// if this is the end of code we're okay
			true;
		} else {
			this.warn('incorrect indentation');
			// console.log "GUTTER IS INCORRECT!!",JSON.stringify(indent),JSON.stringify(@chunk[indent:length]),@last # @chunk[indent:length - 1]
		};
		
		// should throw error otherwise?
	};
	
	var size = whitespace.length;
	
	if (this._opts.dropIndentation) {
		return size;
	};
	
	if (size > 0) {
		// seen indent?
		
		if (!this._indentStyle) {
			this._opts.indent = this._indentStyle = whitespace;
		};
		
		var indentSize = 0;
		var offset = 0;
		
		while (true){
			var idx = whitespace.indexOf(this._indentStyle,offset);
			if (idx == offset) {
				indentSize++;
				offset += this._indentStyle.length;
			} else if (offset == whitespace.length) {
				break;
			} else if (this._opts.silent) {
				break;
			} else {
				// workaround to report correct location
				this._loc += indent.length - whitespace.length;
				this.token('INDENT',whitespace,whitespace.length);
				if (!this._opts.silent) {
					return this.error(("inconsistent " + (this._indentStyle) + " indentation"));
				};
			};
		};
		
		size = indentSize;
	};
	
	
	if ((size - this._indebt) == this._indent) {
		if (noNewlines) {
			this.suppressNewlines();
		} else {
			this.newlineToken(brCount);
		};
		return indent.length;
	};
	
	if (size > this._indent) {
		if (noNewlines) {
			this._indebt = size - this._indent;
			this.suppressNewlines();
			return indent.length;
		};
		
		if (this.inTag()) {
			return indent.length;
		};
		
		var diff = size - this._indent + this._outdebt;
		this.closeDef();
		
		var immediate = last(this._tokens);
		
		if (immediate && tT(immediate) == 'TERMINATOR') {
			tTs(immediate,'INDENT');
			// should add terminator inside indent?
			immediate._meta || (immediate._meta = {pre: tV(immediate),post: ''});
			
			// should rather add to meta somehow?!?
			// tVs(immediate,tV(immediate) + '%|%') # crazy
		} else {
			this.token('INDENT',"" + diff,0);
		};
		
		// console.log "indenting", prev, last(@tokens,1)
		// if prev and prev[0] == 'TERMINATOR'
		//   console.log "terminator before indent??"
		
		// check for comments as well ?
		
		this._indents.push(diff);
		this.pushEnd('OUTDENT');
		this._outdebt = this._indebt = 0;
		this.addLinebreaks(brCount);
	} else {
		this._indebt = 0;
		this.outdentToken(this._indent - size,noNewlines,brCount);
		this.addLinebreaks(brCount - 1);
		// console.log "outdent",noNewlines,tokid()
	};
	
	this._indent = size;
	return indent.length;
};

// Record an outdent token or multiple tokens, if we happen to be moving back
// inwards past several recorded indents.
Lexer.prototype.outdentToken = function (moveOut,noNewlines,newlineCount){
	// here we should also take care to pop / reset the scope-body
	// or context-type for indentation 
	var dent = 0;
	while (moveOut > 0){
		var len = this._indents.length - 1;
		if (this._indents[len] == undefined) {
			moveOut = 0;
		} else if (this._indents[len] == this._outdebt) {
			moveOut -= this._outdebt;
			this._outdebt = 0;
		} else if (this._indents[len] < this._outdebt) {
			this._outdebt -= this._indents[len];
			moveOut -= this._indents[len];
		} else {
			dent = this._indents.pop() - this._outdebt;
			moveOut -= dent;
			this._outdebt = 0;
			
			if (!(noNewlines)) { this.addLinebreaks(1) };
			
			this.pair('OUTDENT');
			this.token('OUTDENT',"" + dent,0);
		};
	};
	
	if (dent) { this._outdebt -= moveOut };
	
	while (this.lastTokenValue() == ';'){
		this._tokens.pop();
	};
	
	if (!(this.lastTokenType() == 'TERMINATOR' || noNewlines)) { this.token('TERMINATOR','\n',0) };
	// capping scopes so they dont hang around 
	this._scopes.length = this._indents.length;
	
	var ctx = this.context();
	if (ctx == '%' || ctx == 'TAG') { this.pair(ctx) }; // really?
	this.closeDef();
	return this;
};

// Matches and consumes non-meaningful whitespace. tokid the previous token
// as being "spaced", because there are some cases where it makes a difference.
Lexer.prototype.whitespaceToken = function (){
	var match,nline,prev;
	if (!((match = WHITESPACE.exec(this._chunk)) || (nline = this._chunk.charAt(0) == '\n'))) { return 0 };
	prev = last(this._tokens);
	
	// FIX - why oh why?
	if (prev) {
		if (match) {
			prev.spaced = true;
			// prev.@s = match[0]
			return match[0].length;
		} else {
			prev.newLine = true;
			return 0;
		};
	};
};

Lexer.prototype.addNewline = function (){
	return this.token('TERMINATOR','\n');
};

Lexer.prototype.moveHead = function (str){
	var br = count(str,'\n');
	return br;
};


Lexer.prototype.addLinebreaks = function (count,raw){
	var br;
	
	if (!(raw) && count == 0) { return this }; // no terminators?
	
	var prev = this._last;
	
	if (!(raw)) {
		if (count == 1) {
			br = '\n';
		} else if (count == 2) {
			br = '\n\n';
		} else if (count == 3) {
			br = '\n\n\n';
		} else {
			br = repeatString('\n',count);
		};
	};
	// FIX
	if (prev) {
		var t = prev._type; // @lastTyp
		var v = tV(prev);
		
		// we really want to add this
		if (t == 'INDENT') {
			// TODO we want to add to the indent
			// console.log "add the comment to the indent -- pre? {raw} {br}"
			
			var meta = prev._meta || (prev._meta = {pre: '',post: ''});
			meta.post += (raw || br);
			// tVs(v + (raw or br))
			return this;
		} else if (t == 'TERMINATOR') {
			// console.log "already exists terminator {br} {raw}"
			tVs(prev,v + (raw || br));
			return this;
		};
	};
	
	this.token('TERMINATOR',br,0);
	return;
};

// Generate a newline token. Consecutive newlines get merged together.
Lexer.prototype.newlineToken = function (lines){
	
	// while lastTokenValue == ';'
	//	@tokens.pop
	
	this.addLinebreaks(lines);
	
	var ctx = this.context();
	// WARN now import cannot go over multiple lines
	if (ctx == 'TAG' || ctx == 'IMPORT') { this.pair(ctx) };
	this.closeDef(); // close def -- really?
	return this;
};

// Use a `\` at a line-ending to suppress the newline.
// The slash is removed here once its job is done.
Lexer.prototype.suppressNewlines = function (){
	if (this.value() == '\\') { this._tokens.pop() };
	return this;
};

// We treat all other single characters as a token. E.g.: `( ) , . !`
// Multi-character operators are also literal tokens, so that Jison can assign
// the proper order of operations. There are some symbols that we tokid specially
// here. `;` and newlines are both treated as a `TERMINATOR`, we distinguish
// parentheses that indicate a method call from regular parentheses, and so on.
Lexer.prototype.literalToken = function (){
	var match,value;
	if (match = OPERATOR.exec(this._chunk)) {
		value = match[0];
		if (CODE.test(value)) this.tagParameters();
	} else {
		value = this._chunk.charAt(0);
	};
	
	var end1 = this._ends[this._ends.length - 1];
	var end2 = this._ends[this._ends.length - 2];
	
	var inTag = end1 == 'TAG_END' || end1 == 'OUTDENT' && end2 == 'TAG_END';
	
	var tokid = value;
	var prev = last(this._tokens);
	var pt = prev && tT(prev);
	var pv = prev && tV(prev);
	var length = value.length;
	
	// is this needed?
	if (value == '=' && prev) {
		
		if (pv == '||' || pv == '&&') { // in ['||', '&&']
			tTs(prev,'COMPOUND_ASSIGN');
			tVs(prev,pv + '='); // need to change the length as well
			prev._len = this._loc - prev._loc + value.length;
			return value.length;
		};
	};
	
	if (value == ';') {
		this._seenFor = false;
		tokid = 'TERMINATOR';
	} else if (value == '(' && inTag && pt != '=' && prev.spaced) { // FIXed
		// console.log 'spaced before ( in tokid'
		// FIXME - should rather add a special token like TAG_PARAMS_START
		this.token(',',',');
	} else if (value == '->' && inTag) {
		tokid = 'TAG_END';
		this.pair('TAG_END');
	} else if (value == '=>' && inTag) {
		tokid = 'TAG_END';
		this.pair('TAG_END');
	} else if (value == '/>' && inTag) {
		tokid = 'TAG_END';
		this.pair('TAG_END');
	} else if (value == '>' && inTag) {
		tokid = 'TAG_END';
		this.pair('TAG_END');
	} else if (value == '>' && this.context() == 'DEF') {
		// console.log('picked up >!!')
		tokid = 'DEF_FRAGMENT';
		
		// elif value is 'TERMINATOR' and end1 is '%' 
		// 	closeSelector()
	} else if (value == 'TERMINATOR' && end1 == 'DEF') {
		this.closeDef();
	} else if (value == '&' && this.context() == 'DEF') {
		// console.log("okay!")
		tokid = 'BLOCK_ARG';
		// change the next identifier instead?
	} else if (value == '*' && this._chunk.charAt(1).match(/[A-Za-z\_\@\[]/) && (prev.spaced || [',','(','[','{','|','\n','\t'].indexOf(pv) >= 0)) {
		tokid = "SPLAT";
	} else if (value == '√') {
		tokid = 'SQRT';
	} else if (value == 'ƒ') {
		tokid = 'DO';
	} else if (idx$(value,MATH) >= 0) {
		tokid = 'MATH';
	} else if (idx$(value,COMPARE) >= 0) {
		tokid = 'COMPARE';
	} else if (idx$(value,COMPOUND_ASSIGN) >= 0) {
		tokid = 'COMPOUND_ASSIGN';
	} else if (idx$(value,UNARY) >= 0) {
		tokid = 'UNARY';
	} else if (idx$(value,SHIFT) >= 0) {
		tokid = 'SHIFT';
	} else if (idx$(value,LOGIC) >= 0) {
		tokid = 'LOGIC'; // or value is '?' and prev?:spaced 
	} else if (prev && !prev.spaced) {
		if (value == '(' && idx$(pt,CALLABLE) >= 0) {
			// not using this ???
			// prev[0] = 'FUNC_EXIST' if prev[0] is '?'
			tokid = 'CALL_START';
		} else if (value == '[' && idx$(pt,INDEXABLE) >= 0) {
			tokid = 'INDEX_START';
			if (pt == '?') { tTs(prev,'INDEX_SOAK') };
			// prev[0] = 'INDEX_SOAK' if prev[0] == '?'
		};
	};
	
	switch (value) {
		case '(':
		case '{':
		case '[':
			this.pushEnd(INVERSES[value]);break;
		
		case ')':
		case '}':
		case ']':
			this.pair(value);break;
	
	};
	
	// hacky rule to try to allow for tuple-assignments in blocks
	// if value is ',' and prev[0] is 'IDENTIFIER' and @tokens[@tokens:length - 2][0] in ['TERMINATOR','INDENT']
	//   # token "TUPLE", "tuple" # should rather insert it somewhere else, no?
	//   console.log("found comma")
	
	this.token(tokid,value,value.length);
	return value.length;
};

// Token Manipulators
// ------------------

// Sanitize a heredoc or herecomment by
// erasing all external indentation on the left-hand side.
Lexer.prototype.sanitizeHeredoc = function (doc,options){
	var match;
	var indent = options.indent;
	var herecomment = options.herecomment;
	
	if (herecomment) {
		if (HEREDOC_ILLEGAL.test(doc)) {
			this.error("block comment cannot contain '*/' starting");
		};
		if (doc.indexOf('\n') <= 0) { return doc };
	} else {
		var length_;while (match = HEREDOC_INDENT.exec(doc)){
			var attempt = match[1];
			if (indent == null || 0 < (length_ = attempt.length) && length_ < indent.length) {
				indent = attempt;
			};
		};
	};
	
	if (indent) { doc = doc.replace(RegExp(("\\n" + indent),"g"),'\n') };
	if (!(herecomment)) {
		if (doc[0] == '\n') {
			options.offset = indent.length + 1;
		};
		doc = doc.replace(/^\n/,'');
	};
	options.realIndent = indent;
	return doc;
};

// A source of ambiguity in our grammar used to be parameter lists in function
// definitions versus argument lists in function calls. Walk backwards, tokidging
// parameters specially in order to make things easier for the parser.
Lexer.prototype.tagParameters = function (){
	var tok;
	if (this.lastTokenType() != ')') { return this };
	var stack = [];
	var tokens = this._tokens;
	var i = tokens.length;
	
	tTs(tokens[--i],'PARAM_END');
	
	while (tok = tokens[--i]){
		var t = tT(tok);
		switch (t) {
			case ')':
				stack.push(tok);
				break;
			
			case '(':
			case 'CALL_START':
				if (stack.length) {
					stack.pop();
				} else if (t == '(') {
					tTs(tok,'PARAM_START');
					return this;
				} else {
					return this;
				};
				break;
		
		};
	};
	
	return this;
};

// Close up all remaining open blocks at the end of the file.
Lexer.prototype.closeIndentation = function (){
	if (this.context() == 'IMPORT') { this.pair(this.context()) };
	this.closeDef();
	this.closeSelector();
	return this.outdentToken(this._indent,false,0);
};

// Matches a balanced group such as a single or double-quoted string. Pass in
// a series of delimiters, all of which must be nested correctly within the
// contents of the string. This method allows us to have strings within
// interpolations within strings, ad infinitum.
Lexer.prototype.balancedString = function (str,end){
	var match,letter,prev;
	
	var stack = [end];
	var i = 0;
	
	// could it not happen here?
	while (i < (str.length - 1)){
		i++;
		letter = str.charAt(i);
		switch (letter) {
			case '\\':
				i++;
				continue;
				break;
			
			case end:
				stack.pop();
				if (!stack.length) {
					var v = str.slice(0,i + 1);
					return v;
				};
				end = stack[stack.length - 1];
				continue;
				break;
		
		};
		
		if (end == '}' && (letter == '"' || letter == "'")) {
			stack.push(end = letter);
		} else if (end == '}' && letter == '/' && (match = (HEREGEX.exec(str.slice(i)) || REGEX.exec(str.slice(i))))) {
			i += match[0].length - 1;
		} else if (end == '}' && letter == '{') {
			stack.push(end = '}');
		} else if (end == '"' && letter == '{') {
			stack.push(end = '}');
		};
		prev = letter;
	};
	
	if (!this._opts.silent) { return this.error(("missing " + (stack.pop()) + ", starting")) };
};

// Expand variables and expressions inside double-quoted strings using
// braces for substitution of arbitrary expressions.
//
//     "Hello {name.capitalize}."
//
// If it encounters an interpolation, this method will recursively create a
// new Lexer, tokenize the interpolated contents, and merge them into the
// token stream.
Lexer.prototype.interpolateString = function (str,options){
	
	if(options === undefined) options = {};
	var heredoc = options.heredoc;
	var quote = options.quote;
	var regex = options.regex;
	var prefix = options.prefix;
	var indent = options.indent;
	
	var startLoc = this._loc;
	var tokens = [];
	var pi = 0;
	var i = -1;
	var locOffset = options.offset || 1;
	var strlen = str.length;
	var letter;
	var expr;
	
	var isInterpolated = false;
	// out of bounds
	
	while (letter = str[i += 1]){
		if (letter == '\\') {
			i += 1;
			continue;
		};
		
		if (letter == '\n' && indent) {
			locOffset += indent.length;
		};
		
		if (!(str[i] == '{' && (expr = this.balancedString(str.slice(i),'}')))) {
			continue;
		};
		
		isInterpolated = true;
		
		// these have no real sense of location or anything?
		if (pi < i) {
			// this is the prefix-string - before any item
			var tok = new Token('NEOSTRING',this.escapeStr(str.slice(pi,i),heredoc,quote),this._loc + pi + locOffset,i - pi);
			// tok.@loc = @loc + pi
			// tok.@len = i - pi + 2
			tokens.push(tok);
		};
		
		tokens.push(new Token('{{','{',this._loc + i + locOffset,1));
		
		var inner = expr.slice(1,-1);
		
		// remove leading spaces 
		// need to keep track of how much whitespace we dropped from the start
		inner = inner.replace(/^[^\n\S]+/,'');
		
		if (inner.length) {
			// we need to remember the loc we start at
			// console.log('interpolate from loc',@loc,i)
			// really? why not just add to the stack??
			// what about the added 
			// should share with the selector no?
			// console.log "tokenize inner parts of string",inner
			var spaces = 0;
			var offset = this._loc + i + (expr.length - inner.length) - 1;
			// why create a whole new lexer? Should rather reuse one
			// much better to simply move into interpolation mode where
			// we continue parsing until we meet unpaired }
			var nested = new Lexer().tokenize(inner,{inline: true,rewrite: false,loc: offset + locOffset});
			// console.log nested.pop
			
			if (nested[0] && tT(nested[0]) == 'TERMINATOR') {
				nested.shift();
			};
			
			if (nested.length) {
				tokens.push.apply(tokens,nested); // T.token('TOKENS',nested,0)
			};
		};
		
		// should rather add the amount by which our lexer has moved?
		i += expr.length - 1;
		tokens.push(new Token('}}','}',this._loc + i + locOffset,1));
		pi = i + 1;
	};
	
	// adding the last part of the string here
	if (i >= pi && pi < str.length) {
		// set the length as well - or?
		// the string after?
		// console.log 'push neostring'
		tokens.push(new Token('NEOSTRING',this.escapeStr(str.slice(pi),heredoc,quote),this._loc + pi + locOffset,str.length - pi));
	};
	
	// console.log tokens:length
	if (regex) { return tokens };
	
	if (!tokens.length) { return this.token('NEOSTRING','""') };
	
	for (var j = 0, len = tokens.length; j < len; j++) {
		this._tokens.push(tokens[j]);
	};
	
	return tokens;
};

// Matches a balanced group such as a single or double-quoted string. Pass in
// a series of delimiters, all of which must be nested correctly within the
// contents of the string. This method allows us to have strings within
// interpolations within strings, ad infinitum.
Lexer.prototype.balancedSelector = function (str,end){
	var prev;
	var letter;
	var stack = [end];
	// FIXME
	for (var len = str.length, i = 1, rd = len - i; (rd > 0) ? (i < len) : (i > len); (rd > 0) ? (i++) : (i--)) {
		switch (letter = str.charAt(i)) {
			case '\\':
				i++;
				continue;
				break;
			
			case end:
				stack.pop();
				if (!stack.length) {
					return str.slice(0,i + 1);
				};
				
				end = stack[stack.length - 1];
				continue;
				break;
		
		};
		if (end == '}' && letter == [')']) {
			stack.push(end = letter);
		} else if (end == '}' && letter == '{') {
			stack.push(end = '}');
		} else if (end == ')' && letter == '{') {
			stack.push(end = '}');
		};
		prev = letter; // what, why?
	};
	
	return this.error(("missing " + (stack.pop()) + ", starting"));
};

// Pairs up a closing token, ensuring that all listed pairs of tokens are
// correctly balanced throughout the course of the token stream.
Lexer.prototype.pair = function (tok){
	var wanted = last(this._ends);
	if (tok != wanted) {
		if (!('OUTDENT' == wanted)) { this.error(("unmatched " + tok)) };
		var size = last(this._indents);
		this._indent -= size;
		this.outdentToken(size,true,0);
		return this.pair(tok);
	};
	return this.popEnd();
};


// Helpers
// -------

// Add a token to the results, taking note of the line number.
Lexer.prototype.token = function (id,value,len,offset){
	this._lastTyp = id;
	this._lastVal = value;
	var tok = this._last = new Token(id,value,this._loc + (offset || 0),len || 0);
	this._tokens.push(tok);
	return;
};

Lexer.prototype.lastTokenType = function (){
	var token = this._tokens[this._tokens.length - 1];
	return token ? tT(token) : 'NONE';
};

Lexer.prototype.lastTokenValue = function (){
	var token = this._tokens[this._tokens.length - 1];
	return token ? token._value : '';
};

// Peek at a tokid in the current token stream.
Lexer.prototype.tokid = function (index,val){
	var tok;
	if (tok = last(this._tokens,index)) {
		if (val) { tTs(tok,val) };
		return tT(tok);
	} else {
		return null;
	};
};

// Peek at a value in the current token stream.
Lexer.prototype.value = function (index,val){
	var tok;
	if (tok = last(this._tokens,index)) {
		if (val) { tVs(tok,val) };
		return tV(tok);
	} else {
		return null;
	};
};


// Are we in the midst of an unfinished expression?
Lexer.prototype.unfinished = function (){
	if (LINE_CONTINUER.test(this._chunk)) { return true };
	return UNFINISHED.indexOf(this._lastTyp) >= 0;
};

// Converts newlines for string literals.
Lexer.prototype.escapeLines = function (str,heredoc){
	return str.replace(MULTILINER,(heredoc ? '\\n' : ''));
};

// Constructs a string token by escaping quotes and newlines.
Lexer.prototype.makeString = function (body,quote,heredoc){
	if (!(body)) { return quote + quote };
	body = body.replace(/\\([\s\S])/g,function(match,contents) {
		return (contents == '\n' || contents == quote) ? contents : match;
	});
	// Does not work now
	body = body.replace(RegExp(("" + quote),"g"),'\\$&');
	return quote + this.escapeLines(body,heredoc) + quote;
};

// Throws a syntax error on the current `@line`.
Lexer.prototype.error = function (message,len){
	if ((typeof this._line=='number'||this._line instanceof Number)) { message = ("" + message + " on line " + (this._line)) };
	
	if (len) {
		message += (" [" + (this._loc) + ":" + (this._loc + len) + "]");
	};
	
	var err = new SyntaxError(message);
	err.line = this._line;
	// err:columnNumber
	err = new ERR.ImbaParseError(err,{tokens: this._tokens,pos: this._tokens.length});
	err.region = [this._loc,this._loc + (len || 0)];
	throw err;
};

Lexer.prototype.warn = function (message){
	var ary = this._tokens.warnings || (this._tokens.warnings = []);
	ary.push(message);
	console.warn(message);
	return this;
};



/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
// imba$inlineHelpers=1
// The Imba language has a good deal of optional syntax, implicit syntax,
// and shorthand syntax. This can greatly complicate a grammar and bloat
// the resulting parse table. Instead of making the parser handle it all, we take
// a series of passes over the token stream, using this **Rewriter** to convert
// shorthand into the unambiguous long form, add implicit indentation and
// parentheses, and generally clean things up.


var T = __webpack_require__(0);
var Token = T.Token;

var v8;


var constants$ = __webpack_require__(4), INVERSES = constants$.INVERSES, BALANCED_PAIRS = constants$.BALANCED_PAIRS, TOK = constants$.TOK;

// var TERMINATOR = TERMINATOR

var TERMINATOR = 'TERMINATOR';
var INDENT = 'INDENT';
var OUTDENT = 'OUTDENT';
var DEF_BODY = 'DEF_BODY';
var THEN = 'THEN';
var CATCH = 'CATCH';

var arrayToHash = function(ary) {
	var hash = {};
	for (var i = 0, items = iter$(ary), len = items.length; i < len; i++) {
		hash[items[i]] = 1;
	};
	return hash;
};

// var EXPRESSION_START = ['(','[','{','INDENT','CALL_START','PARAM_START','INDEX_START','BLOCK_PARAM_START','STRING_START','{{', 'TAG_START']
// var EXPRESSION_END   = [')',']','}','OUTDENT','CALL_END','PARAM_END','INDEX_END','BLOCK_PARAM_END','STRING_END','}}', 'TAG_END']
// Tokens that indicate the close of a clause of an expression.
var EXPRESSION_CLOSE = [')',']','}','OUTDENT','CALL_END','PARAM_END','INDEX_END','BLOCK_PARAM_END','STRING_END','}}','TAG_END','CATCH','WHEN','ELSE','FINALLY'];

var EXPRESSION_CLOSE_HASH = arrayToHash(EXPRESSION_CLOSE);

var EXPRESSION_START = {
	'(': 1,
	'[': 1,
	'{': 1,
	'{{': 1,
	'INDENT': 1,
	'CALL_START': 1,
	'PARAM_START': 1,
	'INDEX_START': 1,
	'BLOCK_PARAM_START': 1,
	'STRING_START': 1,
	'TAG_START': 1
};

var EXPRESSION_END = {
	')': 1,
	']': 1,
	'}': 1,
	'}}': 1,
	'OUTDENT': 1,
	'CALL_END': 1,
	'PARAM_END': 1,
	'INDEX_END': 1,
	'BLOCK_PARAM_END': 1,
	'STRING_END': 1,
	'TAG_END': 1
};

var SINGLE_LINERS = {
	ELSE: 1,
	TRY: 1,
	FINALLY: 1,
	THEN: 1,
	BLOCK_PARAM_END: 1,
	DO: 1,
	BEGIN: 1,
	CATCH_VAR: 1
};

var SINGLE_CLOSERS_MAP = {
	TERMINATOR: true,
	CATCH: true,
	FINALLY: true,
	ELSE: true,
	OUTDENT: true,
	LEADING_WHEN: true
};

var IMPLICIT_FUNC_MAP = {
	'IDENTIFIER': 1,
	'SUPER': 1,
	'@': 1,
	'THIS': 1,
	'SELF': 1,
	'TAG_END': 1,
	'IVAR': 1,
	'GVAR': 1,
	'CONST': 1,
	'ARGVAR': 1,
	'NEW': 1,
	'BREAK': 1,
	'CONTINUE': 1,
	'RETURN': 1
};

var IMPLICIT_CALL_MAP = {
	'SELECTOR': 1,
	'IDENTIFIER': 1,
	'NUMBER': 1,
	'STRING': 1,
	'SYMBOL': 1,
	'JS': 1,
	'REGEX': 1,
	'NEW': 1,
	'CLASS': 1,
	'IF': 1,
	'UNLESS': 1,
	'TRY': 1,
	'SWITCH': 1,
	'THIS': 1,
	'BOOL': 1,
	'TRUE': 1,
	'FALSE': 1,
	'NULL': 1,
	'UNDEFINED': 1,
	'UNARY': 1,
	'SUPER': 1,
	'IVAR': 1,
	'GVAR': 1,
	'CONST': 1,
	'ARGVAR': 1,
	'SELF': 1,
	'@': 1,
	'[': 1,
	'(': 1,
	'{': 1,
	'--': 1,
	'++': 1,
	'TAGID': 1,
	'#': 1,
	'TAG_START': 1,
	'PARAM_START': 1,
	'SELECTOR_START': 1,
	'STRING_START': 1,
	'IDREF': 1,
	'SPLAT': 1,
	'DO': 1,
	'BLOCK_ARG': 1,
	'FOR': 1,
	'CONTINUE': 1,
	'BREAK': 1
};


var IDENTIFIERS = ['IDENTIFIER','GVAR','IVAR','CVAR','CONST','ARGVAR'];



// Tokens that, if followed by an `IMPLICIT_CALL`, indicate a function invocation.
var IMPLICIT_FUNC = ['IDENTIFIER','SUPER','@','THIS','SELF','EVENT','TRIGGER','TAG_END','IVAR',
'GVAR','CONST','ARGVAR','NEW','BREAK','CONTINUE','RETURN'];

// If preceded by an `IMPLICIT_FUNC`, indicates a function invocation.
var IMPLICIT_CALL = [
	'SELECTOR','IDENTIFIER','NUMBER','STRING','SYMBOL','JS','REGEX','NEW','PARAM_START','CLASS',
	'IF','UNLESS','TRY','SWITCH','THIS','BOOL','TRUE','FALSE','NULL','UNDEFINED','UNARY','SUPER','IVAR','GVAR','CONST','ARGVAR','SELF',
	'@','[','(','{','--','++','SELECTOR','TAG_START','TAGID','#','SELECTOR_START','IDREF','SPLAT','DO','BLOCK_ARG',
	'FOR','STRING_START','CONTINUE','BREAK'
]; // '->', '=>', why does it not work with symbol?

var IMPLICIT_INDENT_CALL = [
	'FOR'
];
// is not do an implicit call??

var IMPLICIT_UNSPACED_CALL = ['+','-'];

// Tokens indicating that the implicit call must enclose a block of expressions.
var IMPLICIT_BLOCK = ['{','[',',','BLOCK_PARAM_END','DO']; // '->', '=>', 

var IMPLICIT_BLOCK_MAP = arrayToHash(IMPLICIT_BLOCK);

var CONDITIONAL_ASSIGN = ['||=','&&=','?=','&=','|='];
var COMPOUND_ASSIGN = ['-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|='];
var UNARY = ['!','~','NEW','TYPEOF','DELETE'];
var LOGIC = ['&&','||','&','|','^'];

// optimize for fixed arrays
var NO_IMPLICIT_BLOCK_CALL = [
	'CALL_END','=','DEF_BODY','(','CALL_START',',',':','RETURN',
	'-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|='
]; // .concat(COMPOUND_ASSIGN)

var NO_CALL_TAG = ['CLASS','IF','UNLESS','TAG','WHILE','FOR','UNTIL','CATCH','FINALLY','MODULE','LEADING_WHEN'];

var NO_CALL_TAG_MAP = arrayToHash(NO_CALL_TAG);


// console.log NO_IMPLICIT_BLOCK_CALL:length
// NO_IMPLICIT_BLOCK_CALL
// IMPLICIT_COMMA = ['->', '=>', '{', '[', 'NUMBER', 'STRING', 'SYMBOL', 'IDENTIFIER','DO']

var IMPLICIT_COMMA = ['DO'];

// Tokens that always mark the end of an implicit call for single-liners.
var IMPLICIT_END = ['POST_IF','POST_UNLESS','POST_FOR','WHILE','UNTIL','WHEN','BY','LOOP','TERMINATOR','DEF_BODY','DEF_FRAGMENT'];

var IMPLICIT_END_MAP = {
	POST_IF: true,
	POST_UNLESS: true,
	POST_FOR: true,
	WHILE: true,
	UNTIL: true,
	WHEN: true,
	BY: true,
	LOOP: true,
	TERMINATOR: true,
	DEF_BODY: true,
	DEF_FRAGMENT: true
};

// Single-line flavors of block expressions that have unclosed endings.
// The grammar can't disambiguate them, so we insert the implicit indentation.
// var SINGLE_LINERS    = ['ELSE', 'TRY', 'FINALLY', 'THEN','BLOCK_PARAM_END','DO','BEGIN','CATCH_VAR'] # '->', '=>', really?
var SINGLE_CLOSERS = ['TERMINATOR','CATCH','FINALLY','ELSE','OUTDENT','LEADING_WHEN'];
var LINEBREAKS = ['TERMINATOR','INDENT','OUTDENT']; // Tokens that end a line.

var CALLCOUNT = 0;
// Based on the original rewriter.coffee from CoffeeScript
function Rewriter(){
	this._tokens = [];
	this._options = {};
	this._len = 0;
	this._starter = null;
	this;
};

exports.Rewriter = Rewriter; // export class 
Rewriter.prototype.reset = function (){
	return this;
};

Rewriter.prototype.tokens = function (){
	return this._tokens;
};

// Helpful snippet for debugging:
//     console.log (t[0] + '/' + t[1] for t in @tokens).join ' '
// Rewrite the token stream in multiple passes, one logical filter at
// a time. This could certainly be changed into a single pass through the
// stream, with a big ol' efficient switch, but it's much nicer to work with
// like this. The order of these passes matters -- indentation must be
// corrected before implicit parentheses can be wrapped around blocks of code.
Rewriter.prototype.rewrite = function (tokens,opts){
	if(opts === undefined) opts = {};
	this.reset();
	
	this._tokens = tokens;
	this._options = opts;
	
	var i = 0;
	var k = tokens.length;
	// flag empty methods
	while (i < (k - 1)){
		var token = tokens[i];
		
		if (token._type == 'DEF_BODY') {
			var next = tokens[i + 1];
			if (next && next._type == TERMINATOR) {
				token._type = 'DEF_EMPTY';
			};
		};
		i++;
	};
	
	this.step("all");
	if (CALLCOUNT) { console.log(CALLCOUNT) };
	return this._tokens;
};

Rewriter.prototype.all = function (){
	this.step("ensureFirstLine");
	this.step("removeLeadingNewlines");
	this.step("removeMidExpressionNewlines");
	this.step("tagDefArguments");
	this.step("closeOpenCalls");
	this.step("closeOpenIndexes");
	this.step("closeOpenTags");
	this.step("addImplicitIndentation");
	this.step("tagPostfixConditionals");
	this.step("addImplicitBraces");
	return this.step("addImplicitParentheses");
};

Rewriter.prototype.step = function (fn){
	
	
	this[fn]();
	
	if (v8) {
		var opt = v8.getOptimizationStatus(this[fn]);
		if (opt != 1) {
			process.stdout.write(("" + fn + ": " + opt + "\n"));
			v8.optimizeFunctionOnNextCall(this[fn]);
		};
		
		// if opt == 2
		// v8.optimizeFunctionOnNextCall(this[fn])
		//	v8:helpers.printStatus(this[fn])
		// console.log v8.getOptimizationStatus(this[fn])
	};
	
	
	
	return;
};

// Rewrite the token stream, looking one token ahead and behind.
// Allow the return value of the block to tell us how many tokens to move
// forwards (or backwards) in the stream, to make sure we don't miss anything
// as tokens are inserted and removed, and the stream changes length under
// our feet.
Rewriter.prototype.scanTokens = function (block){
	var tokens = this._tokens;
	
	var i = 0;
	while (i < tokens.length){
		i += block.call(this,tokens[i],i,tokens);
	};
	return true;
};

Rewriter.prototype.detectEnd = function (i,condition,action,state){
	
	if(state === undefined) state = {};
	var tokens = this._tokens;
	var levels = 0;
	var token;
	var t,v;
	
	while (i < tokens.length){
		token = tokens[i];
		
		if (levels == 0 && condition.call(this,token,i,tokens,state)) {
			return action.call(this,token,i,tokens,state);
		};
		
		if (!(token) || levels < 0) {
			return action.call(this,token,i - 1,tokens,state);
		};
		
		t = token._type;
		
		if (EXPRESSION_START[t]) {
			levels += 1;
		} else if (EXPRESSION_END[t]) {
			levels -= 1;
		};
		i += 1;
	};
	
	return i - 1;
};

Rewriter.prototype.ensureFirstLine = function (){
	var token = this._tokens[0];
	
	if (token._type === TERMINATOR) {
		this._tokens.unshift(T.token('BODYSTART','BODYSTART'));
		// @tokens = [T.token('BODYSTART','BODYSTART')].concat(@tokens)
	};
	return;
};

// Leading newlines would introduce an ambiguity in the grammar, so we
// dispatch them here.
Rewriter.prototype.removeLeadingNewlines = function (){
	var at = 0;
	
	var i = 0; // @tokens:length
	var tokens = this._tokens;
	var token;
	var l = tokens.length;
	
	while (i < l){
		token = tokens[i];
		if (token._type !== TERMINATOR) {
			at = i;break;
		};
		i++;
	};
	
	if (at) { tokens.splice(0,at) };
	return;
};

// Some blocks occur in the middle of expressions -- when we're expecting
// this, remove their trailing newlines.
Rewriter.prototype.removeMidExpressionNewlines = function (){
	
	return this.scanTokens(function(token,i,tokens) { // do |token,i,tokens|
		var next = (tokens.length > (i + 1)) ? tokens[i + 1] : null;
		if (!(token._type === TERMINATOR && next && EXPRESSION_CLOSE_HASH[next._type])) { return 1 }; // .indexOf(next) >= 0
		if (next && next._type == OUTDENT) { return 1 };
		// return 1
		tokens.splice(i,1);
		return 0;
	});
};


Rewriter.prototype.tagDefArguments = function (){
	return true;
};

// The lexer has tagged the opening parenthesis of a method call. Match it with
// its paired close. We have the mis-nested outdent case included here for
// calls that close on the same line, just before their outdent.
Rewriter.prototype.closeOpenCalls = function (){
	var condition = function(token,i,tokens) {
		var t = token._type;
		return (t == ')' || t == 'CALL_END') || t == OUTDENT && this.tokenType(i - 1) == ')';
	};
	
	var action = function(token,i,tokens) {
		var t = token._type;
		if (t === OUTDENT) { token = tokens[i - 1] };
		// var tok = @tokens[t == OUTDENT ? i - 1 : i]
		token._type = 'CALL_END';
		return;
		// T.setTyp(tok,'CALL_END')
	};
	
	this.scanTokens(function(token,i,tokens) {
		if (token._type === 'CALL_START') { this.detectEnd(i + 1,condition,action) };
		return 1;
	});
	
	return;
};

// The lexer has tagged the opening parenthesis of an indexing operation call.
// Match it with its paired close.
Rewriter.prototype.closeOpenIndexes = function (){
	// why differentiate between index and []
	var self = this;
	var condition = function(token,i) { return token._type === ']' || token._type === 'INDEX_END'; };
	var action = function(token,i) { return token._type = 'INDEX_END'; };
	
	return self.scanTokens(function(token,i,tokens) {
		if (token._type === 'INDEX_START') { self.detectEnd(i + 1,condition,action) };
		return 1;
	});
};

// The lexer has tagged the opening parenthesis of an indexing operation call.
// Match it with its paired close. Should be done in lexer directly
Rewriter.prototype.closeOpenTags = function (){
	var self = this;
	var condition = function(token,i) { return token._type == '>' || token._type == 'TAG_END'; };
	var action = function(token,i) { return token._type = 'TAG_END'; };
	
	return self.scanTokens(function(token,i,tokens) {
		if (token._type === 'TAG_START') { self.detectEnd(i + 1,condition,action) };
		return 1;
	});
};

Rewriter.prototype.addImplicitBlockCalls = function (){
	var i = 1;
	var tokens = this._tokens;
	
	// can use shared states for these
	while (i < tokens.length){
		
		var token = tokens[i];
		var t = token._type;
		var v = token._value;
		// hmm
		if (t == 'DO' && (v == 'INDEX_END' || v == 'IDENTIFIER' || v == 'NEW')) {
			tokens.splice(i + 1,0,T.token('CALL_END',')'));
			tokens.splice(i + 1,0,T.token('CALL_START','('));
			i++;
		};
		i++;
	};
	
	return;
};

// Object literals may be written with implicit braces, for simple cases.
// Insert the missing braces here, so that the parser doesn't have to.

Rewriter.prototype.addLeftBrace = function (){
	return this;
};

Rewriter.prototype.addImplicitBraces = function (){
	var self = this;
	var stack = [];
	var start = null;
	var startIndent = 0;
	var startIdx = null;
	var baseCtx = ['ROOT',0];
	
	var noBraceContext = ['IF','TERNARY','FOR'];
	
	var noBrace = false;
	
	var action = function(token,i) {
		return self._tokens.splice(i,0,T.RBRACKET);
	};
	
	var open = function(token,i) {
		return self._tokens.splice(i,0,T.LBRACKET);
	};
	
	var close = function(token,i) {
		return self._tokens.splice(i,0,T.RBRACKET);
	};
	
	var stackToken = function(a,b) {
		return [a,b];
	};
	
	// method is called so many times
	return self.scanTokens(function(token,i,tokens) {
		var type = token._type;
		var v = token._value;
		
		var ctx = stack.length ? stack[stack.length - 1] : baseCtx;
		var idx;
		
		if (noBraceContext.indexOf(type) >= 0) {
			stack.push(stackToken(type,i));
			return 1;
		};
		
		if (v == '?') {
			stack.push(stackToken('TERNARY',i));
			return 1;
		};
		
		// no need to test for this here as well as in
		if (EXPRESSION_START[type]) {
			if (type === INDENT && noBraceContext.indexOf(ctx[0]) >= 0) {
				stack.pop();
			};
			
			if (type === INDENT && self.tokenType(i - 1) == '{') {
				stack.push(stackToken('{',i)); // should not autogenerate another?
			} else {
				stack.push(stackToken(type,i));
			};
			return 1;
		};
		
		if (EXPRESSION_END[type]) {
			if (ctx[0] == 'TERNARY') {
				stack.pop();
			};
			
			start = stack.pop();
			start[2] = i;
			
			// seems like the stack should use tokens, no?)
			if (start[0] == '{' && start.generated) {
				close(token,i);
				return 1;
			};
			
			return 1;
		};
		
		// is this correct? same for if/class etc?
		if (ctx[0] == 'TERNARY' && (type === TERMINATOR || type === OUTDENT)) {
			stack.pop();
			return 1;
		};
		
		if (noBraceContext.indexOf(ctx[0]) >= 0 && type === INDENT) {
			stack.pop();
			return 1;
		};
		
		
		if (type == ',') {
			if (ctx[0] == '{' && ctx.generated) {
				tokens.splice(i,0,T.RBRACKET);
				stack.pop();
				return 2;
			} else {
				return 1;
			};
			true;
		};
		
		// found a type
		if (type == ':' && ctx[0] != '{' && ctx[0] != 'TERNARY' && (noBraceContext.indexOf(ctx[0]) == -1)) {
			// could just check if the end was right before this?
			
			if (start && start[2] == i - 1) {
				idx = start[1] - 1; // these are the stackTokens
			} else {
				idx = i - 2; // if start then start[1] - 1 else i - 2
				// idx = idx - 1 if tokenType(idx) is TERMINATOR
			};
			
			while (self.tokenType(idx - 1) === 'HERECOMMENT'){
				idx -= 2;
			};
			
			var t0 = tokens[idx - 1];
			
			if (t0 && T.typ(t0) == '}' && t0.generated) {
				tokens.splice(idx - 1,1);
				var s = stackToken('{');
				s.generated = true;
				stack.push(s);
				return 0;
			} else if (t0 && T.typ(t0) == ',' && self.tokenType(idx - 2) == '}') {
				tokens.splice(idx - 2,1);
				s = stackToken('{');
				s.generated = true;
				stack.push(s);
				return 0;
			} else {
				s = stackToken('{');
				s.generated = true;
				stack.push(s);
				open(token,idx + 1);
				return 2;
			};
		};
		
		// we probably need to run through autocall first?!
		
		if (type == 'DO') { // and ctx:generated
			var prev = T.typ(tokens[i - 1]);
			if (['NUMBER','STRING','REGEX','SYMBOL',']','}',')','STRING_END'].indexOf(prev) >= 0) {
				
				var tok = T.token(',',',');
				tok.generated = true;
				tokens.splice(i,0,tok);
				
				if (ctx.generated) {
					close(token,i);
					stack.pop();
					return 2;
				};
			};
		};
		
		if (ctx.generated && (type === TERMINATOR || type === OUTDENT || type === 'DEF_BODY')) {
			close(token,i);
			stack.pop();
			return 2;
		};
		
		return 1;
	});
};

// Methods may be optionally called without parentheses, for simple cases.
// Insert the implicit parentheses here, so that the parser doesn't have to
// deal with them.
// Practically everything will now be callable this way (every identifier)
Rewriter.prototype.addImplicitParentheses = function (){
	var self = this;
	var tokens = self._tokens;
	
	var noCall = false;
	var seenFor = false;
	var endCallAtTerminator = false;
	
	var seenSingle = false;
	var seenControl = false;
	
	var callObject = false;
	var callIndent = false;
	
	var parensAction = function(token,i,tokens) {
		return tokens.splice(i,0,T.token('CALL_END',')'));
	};
	
	// function will not be optimized in single run
	// could tro to move this out
	var parensCond = function(token,i,tokens) {
		
		var type = token._type;
		
		if (!(seenSingle) && token.fromThen) {
			return true;
		};
		
		var ifelse = type == 'IF' || type == 'UNLESS' || type == 'ELSE';
		
		if (ifelse || type === 'CATCH') {
			seenSingle = true;
		};
		
		if (ifelse || type === 'SWITCH' || type == 'TRY') {
			seenControl = true;
		};
		
		var prev = self.tokenType(i - 1);
		
		if ((type == '.' || type == '?.' || type == '::') && prev === OUTDENT) {
			return true;
		};
		
		if (endCallAtTerminator && (type === INDENT || type === TERMINATOR)) {
			return true;
		};
		
		if ((type == 'WHEN' || type == 'BY') && !(seenFor)) {
			// console.log "dont close implicit call outside for"
			return false;
		};
		
		var post = (tokens.length > (i + 1)) ? tokens[i + 1] : null;
		var postTyp = post && post._type;
		
		if (token.generated || prev === ',') {
			return false;
		};
		
		var cond1 = (IMPLICIT_END_MAP[type] || (type == INDENT && !(seenControl)) || (type == 'DOS' && prev != '='));
		
		if (!(cond1)) {
			return false;
		};
		
		if (type !== INDENT) {
			return true;
		};
		
		if (!IMPLICIT_BLOCK_MAP[prev] && self.tokenType(i - 2) != 'CLASS' && !(post && ((post.generated && postTyp == '{') || IMPLICIT_CALL_MAP[postTyp]))) {
			return true;
		};
		
		return false;
	};
	
	var i = 0;
	
	while (tokens.length > (i + 1)){
		var token = tokens[i];
		var type = token._type;
		
		var prev = (i > 0) ? tokens[i - 1] : null;
		var next = tokens[i + 1];
		
		var pt = prev && prev._type;
		var nt = next && next._type;
		
		if (type === INDENT && (pt == ')' || pt == ']')) {
			noCall = true;
		};
		
		if (NO_CALL_TAG_MAP[pt]) { // .indexOf(pt) >= 0
			// CALLCOUNT++
			// console.log("seen nocall tag {pt} ({pt} {type} {nt})")
			endCallAtTerminator = true;
			noCall = true;
			if (pt == 'FOR') {
				seenFor = true;
			};
		};
		
		callObject = false;
		callIndent = false;
		
		if (!(noCall) && type == INDENT && next) {
			var prevImpFunc = pt && IMPLICIT_FUNC_MAP[pt];
			var nextImpCall = nt && IMPLICIT_CALL_MAP[nt];
			
			callObject = ((next.generated && nt == '{') || nextImpCall) && prevImpFunc;
			callIndent = nextImpCall && prevImpFunc;
		};
		
		seenSingle = false;
		seenControl = false;
		
		// this is not correct if this is inside a block,no?
		if ((type == TERMINATOR || type == OUTDENT || type == INDENT)) {
			endCallAtTerminator = false;
			noCall = false;
		};
		
		if (type == '?' && prev && !prev.spaced) {
			token.call = true;
		};
		
		// where does fromThem come from?
		if (token.fromThen) {
			i += 1;continue;
		};
		
		// here we deal with :spaced and :newLine
		if (!(callObject || callIndent || (prev && prev.spaced) && (prev.call || IMPLICIT_FUNC_MAP[pt]) && (IMPLICIT_CALL_MAP[type] || !(token.spaced || token.newLine) && IMPLICIT_UNSPACED_CALL.indexOf(type) >= 0))) {
			i += 1;continue;
		};
		
		// cache where we want to splice -- add them later
		tokens.splice(i,0,T.token('CALL_START','('));
		// CALLCOUNT++
		
		self.detectEnd(i + 1,parensCond,parensAction);
		
		if (prev._type == '?') {
			prev._type = 'FUNC_EXIST';
		};
		
		i += 2;
		
		// need to reset after a match
		endCallAtTerminator = false;
		noCall = false;
		seenFor = false;
	};
	
	return;
};



Rewriter.prototype.indentCondition = function (token,i,tokens){
	var t = token._type;
	return SINGLE_CLOSERS_MAP[t] && token._value !== ';' && !(t == 'ELSE' && this._starter != 'IF' && this._starter != 'THEN');
};

Rewriter.prototype.indentAction = function (token,i,tokens){
	var idx = (this.tokenType(i - 1) === ',') ? ((i - 1)) : i;
	tokens.splice(idx,0,T.OUTDENT);
	return;
};


// Because our grammar is LALR(1), it can't handle some single-line
// expressions that lack ending delimiters. The **Rewriter** adds the implicit
// blocks, so it doesn't need to. ')' can close a single-line block,
// but we need to make sure it's balanced.
Rewriter.prototype.addImplicitIndentation = function (){
	
	var lookup1 = {
		OUTDENT: 1,
		TERMINATOR: 1,
		FINALLY: 1
	};
	
	var i = 0;
	var tokens = this._tokens;
	var starter;
	
	while (i < tokens.length){
		var token = tokens[i];
		var type = token._type;
		var next = this.tokenType(i + 1);
		
		// why are we removing terminators after then? should be able to handle
		if (type === TERMINATOR && next === THEN) {
			tokens.splice(i,1);
			continue;
		};
		
		if (type === CATCH && lookup1[this.tokenType(i + 2)]) {
			tokens.splice(i + 2,0,T.token(INDENT,'2'),T.token(OUTDENT,'2'));
			i += 4;
			continue;
		};
		
		if (SINGLE_LINERS[type] && (next != INDENT && next != 'BLOCK_PARAM_START') && !(type == 'ELSE' && next == 'IF') && type != 'ELIF') {
			this._starter = starter = type;
			
			var indent = T.token(INDENT,'2');
			if (starter === THEN) { indent.fromThen = true };
			indent.generated = true;
			tokens.splice(i + 1,0,indent);
			this.detectEnd(i + 2,this.indentCondition,this.indentAction);
			if (type === THEN) { tokens.splice(i,1) };
		};
		i++;
	};
	
	return;
};

// Tag postfix conditionals as such, so that we can parse them with a
// different precedence.
Rewriter.prototype.tagPostfixConditionals = function (){
	var self = this;
	var condition = function(token,i,tokens) { return token._type === TERMINATOR || token._type === INDENT; };
	var action = function(token,i,tokens,s) {
		if (token._type != INDENT) { return T.setTyp(s.original,'POST_' + s.original._type) };
	};
	
	return self.scanTokens(function(token,i,tokens) {
		var typ = token._type;
		if (!(typ == 'IF' || typ == 'FOR')) { return 1 };
		self.detectEnd(i + 1,condition,action,{original: token});
		return 1;
	});
};

// Look up a type by token index.
Rewriter.prototype.type = function (i){
	// if i < 0 then return null
	throw "deprecated";
	var tok = this._tokens[i];
	return tok && tok._type;
};

Rewriter.prototype.injectToken = function (index,token){
	return this;
};

Rewriter.prototype.tokenType = function (i){
	if (i < 0 || i >= this._tokens.length) {
		// CALLCOUNT++
		return null;
	};
	
	var tok = this._tokens[i];
	return tok && tok._type;
};

// Constants
// ---------

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

/* parser generated by jison-fork */
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,4],$V1=[1,6],$V2=[1,33],$V3=[1,34],$V4=[1,35],$V5=[1,36],$V6=[1,77],$V7=[1,119],$V8=[1,95],$V9=[1,132],$Va=[1,125],$Vb=[1,126],$Vc=[1,127],$Vd=[1,124],$Ve=[1,128],$Vf=[1,135],$Vg=[1,118],$Vh=[1,136],$Vi=[1,82],$Vj=[1,83],$Vk=[1,84],$Vl=[1,85],$Vm=[1,86],$Vn=[1,87],$Vo=[1,88],$Vp=[1,75],$Vq=[1,122],$Vr=[1,117],$Vs=[1,90],$Vt=[1,73],$Vu=[1,38],$Vv=[1,68],$Vw=[1,69],$Vx=[1,70],$Vy=[1,114],$Vz=[1,92],$VA=[1,93],$VB=[1,89],$VC=[1,29],$VD=[1,30],$VE=[1,98],$VF=[1,97],$VG=[1,115],$VH=[1,116],$VI=[1,123],$VJ=[1,12],$VK=[1,130],$VL=[1,131],$VM=[1,99],$VN=[1,80],$VO=[1,39],$VP=[1,45],$VQ=[1,113],$VR=[1,71],$VS=[1,91],$VT=[1,129],$VU=[1,62],$VV=[1,76],$VW=[1,108],$VX=[1,109],$VY=[1,110],$VZ=[1,133],$V_=[1,134],$V$=[1,66],$V01=[1,107],$V11=[1,54],$V21=[1,55],$V31=[1,56],$V41=[1,57],$V51=[1,58],$V61=[1,59],$V71=[1,138],$V81=[1,6,11,148],$V91=[1,140],$Va1=[1,6,11,14,148],$Vb1=[1,148],$Vc1=[1,149],$Vd1=[1,152],$Ve1=[1,153],$Vf1=[1,145],$Vg1=[1,144],$Vh1=[1,146],$Vi1=[1,147],$Vj1=[1,150],$Vk1=[1,151],$Vl1=[1,156],$Vm1=[1,6,10,11,14,23,79,97,104,118,125,136,146,148,158,178,208,209,220,221,222,227,228,237,246,247,250,251,254,255,256,257],$Vn1=[2,268],$Vo1=[1,163],$Vp1=[1,167],$Vq1=[1,165],$Vr1=[1,166],$Vs1=[1,169],$Vt1=[1,168],$Vu1=[1,6,10,11,14,23,97,104,148],$Vv1=[1,6,11,14,148,220,222,227,228,246],$Vw1=[1,6,10,11,14,22,23,79,95,97,104,117,118,125,136,146,148,155,158,178,189,190,192,204,208,209,220,221,222,227,228,237,246,247,250,251,254,255,256,257],$Vx1=[2,237],$Vy1=[1,6,10,11,14,22,23,79,95,97,104,117,118,122,125,136,146,148,155,158,178,189,190,192,204,208,209,220,221,222,227,228,237,246,247,250,251,254,255,256,257],$Vz1=[2,233],$VA1=[61,62,95,98,112,117,119,121],$VB1=[1,213],$VC1=[1,218],$VD1=[1,6,10,11,14,22,23,79,95,97,104,117,118,122,125,136,146,148,155,158,178,189,190,192,204,208,209,220,221,222,227,228,237,246,247,250,251,252,253,254,255,256,257,258],$VE1=[1,228],$VF1=[1,225],$VG1=[1,230],$VH1=[1,268],$VI1=[1,269],$VJ1=[57,96],$VK1=[2,251],$VL1=[1,281],$VM1=[1,280],$VN1=[92,93,94,95,98,99,100,101,102,103,107,109],$VO1=[1,293],$VP1=[1,6,10,11,14,22,23,61,62,79,95,97,98,104,112,117,118,119,121,122,125,136,146,148,155,158,178,189,190,192,204,208,209,220,221,222,227,228,237,246,247,250,251,252,253,254,255,256,257,258],$VQ1=[1,299],$VR1=[57,96,103,233],$VS1=[1,6,10,11,14,22,23,75,77,78,79,95,97,104,117,118,125,136,146,148,155,158,178,189,190,192,204,208,209,220,221,222,227,228,237,246,247,250,251,254,255,256,257],$VT1=[1,6,10,11,14,22,23,79,95,97,104,117,118,125,136,146,148,155,158,178,189,190,192,204,208,209,215,216,220,221,222,227,228,237,240,242,245,246,247,250,251,254,255,256,257],$VU1=[57,61,62,66],$VV1=[1,331],$VW1=[1,332],$VX1=[1,6,10,11,14,23,79,97,104,118,125,146,148,158,208,209,220,221,222,227,228,237,246],$VY1=[1,6,10,11,14,23,79,97,104,118,125,136,146,148,158,178,208,209,220,221,222,227,228,237,246,247,250,251,254,255,257],$VZ1=[1,346],$V_1=[1,350],$V$1=[1,6,11,14,23,79,97,104,118,125,136,146,148,158,178,208,209,220,221,222,227,228,237,246,247,250,251,254,255,256,257],$V02=[1,6,10,11,14,22,23,79,96,97,104,118,125,136,146,148,158,178,208,209,220,221,222,227,228,237,246,247,250,251,254,255,256,257],$V12=[14,29],$V22=[1,6,11,14,29,148,220,222,227,228,246],$V32=[2,289],$V42=[1,6,10,11,14,22,23,79,95,97,104,117,118,122,125,136,146,148,155,158,178,189,190,192,204,208,209,220,221,222,227,228,235,236,237,246,247,250,251,252,253,254,255,256,257,258],$V52=[2,190],$V62=[1,374],$V72=[6,10,11,14,23,104],$V82=[2,192],$V92=[1,384],$Va2=[1,385],$Vb2=[1,386],$Vc2=[1,6,10,11,14,23,79,97,104,118,125,146,148,158,208,209,228,237,246],$Vd2=[1,6,10,11,14,23,79,97,104,118,125,146,148,158,208,209,221,228,237,246],$Ve2=[235,236],$Vf2=[14,235,236],$Vg2=[1,6,11,14,23,79,97,104,118,125,146,148,158,178,208,209,220,221,222,227,228,237,246,247,250,251,254,255,256,257],$Vh2=[1,400],$Vi2=[6,10,11,14,97],$Vj2=[6,10,11,14,97,146],$Vk2=[95,98],$Vl2=[1,410],$Vm2=[1,411],$Vn2=[22,95,98,170,171],$Vo2=[1,6,10,11,14,23,79,97,104,118,125,136,146,148,158,178,208,209,220,221,222,227,228,237,246,247,250,251,255,257],$Vp2=[1,6,10,11,14,23,79,97,104,118,125,146,148,158,208,209,221,237],$Vq2=[20,21,24,25,27,33,36,57,61,62,64,66,68,70,72,74,80,81,82,83,84,85,86,87,90,96,103,110,118,131,132,133,134,140,141,147,154,155,162,163,165,181,183,185,193,194,196,201,202,205,206,212,218,220,222,224,227,228,238,244,248,249,250,251,252,253],$Vr2=[1,6,10,11,14,23,79,97,104,118,125,136,146,148,158,178,208,209,220,221,222,227,228,237,240,245,246,247,250,251,254,255,256,257],$Vs2=[11,240,242],$Vt2=[1,460],$Vu2=[2,191],$Vv2=[6,10,11],$Vw2=[1,468],$Vx2=[14,23,158],$Vy2=[1,6,10,11,14,23,79,97,104,118,125,146,148,158,208,209,220,222,227,228,237,246],$Vz2=[1,483],$VA2=[57,66,96],$VB2=[14,23],$VC2=[1,498],$VD2=[10,14],$VE2=[1,544],$VF2=[6,10];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"Root":3,"Body":4,"Block":5,"TERMINATOR":6,"BODYSTART":7,"Line":8,"Terminator":9,"INDENT":10,"OUTDENT":11,"Splat":12,"Expression":13,",":14,"Comment":15,"Statement":16,"ExportStatement":17,"Return":18,"Throw":19,"STATEMENT":20,"BREAK":21,"CALL_START":22,"CALL_END":23,"CONTINUE":24,"DEBUGGER":25,"ImportStatement":26,"IMPORT":27,"ImportArgList":28,"FROM":29,"ImportFrom":30,"AS":31,"ImportArg":32,"STRING":33,"VarIdentifier":34,"Require":35,"REQUIRE":36,"RequireArg":37,"Literal":38,"Parenthetical":39,"Await":40,"Value":41,"Code":42,"Operation":43,"Assign":44,"If":45,"Ternary":46,"Try":47,"While":48,"For":49,"Switch":50,"Class":51,"Module":52,"TagDeclaration":53,"Tag":54,"Property":55,"Identifier":56,"IDENTIFIER":57,"Key":58,"KEY":59,"Ivar":60,"IVAR":61,"CVAR":62,"Gvar":63,"GVAR":64,"Const":65,"CONST":66,"Argvar":67,"ARGVAR":68,"Symbol":69,"SYMBOL":70,"AlphaNumeric":71,"NUMBER":72,"InterpolatedString":73,"STRING_START":74,"NEOSTRING":75,"Interpolation":76,"STRING_END":77,"{{":78,"}}":79,"JS":80,"REGEX":81,"BOOL":82,"TRUE":83,"FALSE":84,"NULL":85,"UNDEFINED":86,"RETURN":87,"Arguments":88,"TagSelector":89,"SELECTOR_START":90,"TagSelectorType":91,"SELECTOR_NS":92,"SELECTOR_ID":93,"SELECTOR_CLASS":94,".":95,"{":96,"}":97,"#":98,"SELECTOR_COMBINATOR":99,"SELECTOR_PSEUDO_CLASS":100,"SELECTOR_GROUP":101,"UNIVERSAL_SELECTOR":102,"[":103,"]":104,"SELECTOR_ATTR_OP":105,"TagSelectorAttrValue":106,"SELECTOR_TAG":107,"Selector":108,"SELECTOR_END":109,"TAG_START":110,"TagOptions":111,"TAG_END":112,"TagBody":113,"TagTypeName":114,"Self":115,"TAG_TYPE":116,"INDEX_START":117,"INDEX_END":118,"@":119,"TagAttr":120,"TAG_ATTR":121,"=":122,"TagAttrValue":123,"VALUE_START":124,"VALUE_END":125,"ArgList":126,"TagTypeDef":127,"EXPORT":128,"DEFAULT":129,"TagDeclarationBlock":130,"EXTEND":131,"LOCAL":132,"GLOBAL":133,"TAG":134,"TagType":135,"COMPARE":136,"TagDeclKeywords":137,"TAG_ID":138,"TagId":139,"IDREF":140,"TAGID":141,"Assignable":142,"Outdent":143,"AssignObj":144,"ObjAssignable":145,":":146,"(":147,")":148,"HERECOMMENT":149,"COMMENT":150,"Method":151,"Do":152,"Begin":153,"BEGIN":154,"DO":155,"BLOCK_PARAM_START":156,"ParamList":157,"BLOCK_PARAM_END":158,"PropType":159,"PropertyIdentifier":160,"Object":161,"PROP":162,"ATTR":163,"MethodDeclaration":164,"DEF":165,"MethodScope":166,"MethodScopeType":167,"MethodIdentifier":168,"MethodBody":169,"DEF_BODY":170,"DEF_EMPTY":171,"This":172,"OptComma":173,"Param":174,"Array":175,"ParamVar":176,"SPLAT":177,"LOGIC":178,"BLOCK_ARG":179,"VarReference":180,"VAR":181,"VarAssignable":182,"LET":183,"SimpleAssignable":184,"ENV_FLAG":185,"NEW":186,"Super":187,"SoakableOp":188,"?:":189,".:":190,"IndexValue":191,"?.":192,"SUPER":193,"AWAIT":194,"Range":195,"ARGUMENTS":196,"Invocation":197,"Slice":198,"AssignList":199,"ClassStart":200,"CLASS":201,"MODULE":202,"OptFuncExist":203,"FUNC_EXIST":204,"THIS":205,"SELF":206,"RangeDots":207,"..":208,"...":209,"Arg":210,"SimpleArgs":211,"TRY":212,"Catch":213,"Finally":214,"FINALLY":215,"CATCH":216,"CATCH_VAR":217,"THROW":218,"WhileSource":219,"WHILE":220,"WHEN":221,"UNTIL":222,"Loop":223,"LOOP":224,"ForBody":225,"ForKeyword":226,"FOR":227,"POST_FOR":228,"ForBlock":229,"ForStart":230,"ForSource":231,"ForVariables":232,"OWN":233,"ForValue":234,"FORIN":235,"FOROF":236,"BY":237,"SWITCH":238,"Whens":239,"ELSE":240,"When":241,"LEADING_WHEN":242,"IfBlock":243,"IF":244,"ELIF":245,"POST_IF":246,"?":247,"UNARY":248,"SQRT":249,"-":250,"+":251,"--":252,"++":253,"MATH":254,"SHIFT":255,"NOT":256,"RELATION":257,"COMPOUND_ASSIGN":258,"$accept":0,"$end":1},
terminals_: {2:"error",6:"TERMINATOR",7:"BODYSTART",10:"INDENT",11:"OUTDENT",14:",",20:"STATEMENT",21:"BREAK",22:"CALL_START",23:"CALL_END",24:"CONTINUE",25:"DEBUGGER",27:"IMPORT",29:"FROM",31:"AS",33:"STRING",36:"REQUIRE",57:"IDENTIFIER",59:"KEY",61:"IVAR",62:"CVAR",64:"GVAR",66:"CONST",68:"ARGVAR",70:"SYMBOL",72:"NUMBER",74:"STRING_START",75:"NEOSTRING",77:"STRING_END",78:"{{",79:"}}",80:"JS",81:"REGEX",82:"BOOL",83:"TRUE",84:"FALSE",85:"NULL",86:"UNDEFINED",87:"RETURN",90:"SELECTOR_START",92:"SELECTOR_NS",93:"SELECTOR_ID",94:"SELECTOR_CLASS",95:".",96:"{",97:"}",98:"#",99:"SELECTOR_COMBINATOR",100:"SELECTOR_PSEUDO_CLASS",101:"SELECTOR_GROUP",102:"UNIVERSAL_SELECTOR",103:"[",104:"]",105:"SELECTOR_ATTR_OP",107:"SELECTOR_TAG",109:"SELECTOR_END",110:"TAG_START",112:"TAG_END",116:"TAG_TYPE",117:"INDEX_START",118:"INDEX_END",119:"@",121:"TAG_ATTR",122:"=",124:"VALUE_START",125:"VALUE_END",128:"EXPORT",129:"DEFAULT",131:"EXTEND",132:"LOCAL",133:"GLOBAL",134:"TAG",136:"COMPARE",138:"TAG_ID",140:"IDREF",141:"TAGID",146:":",147:"(",148:")",149:"HERECOMMENT",150:"COMMENT",154:"BEGIN",155:"DO",156:"BLOCK_PARAM_START",158:"BLOCK_PARAM_END",162:"PROP",163:"ATTR",165:"DEF",170:"DEF_BODY",171:"DEF_EMPTY",177:"SPLAT",178:"LOGIC",179:"BLOCK_ARG",181:"VAR",183:"LET",185:"ENV_FLAG",186:"NEW",189:"?:",190:".:",192:"?.",193:"SUPER",194:"AWAIT",196:"ARGUMENTS",201:"CLASS",202:"MODULE",204:"FUNC_EXIST",205:"THIS",206:"SELF",208:"..",209:"...",212:"TRY",215:"FINALLY",216:"CATCH",217:"CATCH_VAR",218:"THROW",220:"WHILE",221:"WHEN",222:"UNTIL",224:"LOOP",227:"FOR",228:"POST_FOR",233:"OWN",235:"FORIN",236:"FOROF",237:"BY",238:"SWITCH",240:"ELSE",242:"LEADING_WHEN",244:"IF",245:"ELIF",246:"POST_IF",247:"?",248:"UNARY",249:"SQRT",250:"-",251:"+",252:"--",253:"++",254:"MATH",255:"SHIFT",256:"NOT",257:"RELATION",258:"COMPOUND_ASSIGN"},
productions_: [0,[3,0],[3,1],[3,2],[4,1],[4,1],[4,3],[4,2],[9,1],[5,2],[5,3],[5,4],[8,1],[8,1],[8,3],[8,3],[8,1],[8,1],[8,1],[16,1],[16,1],[16,1],[16,1],[16,4],[16,1],[16,4],[16,1],[16,1],[26,4],[26,4],[26,2],[30,1],[28,1],[28,3],[32,1],[35,2],[37,1],[37,1],[37,0],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[56,1],[58,1],[60,1],[60,1],[63,1],[65,1],[67,1],[69,1],[71,1],[71,1],[71,1],[71,1],[73,1],[73,2],[73,2],[73,2],[76,2],[76,3],[38,1],[38,1],[38,1],[38,1],[38,1],[38,1],[38,1],[38,1],[18,2],[18,2],[18,1],[89,1],[89,2],[89,2],[89,2],[89,2],[89,5],[89,5],[89,2],[89,2],[89,2],[89,2],[89,4],[89,6],[91,1],[108,2],[106,1],[106,1],[106,3],[54,3],[54,4],[54,5],[114,1],[114,1],[114,1],[114,0],[111,1],[111,3],[111,4],[111,3],[111,3],[111,5],[111,5],[111,3],[111,2],[111,5],[111,2],[120,1],[120,3],[123,3],[113,3],[113,3],[113,1],[127,1],[127,3],[17,3],[17,2],[53,1],[53,2],[53,2],[53,2],[130,2],[130,3],[130,4],[130,5],[137,0],[137,1],[135,1],[135,1],[139,1],[139,1],[44,3],[44,5],[144,1],[144,3],[144,5],[144,1],[145,1],[145,1],[145,1],[145,1],[145,1],[145,1],[145,3],[15,1],[15,1],[42,1],[42,1],[42,1],[153,2],[152,2],[152,5],[55,3],[55,5],[55,2],[159,1],[159,1],[160,1],[160,3],[151,1],[151,2],[164,8],[164,5],[164,6],[164,3],[167,1],[167,1],[168,1],[168,1],[168,3],[169,2],[169,2],[169,1],[166,1],[166,1],[166,1],[166,1],[173,0],[173,1],[157,0],[157,1],[157,3],[174,1],[174,1],[174,1],[174,2],[174,2],[174,2],[174,3],[176,1],[12,2],[180,3],[180,2],[180,2],[180,3],[34,1],[34,1],[182,1],[182,1],[182,1],[184,1],[184,1],[184,1],[184,1],[184,1],[184,1],[184,1],[184,1],[184,3],[184,3],[184,3],[184,3],[184,3],[184,3],[184,3],[184,3],[184,4],[188,1],[188,1],[187,1],[142,1],[142,1],[142,1],[40,2],[41,1],[41,1],[41,1],[41,1],[41,1],[41,1],[41,1],[41,1],[41,1],[41,1],[41,1],[191,1],[191,1],[161,4],[199,0],[199,1],[199,3],[199,4],[199,6],[51,1],[51,2],[51,2],[51,2],[200,2],[200,3],[200,4],[200,5],[52,2],[52,3],[197,3],[197,2],[203,0],[203,1],[88,2],[88,4],[172,1],[115,1],[175,2],[175,4],[207,1],[207,1],[195,5],[198,3],[198,2],[198,2],[126,1],[126,3],[126,4],[126,4],[126,6],[143,2],[143,1],[210,1],[210,1],[210,1],[210,1],[211,1],[211,3],[47,2],[47,3],[47,3],[47,4],[214,2],[213,3],[19,2],[39,3],[39,5],[219,2],[219,4],[219,2],[219,4],[48,2],[48,2],[48,2],[48,1],[223,2],[223,2],[49,2],[49,2],[49,2],[226,1],[226,1],[229,2],[225,2],[225,2],[230,2],[230,3],[234,1],[234,1],[234,1],[232,1],[232,3],[231,2],[231,2],[231,4],[231,4],[231,4],[231,6],[231,6],[50,5],[50,7],[50,4],[50,6],[239,1],[239,2],[241,3],[241,4],[243,3],[243,5],[243,4],[243,3],[45,1],[45,3],[45,3],[46,5],[43,2],[43,2],[43,2],[43,2],[43,2],[43,2],[43,2],[43,2],[43,3],[43,3],[43,3],[43,3],[43,3],[43,3],[43,4],[43,3],[43,3],[43,5]],
performAction: function performAction(self, yytext, yy, yystate /* action[1] */, $$ /* vstack */) {
/* self == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
return self.$ = new yy.Root([]);
break;
case 2:
return self.$ = new yy.Root($$[$0]);
break;
case 3:
return self.$ = $$[$0-1];
break;
case 4:
self.$ = new yy.Block([]);
break;
case 5:
self.$ = new yy.Block([$$[$0]]);
break;
case 6:
self.$ = $$[$0-2].break($$[$0-1]).add($$[$0]);
break;
case 7:
self.$ = $$[$0-1].break($$[$0]);
break;
case 8:
self.$ = new yy.Terminator($$[$0]);
break;
case 9:
self.$ = new yy.Block([]).indented($$[$0-1],$$[$0]);
break;
case 10: case 123:
self.$ = $$[$0-1].indented($$[$0-2],$$[$0]);
break;
case 11:
self.$ = $$[$0-1].prebreak($$[$0-2]).indented($$[$0-3],$$[$0]);
break;
case 12: case 13: case 16: case 17: case 18: case 19: case 20: case 27: case 31: case 34: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 65: case 66: case 73: case 99: case 100: case 105: case 130: case 138: case 149: case 150: case 151: case 152: case 153: case 154: case 155: case 159: case 160: case 161: case 168: case 169: case 170: case 172: case 180: case 181: case 183: case 186: case 187: case 188: case 189: case 190: case 191: case 202: case 208: case 209: case 210: case 211: case 212: case 214: case 216: case 217: case 218: case 219: case 233: case 234: case 235: case 237: case 238: case 239: case 240: case 241: case 243: case 244: case 245: case 246: case 247: case 256: case 288: case 289: case 290: case 291: case 292: case 293: case 311: case 317: case 318: case 324: case 340: case 348:
self.$ = $$[$0];
break;
case 14: case 15:
self.$ = $$[$0-2].addExpression($$[$0]);
break;
case 21: case 74:
self.$ = new yy.Literal($$[$0]);
break;
case 22:
self.$ = new yy.BreakStatement($$[$0]);
break;
case 23:
self.$ = new yy.BreakStatement($$[$0-3],$$[$0-1]);
break;
case 24:
self.$ = new yy.ContinueStatement($$[$0]);
break;
case 25:
self.$ = new yy.ContinueStatement($$[$0-3],$$[$0-1]);
break;
case 26:
self.$ = new yy.DebuggerStatement($$[$0]);
break;
case 28:
self.$ = new yy.ImportStatement($$[$0-2],$$[$0]);
break;
case 29:
self.$ = new yy.ImportStatement(null,$$[$0-2],$$[$0]);
break;
case 30:
self.$ = new yy.ImportStatement(null,$$[$0]);
break;
case 32: case 193: case 327:
self.$ = [$$[$0]];
break;
case 33: case 194:
self.$ = $$[$0-2].concat($$[$0]);
break;
case 35:
self.$ = new yy.Require($$[$0]).set({keyword: $$[$0-1]});
break;
case 55: case 56:
self.$ = new yy.Identifier($$[$0]);
break;
case 57: case 58:
self.$ = new yy.Ivar($$[$0]);
break;
case 59:
self.$ = new yy.Gvar($$[$0]);
break;
case 60:
self.$ = new yy.Const($$[$0]);
break;
case 61:
self.$ = new yy.Argvar($$[$0]);
break;
case 62:
self.$ = new yy.Symbol($$[$0]);
break;
case 63:
self.$ = new yy.Num($$[$0]);
break;
case 64:
self.$ = new yy.Str($$[$0]);
break;
case 67:
self.$ = new yy.InterpolatedString([],{open: $$[$0]});
break;
case 68:
self.$ = $$[$0-1].add($$[$0]);
break;
case 69:
self.$ = $$[$0] ? ($$[$0-1].add($$[$0])) : ($$[$0-1]);
break;
case 70:
self.$ = $$[$0-1].option('close',$$[$0]);
break;
case 71:
self.$ = null;
break;
case 72: case 98: case 101: case 122: case 124: case 156: case 171: case 182: case 287:
self.$ = $$[$0-1];
break;
case 75:
self.$ = new yy.RegExp($$[$0]);
break;
case 76:
self.$ = new yy.Bool($$[$0]);
break;
case 77:
self.$ = new yy.True($$[$0]);
break;
case 78:
self.$ = new yy.False($$[$0]);
break;
case 79:
self.$ = new yy.Nil($$[$0]);
break;
case 80:
self.$ = new yy.Undefined($$[$0]);
break;
case 81: case 82:
self.$ = new yy.Return($$[$0]);
break;
case 83:
self.$ = new yy.Return();
break;
case 84:
self.$ = new yy.Selector([],{type: $$[$0]});
break;
case 85:
self.$ = $$[$0-1].add(new yy.SelectorType($$[$0]),'tag');
break;
case 86:
self.$ = $$[$0-1].add(new yy.SelectorNamespace($$[$0]),'ns');
break;
case 87:
self.$ = $$[$0-1].add(new yy.SelectorId($$[$0]),'id');
break;
case 88:
self.$ = $$[$0-1].add(new yy.SelectorClass($$[$0]),'class');
break;
case 89:
self.$ = $$[$0-4].add(new yy.SelectorClass($$[$0-1]),'class');
break;
case 90:
self.$ = $$[$0-4].add(new yy.SelectorId($$[$0-1]),'id');
break;
case 91:
self.$ = $$[$0-1].add(new yy.SelectorCombinator($$[$0]),'sep');
break;
case 92:
self.$ = $$[$0-1].add(new yy.SelectorPseudoClass($$[$0]),'pseudoclass');
break;
case 93:
self.$ = $$[$0-1].group();
break;
case 94:
self.$ = $$[$0-1].add(new yy.SelectorUniversal($$[$0]),'universal');
break;
case 95:
self.$ = $$[$0-3].add(new yy.SelectorAttribute($$[$0-1]),'attr');
break;
case 96:
self.$ = $$[$0-5].add(new yy.SelectorAttribute($$[$0-3],$$[$0-2],$$[$0-1]),'attr');
break;
case 97: case 106: case 107: case 140: case 141:
self.$ = new yy.TagTypeIdentifier($$[$0]);
break;
case 102:
self.$ = $$[$0-1].set({open: $$[$0-2],close: $$[$0]});
break;
case 103:
self.$ = $$[$0-2].set({body: $$[$0],open: $$[$0-3],close: $$[$0-1]});
break;
case 104:
self.$ = new yy.TagWrapper($$[$0-2],$$[$0-4],$$[$0]);
break;
case 108:
self.$ = new yy.TagTypeIdentifier('div');
break;
case 109:
self.$ = new yy.Tag({type: $$[$0]});
break;
case 110:
self.$ = $$[$0-2].addSymbol($$[$0]);
break;
case 111:
self.$ = $$[$0-3].addIndex($$[$0-1]);
break;
case 112: case 113:
self.$ = $$[$0-2].addClass($$[$0]);
break;
case 114:
self.$ = $$[$0-4].addClass($$[$0-1]);
break;
case 115:
self.$ = $$[$0-4].set({key: $$[$0-1]});
break;
case 116:
self.$ = $$[$0-2].set({id: $$[$0]});
break;
case 117:
self.$ = $$[$0-1].set({ivar: $$[$0]});
break;
case 118:
self.$ = $$[$0-4].set({id: $$[$0-1]});
break;
case 119:
self.$ = $$[$0-1].addAttribute($$[$0]);
break;
case 120:
self.$ = new yy.TagAttr($$[$0],$$[$0]);
break;
case 121:
self.$ = new yy.TagAttr($$[$0-2],$$[$0],$$[$0-1]);
break;
case 125: case 282:
self.$ = new yy.ArgList([$$[$0]]);
break;
case 126:
self.$ = new yy.TagDesc($$[$0]);
break;
case 127:
self.$ = $$[$0-2].classes($$[$0]);
break;
case 128:
self.$ = new yy.Export($$[$0]).set({'default': $$[$0-1],keyword: $$[$0-2]});
break;
case 129:
self.$ = new yy.Export($$[$0]).set({keyword: $$[$0-1]});
break;
case 131:
self.$ = $$[$0].set({extension: true});
break;
case 132:
self.$ = $$[$0].set({local: true});
break;
case 133: case 173: case 259:
self.$ = $$[$0].set({global: $$[$0-1]});
break;
case 134:
self.$ = new yy.TagDeclaration($$[$0]).set({keyword: $$[$0-1]});
break;
case 135:
self.$ = new yy.TagDeclaration($$[$0-1],null,$$[$0]).set({keyword: $$[$0-2]});
break;
case 136:
self.$ = new yy.TagDeclaration($$[$0-2],$$[$0]).set({keyword: $$[$0-3]});
break;
case 137:
self.$ = new yy.TagDeclaration($$[$0-3],$$[$0-1],$$[$0]).set({keyword: $$[$0-4]});
break;
case 139:
self.$ = ['yy.extend'];
break;
case 142: case 143:
self.$ = new yy.TagId($$[$0]);
break;
case 144:
self.$ = new yy.Assign($$[$0-1],$$[$0-2],$$[$0]);
break;
case 145:
self.$ = new yy.Assign($$[$0-3],$$[$0-4],$$[$0-1].indented($$[$0-2],$$[$0]));
break;
case 146:
self.$ = new yy.ObjAttr($$[$0]);
break;
case 147:
self.$ = new yy.ObjAttr($$[$0-2],$$[$0],'object');
break;
case 148:
self.$ = new yy.ObjAttr($$[$0-4],$$[$0-1].indented($$[$0-2],$$[$0]),'object');
break;
case 157:
self.$ = new yy.Comment($$[$0],true);
break;
case 158:
self.$ = new yy.Comment($$[$0],false);
break;
case 162:
self.$ = new yy.Begin($$[$0]);
break;
case 163:
self.$ = new yy.Lambda([],$$[$0],null,null,{bound: true,keyword: $$[$0-1]});
break;
case 164:
self.$ = new yy.Lambda($$[$0-2],$$[$0],null,null,{bound: true,keyword: $$[$0-4]});
break;
case 165:
self.$ = new yy.PropertyDeclaration($$[$0-1],$$[$0],$$[$0-2]);
break;
case 166:
self.$ = new yy.PropertyDeclaration($$[$0-3],$$[$0-1],$$[$0-4]);
break;
case 167:
self.$ = new yy.PropertyDeclaration($$[$0],null,$$[$0-1]);
break;
case 174:
self.$ = new yy.MethodDeclaration($$[$0-2],$$[$0],$$[$0-4],$$[$0-6],$$[$0-5]).set({def: $$[$0-7]});
break;
case 175:
self.$ = new yy.MethodDeclaration([],$$[$0],$$[$0-1],$$[$0-3],$$[$0-2]).set({def: $$[$0-4]});
break;
case 176:
self.$ = new yy.MethodDeclaration($$[$0-2],$$[$0],$$[$0-4],null).set({def: $$[$0-5]});
break;
case 177:
self.$ = new yy.MethodDeclaration([],$$[$0],$$[$0-1],null).set({def: $$[$0-2]});
break;
case 178:
self.$ = {static: true};
break;
case 179:
self.$ = {};
break;
case 184:
self.$ = $$[$0].body();
break;
case 185: case 192:
self.$ = [];
break;
case 195:
self.$ = new yy.NamedParams($$[$0]);
break;
case 196:
self.$ = new yy.ArrayParams($$[$0]);
break;
case 197:
self.$ = new yy.RequiredParam($$[$0]);
break;
case 198:
self.$ = new yy.SplatParam($$[$0],null,$$[$0-1]);
break;
case 199: case 200:
self.$ = new yy.BlockParam($$[$0],null,$$[$0-1]);
break;
case 201:
self.$ = new yy.OptionalParam($$[$0-2],$$[$0],$$[$0-1]);
break;
case 203:
self.$ = yy.SPLAT($$[$0]);
break;
case 204: case 207:
self.$ = yy.SPLAT(new yy.VarReference($$[$0],$$[$0-2]),$$[$0-1]);
break;
case 205: case 206:
self.$ = new yy.VarReference($$[$0],$$[$0-1]);
break;
case 213:
self.$ = new yy.EnvFlag($$[$0]);
break;
case 215:
self.$ = new yy.IvarAccess('.',null,$$[$0]);
break;
case 220:
self.$ = new yy.VarOrAccess($$[$0]);
break;
case 221:
self.$ = new yy.New($$[$0-2]);
break;
case 222:
self.$ = new yy.SuperAccess('.',$$[$0-2],$$[$0]);
break;
case 223:
self.$ = new yy.PropertyAccess($$[$0-1],$$[$0-2],$$[$0]);
break;
case 224: case 225: case 226: case 228:
self.$ = new yy.Access($$[$0-1],$$[$0-2],$$[$0]);
break;
case 227:
self.$ = new yy.Access('.',$$[$0-2],new yy.Identifier($$[$0].value()));
break;
case 229:
self.$ = new yy.IndexAccess('.',$$[$0-3],$$[$0-1]);
break;
case 232:
self.$ = yy.SUPER;
break;
case 236:
self.$ = new yy.Await($$[$0]).set({keyword: $$[$0-1]});
break;
case 242:
self.$ = yy.ARGUMENTS;
break;
case 248:
self.$ = new yy.Index($$[$0]);
break;
case 249:
self.$ = new yy.Slice($$[$0]);
break;
case 250:
self.$ = new yy.Obj($$[$0-2],$$[$0-3].generated);
break;
case 251:
self.$ = new yy.AssignList([]);
break;
case 252:
self.$ = new yy.AssignList([$$[$0]]);
break;
case 253: case 283:
self.$ = $$[$0-2].add($$[$0]);
break;
case 254: case 284:
self.$ = $$[$0-3].add($$[$0-1]).add($$[$0]);
break;
case 255:
self.$ = $$[$0-5].concat($$[$0-2].indented($$[$0-3],$$[$0]));
break;
case 257:
self.$ = $$[$0].set({extension: $$[$0-1]});
break;
case 258:
self.$ = $$[$0].set({local: $$[$0-1]});
break;
case 260:
self.$ = new yy.ClassDeclaration($$[$0],null,[]).set({keyword: $$[$0-1]});
break;
case 261:
self.$ = new yy.ClassDeclaration($$[$0-1],null,$$[$0]).set({keyword: $$[$0-2]});
break;
case 262:
self.$ = new yy.ClassDeclaration($$[$0-2],$$[$0],[]).set({keyword: $$[$0-3]});
break;
case 263:
self.$ = new yy.ClassDeclaration($$[$0-3],$$[$0-1],$$[$0]).set({keyword: $$[$0-4]});
break;
case 264:
self.$ = new yy.Module($$[$0]);
break;
case 265:
self.$ = new yy.Module($$[$0-1],null,$$[$0]);
break;
case 266:
self.$ = new yy.Call($$[$0-2],$$[$0],$$[$0-1]);
break;
case 267:
self.$ = $$[$0-1].addBlock($$[$0]);
break;
case 268:
self.$ = false;
break;
case 269:
self.$ = true;
break;
case 270:
self.$ = new yy.ArgList([]);
break;
case 271:
self.$ = $$[$0-2];
break;
case 272:
self.$ = new yy.This($$[$0]);
break;
case 273:
self.$ = new yy.Self($$[$0]);
break;
case 274:
self.$ = new yy.Arr(new yy.ArgList([]));
break;
case 275:
self.$ = new yy.Arr($$[$0-2]);
break;
case 276:
self.$ = '..';
break;
case 277:
self.$ = '...';
break;
case 278:
self.$ = yy.OP($$[$0-2],$$[$0-3],$$[$0-1]);
break;
case 279:
self.$ = new yy.Range($$[$0-2],$$[$0],$$[$0-1]);
break;
case 280:
self.$ = new yy.Range($$[$0-1],null,$$[$0]);
break;
case 281:
self.$ = new yy.Range(null,$$[$0],$$[$0-1]);
break;
case 285:
self.$ = $$[$0-2].indented($$[$0-3],$$[$0]);
break;
case 286:
self.$ = $$[$0-5].concat($$[$0-2]);
break;
case 294:
self.$ = [].concat($$[$0-2],$$[$0]);
break;
case 295:
self.$ = new yy.Try($$[$0]);
break;
case 296:
self.$ = new yy.Try($$[$0-1],$$[$0]);
break;
case 297:
self.$ = new yy.Try($$[$0-1],null,$$[$0]);
break;
case 298:
self.$ = new yy.Try($$[$0-2],$$[$0-1],$$[$0]);
break;
case 299:
self.$ = new yy.Finally($$[$0]);
break;
case 300:
self.$ = new yy.Catch($$[$0],$$[$0-1]);
break;
case 301:
self.$ = new yy.Throw($$[$0]);
break;
case 302:
self.$ = new yy.Parens($$[$0-1],$$[$0-2],$$[$0]);
break;
case 303:
self.$ = new yy.Parens($$[$0-2],$$[$0-4],$$[$0]);
break;
case 304:
self.$ = new yy.While($$[$0],{keyword: $$[$0-1]});
break;
case 305:
self.$ = new yy.While($$[$0-2],{guard: $$[$0],keyword: $$[$0-3]});
break;
case 306:
self.$ = new yy.While($$[$0],{invert: true,keyword: $$[$0-1]});
break;
case 307:
self.$ = new yy.While($$[$0-2],{invert: true,guard: $$[$0],keyword: $$[$0-3]});
break;
case 308: case 316: case 319:
self.$ = $$[$0-1].addBody($$[$0]);
break;
case 309: case 310:
self.$ = $$[$0].addBody(yy.Block.wrap([$$[$0-1]]));
break;
case 312:
self.$ = new yy.While(new yy.Literal('true',{keyword: $$[$0-1]})).addBody($$[$0]);
break;
case 313:
self.$ = new yy.While(new yy.Literal('true',{keyword: $$[$0-1]})).addBody(yy.Block.wrap([$$[$0]]));
break;
case 314: case 315:
self.$ = $$[$0].addBody([$$[$0-1]]);
break;
case 320:
self.$ = {source: new yy.ValueNode($$[$0])};
break;
case 321:
self.$ = $$[$0].configure({own: $$[$0-1].own,name: $$[$0-1][0],index: $$[$0-1][1],keyword: $$[$0-1].keyword});
break;
case 322:
self.$ = ($$[$0].keyword = $$[$0-1]) && $$[$0];
break;
case 323:
self.$ = ($$[$0].own = true) && ($$[$0].keyword = $$[$0-2]) && $$[$0];
break;
case 325: case 326:
self.$ = new yy.ValueNode($$[$0]);
break;
case 328:
self.$ = [$$[$0-2],$$[$0]];
break;
case 329:
self.$ = new yy.ForIn({source: $$[$0]});
break;
case 330:
self.$ = new yy.ForOf({source: $$[$0],object: true});
break;
case 331:
self.$ = new yy.ForIn({source: $$[$0-2],guard: $$[$0]});
break;
case 332:
self.$ = new yy.ForOf({source: $$[$0-2],guard: $$[$0],object: true});
break;
case 333:
self.$ = new yy.ForIn({source: $$[$0-2],step: $$[$0]});
break;
case 334:
self.$ = new yy.ForIn({source: $$[$0-4],guard: $$[$0-2],step: $$[$0]});
break;
case 335:
self.$ = new yy.ForIn({source: $$[$0-4],step: $$[$0-2],guard: $$[$0]});
break;
case 336:
self.$ = new yy.Switch($$[$0-3],$$[$0-1]);
break;
case 337:
self.$ = new yy.Switch($$[$0-5],$$[$0-3],$$[$0-1]);
break;
case 338:
self.$ = new yy.Switch(null,$$[$0-1]);
break;
case 339:
self.$ = new yy.Switch(null,$$[$0-3],$$[$0-1]);
break;
case 341:
self.$ = $$[$0-1].concat($$[$0]);
break;
case 342:
self.$ = [new yy.SwitchCase($$[$0-1],$$[$0])];
break;
case 343:
self.$ = [new yy.SwitchCase($$[$0-2],$$[$0-1])];
break;
case 344:
self.$ = new yy.If($$[$0-1],$$[$0],{type: $$[$0-2]});
break;
case 345:
self.$ = $$[$0-4].addElse(new yy.If($$[$0-1],$$[$0],{type: $$[$0-2]}));
break;
case 346:
self.$ = $$[$0-3].addElse(new yy.If($$[$0-1],$$[$0],{type: $$[$0-2]}));
break;
case 347:
self.$ = $$[$0-2].addElse($$[$0]);
break;
case 349:
self.$ = new yy.If($$[$0],new yy.Block([$$[$0-2]]),{type: $$[$0-1],statement: true});
break;
case 350:
self.$ = new yy.If($$[$0],new yy.Block([$$[$0-2]]),{type: $$[$0-1]});
break;
case 351:
self.$ = yy.If.ternary($$[$0-4],$$[$0-2],$$[$0]);
break;
case 352: case 353:
self.$ = yy.OP($$[$0-1],$$[$0]);
break;
case 354:
self.$ = new yy.Op('-',$$[$0]);
break;
case 355:
self.$ = new yy.Op('+',$$[$0]);
break;
case 356:
self.$ = new yy.UnaryOp('--',null,$$[$0]);
break;
case 357:
self.$ = new yy.UnaryOp('++',null,$$[$0]);
break;
case 358:
self.$ = new yy.UnaryOp('--',$$[$0-1],null,true);
break;
case 359:
self.$ = new yy.UnaryOp('++',$$[$0-1],null,true);
break;
case 360: case 361:
self.$ = new yy.Op($$[$0-1],$$[$0-2],$$[$0]);
break;
case 362: case 363: case 364: case 365: case 367:
self.$ = yy.OP($$[$0-1],$$[$0-2],$$[$0]);
break;
case 366:
self.$ = yy.OP($$[$0-1],$$[$0-3],$$[$0]).invert($$[$0-2]);
break;
case 368:
self.$ = yy.OP_COMPOUND($$[$0-1]._value,$$[$0-1],$$[$0-2],$$[$0]);
break;
case 369:
self.$ = yy.OP_COMPOUND($$[$0-3]._value,$$[$0-4],$$[$0-1].indented($$[$0-2],$$[$0]));
break;
}
},
table: [{1:[2,1],3:1,4:2,5:3,7:$V0,8:5,10:$V1,12:7,13:8,15:9,16:10,17:11,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,128:$Vu,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,149:$VC,150:$VD,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,177:$VJ,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{1:[3]},{1:[2,2],6:$V71,9:137},{6:[1,139]},o($V81,[2,4]),o($V81,[2,5],{14:$V91}),{4:142,6:[1,143],7:$V0,8:5,11:[1,141],12:7,13:8,15:9,16:10,17:11,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,128:$Vu,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,149:$VC,150:$VD,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,177:$VJ,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Va1,[2,12]),o($Va1,[2,13],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,220:$VW,222:$VX,227:$VZ,228:$V_,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($Va1,[2,16]),o($Va1,[2,17],{226:111,230:112,219:157,225:158,220:$VW,222:$VX,227:$VZ,228:$V_,246:$Vl1}),o($Va1,[2,18]),{13:159,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vm1,[2,39]),o($Vm1,[2,40],{203:161,152:162,188:164,22:$Vn1,95:$Vo1,117:$Vp1,155:$VF,189:$Vq1,190:$Vr1,192:$Vs1,204:$Vt1}),o($Vm1,[2,41]),o($Vm1,[2,42]),o($Vm1,[2,43]),o($Vm1,[2,44]),o($Vm1,[2,45]),o($Vm1,[2,46]),o($Vm1,[2,47]),o($Vm1,[2,48]),o($Vm1,[2,49]),o($Vm1,[2,50]),o($Vm1,[2,51]),o($Vm1,[2,52]),o($Vm1,[2,53]),o($Vm1,[2,54]),o($Vu1,[2,157]),o($Vu1,[2,158]),o($Vv1,[2,19]),o($Vv1,[2,20]),o($Vv1,[2,21]),o($Vv1,[2,22],{22:[1,170]}),o($Vv1,[2,24],{22:[1,171]}),o($Vv1,[2,26]),o($Vv1,[2,27]),{13:173,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,129:[1,172],130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:174,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vw1,$Vx1,{122:[1,175]}),o($Vw1,[2,238]),o($Vw1,[2,239]),o($Vw1,[2,240]),o($Vw1,[2,241]),o($Vw1,[2,242]),o($Vw1,[2,243]),o($Vw1,[2,244]),o($Vw1,[2,245]),o($Vw1,[2,246]),o($Vw1,[2,247]),o($Vm1,[2,159]),o($Vm1,[2,160]),o($Vm1,[2,161]),{13:176,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:177,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:178,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:179,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{33:$V7,35:50,36:$V8,38:42,39:43,41:181,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,115:104,139:47,140:$Vz,141:$VA,142:182,147:$VB,161:79,172:46,175:78,180:105,181:$VK,183:$VL,184:180,185:$VM,187:41,193:$VN,195:44,196:$VP,197:49,205:$VS,206:$VT},{33:$V7,35:50,36:$V8,38:42,39:43,41:181,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,115:104,139:47,140:$Vz,141:$VA,142:182,147:$VB,161:79,172:46,175:78,180:105,181:$VK,183:$VL,184:183,185:$VM,187:41,193:$VN,195:44,196:$VP,197:49,205:$VS,206:$VT},o($Vy1,$Vz1,{252:[1,184],253:[1,185],258:[1,186]}),o($Vm1,[2,348],{240:[1,187],245:[1,188]}),{5:189,10:$V1},{5:190,10:$V1},o($Vm1,[2,311]),{5:191,10:$V1},{10:[1,193],13:192,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vm1,[2,256]),{130:195,134:$Vy,200:194,201:$VQ},{130:197,134:$Vy,200:196,201:$VQ},{130:199,134:$Vy,164:200,165:$VI,200:198,201:$VQ},{33:$V7,35:50,36:$V8,38:42,39:43,41:181,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,115:104,139:47,140:$Vz,141:$VA,142:182,147:$VB,161:79,172:46,175:78,180:105,181:$VK,183:$VL,184:201,185:$VM,187:41,193:$VN,195:44,196:$VP,197:49,205:$VS,206:$VT},o($Vm1,[2,130]),o($VA1,[2,108],{111:202,114:204,115:205,57:[1,206],96:[1,203],116:[1,207],206:$VT}),{56:209,57:$V9,96:[1,210],160:208},o($Vv1,[2,83],{40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,18:31,19:32,26:37,142:40,187:41,38:42,39:43,195:44,172:46,139:47,108:48,197:49,35:50,151:51,152:52,153:53,184:60,243:61,219:63,223:64,225:65,200:67,130:72,159:74,175:78,161:79,71:81,89:94,164:96,65:100,60:101,63:102,67:103,115:104,180:105,56:106,226:111,230:112,69:120,73:121,16:160,13:211,88:212,20:$V2,21:$V3,22:$VB1,24:$V4,25:$V5,27:$V6,33:$V7,36:$V8,57:$V9,61:$Va,62:$Vb,64:$Vc,66:$Vd,68:$Ve,70:$Vf,72:$Vg,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,90:$Vq,96:$Vr,103:$Vs,110:$Vt,131:$Vv,132:$Vw,133:$Vx,134:$Vy,140:$Vz,141:$VA,147:$VB,154:$VE,155:$VF,162:$VG,163:$VH,165:$VI,181:$VK,183:$VL,185:$VM,193:$VN,194:$VO,196:$VP,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,224:$VY,238:$V$,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61}),{13:214,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{28:215,30:216,32:217,33:$VC1,34:219,56:221,57:$V9,65:220,66:$Vd},o($Vy1,[2,234]),o($Vy1,[2,235]),o($VD1,[2,232]),o($Vw1,[2,73]),o($Vw1,[2,74]),o($Vw1,[2,75]),o($Vw1,[2,76]),o($Vw1,[2,77]),o($Vw1,[2,78]),o($Vw1,[2,79]),o($Vw1,[2,80]),{4:222,7:$V0,8:5,10:[1,223],12:7,13:8,15:9,16:10,17:11,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,128:$Vu,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,149:$VC,150:$VD,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,177:$VJ,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{10:$VE1,12:229,13:224,15:231,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,104:$VF1,108:48,110:$Vt,115:104,126:226,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,149:$VC,150:$VD,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,177:$VJ,178:$VG1,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,210:227,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o([1,6,10,11,14,22,23,79,95,97,98,104,117,118,125,136,146,148,155,158,178,189,190,192,204,208,209,220,221,222,227,228,237,246,247,250,251,254,255,256,257],[2,272]),o($Vw1,[2,142]),o($Vw1,[2,143]),{91:233,92:[1,234],93:[1,235],94:[1,236],95:[1,237],98:[1,238],99:[1,239],100:[1,240],101:[1,241],102:[1,242],103:[1,243],107:[1,244],109:[1,232]},o($Vw1,[2,38],{71:81,69:120,73:121,37:245,38:246,39:247,33:$V7,70:$Vf,72:$Vg,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,147:$VB}),o($Vm1,[2,172]),{5:248,10:$V1,156:[1,249]},{5:250,10:$V1},o($VD1,[2,213]),o($VD1,[2,214]),o($VD1,[2,215]),o($VD1,[2,216]),o($VD1,[2,217]),o($VD1,[2,218]),o($VD1,[2,219]),o($VD1,[2,220]),{13:251,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:252,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:253,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{5:254,10:$V1,13:255,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{56:260,57:$V9,96:$Vr,103:$Vs,161:262,175:261,195:256,232:257,233:[1,258],234:259},{231:263,235:[1,264],236:[1,265]},{33:$V7,35:50,36:$V8,38:42,39:43,41:181,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,115:104,139:47,140:$Vz,141:$VA,142:182,147:$VB,161:79,172:46,175:78,180:105,181:$VK,183:$VL,184:266,185:$VM,187:41,193:$VN,195:44,196:$VP,197:49,205:$VS,206:$VT},{116:$VH1,135:267,138:$VI1},o($VJ1,[2,168]),o($VJ1,[2,169]),o([6,10,14,97],$VK1,{69:120,73:121,199:270,144:271,145:272,15:273,56:274,65:275,58:276,71:277,60:278,63:279,33:$V7,57:$V9,59:$VL1,61:$Va,62:$Vb,64:$Vc,66:$Vd,70:$Vf,72:$Vg,74:$Vh,147:$VM1,149:$VC,150:$VD}),o($Vw1,[2,63]),o($Vw1,[2,64]),o($Vw1,[2,65]),o($Vw1,[2,66],{76:283,75:[1,282],77:[1,284],78:[1,285]}),o($VN1,[2,84]),{56:291,57:$V9,63:290,64:$Vc,65:292,66:$Vd,96:$VO1,115:289,166:286,168:287,172:288,205:$VS,206:$VT},o([1,6,10,11,14,22,23,29,79,95,97,98,104,117,118,122,125,136,146,148,155,158,170,171,178,189,190,192,204,208,209,220,221,222,227,228,237,246,247,250,251,252,253,254,255,256,257,258],[2,60]),o($VP1,[2,57]),o($VP1,[2,58]),o([1,6,10,11,14,22,23,79,95,97,98,104,117,118,122,125,136,146,148,155,158,178,189,190,192,204,208,209,220,221,222,227,228,237,246,247,250,251,252,253,254,255,256,257,258],[2,59]),o($VD1,[2,61]),o($VP1,[2,273]),{56:297,57:$V9,65:296,66:$Vd,103:$VQ1,175:298,177:[1,294],182:295},{56:297,57:$V9,65:296,66:$Vd,103:$VQ1,175:298,177:[1,301],182:300},o([1,6,10,11,14,22,23,29,79,95,96,97,98,104,105,117,118,122,125,136,146,148,155,158,170,171,178,189,190,192,204,208,209,220,221,222,227,228,235,236,237,246,247,250,251,252,253,254,255,256,257,258],[2,55]),o($VR1,[2,317]),o($VR1,[2,318]),o($VD1,[2,62]),o($VS1,[2,67]),o($V81,[2,7],{12:7,13:8,15:9,16:10,17:11,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,18:31,19:32,26:37,142:40,187:41,38:42,39:43,195:44,172:46,139:47,108:48,197:49,35:50,151:51,152:52,153:53,184:60,243:61,219:63,223:64,225:65,200:67,130:72,159:74,175:78,161:79,71:81,89:94,164:96,65:100,60:101,63:102,67:103,115:104,180:105,56:106,226:111,230:112,69:120,73:121,8:302,20:$V2,21:$V3,24:$V4,25:$V5,27:$V6,33:$V7,36:$V8,57:$V9,61:$Va,62:$Vb,64:$Vc,66:$Vd,68:$Ve,70:$Vf,72:$Vg,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,90:$Vq,96:$Vr,103:$Vs,110:$Vt,128:$Vu,131:$Vv,132:$Vw,133:$Vx,134:$Vy,140:$Vz,141:$VA,147:$VB,149:$VC,150:$VD,154:$VE,155:$VF,162:$VG,163:$VH,165:$VI,177:$VJ,181:$VK,183:$VL,185:$VM,193:$VN,194:$VO,196:$VP,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,220:$VW,222:$VX,224:$VY,227:$VZ,228:$V_,238:$V$,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61}),o([1,6,11,20,21,24,25,27,33,36,57,59,61,62,64,66,68,70,72,74,80,81,82,83,84,85,86,87,90,96,103,110,128,131,132,133,134,140,141,147,148,149,150,154,155,162,163,165,177,178,181,183,185,193,194,196,201,202,205,206,212,218,220,222,224,227,228,238,244,248,249,250,251,252,253],[2,8]),{1:[2,3]},{12:304,13:303,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,177:$VJ,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($VT1,[2,9]),{6:$V71,9:137,11:[1,305]},{4:306,7:$V0,8:5,12:7,13:8,15:9,16:10,17:11,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,128:$Vu,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,149:$VC,150:$VD,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,177:$VJ,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:307,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:308,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:309,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:310,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:311,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:312,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{257:[1,313]},{13:314,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:315,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:316,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vm1,[2,310]),o($Vm1,[2,315]),{13:317,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vm1,[2,309]),o($Vm1,[2,314]),o([1,6,10,11,14,23,104,148],[2,203],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,220:$VW,222:$VX,227:$VZ,228:$V_,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),{219:157,220:$VW,222:$VX,225:158,226:111,227:$VZ,228:$V_,230:112,246:$Vl1},{22:$VB1,88:318},o($Vw1,[2,267]),o($VU1,[2,230],{187:320,69:321,70:$Vf,186:[1,319],193:$VN}),{56:322,57:$V9,60:323,61:$Va,62:$Vb,65:324,66:$Vd},{56:325,57:$V9},{56:326,57:$V9},{13:328,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,191:327,193:$VN,194:$VO,195:44,196:$VP,197:49,198:329,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,207:330,208:$VV1,209:$VW1,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{22:[2,269]},o($VU1,[2,231]),{13:333,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:334,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:335,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Va1,[2,129],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,220:$VW,222:$VX,227:$VZ,228:$V_,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($VX1,[2,236],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),{10:[1,337],13:336,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($VY1,[2,352],{226:111,230:112,219:154,225:155,256:$Vj1}),o($VY1,[2,353],{226:111,230:112,219:154,225:155,256:$Vj1}),o($VY1,[2,354],{226:111,230:112,219:154,225:155,256:$Vj1}),o($VY1,[2,355],{226:111,230:112,219:154,225:155,256:$Vj1}),o($Vm1,[2,356],{22:$Vz1,95:$Vz1,117:$Vz1,155:$Vz1,189:$Vz1,190:$Vz1,192:$Vz1,204:$Vz1}),{22:$Vn1,95:$Vo1,117:$Vp1,152:162,155:$VF,188:164,189:$Vq1,190:$Vr1,192:$Vs1,203:161,204:$Vt1},o([22,95,117,155,189,190,192,204],$Vx1),o($Vm1,[2,357],{22:$Vz1,95:$Vz1,117:$Vz1,155:$Vz1,189:$Vz1,190:$Vz1,192:$Vz1,204:$Vz1}),o($Vm1,[2,358]),o($Vm1,[2,359]),{10:[1,339],13:338,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{5:341,10:$V1,244:[1,340]},{13:342,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vm1,[2,295],{213:343,214:344,215:$VZ1,216:[1,345]}),o($Vm1,[2,308]),o($Vm1,[2,316]),{10:[1,347],136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},{239:348,241:349,242:$V_1},o($Vm1,[2,257]),o($Vm1,[2,131]),o($Vm1,[2,258]),o($Vm1,[2,132]),o($Vm1,[2,259]),o($Vm1,[2,133]),o($Vm1,[2,173]),o($V$1,[2,264],{5:351,10:$V1,22:$Vz1,95:$Vz1,117:$Vz1,155:$Vz1,189:$Vz1,190:$Vz1,192:$Vz1,204:$Vz1}),{60:357,61:$Va,62:$Vb,95:[1,353],98:[1,356],112:[1,352],117:[1,354],119:[1,355],120:358,121:[1,359]},{13:360,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($VA1,[2,109]),o($VA1,[2,105]),o($VA1,[2,106]),o($VA1,[2,107]),o($Vm1,[2,167],{161:361,22:[1,362],96:$Vr}),o($V02,[2,170]),{13:363,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vv1,[2,81],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($Vv1,[2,82]),{10:$VE1,12:229,13:366,15:231,16:160,18:31,19:32,20:$V2,21:$V3,23:[1,364],24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,126:365,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,149:$VC,150:$VD,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,177:$VJ,178:$VG1,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,210:227,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vv1,[2,301],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),{14:[1,368],29:[1,367]},o($Vv1,[2,30],{31:[1,369]}),o($V12,[2,32]),o([1,6,11,14,31,148,220,222,227,228,246],[2,31]),o($V22,[2,34]),o($V22,[2,208]),o($V22,[2,209]),{6:$V71,9:137,148:[1,370]},{4:371,7:$V0,8:5,12:7,13:8,15:9,16:10,17:11,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,128:$Vu,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,149:$VC,150:$VD,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,177:$VJ,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o([6,10,14,104],$V32,{226:111,230:112,219:154,225:155,207:372,136:$Vb1,178:$Vc1,208:$VV1,209:$VW1,220:$VW,222:$VX,227:$VZ,228:$V_,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($V42,[2,274]),o([6,10,104],$V52,{173:373,14:$V62}),o($V72,[2,282]),{10:$VE1,12:229,13:366,15:231,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,126:375,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,149:$VC,150:$VD,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,177:$VJ,178:$VG1,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,210:227,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($V72,[2,290]),o($V72,[2,291]),o($V72,[2,292]),o($Vw1,[2,98]),o($VN1,[2,85]),o($VN1,[2,86]),o($VN1,[2,87]),o($VN1,[2,88]),{96:[1,376]},{96:[1,377]},o($VN1,[2,91]),o($VN1,[2,92]),o($VN1,[2,93]),o($VN1,[2,94]),{56:378,57:$V9},o($VN1,[2,97]),o($Vw1,[2,35]),o($Vw1,[2,36]),o($Vw1,[2,37]),o($Vw1,[2,163]),o([14,158],$V82,{157:379,174:380,161:381,175:382,176:383,56:387,57:$V9,96:$Vr,103:$VQ1,177:$V92,178:$Va2,179:$Vb2}),o($Vm1,[2,162]),{5:388,10:$V1,136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},o($Vc2,[2,304],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,220:$VW,221:[1,389],222:$VX,227:$VZ,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($Vc2,[2,306],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,220:$VW,221:[1,390],222:$VX,227:$VZ,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($Vm1,[2,312]),o($Vd2,[2,313],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,220:$VW,222:$VX,227:$VZ,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($Vm1,[2,320]),o($Ve2,[2,322]),{56:260,57:$V9,96:$Vr,103:$VQ1,161:262,175:261,232:391,234:259},o($Ve2,[2,327],{14:[1,392]}),o($Vf2,[2,324]),o($Vf2,[2,325]),o($Vf2,[2,326]),o($Vm1,[2,321]),{13:393,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:394,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vg2,[2,260],{5:395,10:$V1,22:$Vz1,95:$Vz1,117:$Vz1,155:$Vz1,189:$Vz1,190:$Vz1,192:$Vz1,204:$Vz1,136:[1,396]}),o($Vg2,[2,134],{5:397,10:$V1,136:[1,398]}),o($Vm1,[2,140]),o($Vm1,[2,141]),o([6,10,97],$V52,{173:399,14:$Vh2}),o($Vi2,[2,252]),o($Vi2,[2,146],{146:[1,401]}),o($Vi2,[2,149]),o($Vj2,[2,150]),o($Vj2,[2,151]),o($Vj2,[2,152]),o($Vj2,[2,153]),o($Vj2,[2,154]),o($Vj2,[2,155]),{13:402,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vj2,[2,56]),o($VS1,[2,68]),o($VS1,[2,69]),o($VS1,[2,70]),{13:404,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,79:[1,403],80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{95:[1,406],98:[1,407],167:405},o($Vk2,[2,186],{169:409,22:[1,408],170:$Vl2,171:$Vm2}),o($Vk2,[2,187]),o($Vk2,[2,188]),o($Vk2,[2,189]),o($Vn2,[2,180]),o($Vn2,[2,181]),{13:412,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{56:297,57:$V9,65:296,66:$Vd,103:$VQ1,175:298,182:413},o($VD1,[2,205]),o($VD1,[2,210]),o($VD1,[2,211]),o($VD1,[2,212]),{10:$VE1,12:229,13:366,15:231,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,104:$VF1,108:48,110:$Vt,115:104,126:226,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,149:$VC,150:$VD,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,177:$VJ,178:$VG1,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,210:227,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($VD1,[2,206]),{56:297,57:$V9,65:296,66:$Vd,103:$VQ1,175:298,182:414},o($V81,[2,6],{14:$V91}),o($Va1,[2,14],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,220:$VW,222:$VX,227:$VZ,228:$V_,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($Va1,[2,15]),o($VT1,[2,10]),{6:$V71,9:137,11:[1,415]},o($Vo2,[2,360],{226:111,230:112,219:154,225:155,254:$Vh1,256:$Vj1}),o($Vo2,[2,361],{226:111,230:112,219:154,225:155,254:$Vh1,256:$Vj1}),o($VY1,[2,362],{226:111,230:112,219:154,225:155,256:$Vj1}),o([1,6,10,11,14,23,79,97,104,118,125,136,146,148,158,178,208,209,220,221,222,227,228,237,246,247,255,257],[2,363],{226:111,230:112,219:154,225:155,250:$Vf1,251:$Vg1,254:$Vh1,256:$Vj1}),o([1,6,10,11,14,23,79,97,104,118,125,136,146,148,158,178,208,209,220,221,222,227,228,237,246,247],[2,364],{226:111,230:112,219:154,225:155,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o([1,6,10,11,14,23,79,97,104,118,125,146,148,158,178,208,209,220,221,222,227,228,237,246,247],[2,365],{226:111,230:112,219:154,225:155,136:$Vb1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),{13:416,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o([1,6,10,11,14,23,79,97,104,118,125,136,146,148,158,178,208,209,220,221,222,227,228,237,246,247,257],[2,367],{226:111,230:112,219:154,225:155,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1}),o($Vp2,[2,350],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,220:$VW,222:$VX,227:$VZ,228:$V_,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),{136:$Vb1,146:[1,417],178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},o($Vp2,[2,349],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,220:$VW,222:$VX,227:$VZ,228:$V_,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($Vw1,[2,266]),o($VD1,[2,221]),o($VD1,[2,222]),o($VD1,[2,227]),o($VD1,[2,223]),o($VD1,[2,226]),o($VD1,[2,228]),o($VD1,[2,224]),o($VD1,[2,225]),{118:[1,418]},{118:[2,248],136:$Vb1,178:$Vc1,207:419,208:$VV1,209:$VW1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},{118:[2,249]},{13:420,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vq2,[2,276]),o($Vq2,[2,277]),{23:[1,421],136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},{23:[1,422],136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},o($Va1,[2,128],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,220:$VW,222:$VX,227:$VZ,228:$V_,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($VX1,[2,144],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),{13:423,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($VX1,[2,368],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),{13:424,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:425,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vr2,[2,347]),{5:426,10:$V1,136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},o($Vm1,[2,296],{214:427,215:$VZ1}),o($Vm1,[2,297]),{217:[1,428]},{5:429,10:$V1},{239:430,241:349,242:$V_1},{11:[1,431],240:[1,432],241:433,242:$V_1},o($Vs2,[2,340]),{13:435,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,211:434,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vm1,[2,265]),o($V$1,[2,102],{113:436,54:439,10:[1,437],22:[1,438],110:$Vt}),{57:[1,441],66:[1,442],70:[1,440],96:[1,443]},{13:444,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{96:[1,445]},{57:[1,446],96:[1,447]},o($VA1,[2,117]),o($VA1,[2,119]),o($VA1,[2,120],{122:[1,448]}),{97:[1,449],136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},o($Vm1,[2,165]),{96:$Vr,161:450},{97:[1,451],136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},o($Vw1,[2,270]),o([6,10,23],$V52,{173:452,14:$V62}),o($V72,$V32,{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,220:$VW,222:$VX,227:$VZ,228:$V_,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),{30:453,33:$VC1},{32:454,34:219,56:221,57:$V9,65:220,66:$Vd},{32:455,34:219,56:221,57:$V9,65:220,66:$Vd},o($Vw1,[2,302]),{6:$V71,9:137,11:[1,456]},{13:457,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{6:$V71,9:459,10:$Vt2,104:[1,458]},o([6,10,11,23,104],$Vu2,{40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,18:31,19:32,26:37,142:40,187:41,38:42,39:43,195:44,172:46,139:47,108:48,197:49,35:50,151:51,152:52,153:53,184:60,243:61,219:63,223:64,225:65,200:67,130:72,159:74,175:78,161:79,71:81,89:94,164:96,65:100,60:101,63:102,67:103,115:104,180:105,56:106,226:111,230:112,69:120,73:121,16:160,12:229,15:231,13:366,210:461,20:$V2,21:$V3,24:$V4,25:$V5,27:$V6,33:$V7,36:$V8,57:$V9,61:$Va,62:$Vb,64:$Vc,66:$Vd,68:$Ve,70:$Vf,72:$Vg,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,90:$Vq,96:$Vr,103:$Vs,110:$Vt,131:$Vv,132:$Vw,133:$Vx,134:$Vy,140:$Vz,141:$VA,147:$VB,149:$VC,150:$VD,154:$VE,155:$VF,162:$VG,163:$VH,165:$VI,177:$VJ,178:$VG1,181:$VK,183:$VL,185:$VM,193:$VN,194:$VO,196:$VP,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,220:$VW,222:$VX,224:$VY,227:$VZ,228:$V_,238:$V$,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61}),o($Vv2,$V52,{173:462,14:$V62}),{13:463,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:464,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{104:[1,465],105:[1,466]},{14:$Vw2,158:[1,467]},o($Vx2,[2,193]),o($Vx2,[2,195]),o($Vx2,[2,196]),o($Vx2,[2,197],{122:[1,469]}),{56:387,57:$V9,176:470},{56:387,57:$V9,176:471},{56:387,57:$V9,176:472},o([14,23,122,158],[2,202]),o($Vr2,[2,344]),{13:473,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:474,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Ve2,[2,323]),{56:260,57:$V9,96:$Vr,103:$VQ1,161:262,175:261,234:475},o([1,6,10,11,14,23,79,97,104,118,125,146,148,158,208,209,220,222,227,228,246],[2,329],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,221:[1,476],237:[1,477],247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($Vy2,[2,330],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,221:[1,478],247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($Vm1,[2,261]),{13:479,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vm1,[2,135]),{116:$VH1,135:480,138:$VI1},{6:$V71,9:482,10:$Vz2,97:[1,481]},o([6,10,11,97],$Vu2,{69:120,73:121,145:272,15:273,56:274,65:275,58:276,71:277,60:278,63:279,144:484,33:$V7,57:$V9,59:$VL1,61:$Va,62:$Vb,64:$Vc,66:$Vd,70:$Vf,72:$Vg,74:$Vh,147:$VM1,149:$VC,150:$VD}),{10:[1,486],13:485,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{136:$Vb1,148:[1,487],178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},o($VS1,[2,71]),{79:[1,488],136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},{56:291,57:$V9,65:292,66:$Vd,96:$VO1,168:489},o($VA2,[2,178]),o($VA2,[2,179]),o($VB2,$V82,{174:380,161:381,175:382,176:383,56:387,157:490,57:$V9,96:$Vr,103:$VQ1,177:$V92,178:$Va2,179:$Vb2}),o($Vm1,[2,177]),{5:491,10:$V1,152:492,155:$VF},o($Vm1,[2,185]),{97:[1,493],136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},o($VD1,[2,204]),o($VD1,[2,207]),o($VT1,[2,11]),o($VY1,[2,366],{226:111,230:112,219:154,225:155,256:$Vj1}),{13:494,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($VD1,[2,229]),{13:495,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,118:[2,280],130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{118:[2,281],136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},o($Vv1,[2,23]),o($Vv1,[2,25]),{6:$V71,9:497,11:$VC2,136:$Vb1,143:496,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},{6:$V71,9:497,11:$VC2,136:$Vb1,143:499,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},{5:500,10:$V1,136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},o($Vr2,[2,346]),o($Vm1,[2,298]),{5:501,10:$V1},o($Vm1,[2,299]),{11:[1,502],240:[1,503],241:433,242:$V_1},o($Vm1,[2,338]),{5:504,10:$V1},o($Vs2,[2,341]),{5:505,10:$V1,14:[1,506]},o($VD2,[2,293],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,220:$VW,222:$VX,227:$VZ,228:$V_,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($Vm1,[2,103]),{10:$VE1,12:229,13:366,15:231,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,126:507,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,149:$VC,150:$VD,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,177:$VJ,178:$VG1,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,210:227,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{10:$VE1,12:229,13:366,15:231,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,126:508,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,149:$VC,150:$VD,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,177:$VJ,178:$VG1,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,210:227,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vm1,[2,125]),o($VA1,[2,110]),o($VA1,[2,112]),o($VA1,[2,113]),{13:509,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{118:[1,510],136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},{13:511,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($VA1,[2,116]),{13:512,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{123:513,124:[1,514]},{112:[1,515]},{23:[1,516]},o($V02,[2,171]),{6:$V71,9:459,10:$Vt2,23:[1,517]},o($Vv1,[2,28]),o($V12,[2,33]),o($Vv1,[2,29]),{148:[1,518]},{104:[1,519],136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},o($V42,[2,275]),{12:229,13:366,15:231,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,149:$VC,150:$VD,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,177:$VJ,178:$VG1,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,210:520,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{10:$VE1,12:229,13:366,15:231,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,126:521,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,149:$VC,150:$VD,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,177:$VJ,178:$VG1,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,210:227,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($V72,[2,283]),{6:$V71,9:523,10:$Vt2,11:$VC2,143:522},{97:[1,524],136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},{97:[1,525],136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},o($VN1,[2,95]),{33:$V7,57:[1,527],69:120,70:$Vf,71:528,72:$Vg,73:121,74:$Vh,96:[1,529],106:526},{5:530,10:$V1},{56:387,57:$V9,96:$Vr,103:$VQ1,161:381,174:531,175:382,176:383,177:$V92,178:$Va2,179:$Vb2},{13:532,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vx2,[2,198]),o($Vx2,[2,199]),o($Vx2,[2,200]),o($Vd2,[2,305],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,220:$VW,222:$VX,227:$VZ,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($Vd2,[2,307],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,220:$VW,222:$VX,227:$VZ,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($Ve2,[2,328]),{13:533,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:534,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:535,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o([1,6,11,14,23,79,97,104,118,125,146,148,158,208,209,221,228,237,246],[2,262],{226:111,230:112,219:154,225:155,5:536,10:$V1,136:$Vb1,178:$Vc1,220:$VW,222:$VX,227:$VZ,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($V$1,[2,136],{5:537,10:$V1}),o([1,6,10,11,14,22,23,79,95,97,104,117,118,122,125,136,146,148,155,158,178,189,190,192,204,208,209,220,221,222,227,228,235,236,237,246,247,250,251,254,255,256,257],[2,250]),{15:273,33:$V7,56:274,57:$V9,58:276,59:$VL1,60:278,61:$Va,62:$Vb,63:279,64:$Vc,65:275,66:$Vd,69:120,70:$Vf,71:277,72:$Vg,73:121,74:$Vh,144:538,145:272,147:$VM1,149:$VC,150:$VD},o([6,10,11,14],$VK1,{69:120,73:121,144:271,145:272,15:273,56:274,65:275,58:276,71:277,60:278,63:279,199:539,33:$V7,57:$V9,59:$VL1,61:$Va,62:$Vb,64:$Vc,66:$Vd,70:$Vf,72:$Vg,74:$Vh,147:$VM1,149:$VC,150:$VD}),o($Vi2,[2,253]),o($Vi2,[2,147],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,220:$VW,222:$VX,227:$VZ,228:$V_,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),{13:540,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vj2,[2,156]),o($VS1,[2,72]),{22:[1,541],169:542,170:$Vl2,171:$Vm2},{14:$Vw2,23:[1,543]},o($Vm1,[2,183]),o($Vm1,[2,184]),o($Vn2,[2,182]),o([1,6,10,11,14,23,79,97,104,118,125,146,148,158,208,209,220,221,222,227,228,237,246,247],[2,351],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),{118:[2,279],136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},o($Vm1,[2,145]),{11:$VE2},o($Vm1,[2,288]),o($Vm1,[2,369]),o($Vr2,[2,345]),o([1,6,10,11,14,23,79,97,104,118,125,136,146,148,158,178,208,209,215,220,221,222,227,228,237,246,247,250,251,254,255,256,257],[2,300]),o($Vm1,[2,336]),{5:545,10:$V1},{11:[1,546]},o($Vs2,[2,342],{6:[1,547]}),{13:548,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($VF2,$V52,{173:550,11:[1,549],14:$V62}),o($VF2,$V52,{173:550,14:$V62,23:[1,551]}),{97:[1,552],136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},o($VA1,[2,111]),{97:[1,553],136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},{97:[1,554],136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},o($VA1,[2,121]),{13:555,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vm1,[2,104]),o($Vm1,[2,166]),o($Vw1,[2,271]),o($Vw1,[2,303]),o($Vw1,[2,278]),o($V72,[2,284]),o($Vv2,$V52,{173:556,14:$V62}),o($V72,[2,285]),{11:$VE2,12:229,13:366,15:231,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,149:$VC,150:$VD,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,177:$VJ,178:$VG1,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,210:520,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($VN1,[2,89]),o($VN1,[2,90]),{104:[1,557]},{104:[2,99]},{104:[2,100]},{13:558,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},o($Vw1,[2,164]),o($Vx2,[2,194]),o($Vx2,[2,201],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,220:$VW,222:$VX,227:$VZ,228:$V_,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o([1,6,10,11,14,23,79,97,104,118,125,146,148,158,208,209,220,221,222,227,228,246],[2,331],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,237:[1,559],247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($Vy2,[2,333],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,221:[1,560],247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($VX1,[2,332],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($Vm1,[2,263]),o($Vm1,[2,137]),o($Vi2,[2,254]),o($Vv2,$V52,{173:561,14:$Vh2}),{6:$V71,9:497,11:$VC2,136:$Vb1,143:562,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},o($VB2,$V82,{174:380,161:381,175:382,176:383,56:387,157:563,57:$V9,96:$Vr,103:$VQ1,177:$V92,178:$Va2,179:$Vb2}),o($Vm1,[2,175]),{169:564,170:$Vl2,171:$Vm2},o($Vm1,[2,287]),{6:$V71,9:497,11:$VC2,143:565},o($Vm1,[2,339]),o($Vs2,[2,343]),o($VD2,[2,294],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,220:$VW,222:$VX,227:$VZ,228:$V_,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($Vm1,[2,123]),{6:$V71,9:459,10:$Vt2},o($Vm1,[2,124]),o($VA1,[2,114]),o($VA1,[2,115]),o($VA1,[2,118]),{125:[1,566],136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},{6:$V71,9:523,10:$Vt2,11:$VC2,143:567},o($VN1,[2,96]),{97:[1,568],136:$Vb1,178:$Vc1,219:154,220:$VW,222:$VX,225:155,226:111,227:$VZ,228:$V_,230:112,246:$Vd1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1},{13:569,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{13:570,16:160,18:31,19:32,20:$V2,21:$V3,24:$V4,25:$V5,26:37,27:$V6,33:$V7,35:50,36:$V8,38:42,39:43,40:13,41:14,42:15,43:16,44:17,45:18,46:19,47:20,48:21,49:22,50:23,51:24,52:25,53:26,54:27,55:28,56:106,57:$V9,60:101,61:$Va,62:$Vb,63:102,64:$Vc,65:100,66:$Vd,67:103,68:$Ve,69:120,70:$Vf,71:81,72:$Vg,73:121,74:$Vh,80:$Vi,81:$Vj,82:$Vk,83:$Vl,84:$Vm,85:$Vn,86:$Vo,87:$Vp,89:94,90:$Vq,96:$Vr,103:$Vs,108:48,110:$Vt,115:104,130:72,131:$Vv,132:$Vw,133:$Vx,134:$Vy,139:47,140:$Vz,141:$VA,142:40,147:$VB,151:51,152:52,153:53,154:$VE,155:$VF,159:74,161:79,162:$VG,163:$VH,164:96,165:$VI,172:46,175:78,180:105,181:$VK,183:$VL,184:60,185:$VM,187:41,193:$VN,194:$VO,195:44,196:$VP,197:49,200:67,201:$VQ,202:$VR,205:$VS,206:$VT,212:$VU,218:$VV,219:63,220:$VW,222:$VX,223:64,224:$VY,225:65,226:111,227:$VZ,228:$V_,230:112,238:$V$,243:61,244:$V01,248:$V11,249:$V21,250:$V31,251:$V41,252:$V51,253:$V61},{6:$V71,9:572,10:$Vz2,11:$VC2,143:571},o($Vi2,[2,148]),{14:$Vw2,23:[1,573]},o($Vm1,[2,176]),o($Vm1,[2,337]),o($VA1,[2,122]),o($V72,[2,286]),{104:[2,101]},o($VX1,[2,334],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($VX1,[2,335],{226:111,230:112,219:154,225:155,136:$Vb1,178:$Vc1,247:$Ve1,250:$Vf1,251:$Vg1,254:$Vh1,255:$Vi1,256:$Vj1,257:$Vk1}),o($Vi2,[2,255]),{11:$VE2,15:273,33:$V7,56:274,57:$V9,58:276,59:$VL1,60:278,61:$Va,62:$Vb,63:279,64:$Vc,65:275,66:$Vd,69:120,70:$Vf,71:277,72:$Vg,73:121,74:$Vh,144:538,145:272,147:$VM1,149:$VC,150:$VD},{169:574,170:$Vl2,171:$Vm2},o($Vm1,[2,174])],
defaultActions: {139:[2,3],168:[2,269],329:[2,249],527:[2,99],528:[2,100],568:[2,101]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        throw new Error(str);
    }
},
parse: function parse(input) {

    // For Imba we are going to drop most of the features that are not used
    // Locations are provided by the tokens from the lexer directly - so drop yylloc
    // We dont really need the shared state (it seems)

    var self = this,
        stack = [0],
        tstack = [], // token stack
        vstack = [null], // semantic value stack
        table = this.table,
        yytext = '',
        yylineno = 0,
        yyleng = 0,
        recovering = 0,
        TERROR = 2,
        EOF = 1;

    // var args = lstack.slice.call(arguments, 1);
    //this.reductionCount = this.shiftCount = 0;

    var lexer = Object.create(this.lexer);
    var yy = this.yy;

    lexer.setInput(input,yy);

    if (typeof yy.parseError === 'function') {
        this.parseError = yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError; // what?
    }

    function popStack (n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
    }

    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;

    function handleError(){
        var error_rule_depth;
        var errStr = '';

        // Return the rule stack depth where the nearest error rule can be found.
        // Return FALSE when no error recovery rule was found.
        // we have no rules now
        function locateNearestErrorRecoveryRule(state) {
            var stack_probe = stack.length - 1;
            var depth = 0;

            // try to recover from error
            for(;;) {
                // check for error recovery rule in this state
                if ((TERROR.toString()) in table[state]) {
                    return depth;
                }
                if (state === 0 || stack_probe < 2) {
                    return false; // No suitable error recovery rule available.
                }
                stack_probe -= 2; // popStack(1): [symbol, action]
                state = stack[stack_probe];
                ++depth;
            }
        }

        if (!recovering) {
            // first see if there's any chance at hitting an error recovery rule:
            error_rule_depth = locateNearestErrorRecoveryRule(state);

            // Report error
            expected = [];

            var tsym = lexer.yytext;
            var tok = self.terminals_[symbol] || symbol;
            var tloc = tsym ? tsym._loc : -1;
            var tpos = tloc != -1 ? "[" + tsym._loc + ":" + tsym._len + "]" : '[0:0]';

            if (lexer.showPosition) {
                errStr = 'Parse error at '+(tpos)+":\n"+lexer.showPosition()+"\nExpecting "+expected.join(', ') + ", got '" + (self.terminals_[symbol] || symbol)+ "'";
            } else {
                errStr = 'Parse error at '+(tpos)+": Unexpected " + (symbol == EOF ? "end of input" : ("'"+(tok)+"'"));
            }

            self.parseError(errStr, {
                lexer: lexer,
                text: lexer.match,
                token: tok,
                line: lexer.yylineno,
                expected: expected,
                recoverable: (error_rule_depth !== false)
            });
        } else if (preErrorSymbol !== EOF) {
            error_rule_depth = locateNearestErrorRecoveryRule(state);
        }

        // just recovered from another error
        if (recovering == 3) {
            if (symbol === EOF || preErrorSymbol === EOF) {
                throw new Error(errStr || 'Parsing halted while starting to recover from another error.');
            }

            // discard current lookahead and grab another
            yytext = lexer.yytext;
        }

        // try to recover from error
        if (error_rule_depth === false) {
            throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');
        }
        popStack(error_rule_depth);
        preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token
        symbol = TERROR;         // insert generic error symbol as new lookahead
        state = stack[stack.length-1];
        action = table[state] && table[state][TERROR];
        recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
    }


    var __sym = this.symbols_;
    var __prod = this.productions_;

    while (true) {
        // retreive state number from top of stack
        state = stack[stack.length - 1];

        if (symbol === null || typeof symbol == 'undefined') {
            symbol = __sym[lexer.lex()] || EOF;
        }
        action = table[state] && table[state][symbol];

_handle_error:
        if (typeof action === 'undefined' || !action.length || !action[0]) {
            handleError();
        }

        switch (action[0]) {
            case 1: // shift
                stack.push(symbol);
                stack.push(action[1]); // push state
                vstack.push(lexer.yytext);
                
                symbol = null;
                if (!preErrorSymbol) { // normal execution/no error
                    yytext = lexer.yytext;
                    if (recovering > 0) {
                        recovering--;
                    }
                } else {
                    // error just occurred, resume old lookahead f/ before error
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                }
                break;

            case 2:
                len = __prod[action[1]][1];
                // perform semantic action
                yyval.$ = vstack[vstack.length-len];
                r = this.performAction(yyval, yytext, yy, action[1], vstack);
                if (typeof r !== 'undefined') {
                    return r;
                }

                while(len > 0) {
                    stack.pop();
                    stack.pop();
                    vstack.pop();
                    len--;
                }

                stack.push(__prod[action[1]][0]);
                newState = table[stack[stack.length-2]][stack[stack.length-1]];
                stack.push(newState);
                vstack.push(yyval.$);
                break;

            case 3:
                return true;
        }
    }

    return true;
}};

function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (true) {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
}

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// helper for subclassing
function subclass$(obj,sup) {
	for (var k in sup) {
		if (sup.hasOwnProperty(k)) obj[k] = sup[k];
	};
	// obj.__super__ = sup;
	obj.prototype = Object.create(sup.prototype);
	obj.__super__ = obj.prototype.__super__ = sup.prototype;
	obj.prototype.initialize = obj.prototype.constructor = obj;
};

function idx$(a,b){
	return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
};
function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
// imba$inlineHelpers=1
// TODO Create Expression - make all expressions inherit from these?

var helpers = __webpack_require__(1);
var constants = __webpack_require__(4);

var ImbaParseError = __webpack_require__(3).ImbaParseError;
var Token = __webpack_require__(0).Token;
var SourceMap = __webpack_require__(13).SourceMap;

var AST = exports.AST = {};

// Helpers for operators
var OP = exports.OP = function(op,l,r) {
	var o = String(op);
	switch (o) {
		case '.':
			if ((typeof r=='string'||r instanceof String)) { r = new Identifier(r) };
			// r = r.value if r isa VarOrAccess
			return new Access(op,l,r);
			break;
		
		case '=':
			if (l instanceof Tuple) { return new TupleAssign(op,l,r) };
			return new Assign(op,l,r);
			break;
		
		case '?=':
		case '||=':
		case '&&=':
			return new ConditionalAssign(op,l,r);
			break;
		
		case '+=':
		case '-=':
		case '*=':
		case '/=':
		case '^=':
		case '%=':
			return new CompoundAssign(op,l,r);
			break;
		
		case '?.':
			if (r instanceof VarOrAccess) {
				r = r.value();
			};
			
			// depends on the right side - this is wrong
			return new PropertyAccess(op,l,r);
			break;
		
		case 'instanceof':
		case 'isa':
			return new InstanceOf(op,l,r);
			break;
		
		case 'in':
			return new In(op,l,r);
			break;
		
		case 'typeof':
			return new TypeOf(op,l,r);
			break;
		
		case 'delete':
			return new Delete(op,l,r);
			break;
		
		case '--':
		case '++':
		case '!':
		case '√':
		case 'not': // alias
			return new UnaryOp(op,l,r);
			break;
		
		case '>':
		case '<':
		case '>=':
		case '<=':
		case '==':
		case '===':
		case '!=':
		case '!==':
			return new ComparisonOp(op,l,r);
			break;
		
		case '∩':
		case '∪':
			return new MathOp(op,l,r);
			break;
		
		case '..':
		case '...':
			return new Range(op,l,r);
			break;
		
		default:
		
			return new Op(op,l,r);
	
	};
};

var OP_COMPOUND = exports.OP_COMPOUND = function(sym,op,l,r) {
	// console.log "?. soak operator",sym
	if (sym == '?.') {
		console.log("?. soak operator");
		return null;
	};
	if (sym == '?=' || sym == '||=' || sym == '&&=') {
		return new ConditionalAssign(op,l,r);
	} else {
		return new CompoundAssign(op,l,r);
	};
};

var OPTS = {};
var ROOT = null;

var NODES = exports.NODES = [];

var LIT = function(val) {
	return new Literal(val);
};

var SYM = function(val) {
	return new Symbol(val);
};

var IF = function(cond,body,alt) {
	var node = new If(cond,body);
	if (alt) { node.addElse(alt) };
	return node;
};

var FN = function(pars,body) {
	return new Func(pars,body);
};

var CALL = function(callee,pars) {
	// possibly return instead(!)
	if(pars === undefined) pars = [];
	return new Call(callee,pars);
};

var CALLSELF = function(name,pars) {
	if(pars === undefined) pars = [];
	var ref = new Identifier(name);
	return new Call(OP('.',SELF,ref),pars);
};

var BLOCK = function() {
	return Block.wrap([].slice.call(arguments));
};

var WHILE = function(test,code) {
	return new While(test).addBody(code);
};

var SPLAT = exports.SPLAT = function(value) {
	if (value instanceof Assign) {
		value.setLeft(new Splat(value.left()));
		return value;
	} else {
		return new Splat(value);
	};
};

var SEMICOLON_TEST = /;(\s*\/\/.*)?[\n\s\t]*$/;
var RESERVED_TEST = /^(default|char|for)$/;

// captures error from parser
function parseError(str,o){
	// find nearest token
	var err;
	
	if (o.lexer) {
		var token = o.lexer.yytext;
		// console.log o:lexer:pos,token.@loc
		err = new ImbaParseError({message: str},{
			pos: o.lexer.pos,
			tokens: o.lexer.tokens,
			token: o.lexer.yytext,
			meta: o
		});
		
		throw err;
		
		// should find the closest token with actual position
		// str = "[{token.@loc}:{token.@len || String(token):length}] {str}"
	};
	var e = new Error(str);
	e.lexer = o.lexer;
	e.options = o;
	throw e;
}; exports.parseError = parseError;

function c__(obj){
	return (typeof obj == 'string') ? obj : obj.c();
};

function mark__(tok){
	if (tok && (OPTS.sourceMapInline || OPTS.sourceMap) && tok.sourceMapMarker) {
		return tok.sourceMapMarker();
	} else {
		return '';
	};
};

function num__(num){
	return new Num(num);
};

function str__(str){
	// should pack in token?!?
	return new Str(str);
};

function blk__(obj){
	return (obj instanceof Array) ? Block.wrap(obj) : obj;
};

function sym__(obj){
	// console.log "sym {obj}"
	return helpers.symbolize(String(obj));
};

function cary__(ary){
	return ary.map(function(v) { return (typeof v == 'string') ? v : v.c(); });
};

function dump__(obj,key){
	if (obj instanceof Array) {
		return obj.map(function(v) { return (v && v.dump) ? v.dump(key) : v; });
	} else if (obj && obj.dump) {
		return obj.dump();
	};
};

function compact__(ary){
	if (ary instanceof ListNode) {
		return ary.compact();
	};
	
	return ary.filter(function(v) { return v != undefined && v != null; });
};

function reduce__(res,ary){
	for (var i = 0, items = iter$(ary), len = items.length, v; i < len; i++) {
		v = items[i];
		(v instanceof Array) ? reduce__(res,v) : res.push(v);
	};
	return;
};

function flatten__(ary,compact){
	if(compact === undefined) compact = false;
	var out = [];
	for (var i = 0, items = iter$(ary), len = items.length, v; i < len; i++) {
		v = items[i];
		(v instanceof Array) ? reduce__(out,v) : out.push(v);
	};
	return out;
};

AST.parse = function (str,opts){
	if(opts === undefined) opts = {};
	var indent = str.match(/\t+/)[0];
	// really? Require the compiler, not this
	return Imbac.parse(str,opts);
};

AST.inline = function (str,opts){
	if(opts === undefined) opts = {};
	return this.parse(str,opts).body();
};

AST.node = function (typ,pars){
	if (typ == 'call') {
		if (pars[0].c() == 'return') {
			pars[0] = 'tata';
		};
		return new Call(pars[0],pars[1],pars[2]);
	};
};


AST.escapeComments = function (str){
	if (!(str)) { return '' };
	return str;
};


var shortRefCache = [];

function counterToShortRef(nr){
	var base = "A".charCodeAt(0);
	
	while (shortRefCache.length <= nr){
		var num = shortRefCache.length + 1;
		var str = "";
		
		while (true){
			num -= 1;
			str = String.fromCharCode(base + (num % 26)) + str;
			num = Math.floor(num / 26);
			if (num <= 0) { break; };
		};
		
		shortRefCache.push(str);
	};
	return shortRefCache[nr];
};

function truthy__(node){
	
	if (node instanceof True) {
		return true;
	};
	
	if (node instanceof False) {
		return false;
	};
	
	if (node.isTruthy) {
		return node.isTruthy();
	};
	
	return undefined;
};

function Indentation(a,b){
	this._open = a;
	this._close = b;
	this;
};

exports.Indentation = Indentation; // export class 
Indentation.prototype.open = function(v){ return this._open; }
Indentation.prototype.setOpen = function(v){ this._open = v; return this; };
Indentation.prototype.close = function(v){ return this._close; }
Indentation.prototype.setClose = function(v){ this._close = v; return this; };

Indentation.prototype.isGenerated = function (){
	return this._open && this._open.generated;
};

Indentation.prototype.aloc = function (){
	return this._open && this._open._loc || 0;
};

Indentation.prototype.bloc = function (){
	return this._close && this._close._loc || 0;
};

Indentation.prototype.wrap = function (str){
	var om = this._open && this._open._meta;
	var pre = om && om.pre || '';
	var post = om && om.post || '';
	var esc = AST.escapeComments;
	var out = this._close;
	
	// the first newline should not be indented?
	str = post.replace(/^\n/,'') + str;
	str = str.replace(/^/g,"\t").replace(/\n/g,"\n\t").replace(/\n\t$/g,"\n");
	
	str = pre + '\n' + str;
	if (out instanceof Terminator) { str += out.c() };
	if (str[str.length - 1] != '\n') { str = str + '\n' };
	return str;
};

var INDENT = new Indentation({},{});

function Stash(){
	this._entities = [];
};

Stash.prototype.add = function (item){
	this._entities.unshift(item);
	return this;
};

Stash.prototype.pluck = function (item){
	var match = null;
	for (var i = 0, ary = iter$(this._entities), len = ary.length, entity; i < len; i++) {
		entity = ary[i];
		if (entity == item || (entity instanceof item)) {
			match = entity;
			this._entities.splice(i,1);
			return match;
		};
	};
	return null;
};


function Stack(){
	this.reset();
};

exports.Stack = Stack; // export class 
Stack.prototype.loglevel = function(v){ return this._loglevel; }
Stack.prototype.setLoglevel = function(v){ this._loglevel = v; return this; };
Stack.prototype.nodes = function(v){ return this._nodes; }
Stack.prototype.setNodes = function(v){ this._nodes = v; return this; };
Stack.prototype.scopes = function(v){ return this._scopes; }
Stack.prototype.setScopes = function(v){ this._scopes = v; return this; };

Stack.prototype.reset = function (){
	this._nodes = [];
	this._scoping = [];
	this._scopes = [];
	this._stash = new Stash(this);
	this._loglevel = 3;
	this._counter = 0;
	this._counters = {};
	return this;
};

Stack.prototype.incr = function (name){
	this._counters[name] || (this._counters[name] = 0);
	return this._counters[name] += 1;
};

Stack.prototype.stash = function (){
	return this._stash;
};

Stack.prototype.option = function (key){
	return this._options && this._options[key];
};

Stack.prototype.platform = function (){
	return this._options.target;
};

Stack.prototype.env = function (key){
	var e;
	var val = this._options[("ENV_" + key)];
	if (val != undefined) { return val };
	
	if (this.platform() && idx$(key,['WEB','NODE','WEBWORKER']) >= 0) {
		return this.platform().toUpperCase() == key;
	};
	
	// console.log 'lookup env var',key,@options:env
	
	if (e = this._options.env) {
		if (e.hasOwnProperty(key)) {
			return e[key];
		} else if (e.hasOwnProperty(key.toLowerCase())) {
			return e[key.toLowerCase()];
		};
	};
	
	if (process.env) {
		val = process.env[key.toUpperCase()];
		if (val != undefined) {
			return val;
		};
		return null;
	};
	
	return undefined;
};


Stack.prototype.addScope = function (scope){
	this._scopes.push(scope);
	return this;
};

Stack.prototype.traverse = function (node){
	return this;
};

Stack.prototype.push = function (node){
	this._nodes.push(node);
	// not sure if we have already defined a scope?
	return this;
};

Stack.prototype.pop = function (node){
	this._nodes.pop(); // (node)
	return this;
};

Stack.prototype.parent = function (){
	return this._nodes[this._nodes.length - 2];
};

Stack.prototype.current = function (){
	return this._nodes[this._nodes.length - 1];
};

Stack.prototype.up = function (test){
	test || (test = function(v) { return !(v instanceof VarOrAccess); });
	
	if (test.prototype instanceof Node) {
		var typ = test;
		test = function(v) { return v instanceof typ; };
	};
	
	var i = this._nodes.length - 2; // key
	while (i >= 0){
		var node = this._nodes[i];
		if (test(node)) { return node };
		i -= 1;
	};
	return null;
};

Stack.prototype.relative = function (node,offset){
	if(offset === undefined) offset = 0;
	var idx = this._nodes.indexOf(node);
	return (idx >= 0) ? this._nodes[idx + offset] : null;
};

Stack.prototype.scope = function (lvl){
	if(lvl === undefined) lvl = 0;
	var i = this._nodes.length - 1 - lvl;
	while (i >= 0){
		var node = this._nodes[i];
		if (node._scope) { return node._scope };
		i -= 1;
	};
	return null;
};

Stack.prototype.scopes = function (){
	// include deeper scopes as well?
	var scopes = [];
	var i = this._nodes.length - 1;
	while (i >= 0){
		var node = this._nodes[i];
		if (node._scope) { scopes.push(node._scope) };
		i -= 1;
	};
	return scopes;
};

Stack.prototype.method = function (){
	return this.up(MethodDeclaration);
};

Stack.prototype.block = function (){
	return this.up(Block);
};

Stack.prototype.isExpression = function (){
	var i = this._nodes.length - 1;
	while (i >= 0){
		var node = this._nodes[i];
		// why are we not using isExpression here as well?
		if ((node instanceof Code) || (node instanceof Loop)) {
			return false;
		};
		if (node.isExpression()) {
			return true;
		};
		// probably not the right test - need to be more explicit
		i -= 1;
	};
	return false;
};

Stack.prototype.toString = function (){
	return ("Stack(" + this._nodes.join(" -> ") + ")");
};

Stack.prototype.isAnalyzing = function (){
	return this._analyzing;
};

Stack.prototype.scoping = function (){
	return this._nodes.filter(function(n) { return n._scope; }).map(function(n) { return n._scope; });
};

// Lots of globals -- really need to deal with one stack per file / context
var STACK = exports.STACK = new Stack();

// use a bitmask for these

function Node(){
	this.setup();
	this;
};

exports.Node = Node; // export class 
Node.prototype.o = function(v){ return this._o; }
Node.prototype.setO = function(v){ this._o = v; return this; };
Node.prototype.options = function(v){ return this._options; }
Node.prototype.setOptions = function(v){ this._options = v; return this; };
Node.prototype.traversed = function(v){ return this._traversed; }
Node.prototype.setTraversed = function(v){ this._traversed = v; return this; };

Node.prototype.safechain = function (){
	return false;
};

Node.prototype.p = function (){
	// allow controlling this from CLI
	if (STACK.loglevel() > 0) {
		console.log.apply(console,arguments);
	};
	return this;
};

Node.prototype.typeName = function (){
	return this.constructor.name;
};

Node.prototype.namepath = function (){
	return this.typeName();
};

Node.prototype.setup = function (){
	this._expression = false;
	this._traversed = false;
	this._parens = false;
	this._cache = null;
	this._value = null;
	return this;
};

Node.prototype.set = function (obj){
	this._options || (this._options = {});
	for (var v, i = 0, keys = Object.keys(obj), l = keys.length, k; i < l; i++){
		k = keys[i];v = obj[k];this._options[k] = v;
	};
	return this;
};

// get and set
Node.prototype.option = function (key,val){
	if (val != undefined) {
		this._options || (this._options = {});
		this._options[key] = val;
		return this;
	};
	
	return this._options && this._options[key];
};

Node.prototype.configure = function (obj){
	return this.set(obj);
};

Node.prototype.region = function (){
	return [0,0];
};

Node.prototype.loc = function (){
	return [0,0];
};

Node.prototype.token = function (){
	return null;
};

Node.prototype.compile = function (){
	return this;
};

Node.prototype.visit = function (){
	return this;
};

Node.prototype.stack = function (){
	return STACK;
};

Node.prototype.isString = function (){
	return false;
};

Node.prototype.isPrimitive = function (deep){
	return false;
};

Node.prototype.isReserved = function (){
	return false;
};

// should rather do traversals
// o = {}, up, key, index
Node.prototype.traverse = function (){
	if (this._traversed) {
		return this;
	};
	// NODES.push(self)
	this._traversed = true;
	STACK.push(this);
	this.visit(STACK);
	STACK.pop(this);
	return this;
};

Node.prototype.inspect = function (){
	return {type: this.constructor.toString()};
};

Node.prototype.js = function (o){
	return "NODE";
};

Node.prototype.toString = function (){
	return ("" + (this.constructor.name));
};

// swallow might be better name
Node.prototype.consume = function (node){
	if (node instanceof PushAssign) {
		return new PushAssign(node.op(),node.left(),this);
	};
	
	if (node instanceof Assign) {
		// node.right = self
		return OP(node.op(),node.left(),this);
	} else if (node instanceof Op) {
		return OP(node.op(),node.left(),this);
	} else if (node instanceof Return) {
		return new Return(this);
	};
	return this;
};

Node.prototype.toExpression = function (){
	this._expression = true;
	return this;
};

Node.prototype.forceExpression = function (){
	this._expression = true;
	return this;
};

Node.prototype.isExpressable = function (){
	return true;
};

Node.prototype.isExpression = function (){
	return this._expression || false;
};

Node.prototype.hasSideEffects = function (){
	return true;
};

Node.prototype.isUsed = function (){
	return true;
};

Node.prototype.shouldParenthesize = function (){
	return false;
};

Node.prototype.shouldParenthesizeInTernary = function (){
	return true;
};

Node.prototype.block = function (){
	return Block.wrap([this]);
};

Node.prototype.node = function (){
	return this;
};

Node.prototype.scope__ = function (){
	return STACK.scope();
};

Node.prototype.up = function (){
	return STACK.parent();
};

Node.prototype.util = function (){
	return Util;
};

Node.prototype.receiver = function (){
	return this;
};

Node.prototype.addExpression = function (expr){
	// might be better to nest this up after parsing is done?
	var node = new ExpressionBlock([this]);
	return node.addExpression(expr);
};


Node.prototype.indented = function (a,b){
	
	if (a instanceof Indentation) {
		this._indentation = a;
		return this;
	};
	
	// this is a _BIG_ hack
	if (b instanceof Array) {
		this.add(b[0]);
		b = b[1];
	};
	
	// if indent and indent.match(/\:/)
	this._indentation || (this._indentation = (a && b) ? new Indentation(a,b) : INDENT);
	return this;
};

Node.prototype.prebreak = function (term){
	if(term === undefined) term = '\n';
	return this;
};

Node.prototype.invert = function (){
	return OP('!',this);
};

Node.prototype.cache = function (o){
	if(o === undefined) o = {};
	this._cache = o;
	o.var = this.scope__().temporary(this,o);
	o.lookups = 0;
	return this;
};

Node.prototype.cachevar = function (){
	return this._cache && this._cache.var;
};

Node.prototype.decache = function (){
	if (this._cache) {
		this.cachevar().free();
		this._cache = null;
	};
	return this;
};

// is this without side-effects? hmm - what does it even do?
Node.prototype.predeclare = function (){
	if (this._cache) {
		this.scope__().vars().swap(this._cache.var,this);
	};
	return this;
};

// the "name-suggestion" for nodes if they need to be cached
Node.prototype.alias = function (){
	return null;
};

Node.prototype.warn = function (text,opts){
	if(opts === undefined) opts = {};
	opts.message = text;
	opts.loc || (opts.loc = this.loc());
	this.scope__().root().warn(opts);
	return this;
};

Node.prototype.c = function (o){
	var indent;
	var s = STACK;
	var ch = this._cache;
	if (ch && ch.cached) { return this.c_cached(ch) };
	
	s.push(this);
	if (o && o.expression) this.forceExpression();
	
	if (o && o.indent) {
		this._indentation || (this._indentation = INDENT);
	};
	
	var out = this.js(s,o);
	
	// really? why not call this somewhere else?
	var paren = this.shouldParenthesize();
	
	if (indent = this._indentation) {
		out = indent.wrap(out,o);
	};
	
	// should move this somewhere else really
	if (paren) { out = ("(" + out + ")") };
	if (o && o.braces) {
		if (indent) {
			out = '{' + out + '}';
		} else {
			out = '{ ' + out + ' }';
		};
	};
	
	s.pop(this);
	
	if (ch = this._cache) {
		if (!ch.manual) { out = ("" + (ch.var.c()) + " = " + out) };
		var par = s.current();
		if ((par instanceof Access) || (par instanceof Op)) { out = '(' + out + ')' }; // others? #
		ch.cached = true;
	};
	return out;
};

Node.prototype.c_cached = function (cache){
	cache.lookups++;
	if (cache.uses == cache.lookups) { cache.var.free() };
	return cache.var.c(); // recompile every time??
};

function ValueNode(value){
	this.setup();
	this._value = this.load(value);
};

subclass$(ValueNode,Node);
exports.ValueNode = ValueNode; // export class 
ValueNode.prototype.value = function(v){ return this._value; }
ValueNode.prototype.setValue = function(v){ this._value = v; return this; };

ValueNode.prototype.load = function (value){
	return value;
};

ValueNode.prototype.js = function (o){
	return (typeof this._value == 'string') ? this._value : this._value.c();
};

ValueNode.prototype.visit = function (){
	
	if (this._value instanceof Node) { this._value.traverse() }; //  && @value:traverse
	return this;
};

ValueNode.prototype.region = function (){
	return [this._value._loc,this._value._loc + this._value._len];
};


function Statement(){ return ValueNode.apply(this,arguments) };

subclass$(Statement,ValueNode);
exports.Statement = Statement; // export class 
Statement.prototype.isExpressable = function (){
	return false;
};


function Meta(){ return ValueNode.apply(this,arguments) };

subclass$(Meta,ValueNode);
exports.Meta = Meta; // export class 
Meta.prototype.isPrimitive = function (deep){
	return true;
};

function Comment(){ return Meta.apply(this,arguments) };

subclass$(Comment,Meta);
exports.Comment = Comment; // export class 
Comment.prototype.visit = function (){
	var block, next;
	if (block = this.up()) {
		var idx = block.indexOf(this) + 1;
		if (block.index(idx) instanceof Terminator) { idx += 1 };
		if (next = block.index(idx)) {
			next._desc = this;
		};
	};
	
	return this;
};

Comment.prototype.toDoc = function (){
	return helpers.normalizeIndentation("" + this._value._value);
};

Comment.prototype.toJSON = function (){
	return helpers.normalizeIndentation("" + this._value._value);
};

Comment.prototype.c = function (o){
	var v = this._value._value;
	if (o && o.expression || v.match(/\n/) || this._value.type() == 'HERECOMMENT') { // multiline?
		return ("/*" + v + "*/");
	} else {
		return ("// " + v);
	};
};

function Terminator(v){
	this._value = v;
	this;
};

subclass$(Terminator,Meta);
exports.Terminator = Terminator; // export class 
Terminator.prototype.traverse = function (){
	return this;
};

Terminator.prototype.loc = function (){
	return [this._value._loc,this._value._loc + this._value._value.length];
};

Terminator.prototype.c = function (){
	return this._value.c();
};

function Newline(v){
	this._traversed = false;
	this._value = v || '\n';
};

subclass$(Newline,Terminator);
exports.Newline = Newline; // export class 
Newline.prototype.c = function (){
	return c__(this._value);
};


// weird place?
function Index(){ return ValueNode.apply(this,arguments) };

subclass$(Index,ValueNode);
exports.Index = Index; // export class 
Index.prototype.cache = function (o){
	if(o === undefined) o = {};
	return this._value.cache(o);
};

Index.prototype.js = function (o){
	return this._value.c();
};

function ListNode(list){
	this.setup();
	this._nodes = this.load(list || []);
	this._indentation = null;
};

// PERF acces @nodes directly?
subclass$(ListNode,Node);
exports.ListNode = ListNode; // export class 
ListNode.prototype.nodes = function(v){ return this._nodes; }
ListNode.prototype.setNodes = function(v){ this._nodes = v; return this; };

ListNode.prototype.list = function (){
	return this._nodes;
};

ListNode.prototype.compact = function (){
	this._nodes = compact__(this._nodes);
	return this;
};

ListNode.prototype.load = function (list){
	return list;
};

ListNode.prototype.concat = function (other){
	// need to store indented content as well?
	this._nodes = this.nodes().concat((other instanceof Array) ? other : other.nodes());
	return this;
};

ListNode.prototype.swap = function (item,other){
	var idx = this.indexOf(item);
	if (idx >= 0) { this.nodes()[idx] = other };
	return this;
};

ListNode.prototype.push = function (item){
	this._nodes.push(item);
	return this;
};

ListNode.prototype.pop = function (){
	var end = this._nodes.pop();
	return end;
};

ListNode.prototype.add = function (item){
	this._nodes.push(item);
	return this;
};

ListNode.prototype.unshift = function (item,br){
	if (br) { this._nodes.unshift(BR) };
	this._nodes.unshift(item);
	return this;
};

// test
ListNode.prototype.slice = function (a,b){
	return new this.constructor(this._nodes.slice(a,b));
};

ListNode.prototype.break = function (br,pre){
	if(pre === undefined) pre = false;
	if (typeof br == 'string') { br = new Terminator(br) };
	pre ? this.unshift(br) : this.push(br);
	return this;
};

ListNode.prototype.some = function (cb){
	for (var i = 0, ary = iter$(this._nodes), len = ary.length; i < len; i++) {
		if (cb(ary[i])) { return true };
	};
	return false;
};

ListNode.prototype.every = function (cb){
	for (var i = 0, ary = iter$(this._nodes), len = ary.length; i < len; i++) {
		if (!cb(ary[i])) { return false };
	};
	return true;
};

ListNode.prototype.filter = function (cb){
	return this._nodes.filter(cb);
};

ListNode.prototype.pluck = function (cb){
	var item = this.filter(cb)[0];
	if (item) { this.remove(item) };
	return item;
};

ListNode.prototype.indexOf = function (item){
	return this._nodes.indexOf(item);
};

ListNode.prototype.index = function (i){
	return this._nodes[i];
};

ListNode.prototype.remove = function (item){
	var idx = this._nodes.indexOf(item);
	if (idx >= 0) { this._nodes.splice(idx,1) };
	return this;
};

ListNode.prototype.removeAt = function (idx){
	var item = this._nodes[idx];
	if (idx >= 0) { this._nodes.splice(idx,1) };
	return item;
};


ListNode.prototype.replace = function (original,replacement){
	var idx = this._nodes.indexOf(original);
	if (idx >= 0) {
		if (replacement instanceof Array) {
			this._nodes.splice.apply(this._nodes,[].concat([idx,1], [].slice.call(replacement)));
		} else {
			this._nodes[idx] = replacement;
		};
	};
	return this;
};

ListNode.prototype.first = function (){
	return this._nodes[0];
};

ListNode.prototype.last = function (){
	var i = this._nodes.length;
	while (i){
		i = i - 1;
		var v = this._nodes[i];
		if (!((v instanceof Meta))) { return v };
	};
	return null;
};

ListNode.prototype.map = function (fn){
	return this._nodes.map(fn);
};

ListNode.prototype.forEach = function (fn){
	return this._nodes.forEach(fn);
};

ListNode.prototype.remap = function (fn){
	this._nodes = this.map(fn);
	return this;
};

ListNode.prototype.count = function (){
	return this._nodes.length;
};

ListNode.prototype.realCount = function (){
	var k = 0;
	for (var i = 0, ary = iter$(this._nodes), len = ary.length, node; i < len; i++) {
		node = ary[i];
		if (node && !(node instanceof Meta)) { k++ };
	};
	return k;
};

ListNode.prototype.visit = function (){
	for (var i = 0, ary = iter$(this._nodes), len = ary.length, node; i < len; i++) {
		node = ary[i];
		node && node.traverse();
	};
	return this;
};

ListNode.prototype.isExpressable = function (){
	for (var i = 0, ary = iter$(this.nodes()), len = ary.length, node; i < len; i++) {
		node = ary[i];
		if (node && !node.isExpressable()) { return false };
	};
	
	return true;
};

ListNode.prototype.toArray = function (){
	return this._nodes;
};

ListNode.prototype.delimiter = function (){
	return this._delimiter || ",";
};

ListNode.prototype.js = function (o,pars){
	if(!pars||pars.constructor !== Object) pars = {};
	var nodes = pars.nodes !== undefined ? pars.nodes : this._nodes;
	var delim = ',';
	var express = delim != ';';
	var last = this.last();
	
	var i = 0;
	var l = nodes.length;
	var str = "";
	
	for (var j = 0, ary = iter$(nodes), len = ary.length, arg; j < len; j++) {
		arg = ary[j];
		var part = (typeof arg == 'string') ? arg : ((arg ? arg.c({expression: express}) : ''));
		str += part;
		if (part && (!(express) || arg != last) && !(arg instanceof Meta)) { str += delim };
	};
	
	return str;
};

ListNode.prototype.indented = function (a,b){
	if (a instanceof Indentation) {
		this._indentation = a;
		return this;
	};
	
	this._indentation || (this._indentation = (a && b) ? new Indentation(a,b) : INDENT);
	return this;
};


function ArgList(){ return ListNode.apply(this,arguments) };

subclass$(ArgList,ListNode);
exports.ArgList = ArgList; // export class 


function AssignList(){ return ArgList.apply(this,arguments) };

subclass$(AssignList,ArgList);
exports.AssignList = AssignList; // export class 
AssignList.prototype.concat = function (other){
	if (this._nodes.length == 0 && (other instanceof AssignList)) {
		return other;
	} else {
		AssignList.__super__.concat.call(this,other);
	};
	// need to store indented content as well?
	// @nodes = nodes.concat(other isa Array ? other : other.nodes)
	return this;
};


function Block(list){
	this.setup();
	this._nodes = list || [];
	this._head = null;
	this._indentation = null;
};

subclass$(Block,ListNode);
exports.Block = Block; // export class 
Block.prototype.head = function(v){ return this._head; }
Block.prototype.setHead = function(v){ this._head = v; return this; };

Block.wrap = function (ary){
	if (!((ary instanceof Array))) {
		throw new SyntaxError("what");
	};
	return (ary.length == 1 && (ary[0] instanceof Block)) ? ary[0] : new Block(ary);
};

Block.prototype.visit = function (){
	if (this._scope) { this._scope.visit() };
	
	for (var i = 0, ary = iter$(this._nodes), len = ary.length, node; i < len; i++) {
		node = ary[i];
		node && node.traverse();
	};
	return this;
};

Block.prototype.block = function (){
	return this;
};

Block.prototype.loc = function (){
	// rather indents, no?
	var opt, ind;
	if (opt = this.option('ends')) {
		var a = opt[0].loc();
		var b = opt[1].loc();
		
		if (!(a)) { this.p(("no loc for " + (opt[0]))) };
		if (!(b)) { this.p(("no loc for " + (opt[1]))) };
		
		return [a[0],b[1]];
	} else if (ind = this._indentation) {
		return [ind.aloc(),ind.bloc()];
	} else {
		// first node
		var a1 = this._nodes[0];
		var b1 = this._nodes[this._nodes.length - 1];
		return [a1 && a1.loc()[0] || 0,b1 && b1.loc()[1] || 0];
	};
};

// go through children and unwrap inner nodes
Block.prototype.unwrap = function (){
	var ary = [];
	for (var i = 0, items = iter$(this.nodes()), len = items.length, node; i < len; i++) {
		node = items[i];
		if (node instanceof Block) {
			ary.push.apply(ary,node.unwrap());
		} else {
			ary.push(node);
		};
	};
	return ary;
};

Block.prototype.push = function (item){
	this._nodes.push(item);
	return this;
};

Block.prototype.add = function (item){
	this._nodes.push(item);
	return this;
};

// This is just to work as an inplace replacement of nodes.coffee
// After things are working okay we'll do bigger refactorings
Block.prototype.compile = function (o){
	if(o === undefined) o = {};
	var root = new Root(this,o);
	return root.compile(o);
};


// Not sure if we should create a separate block?
Block.prototype.analyze = function (o){
	if(o === undefined) o = {};
	return this;
};

Block.prototype.cpart = function (node){
	var out = (typeof node == 'string') ? node : ((node ? node.c() : ""));
	if (out == null || out == undefined || out == "") { return "" };
	
	if (out instanceof Array) {
		var str = "";
		var l = out.length;
		var i = 0;
		while (i < l){
			str += this.cpart(out[i++]);
		};
		return str;
	};
	
	var hasSemiColon = SEMICOLON_TEST.test(out);
	if (!(hasSemiColon || (node instanceof Meta))) { out += ";" };
	return out;
};

Block.prototype.js = function (o,opts){
	var ast = this._nodes;
	var l = ast.length;
	// really?
	var express = this.isExpression() || o.isExpression() || (this.option('express') && this.isExpressable());
	if (ast.length == 0) { return '' };
	
	if (express) {
		return Block.__super__.js.call(this,o,{nodes: ast});
	};
	
	var str = "";
	for (var i = 0, ary = iter$(ast), len = ary.length; i < len; i++) {
		str += this.cpart(ary[i]);
	};
	
	// now add the head items as well
	if (this._head && this._head.length > 0) {
		var prefix = "";
		for (var j = 0, items = iter$(this._head), len_ = items.length; j < len_; j++) {
			var hv = this.cpart(items[j]);
			if (hv) { prefix += hv + '\n' };
		};
		str = prefix + str;
	};
	return str;
};


// Should this create the function as well?
Block.prototype.defers = function (original,replacement){
	var idx = this._nodes.indexOf(original);
	if (idx >= 0) { this._nodes[idx] = replacement };
	var rest = this._nodes.splice(idx + 1);
	return rest;
};

Block.prototype.expressions = function (){
	var expressions = [];
	for (var i = 0, ary = iter$(this.nodes()), len = ary.length, node; i < len; i++) {
		node = ary[i];
		if (!((node instanceof Terminator))) { expressions.push(node) };
	};
	return expressions;
};


Block.prototype.consume = function (node){
	var before;
	if (node instanceof TagTree) { // special case?!?
		this._nodes = this._nodes.map(function(child) {
			return child.consume(node);
		});
		
		var real = this.expressions();
		// console.log 'Block.consume TagTree',node.@loop
		// FIXME should not include terminators and comments when counting
		// should only wrap the content in array (returning all parts)
		// for if/else blocks -- not loops
		
		// we need to compare the real length
		if (!node._loop && real.length > 1) {
			var nr = node.blocks().push(this);
			var arr = new Arr(new ArgList(this._nodes));
			arr.indented(this._indentation);
			this._indentation = null;
			
			if (node.reactive()) {
				this._nodes = [Util.callImba(this.scope__(),"static",[arr,new Num(nr)])];
			} else {
				this._nodes = [arr];
			};
		};
		
		
		
		return this;
	} else if (node instanceof TagPushAssign) {
		// console.log 'TagPushAssign'
		var real1 = this.expressions();
		
		this._nodes = this._nodes.map(function(child) {
			if (idx$(child,real1) >= 0 && !(child instanceof Assign)) {
				// console.log "{child}"
				return child.consume(node);
			} else {
				return child;
			};
		});
		
		return this;
	};
	
	// can also return super if it is expressable, but should we really?
	if (before = this.last()) {
		var after = before.consume(node);
		if (after != before) {
			if (after instanceof Block) {
				after = after.nodes();
			};
			
			this.replace(before,after);
		};
	};
	
	return this;
};


Block.prototype.isExpressable = function (){
	if (!this._nodes.every(function(v) { return v.isExpressable(); })) { return false };
	return true;
};

Block.prototype.isExpression = function (){
	
	return this.option('express') || this._expression;
};

Block.prototype.shouldParenthesizeInTernary = function (){
	if (this.count() == 1) {
		return this.first().shouldParenthesizeInTernary();
	};
	
	return true;
};


// this is almost like the old VarDeclarations but without the values
function VarBlock(){ return ListNode.apply(this,arguments) };

subclass$(VarBlock,ListNode);
exports.VarBlock = VarBlock; // export class 
VarBlock.prototype.load = function (list){
	var first = list[0];
	
	if (first instanceof Assign) {
		this._type = first.left()._type;
	} else if (first instanceof VarReference) {
		this._type = first._type;
	};
	// @type = list[0] and list[0].type
	return list;
};

// TODO All these inner items should rather be straight up literals
// or basic localvars - without any care whatsoever about adding var to the
// beginning etc.
VarBlock.prototype.addExpression = function (expr){
	
	if (expr instanceof Assign) {
		// make sure the left-side is a var-reference
		// this should be a different type of assign, no?
		if (expr.left() instanceof VarOrAccess) {
			expr.setLeft(new VarReference(expr.left().value(),this._type));
		};
		
		this.push(expr);
	} else if (expr instanceof Assign) {
		this.addExpression(expr.left()); // make sure this is a valid thing?
		// make this into a tuple instead
		// does not need to be a tuple?
		return new TupleAssign('=',new Tuple(this.nodes()),expr.right());
	} else if (expr instanceof VarOrAccess) {
		// this is really a VarReference
		this.push(new VarReference(expr.value(),this._type));
	} else if ((expr instanceof Splat) && (expr.node() instanceof VarOrAccess)) {
		expr.setValue(new VarReference(expr.node().value(),this._type));
		this.push(expr);
	} else {
		this.p(("VarBlock.addExpression " + this + " <- " + expr));
		throw "VarBlock does not allow non-variable expressions";
	};
	return this;
};


VarBlock.prototype.isExpressable = function (){
	// we would need to force-drop the variables, makes little sense
	// but, it could be, could just push the variables out?
	return false;
};

VarBlock.prototype.js = function (o){
	var code = compact__(flatten__(cary__(this.nodes())));
	code = code.filter(function(n) { return n != null && n != undefined && n != EMPTY; });
	var out = code.join(",");
	// we just need to trust that the variables have been autodeclared beforehand
	// if we are inside an expression
	if (!o.isExpression()) { out = "var " + out };
	return out;
};


VarBlock.prototype.consume = function (node){
	// It doesnt make much sense for a VarBlock to consume anything
	// it should probably return void for methods
	return this;
};


// Could inherit from valueNode
function Parens(value,open,close){
	this.setup();
	this._open = open;
	this._close = close;
	this._value = this.load(value);
};

subclass$(Parens,ValueNode);
exports.Parens = Parens; // export class 
Parens.prototype.load = function (value){
	this._noparen = false;
	return ((value instanceof Block) && value.count() == 1) ? value.first() : value;
};

Parens.prototype.isString = function (){
	// checking if this is an interpolated string
	return this._open && String(this._open) == '("' || this.value().isString();
};

Parens.prototype.js = function (o){
	
	var par = this.up();
	var v = this._value;
	var str = null;
	
	if (v instanceof Func) { this._noparen = true };
	
	if (par instanceof Block) {
		// is it worth it?
		if (!o.isExpression()) { this._noparen = true };
		str = (v instanceof Array) ? cary__(v) : v.c({expression: o.isExpression()});
	} else {
		str = (v instanceof Array) ? cary__(v) : v.c({expression: true});
	};
	
	// check if we really need parens here?
	return str;
};

Parens.prototype.set = function (obj){
	console.log(("Parens set " + JSON.stringify(obj)));
	return Parens.__super__.set.call(this,obj);
};


Parens.prototype.shouldParenthesize = function (){
	// no need to parenthesize if this is a line in a block
	if (this._noparen) { return false }; //  or par isa ArgList
	return true;
};


Parens.prototype.prebreak = function (br){
	Parens.__super__.prebreak.call(this,br);
	console.log("PREBREAK");
	if (this._value) { this._value.prebreak(br) };
	return this;
};


Parens.prototype.isExpressable = function (){
	return this._value.isExpressable();
};

Parens.prototype.consume = function (node){
	return this._value.consume(node);
};


// Could inherit from valueNode
// an explicit expression-block (with parens) is somewhat different
// can be used to return after an expression
function ExpressionBlock(){ return ListNode.apply(this,arguments) };

subclass$(ExpressionBlock,ListNode);
exports.ExpressionBlock = ExpressionBlock; // export class 
ExpressionBlock.prototype.c = function (o){
	return this.map(function(item) { return item.c(o); }).join(",");
};

ExpressionBlock.prototype.consume = function (node){
	return this.value().consume(node);
};

ExpressionBlock.prototype.addExpression = function (expr){
	// Need to take care of the splat here to.. hazzle
	if (expr.node() instanceof Assign) {
		this.push(expr.left());
		// make this into a tuple instead
		// possibly fix this as well?!?
		return new TupleAssign('=',new Tuple(this.nodes()),expr.right());
	} else {
		this.push(expr);
	};
	return this;
};



// STATEMENTS

function Return(v){
	this._traversed = false;
	this._value = ((v instanceof ArgList) && v.count() == 1) ? v.last() : v;
	return this;
};

subclass$(Return,Statement);
exports.Return = Return; // export class 
Return.prototype.value = function(v){ return this._value; }
Return.prototype.setValue = function(v){ this._value = v; return this; };

Return.prototype.visit = function (){
	if (this._value && this._value.traverse) { return this._value.traverse() };
};

Return.prototype.js = function (o){
	var v = this._value;
	
	if (v instanceof ArgList) {
		return ("return [" + v.c({expression: true}) + "]");
	} else if (v) {
		return ("return " + v.c({expression: true}));
	} else {
		return "return";
	};
};

Return.prototype.c = function (){
	if (!(this.value()) || this.value().isExpressable()) { return Return.__super__.c.apply(this,arguments) };
	return this.value().consume(this).c();
};

Return.prototype.consume = function (node){
	return this;
};

function ImplicitReturn(){ return Return.apply(this,arguments) };

subclass$(ImplicitReturn,Return);
exports.ImplicitReturn = ImplicitReturn; // export class 


function GreedyReturn(){ return ImplicitReturn.apply(this,arguments) };

subclass$(GreedyReturn,ImplicitReturn);
exports.GreedyReturn = GreedyReturn; // export class 


// cannot live inside an expression(!)
function Throw(){ return Statement.apply(this,arguments) };

subclass$(Throw,Statement);
exports.Throw = Throw; // export class 
Throw.prototype.js = function (o){
	return ("throw " + (this.value().c()));
};

Throw.prototype.consume = function (node){
	// ROADMAP should possibly consume to the value of throw and then throw?
	return this;
};


function LoopFlowStatement(lit,expr){
	this.setLiteral(lit);
	this.setExpression(expr);
};

subclass$(LoopFlowStatement,Statement);
exports.LoopFlowStatement = LoopFlowStatement; // export class 
LoopFlowStatement.prototype.literal = function(v){ return this._literal; }
LoopFlowStatement.prototype.setLiteral = function(v){ this._literal = v; return this; };
LoopFlowStatement.prototype.expression = function(v){ return this._expression; }
LoopFlowStatement.prototype.setExpression = function(v){ this._expression = v; return this; };

LoopFlowStatement.prototype.visit = function (){
	if (this.expression()) { return this.expression().traverse() };
};

LoopFlowStatement.prototype.consume = function (node){
	return this;
};

LoopFlowStatement.prototype.c = function (){
	if (!(this.expression())) { return LoopFlowStatement.__super__.c.apply(this,arguments) };
	// get up to the outer loop
	var _loop = STACK.up(Loop);
	
	// need to fix the grammar for this. Right now it
	// is like a fake call, but should only care about the first argument
	var expr = this.expression();
	
	if (_loop.catcher()) {
		expr = expr.consume(_loop.catcher());
		var copy = new this.constructor(this.literal());
		return new Block([expr,copy]).c();
	} else if (expr) {
		copy = new this.constructor(this.literal());
		return new Block([expr,copy]).c();
	} else {
		return LoopFlowStatement.__super__.c.apply(this,arguments);
	};
	// return "loopflow"
};


function BreakStatement(){ return LoopFlowStatement.apply(this,arguments) };

subclass$(BreakStatement,LoopFlowStatement);
exports.BreakStatement = BreakStatement; // export class 
BreakStatement.prototype.js = function (o){
	return "break";
};

function ContinueStatement(){ return LoopFlowStatement.apply(this,arguments) };

subclass$(ContinueStatement,LoopFlowStatement);
exports.ContinueStatement = ContinueStatement; // export class 
ContinueStatement.prototype.js = function (o){
	return "continue";
};

function DebuggerStatement(){ return Statement.apply(this,arguments) };

subclass$(DebuggerStatement,Statement);
exports.DebuggerStatement = DebuggerStatement; // export class 



// PARAMS

function Param(name,defaults,typ){
	// could have introduced bugs by moving back to identifier here
	this._traversed = false;
	this._name = name;
	this._defaults = defaults;
	this._typ = typ;
	this._variable = null;
};

subclass$(Param,Node);
exports.Param = Param; // export class 
Param.prototype.name = function(v){ return this._name; }
Param.prototype.setName = function(v){ this._name = v; return this; };
Param.prototype.index = function(v){ return this._index; }
Param.prototype.setIndex = function(v){ this._index = v; return this; };
Param.prototype.defaults = function(v){ return this._defaults; }
Param.prototype.setDefaults = function(v){ this._defaults = v; return this; };
Param.prototype.splat = function(v){ return this._splat; }
Param.prototype.setSplat = function(v){ this._splat = v; return this; };
Param.prototype.variable = function(v){ return this._variable; }
Param.prototype.setVariable = function(v){ this._variable = v; return this; };

Param.prototype.varname = function (){
	return this._variable ? this._variable.c() : this.name();
};

Param.prototype.js = function (o){
	if (this._variable) { return this._variable.c() };
	
	if (this.defaults()) {
		// should not include any source-mapping here?
		return ("if(" + (this.name().c()) + " == null) " + (this.name().c()) + " = " + (this.defaults().c()));
	};
	// see if this is the initial declarator?
};

Param.prototype.visit = function (){
	var variable_, v_;
	if (this._defaults) { this._defaults.traverse() };
	(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.name(),this)),v_));
	
	if (this._name instanceof Identifier) {
		// change type here?
		if (this._name._value) { this._name._value._type = "PARAMVAR" };
		this._name.references(this._variable);
		this._variable.addReference(this._name);
		// console.log @name.c, "got here!! {@name:constructor}"
		// @name.@token.@variable = @variable if @name.@token
	};
	
	return this;
};

Param.prototype.assignment = function (){
	return OP('=',this.variable().accessor(),this.defaults());
};

Param.prototype.isExpressable = function (){
	return !(this.defaults()) || this.defaults().isExpressable();
};

Param.prototype.dump = function (){
	return {loc: this.loc()};
};

Param.prototype.loc = function (){
	return this._name && this._name.region();
};

Param.prototype.toJSON = function (){
	return {
		type: this.typeName(),
		name: this.name(),
		defaults: this.defaults()
	};
};


function SplatParam(){ return Param.apply(this,arguments) };

subclass$(SplatParam,Param);
exports.SplatParam = SplatParam; // export class 
SplatParam.prototype.loc = function (){
	// hacky.. cannot know for sure that this is right?
	var r = this.name().region();
	return [r[0] - 1,r[1]];
};

function BlockParam(){ return Param.apply(this,arguments) };

subclass$(BlockParam,Param);
exports.BlockParam = BlockParam; // export class 
BlockParam.prototype.c = function (){
	return "blockparam";
};

BlockParam.prototype.loc = function (){
	// hacky.. cannot know for sure that this is right?
	var r = this.name().region();
	return [r[0] - 1,r[1]];
};


function OptionalParam(){ return Param.apply(this,arguments) };

subclass$(OptionalParam,Param);
exports.OptionalParam = OptionalParam; // export class 


function NamedParam(){ return Param.apply(this,arguments) };

subclass$(NamedParam,Param);
exports.NamedParam = NamedParam; // export class 


function RequiredParam(){ return Param.apply(this,arguments) };

subclass$(RequiredParam,Param);
exports.RequiredParam = RequiredParam; // export class 


function NamedParams(){ return ListNode.apply(this,arguments) };

subclass$(NamedParams,ListNode);
exports.NamedParams = NamedParams; // export class 
NamedParams.prototype.index = function(v){ return this._index; }
NamedParams.prototype.setIndex = function(v){ this._index = v; return this; };
NamedParams.prototype.variable = function(v){ return this._variable; }
NamedParams.prototype.setVariable = function(v){ this._variable = v; return this; };

NamedParams.prototype.load = function (list){
	var load = function(k) { return new NamedParam(k.key(),k.value()); };
	return (list instanceof Obj) ? list.value().map(load) : list;
};

NamedParams.prototype.visit = function (){
	var s = this.scope__();
	this._variable || (this._variable = s.temporary(this,{pool: 'keypars'}));
	this._variable.predeclared();
	
	// this is a listnode, which will automatically traverse
	// and visit all children
	NamedParams.__super__.visit.apply(this,arguments);
	// register the inner variables as well(!)
	return this;
};


NamedParams.prototype.varname = function (){
	return this.variable().c();
};

NamedParams.prototype.name = function (){
	return this.varname();
};

NamedParams.prototype.js = function (o){
	return "namedpar";
};

NamedParams.prototype.toJSON = function (){
	return {
		type: this.typeName(),
		nodes: this.filter(function(v) { return v instanceof NamedParam; })
	};
};


function IndexedParam(){ return Param.apply(this,arguments) };

subclass$(IndexedParam,Param);
exports.IndexedParam = IndexedParam; // export class 
IndexedParam.prototype.parent = function(v){ return this._parent; }
IndexedParam.prototype.setParent = function(v){ this._parent = v; return this; };
IndexedParam.prototype.subindex = function(v){ return this._subindex; }
IndexedParam.prototype.setSubindex = function(v){ this._subindex = v; return this; };

IndexedParam.prototype.visit = function (){
	// BUG The defaults should probably be looked up like vars
	var variable_, v_;
	(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.name(),this)),v_));
	this.variable().proxy(this.parent().variable(),this.subindex());
	return this;
};


function ArrayParams(){ return ListNode.apply(this,arguments) };

subclass$(ArrayParams,ListNode);
exports.ArrayParams = ArrayParams; // export class 
ArrayParams.prototype.index = function(v){ return this._index; }
ArrayParams.prototype.setIndex = function(v){ this._index = v; return this; };
ArrayParams.prototype.variable = function(v){ return this._variable; }
ArrayParams.prototype.setVariable = function(v){ this._variable = v; return this; };

ArrayParams.prototype.visit = function (){
	var s = this.scope__();
	this._variable || (this._variable = s.temporary(this,{pool: 'keypars'}));
	this._variable.predeclared();
	
	// now when we loop through these inner params - we create the pars
	// with the correct name, but bind them to the parent
	return ArrayParams.__super__.visit.apply(this,arguments);
};

ArrayParams.prototype.name = function (){
	return this.variable().c();
};

ArrayParams.prototype.load = function (list){
	var self = this;
	if (!((list instanceof Arr))) { return null };
	// try the basic first
	if (!list.splat()) {
		return list.value().map(function(v,i) {
			// must make sure the params are supported here
			// should really not parse any array at all(!)
			var name = v;
			if (v instanceof VarOrAccess) {
				// FIX?
				name = v.value().value();
				// this is accepted
			};
			return self.parse(name,v,i);
		});
	};
};

ArrayParams.prototype.parse = function (name,child,i){
	var param = new IndexedParam(name,null);
	
	param.setParent(this);
	param.setSubindex(i);
	return param;
};

ArrayParams.prototype.head = function (ast){
	return this;
};

function ParamList(){ return ListNode.apply(this,arguments) };

subclass$(ParamList,ListNode);
exports.ParamList = ParamList; // export class 
ParamList.prototype.splat = function(v){ return this._splat; }
ParamList.prototype.setSplat = function(v){ this._splat = v; return this; };
ParamList.prototype.block = function(v){ return this._block; }
ParamList.prototype.setBlock = function(v){ this._block = v; return this; };

ParamList.prototype.at = function (index,force,name){
	if(force === undefined) force = false;
	if(name === undefined) name = null;
	if (force) {
		while (this.count() <= index){
			this.add(new Param(this.count() == index && name || ("_" + this.count())));
		};
		// need to visit at the same time, no?
	};
	return this.list()[index];
};

ParamList.prototype.metadata = function (){
	return this.filter(function(par) { return !(par instanceof Meta); });
};

ParamList.prototype.toJSON = function (){
	return this.metadata();
};

ParamList.prototype.visit = function (){
	this._splat = this.filter(function(par) { return par instanceof SplatParam; })[0];
	var blk = this.filter(function(par) { return par instanceof BlockParam; });
	
	if (blk.length > 1) {
		blk[1].warn("a method can only have one &block parameter");
	} else if (blk[0] && blk[0] != this.last()) {
		blk[0].warn("&block must be the last parameter of a method");
		// warn "&block must be the last parameter of a method", blk[0]
	};
	
	// add more warnings later(!)
	// should probably throw error as well to stop compilation
	
	// need to register the required-pars as variables
	return ParamList.__super__.visit.apply(this,arguments);
};

ParamList.prototype.js = function (o){
	if (this.count() == 0) { return EMPTY };
	if (o.parent() instanceof Block) { return this.head(o) };
	
	// items = map(|arg| arg.name.c ).compact
	// return null unless items[0]
	
	if (o.parent() instanceof Code) {
		// remove the splat, for sure.. need to handle the other items as well
		// this is messy with references to argvars etc etc. Fix
		var pars = this.nodes();
		// pars = filter(|arg| arg != @splat && !(arg isa BlockParam)) if @splat
		if (this._splat) { pars = this.filter(function(arg) { return (arg instanceof RequiredParam) || (arg instanceof OptionalParam); }) };
		return compact__(pars.map(function(arg) { return c__(arg.varname()); })).join(",");
	} else {
		throw "not implemented paramlist js";
		return "ta" + compact__(this.map(function(arg) { return arg.c(); })).join(",");
	};
};

ParamList.prototype.head = function (o){
	var reg = [];
	var opt = [];
	var blk = null;
	var splat = null;
	var named = null;
	var arys = [];
	var signature = [];
	var idx = 0;
	
	this.nodes().forEach(function(par,i) {
		par.setIndex(idx);
		if (par instanceof NamedParams) {
			signature.push('named');
			named = par;
		} else if (par instanceof OptionalParam) {
			signature.push('opt');
			opt.push(par);
		} else if (par instanceof BlockParam) {
			signature.push('blk');
			blk = par;
		} else if (par instanceof SplatParam) {
			signature.push('splat');
			splat = par;
			idx -= 1; // this should really be removed from the list, no?
		} else if (par instanceof ArrayParams) {
			arys.push(par);
			signature.push('ary');
		} else {
			signature.push('reg');
			reg.push(par);
		};
		return idx++;
	});
	
	if (named) {
		var namedvar = named.variable();
	};
	
	// var opt = nodes.filter(|n| n isa OptionalParam)
	// var blk = nodes.filter(|n| n isa BlockParam)[0]
	// var splat = nodes.filter(|n| n isa SplatParam)[0]
	
	// simple situation where we simply switch
	// can probably optimize by not looking at arguments at all
	var ast = [];
	var isFunc = function(js) { return ("typeof " + js + " == 'function'"); };
	
	// This is broken when dealing with iframes anc XSS scripting
	// but for now it is the best test for actual arguments
	// can also do constructor.name == 'Object'
	var isObj = function(js) { return ("" + js + ".constructor === Object"); };
	var isntObj = function(js) { return ("" + js + ".constructor !== Object"); };
	// should handle some common cases in a cleaner (less verbose) manner
	// does this work with default params after optional ones? Is that even worth anything?
	// this only works in one direction now, unlike TupleAssign
	
	// we dont really check the length etc now -- so it is buggy for lots of arguments
	
	// if we have optional params in the regular order etc we can go the easy route
	// slightly hacky now. Should refactor all of these to use the signature?
	if (!(named) && !(splat) && !(blk) && opt.length > 0 && signature.join(" ").match(/opt$/)) {
		for (var i = 0, len_ = opt.length, par; i < len_; i++) {
			par = opt[i];
			ast.push(("if(" + (par.name().c()) + " === undefined) " + (par.name().c()) + " = " + (par.defaults().c())));
		};
	} else if (named && !(splat) && !(blk) && opt.length == 0) { // and no block?!
		// different shorthands
		// if named
		ast.push(("if(!" + (namedvar.c()) + "||" + isntObj(namedvar.c()) + ") " + (namedvar.c()) + " = \{\}"));
	} else if (blk && opt.length == 1 && !(splat) && !(named)) {
		var op = opt[0];
		var opn = op.name().c();
		var bn = blk.name().c();
		ast.push(("if(" + bn + "==undefined && " + isFunc(opn) + ") " + bn + " = " + opn + "," + opn + " = " + (op.defaults().c())));
		ast.push(("if(" + opn + "==undefined) " + opn + " = " + (op.defaults().c())));
	} else if (blk && named && opt.length == 0 && !(splat)) {
		bn = blk.name().c();
		ast.push(("if(" + bn + "==undefined && " + isFunc(namedvar.c()) + ") " + bn + " = " + (namedvar.c()) + "," + (namedvar.c()) + " = \{\}"));
		ast.push(("else if(!" + (namedvar.c()) + "||" + isntObj(namedvar.c()) + ") " + (namedvar.c()) + " = \{\}"));
	} else if (opt.length > 0 || splat) { // && blk  # && !splat
		
		var argvar = this.scope__().temporary(this,{pool: 'arguments'}).predeclared().c();
		var len = this.scope__().temporary(this,{pool: 'counter'}).predeclared().c();
		
		var last = ("" + argvar + "[" + len + "-1]");
		var pop = ("" + argvar + "[--" + len + "]");
		ast.push(("var " + argvar + " = arguments, " + len + " = " + argvar + ".length"));
		
		if (blk) {
			bn = blk.name().c();
			if (splat) {
				ast.push(("var " + bn + " = " + isFunc(last) + " ? " + pop + " : null"));
			} else if (reg.length > 0) {
				// ast.push "// several regs really?"
				ast.push(("var " + bn + " = " + len + " > " + (reg.length) + " && " + isFunc(last) + " ? " + pop + " : null"));
			} else {
				ast.push(("var " + bn + " = " + isFunc(last) + " ? " + pop + " : null"));
			};
		};
		
		// if we have named params - look for them before splat
		// should probably loop through pars in the same order they were added
		// should it be prioritized above optional objects??
		if (named) {
			// should not include it when there is a splat?
			ast.push(("var " + (namedvar.c()) + " = " + last + "&&" + isObj(last) + " ? " + pop + " : \{\}"));
		};
		
		for (var i1 = 0, len__ = opt.length, par1; i1 < len__; i1++) {
			par1 = opt[i1];
			ast.push(("if(" + len + " < " + (par1.index() + 1) + ") " + (par1.name().c()) + " = " + (par1.defaults().c())));
		};
		
		// add the splat
		if (splat) {
			var sn = splat.name().c();
			var si = splat.index();
			
			if (si == 0) {
				ast.push(("var " + sn + " = new Array(" + len + ">" + si + " ? " + len + " : 0)"));
				ast.push(("while(" + len + ">" + si + ") " + sn + "[" + len + "-1] = " + pop));
			} else {
				ast.push(("var " + sn + " = new Array(" + len + ">" + si + " ? " + len + "-" + si + " : 0)"));
				ast.push(("while(" + len + ">" + si + ") " + sn + "[--" + len + " - " + si + "] = " + argvar + "[" + len + "]"));
			};
		};
		
		// if named
		// 	for k,i in named.nodes
		// 		# OP('.',namedvar) <- this is the right way, with invalid names etc
		// 		var op = OP('.',namedvar,k.key).c
		// 		ast.push "var {k.key.c} = {op} !== undefined ? {op} : {k.value.c}"
		
		// if named
		
		// return ast.join(";\n") + ";"
		// return "if({opt[0].name.c} instanceof Function) {blk.c} = {opt[0].c};"
	} else if (opt.length > 0) {
		for (var i2 = 0, length_ = opt.length, par2; i2 < length_; i2++) {
			par2 = opt[i2];
			ast.push(("if(" + (par2.name().c()) + " === undefined) " + (par2.name().c()) + " = " + (par2.defaults().c())));
		};
	};
	
	// now set stuff if named params(!)
	
	if (named) {
		for (var i3 = 0, ary = iter$(named.nodes()), $1 = ary.length, k; i3 < $1; i3++) {
			// console.log "named var {k.c}"
			k = ary[i3];
			op = OP('.',namedvar,k.c()).c();
			ast.push(("var " + (k.c()) + " = " + op + " !== undefined ? " + op + " : " + (k.defaults().c())));
		};
	};
	
	if (arys.length) {
		for (var i4 = 0, $1 = arys.length; i4 < $1; i4++) {
			// create tuples
			arys[i4].head(o,ast,this);
			// ast.push v.c
		};
	};
	
	
	
	// if opt:length == 0
	return (ast.length > 0) ? ((ast.join(";\n") + ";")) : EMPTY;
};


// Legacy. Should move away from this?
function VariableDeclaration(){ return ListNode.apply(this,arguments) };

subclass$(VariableDeclaration,ListNode);
exports.VariableDeclaration = VariableDeclaration; // export class 
VariableDeclaration.prototype.kind = function(v){ return this._kind; }
VariableDeclaration.prototype.setKind = function(v){ this._kind = v; return this; };

// we want to register these variables in
VariableDeclaration.prototype.add = function (name,init,pos){
	if(pos === undefined) pos = -1;
	var vardec = new VariableDeclarator(name,init);
	if (name instanceof Variable) { (vardec.setVariable(name),name) };
	(pos == 0) ? this.unshift(vardec) : this.push(vardec);
	return vardec;
};

VariableDeclaration.prototype.load = function (list){
	// temporary solution!!!
	return list.map(function(par) { return new VariableDeclarator(par.name(),par.defaults(),par.splat()); });
};

VariableDeclaration.prototype.isExpressable = function (){
	return this.nodes().every(function(item) { return item.isExpressable(); });
};

VariableDeclaration.prototype.js = function (o){
	if (this.count() == 0) { return EMPTY };
	
	if (this.count() == 1 && !(this.isExpressable())) {
		this.first().variable().autodeclare();
		var node = this.first().assignment();
		return node.c();
	};
	
	// FIX PERFORMANCE
	var out = compact__(cary__(this.nodes())).join(", ");
	return out ? (("var " + out)) : "";
};

function VariableDeclarator(){ return Param.apply(this,arguments) };

subclass$(VariableDeclarator,Param);
exports.VariableDeclarator = VariableDeclarator; // export class 
VariableDeclarator.prototype.visit = function (){
	// even if we should traverse the defaults as if this variable does not exist
	// we need to preregister it and then activate it later
	var variable_, v_;
	(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.name(),null)),v_));
	if (this.defaults()) { this.defaults().traverse() };
	// WARN what if it is already declared?
	this.variable().setDeclarator(this);
	this.variable().addReference(this.name());
	return this;
};

// needs to be linked up to the actual scoped variables, no?
VariableDeclarator.prototype.js = function (o){
	if (this.variable()._proxy) { return null };
	
	var defs = this.defaults();
	// FIXME need to deal with var-defines within other statements etc
	// FIXME need better syntax for this
	if (defs != null && defs != undefined) {
		// console.log "defaults is {defaults}"
		if (defs instanceof Node) { defs = defs.c({expression: true}) };
		
		return ("" + (this.variable().c()) + " = " + defs);
	} else {
		return ("" + (this.variable().c()));
	};
};

VariableDeclarator.prototype.accessor = function (){
	return this;
};


// TODO clean up and refactor all the different representations of vars
// VarName, VarReference, LocalVarAccess?
function VarName(a,b){
	VarName.__super__.constructor.apply(this,arguments);
	this._splat = b;
};

subclass$(VarName,ValueNode);
exports.VarName = VarName; // export class 
VarName.prototype.variable = function(v){ return this._variable; }
VarName.prototype.setVariable = function(v){ this._variable = v; return this; };
VarName.prototype.splat = function(v){ return this._splat; }
VarName.prototype.setSplat = function(v){ this._splat = v; return this; };

VarName.prototype.visit = function (){
	// should we not lookup instead?
	// FIXME p "register value {value.c}"
	var variable_, v_;
	(variable_ = this.variable()) || ((this.setVariable(v_ = this.scope__().register(this.value().c(),null)),v_));
	this.variable().setDeclarator(this);
	this.variable().addReference(this.value());
	return this;
};

VarName.prototype.js = function (o){
	return this.variable().c();
};

VarName.prototype.c = function (){
	return this.variable().c();
};


function VarList(t,l,r){
	this._traversed = false;
	this._type = this.type();
	this._left = l;
	this._right = r;
};

subclass$(VarList,Node);
exports.VarList = VarList; // export class 
VarList.prototype.type = function(v){ return this._type; }
VarList.prototype.setType = function(v){ this._type = v; return this; }; // let / var / const
VarList.prototype.left = function(v){ return this._left; }
VarList.prototype.setLeft = function(v){ this._left = v; return this; };
VarList.prototype.right = function(v){ return this._right; }
VarList.prototype.setRight = function(v){ this._right = v; return this; };

// format :type, :left, :right

// should throw error if there are more values on right than left

VarList.prototype.visit = function (){
	
	// we need to carefully traverse children in the right order
	// since we should be able to reference
	var r;
	for (var i = 0, ary = iter$(this.left()), len = ary.length; i < len; i++) {
		ary[i].traverse(); // this should really be a var-declaration
		if (r = this.right()[i]) { r.traverse() };
	};
	return this;
};

VarList.prototype.js = function (o){
	// for the regular items
	var pairs = [];
	var ll = this.left().length;
	var rl = this.right().length;
	var v = null;
	
	// splatting here we come
	if (ll > 1 && rl == 1) {
		this.p("multiassign!");
		var r = this.right()[0];
		r.cache();
		for (var i = 0, ary = iter$(this.left()), len = ary.length, l; i < len; i++) {
			l = ary[i];
			if (l.splat()) {
				throw "not supported?";
				this.p("splat"); // FIX reimplement slice?
				if (i == ll - 1) {
					v = this.util().slice(r,i);
					this.p("last");
				} else {
					v = this.util().slice(r,i,-(ll - i) + 1);
				};
			} else {
				v = OP('.',r,num__(i));
			};
			
			pairs.push(OP('=',l,v));
		};
	} else {
		for (var i1 = 0, items = iter$(this.left()), len_ = items.length, l1; i1 < len_; i1++) {
			l1 = items[i1];
			r = this.right()[i1];
			pairs.push(r ? OP('=',l1.variable().accessor(),r) : l1);
		};
	};
	
	return ("var " + (pairs.c()));
};


// CODE

function Code(){ return Node.apply(this,arguments) };

subclass$(Code,Node);
exports.Code = Code; // export class 
Code.prototype.head = function(v){ return this._head; }
Code.prototype.setHead = function(v){ this._head = v; return this; };
Code.prototype.body = function(v){ return this._body; }
Code.prototype.setBody = function(v){ this._body = v; return this; };
Code.prototype.scope = function(v){ return this._scope; }
Code.prototype.setScope = function(v){ this._scope = v; return this; };
Code.prototype.params = function(v){ return this._params; }
Code.prototype.setParams = function(v){ this._params = v; return this; };

Code.prototype.scopetype = function (){
	return Scope;
};

Code.prototype.visit = function (){
	if (this._scope) { this._scope.visit() };
	// @scope.parent = STACK.scope(1) if @scope
	return this;
};


// Rename to Program?
function Root(body,opts){
	this._traversed = false;
	this._body = blk__(body);
	this._scope = new RootScope(this,null);
	this._options = {};
};

subclass$(Root,Code);
exports.Root = Root; // export class 
Root.prototype.loc = function (){
	return this._body.loc();
};

Root.prototype.visit = function (){
	ROOT = STACK.ROOT = this._scope;
	this.scope().visit();
	return this.body().traverse();
};

Root.prototype.compile = function (o){
	STACK.reset(); // -- nested compilation does not work now
	OPTS = STACK._options = this._options = o || {};
	
	this.traverse();
	
	var out = this.c();
	var result = {
		js: out,
		ast: this,
		warnings: this.scope().warnings(),
		options: o,
		toString: function() { return this.js; }
	};
	if (o.sourceMapInline || o.sourceMap) {
		result.sourcemap = new SourceMap(result).generate();
	};
	
	return result;
};

Root.prototype.js = function (o){
	var out;
	if (!this._options.wrap) {
		out = this.scope().c();
	} else {
		this.body().consume(new ImplicitReturn());
		out = this.scope().c({indent: true});
		out = out.replace(/^\n?/,'\n');
		out = out.replace(/\n?$/,'\n\n');
		out = '(function(){' + out + '})();';
	};
	
	// find and replace shebangs
	var shebangs = [];
	out = out.replace(/^[ \t]*\/\/(\!.+)$/mg,function(m,shebang) {
		shebang = shebang.replace(/\bimba\b/g,'node');
		shebangs.push(("#" + shebang + "\n"));
		return "";
	});
	
	out = shebangs.join('') + out;
	
	return out;
};


Root.prototype.analyze = function (o){
	// loglevel: 0, entities: no, scopes: yes
	if(o === undefined) o = {};
	STACK.setLoglevel(o.loglevel || 0);
	STACK._analyzing = true;
	ROOT = STACK.ROOT = this._scope;
	OPTS = STACK._options = {
		target: o.target,
		loglevel: o.loglevel || 0,
		analysis: {
			entities: (o.entities || false),
			scopes: ((o.scopes == null) ? (o.scopes = true) : o.scopes)
		}
	};
	
	this.traverse();
	STACK._analyzing = false;
	
	return this.scope().dump();
};

Root.prototype.inspect = function (){
	return true;
};

function ClassDeclaration(name,superclass,body){
	// what about the namespace?
	this._traversed = false;
	this._name = name;
	this._superclass = superclass;
	this._scope = new ClassScope(this);
	this._body = blk__(body);
	this;
};

subclass$(ClassDeclaration,Code);
exports.ClassDeclaration = ClassDeclaration; // export class 
ClassDeclaration.prototype.name = function(v){ return this._name; }
ClassDeclaration.prototype.setName = function(v){ this._name = v; return this; };
ClassDeclaration.prototype.superclass = function(v){ return this._superclass; }
ClassDeclaration.prototype.setSuperclass = function(v){ this._superclass = v; return this; };
ClassDeclaration.prototype.initor = function(v){ return this._initor; }
ClassDeclaration.prototype.setInitor = function(v){ this._initor = v; return this; };

ClassDeclaration.prototype.consume = function (node){
	if (node instanceof Return) {
		this.option('return',true);
		return this;
	};
	return ClassDeclaration.__super__.consume.apply(this,arguments);
};

ClassDeclaration.prototype.namepath = function (){
	return this._namepath || (this._namepath = ("" + (this.name().c())));
};

ClassDeclaration.prototype.metadata = function (){
	var superclass_;
	return {
		type: 'class',
		namepath: this.namepath(),
		inherits: (superclass_ = this.superclass()) && superclass_.namepath  &&  superclass_.namepath(),
		path: this.name().c().toString(),
		desc: this._desc,
		loc: this.loc()
	};
};

ClassDeclaration.prototype.toJSON = function (){
	return this.metadata();
};

ClassDeclaration.prototype.visit = function (){
	// replace with some advanced lookup?
	ROOT.entities().add(this.namepath(),this);
	this.scope().visit();
	this.body().traverse();
	return this;
};

ClassDeclaration.prototype.js = function (o){
	this.scope().virtualize(); // is this always needed?
	this.scope().context().setValue(this.name());
	this.scope().context().setReference(this.name());
	// should probably also warn about stuff etc
	if (this.option('extension')) {
		return this.body().c();
	};
	
	var head = [];
	var o = this._options || {};
	var cname = (this.name() instanceof Access) ? this.name().right() : this.name();
	var namespaced = this.name() != cname;
	var initor = null;
	var sup = this.superclass();
	
	var bodyindex = -1;
	var spaces = this.body().filter(function(item) { return item instanceof Terminator; });
	var mark = mark__(this.option('keyword'));
	
	this.body().map(function(c,i) {
		if ((c instanceof MethodDeclaration) && c.type() == 'constructor') {
			return bodyindex = i;
		};
	});
	
	if (bodyindex >= 0) {
		initor = this.body().removeAt(bodyindex);
	};
	
	// var initor = body.pluck do |c| c isa MethodDeclaration && c.type == :constructor
	// compile the cname
	if (typeof cname != 'string') { cname = cname.c() };
	
	var cpath = (typeof this.name() == 'string') ? this.name() : this.name().c();
	
	this._cname = cname;
	this._cpath = cpath;
	
	if (!(initor)) {
		if (sup) {
			initor = ("" + mark + "function " + cname + "()\{ return " + (sup.c()) + ".apply(this,arguments) \};\n\n");
		} else {
			initor = ("" + mark + "function " + cname + "()") + '{ };\n\n';
		};
	} else {
		initor.setName(cname);
		initor = initor.c() + ';';
	};
	
	// if we are defining a class inside a namespace etc -- how should we set up the class?
	
	if (namespaced) {
		// should use Nodes to build this instead
		initor = ("" + cpath + " = " + initor); // OP('=',name,initor)
	};
	
	head.push(initor); // // @class {cname}\n
	
	if (bodyindex >= 0) {
		// add the space after initor?
		if (this.body().index(bodyindex) instanceof Terminator) {
			head.push(this.body().removeAt(bodyindex));
		};
	} else {
		// head.push(Terminator.new('\n\n'))
		true;
	};
	
	if (sup) {
		// console.log "deal with superclass!"
		// head.push("// extending the superclass\nimba$class({name.c},{sup.c});\n\n")
		head.push(new Util.Subclass([this.name(),sup]));
	};
	
	// only if it is not namespaced
	if (o.global && !(namespaced)) { // option(:global)
		var globalName = (STACK.platform() == 'web') ? "window" : "global";
		head.push(("" + globalName + "." + cname + " = " + cpath + "; // global class \n"))
	};
	
	if (o.export && !(namespaced)) {
		head.push(("exports." + (o.default ? 'default' : cname) + " = " + cpath + "; // export class \n"))
	};
	
	// FIXME
	// if namespaced and (o:local or o:export)
	// 	console.log "namespaced classes are implicitly local/global depending on the namespace"
	
	if (this.option('return')) {
		this.body().push(("return " + cpath + ";"));
	};
	
	for (var i = 0, ary = iter$(head.reverse()), len = ary.length; i < len; i++) {
		this.body().unshift(ary[i]);
	};
	this.body()._indentation = null;
	var end = this.body().index(this.body().count() - 1);
	if ((end instanceof Terminator) && end.c().length == 1) { this.body().pop() };
	
	var out = this.body().c();
	
	return out;
};


function TagDeclaration(name,superclass,body){
	this._traversed = false;
	this._name = name;
	this._superclass = superclass;
	this._scope = new TagScope(this);
	this._body = blk__(body || []);
};

subclass$(TagDeclaration,Code);
exports.TagDeclaration = TagDeclaration; // export class 
TagDeclaration.prototype.name = function(v){ return this._name; }
TagDeclaration.prototype.setName = function(v){ this._name = v; return this; };
TagDeclaration.prototype.superclass = function(v){ return this._superclass; }
TagDeclaration.prototype.setSuperclass = function(v){ this._superclass = v; return this; };
TagDeclaration.prototype.initor = function(v){ return this._initor; }
TagDeclaration.prototype.setInitor = function(v){ this._initor = v; return this; };

TagDeclaration.prototype.namepath = function (){
	return ("<" + this.name() + ">");
};

TagDeclaration.prototype.toJSON = function (){
	return {
		type: 'tag',
		namepath: this.namepath(),
		inherits: this.superclass() ? (("<" + (this.superclass().name()) + ">")) : null,
		loc: this.loc(),
		desc: this._desc
	};
};

TagDeclaration.prototype.consume = function (node){
	if (node instanceof Return) {
		this.option('return',true);
		return this;
	};
	return TagDeclaration.__super__.consume.apply(this,arguments);
};

TagDeclaration.prototype.visit = function (){
	if (String(this.name()).match(/^[A-Z]/)) {
		this.set({isClass: true});
	};
	
	ROOT.entities().register(this); // what if this is not local?
	
	// replace with some advanced lookup?
	this.scope().visit();
	return this.body().traverse();
};

TagDeclaration.prototype.id = function (){
	return this.name().id();
};

TagDeclaration.prototype.tagspace = function (){
	var ctx = this.scope().closure().tagContextPath();
	return this.name().ns() ? (("" + ctx + ".ns(" + helpers.singlequote(this.name().ns()) + ")")) : ctx;
};

TagDeclaration.prototype.js = function (o){
	this.scope().context().setValue(this._ctx = this.scope().declare('tag',null,{system: true}));
	
	var ns = this.name().ns();
	var mark = mark__(this.option('keyword'));
	var params = [];
	
	params.push(helpers.singlequote(this.name().name()));
	var cbody = this.body().c();
	
	if (this.superclass()) {
		// WARN what if the superclass has a namespace?
		// what if it is a regular class?
		var supname = this.superclass().name();
		if (!supname[0].match(/[A-Z]/)) {
			supname = helpers.singlequote(supname);
		};
		params.push(supname);
	};
	
	if (this.body().count()) {
		params.push(("function(" + (this._ctx.c()) + ")\{" + cbody + "\}"));
	};
	
	var meth = this.option('extension') ? 'extendTag' : 'defineTag';
	
	var js = ("" + mark + this.tagspace() + "." + meth + "(" + params.join(', ') + ")");
	
	
	if (this.option('isClass')) {
		var cname = this.name().name();
		// declare variable
		js = ("var " + cname + " = " + js);
		// only if it is not namespaced
		// if o:global and !namespaced # option(:global)
		//	js.push("global.{cname} = {cpath}; // global class \n")
		if (this.option('export')) {
			js = ("" + js + "\nexports." + (this.option('default') ? 'default' : cname) + " = " + cname + ";");
		};
		
		if (this.option('return')) {
			js += ("\nreturn " + cname + ";");
		};
	} else {
		if (this.option('return')) {
			js = "return " + js;
		};
	};
	
	
	return js;
	
	// return out
};

function Func(params,body,name,target,o){
	this._options = o;
	var typ = this.scopetype();
	this._traversed = false;
	this._body = blk__(body);
	this._scope || (this._scope = (o && o.scope) || new typ(this));
	this._scope.setParams(this._params = new ParamList(params));
	this._name = name || '';
	this._target = target;
	this._type = 'function';
	this._variable = null;
	this;
};

subclass$(Func,Code);
exports.Func = Func; // export class 
Func.prototype.name = function(v){ return this._name; }
Func.prototype.setName = function(v){ this._name = v; return this; };
Func.prototype.params = function(v){ return this._params; }
Func.prototype.setParams = function(v){ this._params = v; return this; };
Func.prototype.target = function(v){ return this._target; }
Func.prototype.setTarget = function(v){ this._target = v; return this; };
Func.prototype.options = function(v){ return this._options; }
Func.prototype.setOptions = function(v){ this._options = v; return this; };
Func.prototype.type = function(v){ return this._type; }
Func.prototype.setType = function(v){ this._type = v; return this; };
Func.prototype.context = function(v){ return this._context; }
Func.prototype.setContext = function(v){ this._context = v; return this; };

Func.prototype.scopetype = function (){
	return FunctionScope;
};

Func.prototype.nonlocals = function (){
	return this._scope._nonlocals;
};

Func.prototype.visit = function (){
	this.scope().visit();
	this._context = this.scope().parent();
	this._params.traverse();
	return this._body.traverse(); // so soon?
};


Func.prototype.js = function (o){
	if (!this.option('noreturn')) { this.body().consume(new ImplicitReturn()) };
	var ind = this.body()._indentation;
	// var s = ind and ind.@open
	if (ind && ind.isGenerated()) { this.body()._indentation = null };
	var code = this.scope().c({indent: (!(ind) || !ind.isGenerated()),braces: true});
	
	// args = params.map do |par| par.name
	// head = params.map do |par| par.c
	// code = [head,body.c(expression: no)].flatten__.compact.join("\n").wrap
	// FIXME creating the function-name this way is prone to create naming-collisions
	// will need to wrap the value in a FunctionName which takes care of looking up scope
	// and possibly dealing with it
	var name = (typeof this._name == 'string') ? this._name : this._name.c();
	name = name ? (' ' + name.replace(/\./g,'_')) : '';
	var out = ("function" + name + "(" + (this.params().c()) + ") ") + code;
	if (this.option('eval')) { out = ("(" + out + ")()") };
	return out;
};

Func.prototype.shouldParenthesize = function (par){
	if(par === undefined) par = this.up();
	return (par instanceof Call) && par.callee() == this;
	// if up as a call? Only if we are
};


function Lambda(){ return Func.apply(this,arguments) };

subclass$(Lambda,Func);
exports.Lambda = Lambda; // export class 
Lambda.prototype.scopetype = function (){
	var k = this.option('keyword');
	return (k && k._value == 'ƒ') ? ((MethodScope)) : ((LambdaScope));
};


function TagFragmentFunc(){ return Func.apply(this,arguments) };

subclass$(TagFragmentFunc,Func);
exports.TagFragmentFunc = TagFragmentFunc; // export class 
TagFragmentFunc.prototype.scopetype = function (){
	// caching still needs to be local no matter what?
	return this.option('closed') ? ((MethodScope)) : ((LambdaScope));
};

function MethodDeclaration(){ return Func.apply(this,arguments) };

subclass$(MethodDeclaration,Func);
exports.MethodDeclaration = MethodDeclaration; // export class 
MethodDeclaration.prototype.variable = function(v){ return this._variable; }
MethodDeclaration.prototype.setVariable = function(v){ this._variable = v; return this; };

MethodDeclaration.prototype.scopetype = function (){
	return MethodScope;
};

MethodDeclaration.prototype.consume = function (node){
	if (node instanceof Return) {
		this.option('return',true);
		return this;
	};
	return MethodDeclaration.__super__.consume.apply(this,arguments);
};

MethodDeclaration.prototype.metadata = function (){
	return {
		type: "method",
		name: "" + this.name(),
		namepath: this.namepath(),
		params: this._params.metadata(),
		desc: this._desc,
		scopenr: this.scope()._nr,
		loc: this.loc()
	};
};

MethodDeclaration.prototype.loc = function (){
	var d;
	if (d = this.option('def')) {
		return [d._loc,this.body().loc()[1]];
	} else {
		return [0,0];
	};
};


MethodDeclaration.prototype.toJSON = function (){
	return this.metadata();
};

MethodDeclaration.prototype.namepath = function (){
	if (this._namepath) { return this._namepath };
	
	var name = String(this.name());
	var sep = (this.option('static') ? '.' : '#');
	if (this.target()) {
		return this._namepath = this._target.namepath() + sep + name;
	} else {
		return this._namepath = '&' + name;
	};
};

MethodDeclaration.prototype.visit = function (){
	// @desc = stack.stash.pluck(Comment)
	// @desc = stack.stash.pluck(Comment)
	// prebreak # make sure this has a break?
	var variable;
	this.scope().visit();
	
	if (String(this.name()).match(/\=$/)) {
		this.set({chainable: true});
	};
	
	if (this.option('greedy')) {
		this.warn("deprecated");
		// set(greedy: true)
		var tree = new TagTree();
		this._body = this.body().consume(tree);
		// body.nodes = [Arr.new(body.nodes)]
	};
	
	this._context = this.scope().parent().closure();
	this._params.traverse();
	
	if (String(this.name()) == 'initialize') {
		if ((this.context() instanceof ClassScope) && !(this.context() instanceof TagScope)) {
			this.setType('constructor');
		};
	};
	
	if (this.target() instanceof Self) {
		this._target = this._context.context();
		this.set({static: true});
	};
	
	if (this.context() instanceof ClassScope) {
		this.context().annotate(this);
		this._target || (this._target = this.context().context());
		// register as class-method?
		// should register for this
		// console.log "context is classscope {@name}"
	};
	
	if (!this._target) {
		// should not be registered on the outermost closure?
		this._variable = this.context().register(this.name(),this,{type: 'meth'});
	};
	
	if (this.target() instanceof Identifier) {
		if (variable = this.scope().lookup(this.target().toString())) {
			this.setTarget(variable);
		};
	};
	
	ROOT.entities().add(this.namepath(),this);
	this._body.traverse(); // so soon?
	return this;
};

MethodDeclaration.prototype.supername = function (){
	return (this.type() == 'constructor') ? this.type() : this.name();
};


// FIXME export global etc are NOT valid for methods inside any other scope than
// the outermost scope (root)

MethodDeclaration.prototype.js = function (o){
	// FIXME Do this in the grammar - remnants of old implementation
	if (!(this.type() == 'constructor' || this.option('noreturn'))) {
		if (this.option('chainable')) {
			this.body().add(new ImplicitReturn(this.scope().context()));
		} else if (this.option('greedy')) {
			// haaack
			this.body().consume(new GreedyReturn());
		} else {
			this.body().consume(new ImplicitReturn());
		};
	};
	
	var code = this.scope().c({indent: true,braces: true});
	
	// same for Func -- should generalize
	var name = (typeof this._name == 'string') ? this._name : this._name.c();
	name = name.replace(/\./g,'_');
	
	// var name = self.name.c.replace(/\./g,'_') # WHAT?
	var foot = [];
	
	var left = "";
	var func = ("(" + (this.params().c()) + ")") + code; // .wrap
	var target = this.target();
	var decl = !this.option('global') && !this.option('export');
	
	if (target instanceof ScopeContext) {
		// the target is a scope context
		target = null;
	};
	
	var ctx = this.context();
	var out = "";
	var mark = mark__(this.option('def'));
	// if ctx
	
	var fname = sym__(this.name());
	// console.log "symbolize {self.name} -- {fname}"
	var fdecl = fname; // decl ? fname : ''
	
	if ((ctx instanceof ClassScope) && !(target)) {
		if (this.type() == 'constructor') {
			out = ("" + mark + "function " + fname + func);
		} else if (this.option('static')) {
			out = ("" + mark + (ctx.context().c()) + "." + fname + " = function " + func);
		} else {
			out = ("" + mark + (ctx.context().c()) + ".prototype." + fname + " = function " + func);
		};
	} else if ((ctx instanceof RootScope) && !(target)) {
		// register method as a root-function, but with auto-call? hmm
		// should probably set using variable directly instead, no?
		out = ("" + mark + "function " + fdecl + func);
	} else if (target && this.option('static')) {
		out = ("" + mark + (target.c()) + "." + fname + " = function " + func);
	} else if (target) {
		out = ("" + mark + (target.c()) + ".prototype." + fname + " = function " + func);
	} else {
		out = ("" + mark + "function " + fdecl + func);
	};
	
	if (this.option('global')) {
		out = ("" + fname + " = " + out);
	};
	
	if (this.option('export')) {
		out = ("" + out + "; exports." + (this.option('default') ? 'default' : fname) + " = " + fname + ";");
		if (this.option('return')) { out = ("" + out + "; return " + fname + ";") };
	} else if (this.option('return')) {
		out = ("return " + out);
	};
	
	return out;
};


function TagFragmentDeclaration(){ return MethodDeclaration.apply(this,arguments) };

subclass$(TagFragmentDeclaration,MethodDeclaration);
exports.TagFragmentDeclaration = TagFragmentDeclaration; // export class 



function PropertyDeclaration(name,options,token){
	this._token = token;
	this._traversed = false;
	this._name = name;
	this._options = options || new Obj(new AssignList());
};

subclass$(PropertyDeclaration,Node);
exports.PropertyDeclaration = PropertyDeclaration; // export class 
var propTemplate = '${headers}\n${path}${getterKey} = function(v){ return ${get}; }\n${path}.${setter} = function(v){ ${set}; return this; }\n${init}';

var propWatchTemplate = '${headers}\n${path}${getterKey} = function(v){ return ${get}; }\n${path}.${setter} = function(v){\n	var a = this.${getter}();\n	if(v != a) { ${set}; }\n	if(v != a) { ${ondirty} }\n	return this;\n}\n${init}';

PropertyDeclaration.prototype.name = function(v){ return this._name; }
PropertyDeclaration.prototype.setName = function(v){ this._name = v; return this; };
PropertyDeclaration.prototype.options = function(v){ return this._options; }
PropertyDeclaration.prototype.setOptions = function(v){ this._options = v; return this; };

PropertyDeclaration.prototype.visit = function (){
	this._options.traverse();
	return this;
};

// This will soon support bindings / listeners etc, much more
// advanced generated code based on options passed in.
PropertyDeclaration.prototype.c = function (){
	var o = this.options();
	var ast = "";
	var key = this.name().js();
	var scope = STACK.scope();
	
	var addDesc = o.keys().length;
	
	var pars = o.hash();
	
	var isAttr = (this._token && String(this._token) == 'attr') || o.key('attr');
	
	var js = {
		key: key,
		getter: key,
		getterKey: RESERVED_TEST.test(key) ? (("['" + key + "']")) : (("." + key)),
		setter: sym__(("set-" + key)),
		scope: ("" + (scope.context().c())),
		path: '${scope}.prototype',
		set: ("this._" + key + " = v"),
		get: ("this._" + key),
		init: "",
		headers: "",
		ondirty: ""
	};
	
	
	if (pars.inline) {
		if ((pars.inline instanceof Bool) && !pars.inline.isTruthy()) {
			o.remove('inline');
			return ("" + (this.scope__().imba().c()) + "." + (this._token) + "(" + (js.scope) + ",'" + (this.name().value()) + "'," + (o.c()) + ")").replace(',{})',')');
		};
	};
	
	var tpl = propTemplate;
	
	o.add('name',new Symbol(key));
	
	if (pars.watch) {
		if (!((pars.watch instanceof Bool) && !pars.watch.isTruthy())) { tpl = propWatchTemplate };
		var wfn = ("" + key + "DidSet");
		
		if (pars.watch instanceof Symbol) {
			wfn = pars.watch;
		} else if (pars.watch instanceof Str) {
			wfn = pars.watch;
		} else if (pars.watch instanceof Bool) {
			o.key('watch').setValue(new Symbol(("" + key + "DidSet")));
		} else {
			wfn = null;
		};
		
		if (wfn) {
			var fn = OP('.',new This(),wfn);
			js.ondirty = OP('&&',fn,CALL(fn,['v','a',("this.__" + key)])).c();
		} else {
			js.ondirty = ("" + (this.scope__().imba().c()) + ".propDidSet(this,this.__" + key + ",v,a)");
		};
	};
	
	
	if (pars.observe) {
		if (pars.observe instanceof Bool) {
			o.key('observe').setValue(new Symbol(("" + key + "DidEmit")));
		};
		
		tpl = propWatchTemplate;
		js.ondirty = ("" + (this.scope__().imba().c()) + ".observeProperty(this,'" + key + "'," + (o.key('observe').value().c()) + ",v,a);") + (js.ondirty || '');
		// OP('&&',fn,CALL(fn,['v','a',"this.__{key}"])).c
	};
	
	if (!(isAttr) && o.key('dom')) {
		js.set = ("if (v != this.dom()." + (this.name().value()) + ") \{ this.dom()." + (this.name().value()) + " = v \}");
		js.get = ("this.dom()." + (this.name().value()));
	};
	
	if (isAttr) { // (@token and String(@token) == 'attr') or o.key(:dom) or o.key(:attr)
		var attrKey = (o.key('dom') instanceof Str) ? o.key('dom') : this.name().value();
		// need to make sure o has a key for attr then - so that the delegate can know?
		js.set = ("this.setAttribute('" + attrKey + "',v)");
		js.get = ("this.getAttribute('" + attrKey + "')");
	} else if (o.key('delegate')) {
		// if we have a delegate
		js.set = ("v = this.__" + key + ".delegate.set(this,'" + key + "',v,this.__" + key + ")");
		js.get = ("this.__" + key + ".delegate.get(this,'" + key + "',this.__" + key + ")");
	};
	
	
	
	if (pars.default) {
		if (o.key('dom')) {
			// FIXME go through class-method setAttribute instead
			js.init = ("" + (js.scope) + ".dom().setAttribute('" + key + "'," + (pars.default.c()) + ");");
		} else {
			// if this is not a primitive - it MUST be included in the
			// getter / setter instead
			// FIXME throw warning if the default is not a primitive object
			js.init = ("" + (js.scope) + ".prototype._" + key + " = " + (pars.default.c()) + ";");
		};
	};
	
	if (o.key('chainable')) {
		js.get = ("v !== undefined ? (this." + (js.setter) + "(v),this) : " + (js.get));
	};
	
	
	js.options = o.c();
	
	if (addDesc) {
		js.headers = ("" + (js.path) + ".__" + (js.getter) + " = " + (js.options) + ";");
	};
	
	var reg = /\$\{(\w+)\}/gm;
	// var tpl = o.key(:watch) ? propWatchTemplate : propTemplate
	var out = tpl.replace(reg,function(m,a) { return js[a]; });
	// run another time for nesting. hacky
	out = out.replace(reg,function(m,a) { return js[a]; });
	// out = out.replace(/\n\s*$/,'')
	out = out.replace(/^\s+|\s+$/g,'');
	
	// if o.key(:v)
	return out;
};



// Literals should probably not inherit from the same parent
// as arrays, tuples, objects would be better off inheriting
// from listnode.

function Literal(v){
	this._traversed = false;
	this._expression = true;
	this._cache = null;
	this._raw = null;
	this._value = v;
};

subclass$(Literal,ValueNode);
exports.Literal = Literal; // export class 
Literal.prototype.toString = function (){
	return "" + this.value();
};

Literal.prototype.hasSideEffects = function (){
	return false;
};

Literal.prototype.shouldParenthesizeInTernary = function (){
	return false;
};


function Bool(v){
	this._value = v;
	this._raw = (String(v) == "true") ? true : false;
};

subclass$(Bool,Literal);
exports.Bool = Bool; // export class 
Bool.prototype.cache = function (){
	return this;
};

Bool.prototype.isPrimitive = function (){
	return true;
};

Bool.prototype.truthy = function (){
	return String(this.value()) == "true";
	// yes
};

Bool.prototype.js = function (o){
	return String(this._value);
};

Bool.prototype.c = function (){
	STACK._counter += 1;
	// undefined should not be a bool
	return String(this._value);
	// @raw ? "true" : "false"
};

Bool.prototype.toJSON = function (){
	return {type: 'Bool',value: this._value};
};

Bool.prototype.loc = function (){
	return this._value.region ? this._value.region() : [0,0];
};

function Undefined(){ return Literal.apply(this,arguments) };

subclass$(Undefined,Literal);
exports.Undefined = Undefined; // export class 
Undefined.prototype.isPrimitive = function (){
	return true;
};

Undefined.prototype.isTruthy = function (){
	return false;
};

Undefined.prototype.c = function (){
	return mark__(this._value) + "undefined";
};

function Nil(){ return Literal.apply(this,arguments) };

subclass$(Nil,Literal);
exports.Nil = Nil; // export class 
Nil.prototype.isPrimitive = function (){
	return true;
};

Nil.prototype.isTruthy = function (){
	return false;
};

Nil.prototype.c = function (){
	return mark__(this._value) + "null";
};

function True(){ return Bool.apply(this,arguments) };

subclass$(True,Bool);
exports.True = True; // export class 
True.prototype.raw = function (){
	return true;
};

True.prototype.isTruthy = function (){
	return true;
};

True.prototype.c = function (){
	return mark__(this._value) + "true";
};

function False(){ return Bool.apply(this,arguments) };

subclass$(False,Bool);
exports.False = False; // export class 
False.prototype.raw = function (){
	return false;
};

False.prototype.isTruthy = function (){
	return false;
};

False.prototype.c = function (){
	return mark__(this._value) + "false";
};

function Num(v){
	this._traversed = false;
	this._value = v;
};

subclass$(Num,Literal);
exports.Num = Num; // export class 
Num.prototype.toString = function (){
	return String(this._value);
};

Num.prototype.isPrimitive = function (deep){
	return true;
};

Num.prototype.isTruthy = function (){
	return String(this._value) != "0";
};

Num.prototype.shouldParenthesize = function (par){
	if(par === undefined) par = this.up();
	return (par instanceof Access) && par.left() == this;
};

Num.prototype.js = function (o){
	var num = String(this._value);
	return num;
};

Num.prototype.c = function (o){
	if (this._cache) { return Num.__super__.c.call(this,o) };
	var js = String(this._value);
	var par = STACK.current();
	var paren = (par instanceof Access) && par.left() == this;
	// only if this is the right part of teh acces
	return paren ? (("(" + mark__(this._value)) + js + ")") : ((mark__(this._value) + js));
	// @cache ? super(o) : String(@value)
};

Num.prototype.cache = function (o){
	if (!(o && (o.cache || o.pool))) { return this };
	return Num.__super__.cache.call(this,o);
};

Num.prototype.raw = function (){
	// really?
	return JSON.parse(String(this.value()));
};

Num.prototype.toJSON = function (){
	return {type: this.typeName(),value: this.raw()};
};

// should be quoted no?
// what about strings in object-literals?
// we want to be able to see if the values are allowed
function Str(v){
	this._traversed = false;
	this._expression = true;
	this._cache = null;
	this._value = v;
	// should grab the actual value immediately?
};

subclass$(Str,Literal);
exports.Str = Str; // export class 
Str.prototype.isString = function (){
	return true;
};

Str.prototype.isPrimitive = function (deep){
	return true;
};

Str.prototype.raw = function (){
	// JSON.parse requires double-quoted strings,
	// while eval also allows single quotes.
	// NEXT eval is not accessible like this
	// WARNING TODO be careful! - should clean up
	
	return this._raw || (this._raw = String(this.value()).slice(1,-1)); // incredibly stupid solution
};

Str.prototype.isValidIdentifier = function (){
	// there are also some values we cannot use
	return this.raw().match(/^[a-zA-Z\$\_]+[\d\w\$\_]*$/) ? true : false;
};

Str.prototype.js = function (o){
	return String(this._value);
};

Str.prototype.c = function (o){
	return this._cache ? Str.__super__.c.call(this,o) : String(this._value);
};


function Interpolation(){ return ValueNode.apply(this,arguments) };

subclass$(Interpolation,ValueNode);
exports.Interpolation = Interpolation; // export class 


// Currently not used - it would be better to use this
// for real interpolated strings though, than to break
// them up into their parts before parsing
function InterpolatedString(nodes,o){
	if(o === undefined) o = {};
	this._nodes = nodes;
	this._options = o;
	this;
};

subclass$(InterpolatedString,Node);
exports.InterpolatedString = InterpolatedString; // export class 
InterpolatedString.prototype.add = function (part){
	if (part) { this._nodes.push(part) };
	return this;
};

InterpolatedString.prototype.visit = function (){
	for (var i = 0, ary = iter$(this._nodes), len = ary.length; i < len; i++) {
		ary[i].traverse();
	};
	return this;
};

InterpolatedString.prototype.escapeString = function (str){
	// var idx = 0
	// var len = str:length
	// var chr
	// while chr = str[idx++]
	return str = str.replace(/\n/g,'\\\n');
};

InterpolatedString.prototype.js = function (o){
	// creating the string
	var self = this;
	var parts = [];
	var str = '(';
	
	self._nodes.map(function(part,i) {
		if ((part instanceof Token) && part._type == 'NEOSTRING') {
			// esca
			return parts.push('"' + self.escapeString(part._value) + '"');
		} else if (part) {
			if (i == 0) {
				// force first part to be string
				parts.push('""');
			};
			part._parens = true;
			return parts.push(part.c({expression: true}));
		};
	});
	
	str += parts.join(" + ");
	str += ')';
	return str;
};


function Tuple(){ return ListNode.apply(this,arguments) };

subclass$(Tuple,ListNode);
exports.Tuple = Tuple; // export class 
Tuple.prototype.c = function (){
	// compiles as an array
	return new Arr(this.nodes()).c();
};

Tuple.prototype.hasSplat = function (){
	return this.filter(function(v) { return v instanceof Splat; })[0];
};

Tuple.prototype.consume = function (node){
	if (this.count() == 1) {
		return this.first().consume(node);
	} else {
		throw "multituple cannot consume";
	};
};


// Because we've dropped the Str-wrapper it is kinda difficult
function Symbol(){ return Literal.apply(this,arguments) };

subclass$(Symbol,Literal);
exports.Symbol = Symbol; // export class 
Symbol.prototype.isValidIdentifier = function (){
	return this.raw().match(/^[a-zA-Z\$\_]+[\d\w\$\_]*$/) ? true : false;
};

Symbol.prototype.isPrimitive = function (deep){
	return true;
};

Symbol.prototype.raw = function (){
	return this._raw || (this._raw = sym__(this.value().toString().replace(/^\:/,'')));
};

Symbol.prototype.js = function (o){
	return ("'" + sym__(this.raw()) + "'");
};

function RegExp(){ return Literal.apply(this,arguments) };

subclass$(RegExp,Literal);
exports.RegExp = RegExp; // export class 
RegExp.prototype.isPrimitive = function (){
	return true;
};

RegExp.prototype.js = function (){
	var m;
	var v = RegExp.__super__.js.apply(this,arguments);
	
	// special casing heregex
	if (m = constants.HEREGEX.exec(v)) {
		// console.log 'matxhed heregex',m
		var re = m[1].replace(constants.HEREGEX_OMIT,'').replace(/\//g,'\\/');
		return '/' + (re || '(?:)') + '/' + m[2];
	};
	
	return (v == '//') ? '/(?:)/' : v;
};

// Should inherit from ListNode - would simplify
function Arr(){ return Literal.apply(this,arguments) };

subclass$(Arr,Literal);
exports.Arr = Arr; // export class 
Arr.prototype.load = function (value){
	return (value instanceof Array) ? new ArgList(value) : value;
};

Arr.prototype.push = function (item){
	this.value().push(item);
	return this;
};

Arr.prototype.count = function (){
	return this.value().length;
};

Arr.prototype.nodes = function (){
	var val = this.value();
	return (val instanceof Array) ? val : val.nodes();
};

Arr.prototype.splat = function (){
	return this.value().some(function(v) { return v instanceof Splat; });
};

Arr.prototype.visit = function (){
	if (this._value && this._value.traverse) { this._value.traverse() };
	return this;
};

Arr.prototype.isPrimitive = function (deep){
	return !this.value().some(function(v) { return !v.isPrimitive(true); });
};

Arr.prototype.js = function (o){
	
	var val = this._value;
	if (!(val)) { return "[]" };
	
	var splat = this.splat();
	var nodes = (val instanceof Array) ? val : val.nodes();
	
	// for v in @value
	// 	break splat = yes if v isa Splat
	// var splat = value.some(|v| v isa Splat)
	
	if (splat) {
		// "SPLATTED ARRAY!"
		// if we know for certain that the splats are arrays we can drop the slice?
		var slices = [];
		var group = null;
		
		for (var i = 0, ary = iter$(nodes), len = ary.length, v; i < len; i++) {
			v = ary[i];
			if (v instanceof Splat) {
				slices.push(v);
				group = null;
			} else {
				if (!(group)) { slices.push(group = new Arr([])) };
				group.push(v);
			};
		};
		
		return ("[].concat(" + cary__(slices).join(", ") + ")");
	} else {
		// very temporary. need a more generic way to prettify code
		// should depend on the length of the inner items etc
		// if @indented or option(:indent) or value.@indented
		//	"[\n{value.c.join(",\n").indent}\n]"
		var out = (val instanceof Array) ? cary__(val) : val.c();
		return ("[" + out + "]");
	};
};

Arr.prototype.hasSideEffects = function (){
	return this.value().some(function(v) { return v.hasSideEffects(); });
};

Arr.prototype.toString = function (){
	return "Arr";
};

Arr.prototype.indented = function (a,b){
	this._value.indented(a,b);
	return this;
};

Arr.wrap = function (val){
	return new Arr(val);
};

// should not be cklassified as a literal?
function Obj(){ return Literal.apply(this,arguments) };

subclass$(Obj,Literal);
exports.Obj = Obj; // export class 
Obj.prototype.load = function (value){
	return (value instanceof Array) ? new AssignList(value) : value;
};

Obj.prototype.visit = function (){
	if (this._value) { this._value.traverse() };
	// for v in value
	// 	v.traverse
	return this;
};

Obj.prototype.js = function (o){
	var dyn = this.value().filter(function(v) { return (v instanceof ObjAttr) && ((v.key() instanceof Op) || (v.key() instanceof InterpolatedString)); });
	
	if (dyn.length > 0) {
		var idx = this.value().indexOf(dyn[0]);
		// create a temp variable
		
		var tmp = this.scope__().temporary(this);
		// set the temporary object to the same
		var first = this.value().slice(0,idx);
		var obj = new Obj(first);
		var ast = [OP('=',tmp,obj)];
		
		this.value().slice(idx).forEach(function(atr) {
			return ast.push(OP('=',OP('.',tmp,atr.key()),atr.value()));
		});
		ast.push(tmp); // access the tmp at in the last part
		return new Parens(ast).c();
	};
	
	// for objects with expression-keys we need to think differently
	return '{' + this.value().c() + '}';
};

Obj.prototype.add = function (k,v){
	if ((typeof k=='string'||k instanceof String)) { k = new Identifier(k) };
	var kv = new ObjAttr(k,v);
	this.value().push(kv);
	return kv;
};

Obj.prototype.remove = function (key){
	for (var i = 0, ary = iter$(this.value()), len = ary.length, k; i < len; i++) {
		k = ary[i];
		if (k.key().symbol() == key) { this.value().remove(k) };
	};
	return this;
};

Obj.prototype.keys = function (){
	return Object.keys(this.hash());
};

Obj.prototype.hash = function (){
	var hash = {};
	for (var i = 0, ary = iter$(this.value()), len = ary.length, k; i < len; i++) {
		k = ary[i];
		if (k instanceof ObjAttr) { hash[k.key().symbol()] = k.value() };
	};
	return hash;
	// return k if k.key.symbol == key
};

// add method for finding properties etc?
Obj.prototype.key = function (key){
	for (var i = 0, ary = iter$(this.value()), len = ary.length, k; i < len; i++) {
		k = ary[i];
		if ((k instanceof ObjAttr) && k.key().symbol() == key) { return k };
	};
	return null;
};

Obj.prototype.indented = function (a,b){
	this._value.indented(a,b);
	return this;
};

Obj.prototype.hasSideEffects = function (){
	return this.value().some(function(v) { return v.hasSideEffects(); });
};

// for converting a real object into an ast-representation
Obj.wrap = function (obj){
	var attrs = [];
	for (var v, i = 0, keys = Object.keys(obj), l = keys.length, k; i < l; i++){
		k = keys[i];v = obj[k];if (v instanceof Array) {
			v = Arr.wrap(v);
		} else if (v.constructor == Object) {
			v = Obj.wrap(v);
		};
		attrs.push(new ObjAttr(k,v));
	};
	return new Obj(attrs);
};

Obj.prototype.toString = function (){
	return "Obj";
};

function ObjAttr(key,value){
	this._traversed = false;
	this._key = key;
	this._value = value;
	this._dynamic = (key instanceof Op);
	this;
};

subclass$(ObjAttr,Node);
exports.ObjAttr = ObjAttr; // export class 
ObjAttr.prototype.key = function(v){ return this._key; }
ObjAttr.prototype.setKey = function(v){ this._key = v; return this; };
ObjAttr.prototype.value = function(v){ return this._value; }
ObjAttr.prototype.setValue = function(v){ this._value = v; return this; };
ObjAttr.prototype.options = function(v){ return this._options; }
ObjAttr.prototype.setOptions = function(v){ this._options = v; return this; };

ObjAttr.prototype.visit = function (){
	// should probably traverse key as well, unless it is a dead simple identifier
	this.key().traverse();
	return this.value().traverse();
};

ObjAttr.prototype.js = function (o){
	var k = this.key().isReserved() ? (("'" + (this.key().c()) + "'")) : this.key().c();
	return ("" + k + ": " + (this.value().c()));
};

ObjAttr.prototype.hasSideEffects = function (){
	return true;
};



function ArgsReference(){ return Node.apply(this,arguments) };

subclass$(ArgsReference,Node);
exports.ArgsReference = ArgsReference; // export class 
ArgsReference.prototype.c = function (){
	return "arguments";
};

// should be a separate Context or something
function Self(value){
	this._value = value;
};

subclass$(Self,Literal);
exports.Self = Self; // export class 
Self.prototype.cache = function (){
	return this;
};

Self.prototype.reference = function (){
	return this;
};

Self.prototype.visit = function (){
	this.scope__().context();
	return this;
};

Self.prototype.c = function (){
	var s = this.scope__();
	return s ? s.context().c() : "this";
};

function ImplicitSelf(){ return Self.apply(this,arguments) };

subclass$(ImplicitSelf,Self);
exports.ImplicitSelf = ImplicitSelf; // export class 


function This(){ return Self.apply(this,arguments) };

subclass$(This,Self);
exports.This = This; // export class 
This.prototype.cache = function (){
	return this;
};

This.prototype.reference = function (){
	return this;
};

This.prototype.visit = function (){
	return this;
};

This.prototype.c = function (){
	return "this";
};




// OPERATORS

function Op(o,l,r){
	// set expression yes, no?
	this._expression = false;
	this._traversed = false;
	this._parens = false;
	this._cache = null;
	this._invert = false;
	this._opToken = o;
	this._op = o && o._value || o;
	
	if (this._op == 'and') {
		this._op = '&&';
	} else if (this._op == 'or') {
		this._op = '||';
	} else if (this._op == 'is') {
		this._op = '==';
	} else if (this._op == 'isnt') {
		this._op = '!=';
	};
	
	
	this._left = l;
	this._right = r;
	return this;
};

subclass$(Op,Node);
exports.Op = Op; // export class 
Op.prototype.op = function(v){ return this._op; }
Op.prototype.setOp = function(v){ this._op = v; return this; };
Op.prototype.left = function(v){ return this._left; }
Op.prototype.setLeft = function(v){ this._left = v; return this; };
Op.prototype.right = function(v){ return this._right; }
Op.prototype.setRight = function(v){ this._right = v; return this; };

Op.prototype.visit = function (){
	if (this._right) { this._right.traverse() };
	if (this._left) { this._left.traverse() };
	return this;
};

Op.prototype.isExpressable = function (){
	// what if right is a string?!?
	return !(this.right()) || this.right().isExpressable();
};

Op.prototype.js = function (o){
	var out = null;
	var op = this._op;
	
	var l = this._left;
	var r = this._right;
	
	if (l instanceof Node) { l = l.c() };
	if (r instanceof Node) { r = r.c() };
	
	if (l && r) {
		out = ("" + l + " " + mark__(this._opToken) + op + " " + r);
	} else if (l) {
		out = ("" + mark__(this._opToken) + op + l);
	};
	// out = out.parenthesize if up isa Op # really?
	return out;
};

Op.prototype.shouldParenthesize = function (){
	return this._parens;
	// option(:parens)
};

Op.prototype.precedence = function (){
	return 10;
};

Op.prototype.consume = function (node){
	// if it is possible, convert into expression
	if (node instanceof TagTree) {
		if (this._left) { this._left.consume(node) };
		if (this._right) { this._right.consume(node) };
		// @body = @body.consume(node)
		// @alt = @alt.consume(node) if @alt
		return this;
	};
	if (this.isExpressable()) { return Op.__super__.consume.apply(this,arguments) };
	
	// TODO can rather use global caching?
	var tmpvar = this.scope__().declare('tmp',null,{system: true});
	var clone = OP(this.op(),this.left(),null);
	var ast = this.right().consume(clone);
	if (node) { ast.consume(node) };
	return ast;
};

function ComparisonOp(){ return Op.apply(this,arguments) };

subclass$(ComparisonOp,Op);
exports.ComparisonOp = ComparisonOp; // export class 
ComparisonOp.prototype.invert = function (){
	// are there other comparison ops?
	// what about a chain?
	var op = this._op;
	var pairs = ["==","!=","===","!==",">","<=","<",">="];
	var idx = pairs.indexOf(op);
	idx += ((idx % 2) ? (-1) : 1);
	this.setOp(pairs[idx]);
	this._invert = !this._invert;
	return this;
};

ComparisonOp.prototype.c = function (){
	if (this.left() instanceof ComparisonOp) {
		this.left().right().cache();
		return OP('&&',this.left(),OP(this.op(),this.left().right(),this.right())).c();
	} else {
		return ComparisonOp.__super__.c.apply(this,arguments);
	};
};

ComparisonOp.prototype.js = function (o){
	var op = this._op;
	var l = this._left;
	var r = this._right;
	
	if (l instanceof Node) { l = l.c() };
	if (r instanceof Node) { r = r.c() };
	return ("" + l + " " + mark__(this._opToken) + op + " " + r);
};


function MathOp(){ return Op.apply(this,arguments) };

subclass$(MathOp,Op);
exports.MathOp = MathOp; // export class 
MathOp.prototype.c = function (){
	if (this.op() == '∪') {
		return this.util().union(this.left(),this.right()).c();
	} else if (this.op() == '∩') {
		return this.util().intersect(this.left(),this.right()).c();
	};
};


function UnaryOp(){ return Op.apply(this,arguments) };

subclass$(UnaryOp,Op);
exports.UnaryOp = UnaryOp; // export class 
UnaryOp.prototype.invert = function (){
	if (this.op() == '!') {
		return this.left();
	} else {
		return UnaryOp.__super__.invert.apply(this,arguments); // regular invert
	};
};

UnaryOp.prototype.isTruthy = function (){
	var val = truthy__(this.left());
	return (val !== undefined) ? ((!(val))) : ((undefined));
};

UnaryOp.prototype.js = function (o){
	var l = this._left;
	var r = this._right;
	var op = this.op();
	
	if (op == 'not') {
		op = '!';
	};
	
	if (op == '!') {
		// l.@parens = yes
		var str = l.c();
		var paren = l.shouldParenthesize(this);
		// FIXME this is a very hacky workaround. Need to handle all this
		// in the child instead, problems arise due to automatic caching
		if (!(str.match(/^\!?([\w\.]+)$/) || (l instanceof Parens) || paren || (l instanceof Access) || (l instanceof Call))) { str = '(' + str + ')' };
		// l.set(parens: yes) # sure?
		return ("" + op + str);
	} else if (op == '√') {
		return ("Math.sqrt(" + (l.c()) + ")");
	} else if (this.left()) {
		return ("" + (l.c()) + op);
	} else {
		return ("" + op + (r.c()));
	};
};

UnaryOp.prototype.normalize = function (){
	if (this.op() == '!' || this.op() == '√') { return this };
	var node = (this.left() || this.right()).node();
	// for property-accessors we need to rewrite the ast
	if (!((node instanceof PropertyAccess))) { return this };
	
	// ask to cache the path
	if ((node instanceof Access) && node.left()) { node.left().cache() };
	
	var num = new Num(1);
	var ast = OP('=',node,OP(this.op()[0],node,num));
	if (this.left()) { ast = OP((this.op()[0] == '-') ? '+' : '-',ast,num) };
	
	return ast;
};

UnaryOp.prototype.consume = function (node){
	var norm = this.normalize();
	return (norm == this) ? (UnaryOp.__super__.consume.apply(this,arguments)) : norm.consume(node);
};

UnaryOp.prototype.c = function (){
	var norm = this.normalize();
	return (norm == this) ? (UnaryOp.__super__.c.apply(this,arguments)) : norm.c();
};

function InstanceOf(){ return Op.apply(this,arguments) };

subclass$(InstanceOf,Op);
exports.InstanceOf = InstanceOf; // export class 
InstanceOf.prototype.js = function (o){
	// fix checks for String and Number
	
	if (this.right() instanceof Const) {
		// WARN otherwise - what do we do? does not work with dynamic
		// classes etc? Should probably send to utility function isa$
		var name = c__(this.right().value());
		var obj = this.left().node();
		// TODO also check for primitive-constructor
		if (idx$(name,['String','Number','Boolean']) >= 0) {
			if (!((obj instanceof LocalVarAccess))) {
				obj.cache();
			};
			// need a double check for these (cache left) - possibly
			return ("(typeof " + (obj.c()) + "=='" + (name.toLowerCase()) + "'||" + (obj.c()) + " instanceof " + name + ")");
			
			// convert
		};
	};
	var out = ("" + (this.left().c()) + " instanceof " + (this.right().c()));
	
	// should this not happen in #c?
	if (o.parent() instanceof Op) { out = helpers.parenthesize(out) };
	return out;
};

function TypeOf(){ return Op.apply(this,arguments) };

subclass$(TypeOf,Op);
exports.TypeOf = TypeOf; // export class 
TypeOf.prototype.js = function (o){
	return ("typeof " + (this.left().c()));
};

function Delete(){ return Op.apply(this,arguments) };

subclass$(Delete,Op);
exports.Delete = Delete; // export class 
Delete.prototype.js = function (o){
	// TODO this will execute calls several times if the path is not directly to an object
	// need to cache the receiver
	var l = this.left();
	var tmp = this.scope__().temporary(this,{pool: 'val'});
	var o = OP('=',tmp,l);
	// FIXME
	return ("(" + (o.c()) + ",delete " + (l.c()) + ", " + (tmp.c()) + ")"); // oh well
	// var ast = [OP('=',tmp,left),"delete {left.c}",tmp]
	// should parenthesize directly no?
	// ast.c
};

Delete.prototype.shouldParenthesize = function (){
	return true;
};

function In(){ return Op.apply(this,arguments) };

subclass$(In,Op);
exports.In = In; // export class 
In.prototype.invert = function (){
	this._invert = !this._invert;
	return this;
};

In.prototype.js = function (o){
	var cond = this._invert ? "== -1" : ">= 0";
	var idx = Util.indexOf(this.left(),this.right());
	return ("" + (idx.c()) + " " + cond);
};



// ACCESS

function Access(o,l,r){
	// set expression yes, no?
	this._expression = false;
	this._traversed = false;
	this._parens = false;
	this._cache = null;
	this._invert = false;
	this._op = o && o._value || o;
	this._left = l;
	this._right = r;
	return this;
};

subclass$(Access,Op);
exports.Access = Access; // export class 
Access.prototype.clone = function (left,right){
	var ctor = this.constructor;
	return new ctor(this.op(),left,right);
};

Access.prototype.js = function (o){
	var r;
	var raw = null;
	var rgt = this.right();
	var ctx = (this.left() || this.scope__().context());
	var pre = "";
	var mark = '';
	
	// if safechain
	//	p "Access is safechained {rgt.c}"
	
	
	if (rgt instanceof Num) {
		return ctx.c() + "[" + rgt.c() + "]";
	};
	
	// is this right? Should not the index compile the brackets
	// or value is a symbol -- should be the same, no?
	if ((rgt instanceof Index) && ((rgt.value() instanceof Str) || (rgt.value() instanceof Symbol))) {
		rgt = rgt.value();
	};
	
	// TODO do the identifier-validation in a central place instead
	if ((rgt instanceof Str) && rgt.isValidIdentifier()) {
		raw = rgt.raw();
	} else if ((rgt instanceof Symbol) && rgt.isValidIdentifier()) {
		raw = rgt.raw();
	} else if ((rgt instanceof Identifier) && rgt.isValidIdentifier()) {
		mark = mark__(rgt._value);
		raw = rgt.c();
	};
	
	if (this.safechain() && ctx) {
		ctx.cache({force: true});
		pre = ctx.c() + " && ";
	};
	
	// really?
	// var ctx = (left || scope__.context)
	var out = raw ? (
		// see if it needs quoting
		// need to check to see if it is legal
		ctx ? (("" + (ctx.c()) + "." + mark + raw)) : raw
	) : (
		r = (rgt instanceof Node) ? rgt.c({expression: true}) : rgt,
		("" + (ctx.c()) + "[" + r + "]")
	);
	
	// if safechain and ctx
	// 	out = "{ctx.c} && {out}"
	
	return pre + out;
};

Access.prototype.visit = function (){
	if (this.left()) { this.left().traverse() };
	if (this.right()) { this.right().traverse() };
	return;
};

Access.prototype.isExpressable = function (){
	return true;
};

Access.prototype.alias = function (){
	return (this.right() instanceof Identifier) ? this.right().alias() : Access.__super__.alias.call(this);
};

Access.prototype.safechain = function (){
	// right.safechain
	return String(this._op) == '?.' || String(this._op) == '?:';
};

Access.prototype.cache = function (o){
	return ((this.right() instanceof Ivar) && !(this.left())) ? this : Access.__super__.cache.call(this,o);
};

Access.prototype.shouldParenthesizeInTernary = function (){
	return this._parens || this._cache;
};


// Should change this to just refer directly to the variable? Or VarReference
function LocalVarAccess(){ return Access.apply(this,arguments) };

subclass$(LocalVarAccess,Access);
exports.LocalVarAccess = LocalVarAccess; // export class 
LocalVarAccess.prototype.safechain = function(v){ return this._safechain; }
LocalVarAccess.prototype.setSafechain = function(v){ this._safechain = v; return this; };

LocalVarAccess.prototype.js = function (o){
	if ((this.right() instanceof Variable) && this.right().type() == 'meth') {
		if (!((this.up() instanceof Call))) { return ("" + (this.right().c()) + "()") };
	};
	
	return this.right().c();
};

LocalVarAccess.prototype.variable = function (){
	return this.right();
};

LocalVarAccess.prototype.cache = function (o){
	if(o === undefined) o = {};
	if (o.force) { LocalVarAccess.__super__.cache.call(this,o) };
	return this;
};

LocalVarAccess.prototype.alias = function (){
	return this.variable()._alias || LocalVarAccess.__super__.alias.call(this);
};


function GlobalVarAccess(){ return ValueNode.apply(this,arguments) };

subclass$(GlobalVarAccess,ValueNode);
exports.GlobalVarAccess = GlobalVarAccess; // export class 
GlobalVarAccess.prototype.js = function (o){
	return this.value().c();
};


function ObjectAccess(){ return Access.apply(this,arguments) };

subclass$(ObjectAccess,Access);
exports.ObjectAccess = ObjectAccess; // export class 



function PropertyAccess(o,l,r){
	this._traversed = false;
	this._invert = false;
	this._parens = false;
	this._expression = false; // yes?
	this._cache = null;
	this._op = o;
	this._left = l;
	this._right = r;
	return this;
};

subclass$(PropertyAccess,Access);
exports.PropertyAccess = PropertyAccess; // export class 
PropertyAccess.prototype.visit = function (){
	if (this._right) { this._right.traverse() };
	if (this._left) { this._left.traverse() };
	return this;
};

// right in c we should possibly override
// to create a call and regular access instead

PropertyAccess.prototype.js = function (o){
	
	var rec;
	if (rec = this.receiver()) {
		var ast = CALL(OP('.',this.left(),this.right()),[]); // convert to ArgList or null
		ast.setReceiver(rec);
		return ast.c();
	};
	
	var up = this.up();
	
	if (!((up instanceof Call))) {
		ast = CALL(new Access(this.op(),this.left(),this.right()),[]);
		return ast.c();
	};
	
	// really need to fix this - for sure
	// should be possible for the function to remove this this instead?
	var js = ("" + PropertyAccess.__super__.js.call(this,o));
	
	if (!((up instanceof Call) || (up instanceof Util.IsFunction))) {
		js += "()";
	};
	
	return js;
};


PropertyAccess.prototype.receiver = function (){
	if ((this.left() instanceof SuperAccess) || (this.left() instanceof Super)) {
		return SELF;
	} else {
		return null;
	};
};


function IvarAccess(){ return Access.apply(this,arguments) };

subclass$(IvarAccess,Access);
exports.IvarAccess = IvarAccess; // export class 
IvarAccess.prototype.visit = function (){
	if (this._right) { this._right.traverse() };
	this._left ? this._left.traverse() : this.scope__().context();
	return this;
};

IvarAccess.prototype.cache = function (){
	// WARN hmm, this is not right... when accessing on another object it will need to be cached
	return this;
};


function ConstAccess(){ return Access.apply(this,arguments) };

subclass$(ConstAccess,Access);
exports.ConstAccess = ConstAccess; // export class 



function IndexAccess(){ return Access.apply(this,arguments) };

subclass$(IndexAccess,Access);
exports.IndexAccess = IndexAccess; // export class 
IndexAccess.prototype.cache = function (o){
	if(o === undefined) o = {};
	if (o.force) { return IndexAccess.__super__.cache.apply(this,arguments) };
	this.right().cache();
	return this;
};


function SuperAccess(){ return Access.apply(this,arguments) };

subclass$(SuperAccess,Access);
exports.SuperAccess = SuperAccess; // export class 
SuperAccess.prototype.js = function (o){
	var m = o.method();
	var up = o.parent();
	var deep = (o.parent() instanceof Access);
	
	var out = ("" + (this.left().c()) + ".__super__");
	
	if (!((up instanceof Access))) {
		out += ("." + (m.supername().c()));
		if (!((up instanceof Call))) { // autocall?
			out += (".apply(" + (m.scope().context().c()) + ",arguments)");
		};
	};
	
	return out;
};

SuperAccess.prototype.receiver = function (){
	return SELF;
};


function VarOrAccess(value){
	// should rather call up to valuenode?
	this._traversed = false;
	this._parens = false;
	this._value = value;
	this._identifier = value;
	this._token = value._value;
	this._variable = null;
	this;
};

// Shortcircuit traverse so that it is not added to the stack?!
subclass$(VarOrAccess,ValueNode);
exports.VarOrAccess = VarOrAccess; // export class 
VarOrAccess.prototype.visit = function (){
	// @identifier = value # this is not a real identifier?
	// console.log "VarOrAccess {@identifier}"
	
	
	var scope = this.scope__();
	
	var variable = scope.lookup(this.value());
	
	// does not really need to have a declarator already? -- tricky
	if (variable && variable.declarator()) {
		// var decl = variable.declarator
		
		// if the variable is not initialized just yet and we are
		// in the same scope - we should not treat this as a var-lookup
		// ie.  var x = x would resolve to var x = this.x() if x
		// was not previously defined
		
		// should do this even if we are not in the same scope?
		// we only need to be in the same closure(!)
		
		if (variable._initialized || (scope.closure() != variable.scope().closure())) {
			this._variable = variable;
			variable.addReference(this);
			this._value = variable; // variable.accessor(self)
			this._token._variable = variable;
			return this;
		};
		// FIX
		// @value.safechain = safechain
	};
	
	// TODO deprecate and remove
	if (this.value().symbol().indexOf('$') >= 0) {
		// big hack - should disable
		// major hack here, no?
		// console.log "GlobalVarAccess"
		this._value = new GlobalVarAccess(this.value());
		return this;
	};
	
	// really? what about just mimicking the two diffrent instead?
	// Should we not return a call directly instead?
	this._value = new PropertyAccess(".",scope.context(),this.value());
	// mark the scope / context -- so we can show correct implicit
	this._token._meta = {type: 'ACCESS'};
	// @value.traverse # nah
	return this;
};

VarOrAccess.prototype.c = function (){
	return mark__(this._token) + (this._variable ? VarOrAccess.__super__.c.call(this) : this.value().c());
};

VarOrAccess.prototype.js = function (o){
	
	var v;
	if (v = this._variable) {
		var out = v.c();
		if (v._type == 'meth' && !(o.up() instanceof Call)) { out += "()" };
		return out;
	};
	return "NONO";
};

VarOrAccess.prototype.node = function (){
	return this._variable ? this : this.value();
};

VarOrAccess.prototype.symbol = function (){
	return this._identifier.symbol();
	// value and value.symbol
};

VarOrAccess.prototype.cache = function (o){
	if(o === undefined) o = {};
	return this._variable ? ((o.force && VarOrAccess.__super__.cache.call(this,o))) : this.value().cache(o);
};

VarOrAccess.prototype.decache = function (){
	this._variable ? VarOrAccess.__super__.decache.call(this) : this.value().decache();
	return this;
};

VarOrAccess.prototype.dom = function (){
	return this.value().dom();
};

VarOrAccess.prototype.safechain = function (){
	return this._identifier.safechain();
};

VarOrAccess.prototype.dump = function (){
	return {loc: this.loc()};
};

VarOrAccess.prototype.loc = function (){
	var loc = this._identifier.region();
	return loc || [0,0];
};

VarOrAccess.prototype.region = function (){
	return this._identifier.region();
};

VarOrAccess.prototype.shouldParenthesizeInTernary = function (){
	return this._cache || (this._value && this._value._cache) || this._parens;
};

VarOrAccess.prototype.toString = function (){
	return ("VarOrAccess(" + this.value() + ")");
};

VarOrAccess.prototype.toJSON = function (){
	return {type: this.typeName(),value: this._identifier.toString()};
};

//	def js
//		if right isa Variable and right.type == 'meth'
//			return "{right.c}()" unless up isa Call
//
//		right.c
//
//	def variable
//		right
//
//	def cache o = {}
//		super if o:force
//		self
//
//	def alias
//		variable.@alias or super # if resolved?
//

function VarReference(value,type){
	if (value instanceof VarOrAccess) {
		value = value.value();
	};
	// for now - this can happen
	VarReference.__super__.constructor.call(this,value);
	this._export = false;
	this._type = type && String(type);
	this._variable = null;
	this._declared = true; // just testing now
};


subclass$(VarReference,ValueNode);
exports.VarReference = VarReference; // export class 
VarReference.prototype.variable = function(v){ return this._variable; }
VarReference.prototype.setVariable = function(v){ this._variable = v; return this; };
VarReference.prototype.declared = function(v){ return this._declared; }
VarReference.prototype.setDeclared = function(v){ this._declared = v; return this; };
VarReference.prototype.type = function(v){ return this._type; }
VarReference.prototype.setType = function(v){ this._type = v; return this; };

VarReference.prototype.loc = function (){
	return this._value.region();
};

VarReference.prototype.set = function (o){
	// hack - workaround for hidden classes perf
	if (o.export) { this._export = true };
	return this;
};

VarReference.prototype.js = function (o){
	// experimental fix
	
	// what about resolving?
	var ref = this._variable;
	var out = ("" + mark__(this._value) + (ref.c()));
	
	if (ref && !ref._declared) { // .option(:declared)
		if (o.up(VarBlock)) { // up varblock??
			ref._declared = true;
			
			// ref.set(declared: yes)
		} else if (o.isExpression() || this._export) { // why?
			ref.autodeclare();
		} else {
			out = ("var " + out);
			ref._declared = true;
			// ref.set(declared: yes)
		};
	};
	
	// need to think the export through -- like registering somehow
	// should register in scope - export on analysis++
	if (this._export) {
		out = ("module.exports." + (ref.c()) + " = " + (ref.c()));
	};
	
	return out;
};

VarReference.prototype.declare = function (){
	return this;
};

VarReference.prototype.consume = function (node){
	// really? the consumed node dissappear?
	this._variable && this._variable.autodeclare();
	return this;
};

VarReference.prototype.visit = function (){
	
	// console.log "value type for VarReference {@value} {@value.@loc} {@value:constructor}"
	
	// should be possible to have a VarReference without a name as well? for a system-variable
	// name should not set this way.
	var name = this.value().c();
	
	// what about looking up? - on register we want to mark
	var v = this._variable || (this._variable = this.scope__().register(name,this,{type: this._type}));
	// FIXME -- should not simply override the declarator here(!)
	
	if (!v.declarator()) {
		v.setDeclarator(this);
	};
	
	if (this._value) { v.addReference(this._value) }; // is this the first reference?
	
	// only needed when analyzing?
	this._value._value._variable = v;
	return this;
};

VarReference.prototype.refnr = function (){
	return this.variable().references().indexOf(this.value());
};

// convert this into a list of references
VarReference.prototype.addExpression = function (expr){
	return new VarBlock([this]).addExpression(expr);
};


// ASSIGN

function Assign(o,l,r){
	
	// workaround until we complete transition from lua-style assignments
	// to always use explicit tuples - then we can move assignments out etc
	// this will not be needed after we remove support for var a,b,c = 1,2,3
	if ((l instanceof VarReference) && (l.value() instanceof Arr)) {
		// converting all nodes to var-references ?
		// do we need to keep it in a varblock at all?
		var vars = l.value().nodes().map(function(v) {
			// what about inner tuples etc?
			// keep the splats -- clumsy but true
			var v_;
			if (v instanceof Splat) {
				if (!((v.value() instanceof VarReference))) { (v.setValue(v_ = new VarReference(v.value(),l.type())),v_) };
			} else if (v instanceof VarReference) {
				true;
			} else {
				// what about retaining location?
				// v = v.value if v isa VarOrAccess
				v = new VarReference(v,l.type());
			};
			
			return v;
			
			// v isa VarReference ? v : VarReference.new(v)
		});
		
		return new TupleAssign(o,new Tuple(vars),r);
	};
	
	if (l instanceof Arr) {
		return new TupleAssign(o,new Tuple(l.nodes()),r);
	};
	
	// set expression yes, no?
	this._expression = false;
	this._traversed = false;
	this._parens = false;
	this._cache = null;
	this._invert = false;
	this._opToken = o;
	this._op = o && o._value || o;
	this._left = l;
	this._right = r;
	return this;
};

subclass$(Assign,Op);
exports.Assign = Assign; // export class 
Assign.prototype.isExpressable = function (){
	return !(this.right()) || this.right().isExpressable();
};

Assign.prototype.isUsed = function (){
	// really?
	// if up is a block in general this should not be used -- since it should already have received implicit self?
	if (this.up() instanceof Block) { // && up.last != self
		return false;
	};
	return true;
};

// FIXME optimize
Assign.prototype.visit = function (){
	var l = this._left;
	var r = this._right;
	
	// WARNING - slightly undefined
	// MARK THE STACK
	if (l) { l.traverse() };
	
	var lvar = (l instanceof VarReference) && l.variable();
	
	// how does this work with constants that are really var references?
	// should work when things are not described as well - but this is for testing
	// but if it refers to something else
	if (!(lvar) && this._desc) {
		// entities should be able to extract the needed info instead
		ROOT.entities().add(l.namepath(),{namepath: l.namepath(),type: r.typeName(),desc: this._desc});
	};
	
	// this should probably be done in a different manner
	if (lvar && lvar.declarator() == l) {
		lvar._initialized = false;
		if (r) { r.traverse() };
		lvar._initialized = true;
	} else {
		if (r) { r.traverse() };
	};
	
	if ((l instanceof VarReference) || l._variable) {
		l._variable.assigned(r,this);
	};
	
	return this;
};

Assign.prototype.c = function (o){
	if (!this.right().isExpressable()) {
		return this.right().consume(this).c(o);
	};
	// testing this
	return Assign.__super__.c.call(this,o);
};

Assign.prototype.js = function (o){
	if (!this.right().isExpressable()) {
		this.p("Assign#js right is not expressable ");
		// here this should be go out of the stack(!)
		// it should already be consumed?
		return this.right().consume(this).c();
	};
	var l = this.left().node();
	var r = this.right();
	
	// We are setting self(!)
	// TODO document functionality
	if (l instanceof Self) {
		var ctx = this.scope__().context();
		l = ctx.reference();
	};
	
	
	if (l instanceof PropertyAccess) {
		var ast = CALL(OP('.',l.left(),l.right().setter()),[this.right()]);
		ast.setReceiver(l.receiver());
		
		if (this.isUsed()) {
			// dont cache it again if it is already cached(!)
			if (!this.right().cachevar()) { this.right().cache({pool: 'val',uses: 1}) }; //
			// this is only when used.. should be more clever about it
			ast = new Parens(blk__([ast,this.right()]));
		};
		
		// should check the up-value no?
		return ast.c({expression: true});
	};
	
	// if l isa VarReference
	// 	p "assign var-ref"
	// 	l.@variable.assigned(r)
	
	// FIXME -- does not always need to be an expression?
	var lc = l.c();
	
	if (this.option('export')) {
		var ename = (l instanceof VarReference) ? l.variable().c() : lc;
		return ("" + lc + " " + mark__(this._opToken) + this.op() + " exports." + ename + " = " + this.right().c({expression: true}));
	} else {
		return ("" + lc + " " + mark__(this._opToken) + this.op() + " " + this.right().c({expression: true}));
	};
	// return out
};

// FIXME op is a token? _FIX_
// this (and similar cases) is broken when called from
// another position in the stack, since 'up' is dynamic
// should maybe freeze up?
Assign.prototype.shouldParenthesize = function (par){
	if(par === undefined) par = this.up();
	return this._parens || (par instanceof Op) && par.op() != '=';
};

Assign.prototype.consume = function (node){
	if (this.isExpressable()) {
		this.forceExpression();
		return Assign.__super__.consume.call(this,node);
	};
	
	var ast = this.right().consume(this);
	return ast.consume(node);
};

// more workaround during transition away from a,b,c = 1,2,3 style assign
Assign.prototype.addExpression = function (expr){
	// p "addExpression {expr}"
	var typ = ExpressionBlock;
	if (this._left && (this._left instanceof VarReference)) {
		typ = VarBlock;
	};
	// might be better to nest this up after parsing is done?
	var node = new typ([this]);
	return node.addExpression(expr);
};


function PushAssign(){ return Assign.apply(this,arguments) };

subclass$(PushAssign,Assign);
exports.PushAssign = PushAssign; // export class 
PushAssign.prototype.js = function (o){
	return ("" + (this.left().c()) + ".push(" + (this.right().c()) + ")");
};

PushAssign.prototype.consume = function (node){
	return this;
};

function TagPushAssign(){ return PushAssign.apply(this,arguments) };

subclass$(TagPushAssign,PushAssign);
exports.TagPushAssign = TagPushAssign; // export class 
TagPushAssign.prototype.js = function (o){
	return ("" + (this.left().c()) + ".push(" + (this.right().c()) + ")");
};

TagPushAssign.prototype.consume = function (node){
	return this;
};


function ConditionalAssign(){ return Assign.apply(this,arguments) };

subclass$(ConditionalAssign,Assign);
exports.ConditionalAssign = ConditionalAssign; // export class 
ConditionalAssign.prototype.consume = function (node){
	return this.normalize().consume(node);
};

ConditionalAssign.prototype.normalize = function (){
	var l = this.left().node();
	var ls = l;
	
	if (l instanceof Access) {
		if (l.left()) {
			l.left().cache();
		};
		ls = l.clone(l.left(),l.right()); // this should still be cached?
		if (l instanceof PropertyAccess) { l.cache() }; // correct now, to a certain degree
		if (l instanceof IndexAccess) {
			l.right().cache();
		};
		
		// we should only cache the value itself if it is dynamic?
		// l.cache # cache the value as well -- we cannot use this in assigns them
	};
	
	// some ops are less messy
	// need op to support consume then?
	var expr = this.right().isExpressable();
	var ast = null;
	// here we should use ast = if ...
	if (expr && this.op() == '||=') {
		ast = OP('||',l,OP('=',ls,this.right()));
	} else if (expr && this.op() == '&&=') {
		ast = OP('&&',l,OP('=',ls,this.right()));
	} else {
		ast = IF(this.condition(),OP('=',ls,this.right()),l); // do we need a scope for these?
		ast.setScope(null);
		// drop the scope
		// touch scope -- should probably visit the whole thing?
		// ast.scope.visit
	};
	if (ast.isExpressable()) { ast.toExpression() };
	return ast;
};


ConditionalAssign.prototype.c = function (){
	// WARN what if we return the same?
	return this.normalize().c();
};

ConditionalAssign.prototype.condition = function (){
	
	// use switch instead to cache op access
	if (this.op() == '?=') {
		return OP('==',this.left(),NULL);
	} else if (this.op() == '||=') {
		return OP('!',this.left());
	} else if (this.op() == '&&=') {
		return this.left();
	} else if (this.op() == '!?=') {
		return OP('!=',this.left(),NULL);
	} else {
		return this.left();
	};
};

ConditionalAssign.prototype.js = function (o){
	var ast = IF(this.condition(),OP('=',this.left(),this.right()),this.left());
	ast.setScope(null); // not sure about this
	if (ast.isExpressable()) { ast.toExpression() }; // forced expression already
	return ast.c();
};

function CompoundAssign(){ return Assign.apply(this,arguments) };

subclass$(CompoundAssign,Assign);
exports.CompoundAssign = CompoundAssign; // export class 
CompoundAssign.prototype.consume = function (node){
	if (this.isExpressable()) { return CompoundAssign.__super__.consume.apply(this,arguments) };
	
	var ast = this.normalize();
	if (ast != this) { return ast.consume(node) };
	
	ast = this.right().consume(this);
	return ast.consume(node);
};

CompoundAssign.prototype.normalize = function (){
	var ln = this.left().node();
	// we dont need to change this at all
	if (!((ln instanceof PropertyAccess))) {
		return this;
	};
	
	if (ln instanceof Access) {
		// left might be zero?!?!
		if (ln.left()) { ln.left().cache() };
	};
	// TODO FIXME we want to cache the context of the assignment
	var ast = OP('=',this.left(),OP(this.op()[0],this.left(),this.right()));
	if (ast.isExpressable()) { ast.toExpression() };
	
	return ast;
};

CompoundAssign.prototype.c = function (){
	var ast = this.normalize();
	if (ast == this) { return CompoundAssign.__super__.c.apply(this,arguments) };
	
	// otherwise it is important that we actually replace this node in the outer block
	// whenever we normalize and override c it is important that we can pass on caching
	// etc -- otherwise there WILL be issues.
	var up = STACK.current();
	if (up instanceof Block) {
		// an alternative would be to just pass
		up.replace(this,ast);
	};
	return ast.c();
};


function AsyncAssign(){ return Assign.apply(this,arguments) };

subclass$(AsyncAssign,Assign);
exports.AsyncAssign = AsyncAssign; // export class 



function TupleAssign(a,b,c){
	this._traversed = false;
	this._op = a;
	this._left = b;
	this._right = c;
	this._temporary = [];
};

subclass$(TupleAssign,Assign);
exports.TupleAssign = TupleAssign; // export class 
TupleAssign.prototype.op = function(v){ return this._op; }
TupleAssign.prototype.setOp = function(v){ this._op = v; return this; };
TupleAssign.prototype.left = function(v){ return this._left; }
TupleAssign.prototype.setLeft = function(v){ this._left = v; return this; };
TupleAssign.prototype.right = function(v){ return this._right; }
TupleAssign.prototype.setRight = function(v){ this._right = v; return this; };
TupleAssign.prototype.type = function(v){ return this._type; }
TupleAssign.prototype.setType = function(v){ this._type = v; return this; };

TupleAssign.prototype.isExpressable = function (){
	return this.right().isExpressable();
};

TupleAssign.prototype.addExpression = function (expr){
	if (this.right() instanceof Tuple) {
		this.right().push(expr);
	} else {
		this.setRight(new Tuple([this.right(),expr]));
	};
	
	return this;
};

TupleAssign.prototype.visit = function (){
	// if the first left-value is a var-reference, then
	// all the variables should be declared as variables.
	// but if we have complex items in the other list - it does become much harder
	
	// if the first is a var-reference, they should all be(!) .. or splats?
	// this is really a hacky wao to do it though
	if (this.left().first().node() instanceof VarReference) {
		this.setType('var');
		// should possibly allow real vars as well, no?
		this._vars = this.left().nodes().filter(function(n) { return n instanceof VarReference; });
		// collect the vars for tuple for easy access
		
		// NOTE can improve.. should rather make the whole left be a VarBlock or TupleVarBlock
	};
	
	this.right().traverse();
	this.left().traverse();
	return this;
};

TupleAssign.prototype.js = function (o){
	// only for actual inner expressions, otherwise cache the whole array, no?
	var self = this;
	if (!self.right().isExpressable()) {
		
		return self.right().consume(self).c();
	};
	
	/* a,b,c = arguments */
	
	// - direct. no matter if lvalues are variables or not. Make fake arguments up to the same count as tuple
	
	/* a,*b,b = arguments */
	
	// Need to convert arguments to an array. IF arguments is not referenced anywhere else in scope,
	// we can do the assignment directly while rolling through arguments
	
	/* a,b = b,a */
	
	// ideally we only need to cache the first value (or n - 1), assign directly when possible.
	
	/* a,b,c = (method | expression) */
	
	// convert res into array, assign from array. Can cache the variable when assigning first value
	
	// First we need to find out whether we are required to store the result in an array before assigning
	// If this needs to be an expression (returns?, we need to fall back to the CS-wa)
	
	var ast = new Block([]);
	var lft = self.left();
	var rgt = self.right();
	var typ = self.type();
	var via = null;
	
	var li = 0;
	var ri = lft.count();
	var llen = ri;
	
	
	// if @vars
	// 	p "tuple has {@vars:length} vars"
	
	// if we have a splat on the left it is much more likely that we need to store right
	// in a temporary array, but if the right side has a known length, it should still not be needed
	var lsplat = lft.filter(function(v) { return v instanceof Splat; })[0];
	
	// if right is an array without any splats (or inner tuples?), normalize it to tuple
	if ((rgt instanceof Arr) && !rgt.splat()) { rgt = new Tuple(rgt.nodes()) };
	var rlen = (rgt instanceof Tuple) ? rgt.count() : null;
	
	// if any values are statements we need to handle this before continuing
	
	/* a,b,c = 10,20,ary */
	
	// ideally we only need to cache the first value (or n - 1), assign directly when possible.
	// only if the variables are not predefined or predeclared can be we certain that we can do it without caching
	// if rlen && typ == 'var' && !lsplat
	// 	# this can be dangerous in edgecases that are very hard to detect
	// 	# if it becomes an issue, fall back to simpler versions
	// 	# does not even matter if there is a splat?
	
	// special case for arguments(!)
	if (!(lsplat) && rgt == ARGUMENTS) {
		
		var pars = self.scope__().params();
		// forcing the arguments to be named
		lft.map(function(l,i) { return ast.push(OP('=',l.node(),pars.at(i,true).visit().variable())); }); // s.params.at(value - 1,yes)
	} else if (rlen) {
		// we have several items in the right part. what about splats here?
		
		// pre-evaluate rvalues that might be reference from other assignments
		// we need to check if the rightside values has no side-effects. Cause if
		// they dont, we really do not need temporary variables.
		
		// some of these optimizations are quite petty - makes things more complicated
		// in the compiler only to get around adding a few temp-variables here and there
		
		// var firstUnsafe = 0
		// lft.map do |v,i|
		// 	if v isa VarReference
		// 		p "left side {i} {v} {v.refnr}"
		
		// rgt.map do |v,i|
		// 	if v.hasSideEffects
		// 		# return if i == 0 or !v.hasSideEffects
		// 		# return if v isa Num || v isa Str || i == 0
		// 		# we could explicitly create a temporary variable and adding nodes for accessing etc
		// 		# but the builtin caching should really take care of this for us
		// 		# we need to really force the caching though -- since we need a copy of it even if it is a local
		// 		# we need to predeclare the variables at the top of scope if this does not take care of it
		//
		// 		# these are the declarations -- we need to add them somewhere smart
		// 		@temporary.push(v) # need a generalized way to do this type of thing
		// 		ast.push(v.cache(force: yes, type: 'swap', declared: typ == 'var'))
		// 		# they do need to be declared, no?
		
		// now we can free the cached variables
		// ast.map do |n| n.decache
		
		var pre = [];
		var rest = [];
		
		var pairs = lft.map(function(l,i) {
			var v = null;
			// determine if this needs to be precached?
			// if l isa VarReference
			// 	# this is the first time the variable is referenced
			// 	# should also count even if it is predeclared at the top
			// 	if l.refnr == 0
			
			if (l == lsplat) {
				v = new ArgList([]);
				var to = (rlen - (ri - i));
				while (li <= to){
					v.push(rgt.index(li++));
				};
				v = new Arr(v);
				// ast.push OP('=',l.node,Arr.new(v))
			} else {
				v = rgt.index(li++);
			};
			return [l.node(),v];
			
			// if l isa VarReference && l.refnr
		});
		var clean = true;
		
		pairs.map(function(v,i) {
			var l = v[0];
			var r = v[1];
			
			if (clean) {
				if ((l instanceof VarReference) && l.refnr() == 0) {
					// still clean
					clean = true;
				} else {
					clean = false;
					pairs.slice(i).map(function(part) {
						if (part[1].hasSideEffects()) {
							self._temporary.push(part[1]); // need a generalized way to do this type of thing
							return ast.push(part[1].cache({force: true,pool: 'swap',declared: typ == 'var'}));
						};
					});
				};
			};
			
			// if the previous value in ast is a reference to our value - the caching was not needed
			if (ast.last() == r) {
				r.decache();
				// simple assign
				return ast.replace(r,OP('=',l,r));
			} else {
				return ast.push(OP('=',l,r));
			};
		});
		
		// WARN FIXME Is there not an issue with VarBlock vs not here?
	} else {
		// this is where we need to cache the right side before assigning
		// if the right side is a for loop, we COULD try to be extra clever, but
		// for now it is not worth the added compiler complexity
		
		// iter.cache(force: yes, type: 'iter')
		var top = new VarBlock();
		var iter = self.util().iterable(rgt,true);
		// could set the vars inside -- most likely
		ast.push(top);
		top.push(iter);
		
		if (lsplat) {
			var len = self.util().len(iter,true);
			var idx = self.util().counter(0,true);
			// cache the length of the array
			top.push(len); // preassign the length
			// cache counter to loop through
			top.push(idx);
		};
		
		// only if the block is variable based, no?
		// ast.push(blk = VarBlock.new)
		// blk = null
		
		var blktype = (typ == 'var') ? VarBlock : Block;
		var blk = new blktype([]);
		// blk = top if typ == 'var'
		ast.push(blk);
		
		// if the lvals are not variables - we need to preassign
		// can also use slice here for simplicity, but try with while now
		lft.map(function(l,i) {
			if (l == lsplat) {
				var lvar = l.node();
				var rem = llen - i - 1; // remaining after splat
				
				if (typ != 'var') {
					var arr = self.util().array(OP('-',len,num__(i + rem)),true);
					top.push(arr);
					lvar = arr.cachevar();
				} else {
					if (!(blk)) { ast.push(blk = new blktype()) };
					arr = self.util().array(OP('-',len,num__(i + rem)));
					blk.push(OP('=',lvar,arr));
				};
				
				// if !lvar:variable || !lvar.variable # lvar =
				// 	top.push()
				//	p "has variable - no need to create a temp"
				// blk.push(OP('=',lvar,Arr.new([]))) # dont precalculate size now
				// max = to = (rlen - (llen - i))
				
				
				var test = rem ? OP('-',len,rem) : len;
				
				var set = OP('=',OP('.',lvar,OP('-',idx,num__(i))),
				OP('.',iter,OP('++',idx)));
				
				ast.push(WHILE(OP('<',idx,test),set));
				
				if (typ != 'var') {
					ast.push(blk = new Block());
					return blk.push(OP('=',l.node(),lvar));
				} else {
					return blk = null;
				};
				
				// not if splat was last?
				// ast.push(blk = VarBlock.new)
			} else if (lsplat) {
				if (!(blk)) { ast.push(blk = new blktype()) };
				// we could cache the raw code of this node for better performance
				return blk.push(OP('=',l,OP('.',iter,OP('++',idx))));
			} else {
				if (!(blk)) { ast.push(blk = new blktype()) };
				return blk.push(OP('=',l,OP('.',iter,num__(i))));
			};
		});
	};
	
	// if we are in an expression we really need to
	if (o.isExpression() && self._vars) {
		for (var i = 0, ary = iter$(self._vars), len_ = ary.length; i < len_; i++) {
			ary[i].variable().autodeclare();
		};
	} else if (self._vars) {
		for (var j = 0, items = iter$(self._vars), len__ = items.length; j < len__; j++) {
			items[j].variable().predeclared();
		};
	};
	
	// is there any reason to make it into an expression?
	if (ast.isExpressable()) { // NO!
		// if this is an expression
		var out = ast.c({expression: true});
		if (typ && !o.isExpression()) { out = ("" + typ + " " + out) }; // not in expression
		return out;
	} else {
		out = ast.c();
		// if this is a varblock
		return out;
	};
};


TupleAssign.prototype.c = function (o){
	var out = TupleAssign.__super__.c.call(this,o);
	// this is only used in tuple -- better to let the tuple hav a separate #c
	if (this._temporary && this._temporary.length) {
		this._temporary.map(function(temp) { return temp.decache(); });
	};
	return out;
};



// IDENTIFIERS

// really need to clean this up
// Drop the token?
function Identifier(value){
	this._value = this.load(value);
	this._symbol = null;
	this._setter = null;
	
	if (("" + value).indexOf("?") >= 0) {
		this._safechain = true;
	};
	// @safechain = ("" + value).indexOf("?") >= 0
	this;
};

subclass$(Identifier,Node);
exports.Identifier = Identifier; // export class 
Identifier.prototype.safechain = function(v){ return this._safechain; }
Identifier.prototype.setSafechain = function(v){ this._safechain = v; return this; };
Identifier.prototype.value = function(v){ return this._value; }
Identifier.prototype.setValue = function(v){ this._value = v; return this; };

Identifier.prototype.references = function (variable){
	if (this._value) { this._value._variable = variable };
	return this;
};

Identifier.prototype.sourceMapMarker = function (){
	return this._value.sourceMapMarker();
};

Identifier.prototype.load = function (v){
	return ((v instanceof Identifier) ? v.value() : v);
};

Identifier.prototype.traverse = function (){
	// NODES.push(self)
	return this;
};

Identifier.prototype.visit = function (){
	
	if (this._value instanceof Node) {
		// console.log "IDENTIFIER VALUE IS NODE"
		this._value.traverse();
	};
	return this;
};

Identifier.prototype.region = function (){
	return [this._value._loc,this._value._loc + this._value._len];
};

Identifier.prototype.isValidIdentifier = function (){
	return true;
};

Identifier.prototype.isReserved = function (){
	return this._value.reserved || RESERVED_TEST.test(String(this._value));
};

Identifier.prototype.symbol = function (){
	// console.log "Identifier#symbol {value}"
	return this._symbol || (this._symbol = sym__(this.value()));
};

Identifier.prototype.setter = function (){
	// console.log "Identifier#setter"
	var tok;
	return this._setter || (this._setter = (
	tok = new Token('IDENTIFIER',sym__('set-' + this._value),this._value._loc || -1),
	new Identifier(tok)
	// Identifier.new("set-{symbol}")
	));
};

Identifier.prototype.toString = function (){
	return String(this._value);
};

Identifier.prototype.toJSON = function (){
	return this.toString();
};

Identifier.prototype.alias = function (){
	return sym__(this._value);
};

Identifier.prototype.js = function (o){
	return this.symbol();
};

Identifier.prototype.c = function (){
	return '' + this.symbol(); // mark__(@value) +
};

Identifier.prototype.dump = function (){
	return {loc: this.region()};
};

Identifier.prototype.namepath = function (){
	return this.toString();
};

Identifier.prototype.shouldParenthesizeInTernary = function (){
	return this._parens || this._cache;
};

function TagId(v){
	this._value = (v instanceof Identifier) ? v.value() : v;
	this;
};

subclass$(TagId,Identifier);
exports.TagId = TagId; // export class 
TagId.prototype.c = function (){
	return ("" + (this.scope__().imba().c()) + ".getTagSingleton('" + this.value().c().substr(1) + "')");
};


// This is not an identifier - it is really a string
// Is this not a literal?

// FIXME Rename to IvarLiteral? or simply Literal with type Ivar
function Ivar(v){
	this._value = (v instanceof Identifier) ? v.value() : v;
	this;
};

subclass$(Ivar,Identifier);
exports.Ivar = Ivar; // export class 
Ivar.prototype.name = function (){
	return helpers.dashToCamelCase(this._value).replace(/^@/,'');
	// value.c.camelCase.replace(/^@/,'')
};

Ivar.prototype.alias = function (){
	return '_' + this.name();
};

// the @ should possibly be gone from the start?
Ivar.prototype.js = function (o){
	return '_' + this.name();
};

Ivar.prototype.c = function (){
	return '_' + helpers.dashToCamelCase(this._value).slice(1); // .replace(/^@/,'') # mark__(@value) +
};



// Ambiguous - We need to be consistent about Const vs ConstAccess
// Becomes more important when we implement typeinference and code-analysis
function Const(){ return Identifier.apply(this,arguments) };

subclass$(Const,Identifier);
exports.Const = Const; // export class 
Const.prototype.symbol = function (){
	// console.log "Identifier#symbol {value}"
	return this._symbol || (this._symbol = sym__(this.value()));
};

Const.prototype.js = function (o){
	return this._variable ? this._variable.c() : this.symbol();
};

Const.prototype.traverse = function (){
	if (this._traversed) {
		return;
	};
	
	this._traversed = true;
	var curr = STACK.current();
	if (!(curr instanceof Access) || curr.left() == this) {
		if (this.symbol() == "Imba") {
			this._variable = this.scope__().imba();
		} else {
			this._variable = this.scope__().lookup(this.value());
		};
	};
	return this;
};

Const.prototype.c = function (){
	if (this.option('export')) {
		return ("exports." + (this._value) + " = ") + mark__(this._value) + this.js();
	} else {
		return mark__(this._value) + this.js();
	};
};


function TagTypeIdentifier(value){
	this._value = this.load(value);
	this;
};

subclass$(TagTypeIdentifier,Identifier);
exports.TagTypeIdentifier = TagTypeIdentifier; // export class 
TagTypeIdentifier.prototype.name = function(v){ return this._name; }
TagTypeIdentifier.prototype.setName = function(v){ this._name = v; return this; };
TagTypeIdentifier.prototype.ns = function(v){ return this._ns; }
TagTypeIdentifier.prototype.setNs = function(v){ this._ns = v; return this; };

TagTypeIdentifier.prototype.load = function (val){
	this._str = ("" + val);
	var parts = this._str.split(":");
	this._raw = val;
	this._name = parts.pop();
	this._ns = parts.shift(); // if any?
	return this._str;
};

TagTypeIdentifier.prototype.js = function (o){
	return ("" + (this.scope__().tagContextPath()) + "." + this._str.replace(":","$"));
};

TagTypeIdentifier.prototype.c = function (){
	return this.js();
};

TagTypeIdentifier.prototype.func = function (){
	var name = this._name.replace(/-/g,'_').replace(/\#/,'');
	if (this._ns) { name += ("$" + (this._ns.toLowerCase())) };
	return name;
};

TagTypeIdentifier.prototype.isClass = function (){
	return this._name[0] == this._name[0].toUpperCase();
};

TagTypeIdentifier.prototype.spawner = function (){
	if (this._ns) {
		return ("_" + (this._ns.toUpperCase()) + "." + (this._name.replace(/-/g,'_').toUpperCase()));
	} else {
		return ("" + (this._name.replace(/-/g,'_').toUpperCase()));
	};
};

TagTypeIdentifier.prototype.id = function (){
	var m = this._str.match(/\#([\w\-\d\_]+)\b/);
	return m ? m[1] : null;
};


TagTypeIdentifier.prototype.flag = function (){
	return "_" + this.name().replace(/--/g,'_').toLowerCase();
};

TagTypeIdentifier.prototype.sel = function (){
	return ("." + this.flag()); // + name.replace(/-/g,'_').toLowerCase
};

TagTypeIdentifier.prototype.string = function (){
	return this.value();
};


function Argvar(){ return ValueNode.apply(this,arguments) };

subclass$(Argvar,ValueNode);
exports.Argvar = Argvar; // export class 
Argvar.prototype.c = function (){
	// NEXT -- global.parseInt or Number.parseInt (better)
	var v = parseInt(String(this.value()));
	// FIXME Not needed anymore? I think the lexer handles this
	if (v == 0) { return "arguments" };
	
	var s = this.scope__();
	// params need to go up to the closeste method-scope
	var par = s.params().at(v - 1,true);
	return ("" + c__(par.name())); // c
};


// CALL

function Call(callee,args,opexists){
	this._traversed = false;
	this._expression = false;
	this._parens = false;
	this._cache = null;
	this._receiver = null;
	this._opexists = opexists;
	// some axioms that share the same syntax as calls will be redirected from here
	
	if (callee instanceof VarOrAccess) {
		var str = callee.value().symbol();
		if (str == 'extern') {
			callee.value().value()._type = 'EXTERN';
			return new ExternDeclaration(args);
		};
		if (str == 'tag') {
			// console.log "ERROR - access args by some method"
			return new TagWrapper((args && args.index) ? args.index(0) : args[0]);
		};
		if (str == 'export') {
			return new Export(args);
		};
	};
	
	this._callee = callee;
	this._args = args || new ArgList([]);
	
	if (args instanceof Array) {
		this._args = new ArgList(args);
	};
	this;
};

subclass$(Call,Node);
exports.Call = Call; // export class 
Call.prototype.callee = function(v){ return this._callee; }
Call.prototype.setCallee = function(v){ this._callee = v; return this; };
Call.prototype.receiver = function(v){ return this._receiver; }
Call.prototype.setReceiver = function(v){ this._receiver = v; return this; };
Call.prototype.args = function(v){ return this._args; }
Call.prototype.setArgs = function(v){ this._args = v; return this; };
Call.prototype.block = function(v){ return this._block; }
Call.prototype.setBlock = function(v){ this._block = v; return this; };

Call.prototype.visit = function (){
	this.args().traverse();
	this.callee().traverse();
	// if the callee is a PropertyAccess - better to immediately change it
	
	return this._block && this._block.traverse();
};

Call.prototype.addBlock = function (block){
	var pos = this._args.filter(function(n,i) { return n == '&'; })[0]; // WOULD BE TOKEN - CAREFUL
	pos ? this.args().replace(pos,block) : this.args().push(block);
	return this;
};

Call.prototype.receiver = function (){
	return this._receiver || (this._receiver = ((this.callee() instanceof Access) && this.callee().left() || NULL));
};

// check if all arguments are expressions - otherwise we have an issue

Call.prototype.safechain = function (){
	return this.callee().safechain(); // really?
};

Call.prototype.shouldParenthesizeInTernary = function (){
	return this._parens || this.safechain() || this._cache;
};

Call.prototype.js = function (o){
	var opt = {expression: true};
	var rec = null;
	// var args = compact__(args) # really?
	var args = this.args();
	
	// drop this?
	
	var splat = args.some(function(v) { return v instanceof Splat; });
	
	var out = null;
	var lft = null;
	var rgt = null;
	var wrap = null;
	
	var callee = this._callee = this._callee.node(); // drop the var or access?
	
	// if callee isa Call && callee.safechain
	//	yes
	
	if (callee instanceof Access) {
		lft = callee.left();
		rgt = callee.right();
	};
	
	if ((callee instanceof Super) || (callee instanceof SuperAccess)) {
		this._receiver = this.scope__().context();
		// return "supercall"
	};
	
	// never call the property-access directly?
	if (callee instanceof PropertyAccess) { // && rec = callee.receiver
		this._receiver = callee.receiver();
		callee = this._callee = new Access(callee.op(),callee.left(),callee.right());
		// console.log "unwrapping the propertyAccess"
	};
	
	if ((rgt instanceof Identifier) && rgt.value() == 'len' && args.count() == 0) {
		return new Util.Len([lft || callee]).c();
		
		// rewrite a.len(..) to len$(a)
	};
	
	if (callee.safechain()) {
		// Does this affect shouldParenthesizeInTernary?
		// if lft isa Call
		// if lft isa Call # could be a property access as well - it is the same?
		// if it is a local var access we simply check if it is a function, then call
		// but it should be safechained outside as well?
		// lft.cache if lft
		// the outer safechain should not cache the whole call - only ask to cache
		// the result? -- chain onto
		var isfn = new Util.IsFunction([callee]);
		wrap = [("" + (isfn.c()) + "  &&  "),""];
		callee = OP('.',callee.left(),callee.right());
		// callee should already be cached now -
	};
	
	// should just force expression from the start, no?
	if (splat) {
		// important to wrap the single value in a value, to keep implicit call
		// this is due to the way we check for an outer Call without checking if
		// we are the receiver (in PropertyAccess). Should rather wrap in CallArguments
		var rec1 = this.receiver();
		var ary = ((args.count() == 1) ? new ValueNode(args.first().value()) : new Arr(args.list()));
		
		rec1.cache(); // need to cache the context as it will be referenced in apply
		out = ("" + callee.c({expression: true}) + ".apply(" + (rec1.c()) + "," + ary.c({expression: true}) + ")");
	} else if (this._receiver) {
		// quick workaround
		if (!((this._receiver instanceof ScopeContext))) { this._receiver.cache() };
		args.unshift(this.receiver());
		// should rather rewrite to a new call?
		out = ("" + callee.c({expression: true}) + ".call(" + args.c({expression: true}) + ")");
	} else {
		out = ("" + callee.c({expression: true}) + "(" + args.c({expression: true}) + ")");
	};
	
	if (wrap) {
		// we set the cachevar inside
		if (this._cache) {
			this._cache.manual = true;
			out = ("(" + (this.cachevar().c()) + "=" + out + ")");
		};
		
		out = [wrap[0],out,wrap[1]].join("");
	};
	
	return out;
};




function ImplicitCall(){ return Call.apply(this,arguments) };

subclass$(ImplicitCall,Call);
exports.ImplicitCall = ImplicitCall; // export class 
ImplicitCall.prototype.js = function (o){
	return ("" + (this.callee().c()) + "()");
};

function New(){ return Call.apply(this,arguments) };

subclass$(New,Call);
exports.New = New; // export class 
New.prototype.js = function (o){
	var target = this.callee();
	
	while (target instanceof Access){
		var left = target.left();
		
		if ((left instanceof PropertyAccess) || (left instanceof VarOrAccess)) {
			this.callee()._parens = true;
			break;
		};
		
		target = left;
	};
	
	var out = ("new " + (this.callee().c()));
	if (!((o.parent() instanceof Call))) { out += '()' };
	return out;
};

function SuperCall(){ return Call.apply(this,arguments) };

subclass$(SuperCall,Call);
exports.SuperCall = SuperCall; // export class 
SuperCall.prototype.js = function (o){
	var m = o.method();
	this.setReceiver(SELF);
	this.setCallee(("" + (m.target().c()) + ".super$.prototype." + (m.name().c())));
	return SuperCall.__super__.js.apply(this,arguments);
};



function ExternDeclaration(){ return ListNode.apply(this,arguments) };

subclass$(ExternDeclaration,ListNode);
exports.ExternDeclaration = ExternDeclaration; // export class 
ExternDeclaration.prototype.visit = function (){
	this.setNodes(this.map(function(item) { return item.node(); })); // drop var or access really
	// only in global scope?
	var root = this.scope__();
	for (var i = 0, ary = iter$(this.nodes()), len = ary.length, item; i < len; i++) {
		item = ary[i];
		var variable = root.register(item.symbol(),item,{type: 'global'});
		variable.addReference(item);
	};
	return this;
};

ExternDeclaration.prototype.c = function (){
	return "// externs";
};


// FLOW

function ControlFlow(){ return Node.apply(this,arguments) };

subclass$(ControlFlow,Node);
exports.ControlFlow = ControlFlow; // export class 
ControlFlow.prototype.loc = function (){
	return this._body ? this._body.loc() : [0,0];
};

function ControlFlowStatement(){ return ControlFlow.apply(this,arguments) };

subclass$(ControlFlowStatement,ControlFlow);
exports.ControlFlowStatement = ControlFlowStatement; // export class 
ControlFlowStatement.prototype.isExpressable = function (){
	return false;
};



function If(cond,body,o){
	if(o === undefined) o = {};
	this.setup();
	this._test = cond; // (o:type == 'unless' ? UnaryOp.new('!',cond,null) : cond)
	this._body = body;
	this._alt = null;
	this._type = o.type;
	if (this._type == 'unless') this.invert();
	this._scope = new IfScope(this);
	this;
};

subclass$(If,ControlFlow);
exports.If = If; // export class 
If.prototype.test = function(v){ return this._test; }
If.prototype.setTest = function(v){ this._test = v; return this; };
If.prototype.body = function(v){ return this._body; }
If.prototype.setBody = function(v){ this._body = v; return this; };
If.prototype.alt = function(v){ return this._alt; }
If.prototype.setAlt = function(v){ this._alt = v; return this; };
If.prototype.scope = function(v){ return this._scope; }
If.prototype.setScope = function(v){ this._scope = v; return this; };
If.prototype.prevIf = function(v){ return this._prevIf; }
If.prototype.setPrevIf = function(v){ this._prevIf = v; return this; };

If.ternary = function (cond,body,alt){
	// prefer to compile it this way as well
	var obj = new If(cond,new Block([body]),{type: '?'});
	obj.addElse(new Block([alt]));
	return obj;
};

If.prototype.addElse = function (add){
	if (this.alt() && (this.alt() instanceof If)) {
		this.alt().addElse(add);
	} else {
		this.setAlt(add);
		if (add instanceof If) {
			add.setPrevIf(this);
		};
	};
	return this;
};

If.prototype.loc = function (){
	return this._loc || (this._loc = [this._type ? this._type._loc : 0,this.body().loc()[1]]);
};

If.prototype.invert = function (){
	if (this._test instanceof ComparisonOp) {
		return this._test = this._test.invert();
	} else {
		return this._test = new UnaryOp('!',this._test,null);
	};
};

If.prototype.visit = function (){
	var alt = this.alt();
	
	if (this._scope) { this._scope.visit() };
	if (this.test()) { this.test().traverse() };
	
	if (!this.stack().isAnalyzing()) {
		this._pretest = truthy__(this.test());
		
		if (this._pretest === true) {
			alt = this._alt = null;
		} else if (this._pretest === false) {
			this.loc(); // cache location before removing body
			this.setBody(null);
		};
	};
	
	if (this.body()) { this.body().traverse() };
	
	// should skip the scope in alt.
	if (alt) {
		STACK.pop(this);
		alt._scope || (alt._scope = new BlockScope(alt));
		alt.traverse();
		STACK.push(this);
	};
	
	// force it as expression?
	if (this._type == '?' && this.isExpressable()) this.toExpression();
	return this;
};


If.prototype.js = function (o){
	var v_, test_;
	var body = this.body();
	// would possibly want to look up / out
	var brace = {braces: true,indent: true};
	
	if (this._pretest === true) {
		// what if it is inside expression?
		var js = body ? body.c({braces: !(!(this.prevIf()))}) : 'true';
		
		if (!(this.prevIf())) {
			js = helpers.normalizeIndentation(js);
		};
		
		if (o.isExpression()) {
			js = '(' + js + ')';
		};
		
		return js;
	} else if (this._pretest === false) {
		if (this.alt() instanceof If) { (this.alt().setPrevIf(v_ = this.prevIf()),v_) };
		var js1 = this.alt() ? this.alt().c({braces: !(!(this.prevIf()))}) : '';
		
		if (!(this.prevIf())) {
			js1 = helpers.normalizeIndentation(js1);
		};
		
		return js1;
	};
	
	
	if (o.isExpression()) {
		
		if ((test_ = this.test()) && test_.shouldParenthesizeInTernary  &&  test_.shouldParenthesizeInTernary()) {
			this.test()._parens = true;
		};
		
		var cond = this.test().c({expression: true}); // the condition is always an expression
		
		var code = body ? body.c() : 'true'; // (braces: yes)
		
		if (body && body.shouldParenthesizeInTernary()) {
			code = '(' + code + ')'; // if code.indexOf(',') >= 0
		};
		
		if (this.alt()) {
			var altbody = this.alt().c();
			if (this.alt().shouldParenthesizeInTernary()) {
				altbody = '(' + altbody + ')';
			};
			
			return ("" + cond + " ? " + code + " : " + altbody);
		} else {
			// again - we need a better way to decide what needs parens
			// maybe better if we rewrite this to an OP('&&'), and put
			// the parens logic there
			// cond should possibly have parens - but where do we decide?
			if (this._tagtree) {
				return ("" + cond + " ? " + code + " : void(0)");
			} else {
				return ("" + cond + " && " + code);
			};
		};
	} else {
		// if there is only a single item - and it is an expression?
		code = null;
		cond = this.test().c({expression: true}); // the condition is always an expression
		
		// if body.count == 1 # dont indent by ourselves?
		
		if ((body instanceof Block) && body.count() == 1 && !(body.first() instanceof LoopFlowStatement)) {
			body = body.first();
		};
		
		// if body.count == 1
		//	p "one item only!"
		//	body = body.first
		
		code = body ? body.c({braces: true}) : '{}'; // (braces: yes)
		
		// don't wrap if it is only a single expression?
		var out = ("" + mark__(this._type) + "if (" + cond + ") ") + code; // ' {' + code + '}' # '{' + code + '}'
		if (this.alt()) { out += (" else " + this.alt().c((this.alt() instanceof If) ? {} : brace)) };
		return out;
	};
};

If.prototype.sourceMapMarker = function (){
	return this;
};

If.prototype.shouldParenthesize = function (){
	return !(!this._parens);
};

If.prototype.consume = function (node){
	// if it is possible, convert into expression
	if (node instanceof TagTree) {
		if (this._body) { this._body = this._body.consume(node) };
		if (this._alt) { this._alt = this._alt.consume(node) };
		this._tagtree = node;
		return this;
	};
	
	if (node instanceof TagPushAssign) {
		if (this._body) { this._body = this._body.consume(node) };
		if (this._alt) { this._alt = this._alt.consume(node) };
		return this;
	};
	
	// special case for If created from conditional assign as well?
	// @type == '?' and
	// ideally we dont really want to make any expression like this by default
	var isRet = (node instanceof Return);
	
	// might have been forced to expression already
	// if it was originally a ternary - why not
	if (this._expression || ((!(isRet) || this._type == '?') && this.isExpressable())) {
		this.toExpression(); // mark as expression(!) - is this needed?
		return If.__super__.consume.call(this,node);
	} else {
		if (this._body) { this._body = this._body.consume(node) };
		if (this._alt) { this._alt = this._alt.consume(node) };
	};
	return this;
};


If.prototype.isExpressable = function (){
	// process:stdout.write 'x'
	var exp = (!(this.body()) || this.body().isExpressable()) && (!(this.alt()) || this.alt().isExpressable());
	return exp;
};



function Loop(options){
	if(options === undefined) options = {};
	this._traversed = false;
	this._options = options;
	this._body = null;
	this;
};

subclass$(Loop,Statement);
exports.Loop = Loop; // export class 
Loop.prototype.scope = function(v){ return this._scope; }
Loop.prototype.setScope = function(v){ this._scope = v; return this; };
Loop.prototype.options = function(v){ return this._options; }
Loop.prototype.setOptions = function(v){ this._options = v; return this; };
Loop.prototype.body = function(v){ return this._body; }
Loop.prototype.setBody = function(v){ this._body = v; return this; };
Loop.prototype.catcher = function(v){ return this._catcher; }
Loop.prototype.setCatcher = function(v){ this._catcher = v; return this; };

Loop.prototype.loc = function (){
	var a = this._options.keyword;
	var b = this._body;
	
	if (a && b) {
		// FIXME does not support POST_ variants yet
		return [a._loc,b.loc()[1]];
	} else {
		return [0,0];
	};
};

Loop.prototype.set = function (obj){
	this._options || (this._options = {});
	var keys = Object.keys(obj);
	for (var i = 0, ary = iter$(keys), len = ary.length, k; i < len; i++) {
		k = ary[i];
		this._options[k] = obj[k];
	};
	return this;
};


Loop.prototype.addBody = function (body){
	this.setBody(blk__(body));
	return this;
};


Loop.prototype.c = function (o){
	
	var s = this.stack();
	var curr = s.current();
	
	
	
	if (this.stack().isExpression() || this.isExpression()) {
		// what the inner one should not be an expression though?
		// this will resut in an infinite loop, no?!?
		this.scope().closeScope();
		var ast = CALL(FN([],[this]),[]);
		return ast.c(o);
	} else if ((this.stack().current() instanceof Block) || ((s.up() instanceof Block) && s.current()._consumer == this)) {
		return Loop.__super__.c.call(this,o);
	} else {
		this.scope().closeScope();
		ast = CALL(FN([],[this]),[]);
		// scope.context.reference
		return ast.c(o);
		// need to wrap in function
	};
};



function While(test,opts){
	this._traversed = false;
	this._test = test;
	this._options = opts || {};
	this._scope = new WhileScope(this);
	// set(opts) if opts
	if (this.option('invert')) {
		// "invert test for while {@test}"
		this._test = test.invert();
	};
	// invert the test
};


subclass$(While,Loop);
exports.While = While; // export class 
While.prototype.test = function(v){ return this._test; }
While.prototype.setTest = function(v){ this._test = v; return this; };

While.prototype.visit = function (){
	this.scope().visit();
	if (this.test()) { this.test().traverse() };
	if (this.body()) { return this.body().traverse() };
};

While.prototype.loc = function (){
	var o = this._options;
	return helpers.unionOfLocations(o.keyword,this._body,o.guard,this._test);
};

// TODO BUG -- when we declare a var like: while var y = ...
// the variable will be declared in the WhileScope which never
// force-declares the inner variables in the scope

While.prototype.consume = function (node){
	// This is never expressable, but at some point
	// we might want to wrap it in a function (like CS)
	if (this.isExpressable()) { return While.__super__.consume.apply(this,arguments) };
	
	if (node instanceof TagTree) {
		// WARN this is a hack to allow references coming through the wrapping scope
		// will result in unneeded self-declarations and other oddities
		this.scope().closeScope();
		return CALL(FN([],[this]),[]);
	};
	
	var reuse = false;
	// WARN Optimization - might have untended side-effects
	// if we are assigning directly to a local variable, we simply
	// use said variable for the inner res
	// if reuse
	// 	resvar = scope.declare(node.left.node.variable,Arr.new([]),proxy: yes)
	// 	node = null
	// 	p "consume variable declarator!?".cyan
	// else
	// declare the variable we will use to soak up results
	// TODO Use a special vartype for this?
	var resvar = this.scope().declare('res',new Arr([]),{system: true});
	// WHAT -- fix this --
	this._catcher = new PushAssign("push",resvar,null); // the value is not preset # what
	this.body().consume(this._catcher); // should still return the same body
	
	// scope vars must not be compiled before this -- this is important
	var ast = new Block([this,resvar.accessor()]); // should be varaccess instead?
	return ast.consume(node);
	// NOTE Here we can find a way to know wheter or not we even need to
	// return the resvar. Often it will not be needed
	// FIXME what happens if there is no node?!?
};


While.prototype.js = function (o){
	var out = ("while (" + this.test().c({expression: true}) + ")") + this.body().c({braces: true,indent: true}); // .wrap
	
	if (this.scope().vars().count() > 0) {
		return [this.scope().vars().c(),out];
	};
	return out;
};



// This should define an open scope
// should rather
function For(o){
	if(o === undefined) o = {};
	this._traversed = false;
	this._options = o;
	this._scope = new ForScope(this);
	this._catcher = null;
};

subclass$(For,Loop);
exports.For = For; // export class 
For.prototype.loc = function (){
	var o = this._options;
	return helpers.unionOfLocations(o.keyword,this._body,o.guard,o.step,o.source);
};

For.prototype.visit = function (){
	this.scope().visit();
	
	this.options().source.traverse(); // what about awakening the vars here?
	this.declare();
	// should be able to toggle whether to keep the results here already(!)
	
	// add guard to body
	if (this.options().guard) {
		var op = IF(this.options().guard.invert(),Block.wrap([new ContinueStatement("continue")]));
		this.body().unshift(op,BR);
	};
	
	return this.body().traverse();
};

For.prototype.isBare = function (src){
	return src && src._variable && src._variable._isArray;
};

For.prototype.declare = function (){
	var o = this.options();
	var scope = this.scope();
	var src = o.source;
	var vars = o.vars = {};
	var oi = o.index;
	
	var bare = this.isBare(src);
	
	// what about a range where we also include an index?
	if (src instanceof Range) {
		
		var from = src.left();
		var to = src.right();
		var dynamic = !((from instanceof Num)) || !((to instanceof Num));
		
		if (to instanceof Num) {
			vars.len = to;
		} else {
			// vars:len = scope.vars.push(vars:index.assignment(src.left))
			// vars:len = to.cache(force: yes, pool: 'len').predeclare
			vars.len = scope.declare('len',to,{type: 'let'});
			// to.cache(force: yes, pool: 'len').predeclare
		};
		
		// scope.vars.push(vars:index.assignment(src.left))
		vars.value = scope.declare(o.name,from,{type: 'let'});
		if (o.name) { vars.value.addReference(o.name) };
		
		if (o.index) {
			vars.index = scope.declare(o.index,0,{type: 'let'});
			vars.index.addReference(o.index);
		} else {
			vars.index = vars.value;
		};
		
		if (dynamic) {
			vars.diff = scope.declare('rd',OP('-',vars.len,vars.value),{type: 'let'});
		};
	} else {
		// we are using automatic caching far too much here
		var i = vars.index = oi ? scope.declare(oi,0,{type: 'let'}) : this.util().counter(0,true,scope).predeclare();
		
		vars.source = bare ? src : this.util().iterable(src,true).predeclare();
		vars.len = this.util().len(vars.source,true).predeclare();
		
		vars.value = scope.declare(o.name,null,{type: 'let'});
		vars.value.addReference(o.name); // adding reference!
		if (oi) { i.addReference(oi) };
	};
	
	return this;
};


For.prototype.consume = function (node){
	
	var receiver;
	if (this.isExpressable()) {
		return For.__super__.consume.apply(this,arguments);
	};
	
	// other cases as well, no?
	if (node instanceof TagTree) {
		this.scope().closeScope();
		
		node._loop = this;
		this._tagtree = node;
		
		this.body().consume(node);
		
		node._loop = null;
		var fn = new Lambda([],[this]);
		fn.scope().wrap(this.scope());
		// TODO Scope of generated lambda should be added into stack for
		// variable naming / resolution
		return CALL(fn,[]);
	};
	
	
	if (this._resvar) {
		var ast = new Block([this,BR,this._resvar.accessor()]);
		ast.consume(node);
		return ast;
	};
	
	var resvar = null;
	var reuseable = false; // node isa Assign && node.left.node isa LocalVarAccess
	var assignee = null;
	// might only work for locals?
	if (node instanceof Assign) {
		if (receiver = node.left()) {
			if (assignee = receiver._variable) {
				// we can only pull the var reference into the scope
				// if we know that the variable is declared in this scope
				reuseable = (receiver instanceof VarReference);
			};
		};
	};
	
	// WARN Optimization - might have untended side-effects
	// if we are assigning directly to a local variable, we simply
	// use said variable for the inner res
	if (reuseable && assignee) {
		// instead of declaring it in the scope - why not declare it outside?
		// it might already exist in the outer scope no?
		// assignee.resolve
		// should probably instead alter the assign-node to set value to a blank array
		// resvar = scope.parent.declare(assignee,Arr.new([]),proxy: yes,pos: 0)
		
		// this variable should really not be redeclared inside here at all
		assignee.resolve();
		// resvar = @resvar = scope.declare(assignee,Arr.new([]),proxy: yes)
		
		// dont declare it - simply push an assign into the vardecl of scope
		this.scope().vars().unshift(OP('=',assignee,new Arr([])));
		resvar = this._resvar = assignee;
		
		
		node._consumer = this;
		node = null;
	} else {
		// declare the variable we will use to soak up results
		// what about a pool here?
		resvar = this._resvar || (this._resvar = this.scope().declare('res',new Arr([]),{system: true,type: 'let'}));
	};
	
	if (this._tagtree) {
		this._catcher = new TagPushAssign("push",resvar,null);
	} else {
		this._catcher = new PushAssign("push",resvar,null); // the value is not preset
	};
	
	this.body().consume(this._catcher); // should still return the same body
	
	if (node) {
		ast = new Block([this,BR,resvar.accessor().consume(node)]);
		return ast;
	};
	// var ast = Block.new([self,BR,resvar.accessor])
	// ast.consume(node) if node
	// return ast
	return this;
	
	// this is never an expression (for now -- but still)
	// return ast
};


For.prototype.js = function (o){
	var vars = this.options().vars;
	var idx = vars.index;
	var val = vars.value;
	var src = this.options().source;
	
	var cond;
	var final;
	
	
	if (src instanceof Range) {
		var a = src.left();
		var b = src.right();
		var inc = src.inclusive();
		
		cond = OP(inc ? '<=' : '<',val,vars.len);
		final = OP('++',val);
		
		if (vars.diff) {
			cond = If.ternary(OP('>',vars.diff,new Num(0)),cond,OP(inc ? '>=' : '>',val,vars.len));
			final = If.ternary(OP('>',vars.diff,new Num(0)),OP('++',val),OP('--',val));
		};
		
		if (idx && idx != val) {
			final = new ExpressionBlock([final,OP('++',idx)]);
		};
	} else {
		cond = OP('<',idx,vars.len);
		
		if (val.refcount() < 3 && val.assignments().length == 0) {
			val.proxy(vars.source,idx);
		} else {
			this.body().unshift(OP('=',val,OP('.',vars.source,idx)),BR);
		};
		
		if (this.options().step) {
			final = OP('=',idx,OP('+',idx,this.options().step));
		} else {
			final = OP('++',idx);
		};
	};
	
	var head = ("" + mark__(this.options().keyword) + "for (" + (this.scope().vars().c()) + "; " + cond.c({expression: true}) + "; " + final.c({expression: true}) + ") ");
	return head + this.body().c({braces: true,indent: true});
};



function ForIn(){ return For.apply(this,arguments) };

subclass$(ForIn,For);
exports.ForIn = ForIn; // export class 




function ForOf(){ return For.apply(this,arguments) };

subclass$(ForOf,For);
exports.ForOf = ForOf; // export class 
ForOf.prototype.declare = function (){
	var o = this.options();
	var vars = o.vars = {};
	
	var src = vars.source = o.source._variable || this.scope().declare('o',o.source,{system: true,type: 'let'});
	if (o.index) { var v = vars.value = this.scope().declare(o.index,null,{let: true,type: 'let'}) };
	
	// possibly proxy the index-variable?
	
	if (o.own) {
		// var i = vars:index = scope.declare('i',0,system: true, type: 'let') # mark as a counter?
		// var i = vars:index = util.counter(0,yes,scope).predeclare
		var i = vars.index = this.scope().declare('i',new Num(0),{system: true,type: 'counter',unique: true});
		
		// systemvariable -- should not really be added to the map
		var keys = vars.keys = this.scope().declare('keys',Util.keys(src.accessor()),{system: true,type: 'let'}); // the outer one should resolve first
		var l = vars.len = this.scope().declare('l',Util.len(keys.accessor()),{system: true,type: 'let'});
		var k = vars.key = this.scope().declare(o.name,null,{type: 'let'}); // scope.declare(o:name,null,system: yes)
	} else {
		// we set the var -- why even declare it
		// no need to declare -- it will declare itself in the loop - no?
		k = vars.key = this.scope().register(o.name,o.name,{type: 'let'});
	};
	
	// TODO use util - why add references already? Ah -- this is for the highlighting
	if (v && o.index) { v.addReference(o.index) };
	if (k && o.name) { k.addReference(o.name) };
	
	return this;
};

ForOf.prototype.js = function (o){
	var vars = this.options().vars;
	
	var o = vars.source;
	var k = vars.key;
	var v = vars.value;
	var i = vars.index;
	
	var code;
	
	if (v) {
		// set value as proxy of object[key]
		// possibly make it a ref? what is happening?
		// v.refcount < 3 ? v.proxy(o,k) : 
		if (v.refcount() > 0) {
			this.body().unshift(OP('=',v,OP('.',o,k)));
		};
	};
	
	if (this.options().own) {
		
		// if k.refcount < 3 # should probably adjust these
		//	k.proxy(vars:keys,i)
		// else
		this.body().unshift(OP('=',k,OP('.',vars.keys,i)));
		code = this.body().c({indent: true,braces: true}); // .wrap
		var head = ("" + mark__(this.options().keyword) + "for (" + (this.scope().vars().c()) + "; " + (OP('<',i,vars.len).c()) + "; " + (OP('++',i).c()) + ")");
		return head + code;
	};
	
	code = this.body().c({braces: true,indent: true});
	// it is really important that this is a treated as a statement
	return this.scope().vars().c() + (";\n" + mark__(this.options().keyword) + "for (var " + (k.c()) + " in " + (o.c()) + ")") + code;
};

ForOf.prototype.head = function (){
	var v = this.options().vars;
	
	return [
		OP('=',v.key,OP('.',v.keys,v.index)),
		v.value && OP('=',v.value,OP('.',v.source,v.key))
	];
};

// NO NEED?
function Begin(body){
	this._nodes = blk__(body).nodes();
};


subclass$(Begin,Block);
exports.Begin = Begin; // export class 
Begin.prototype.shouldParenthesize = function (){
	return this.isExpression();
};



function Switch(a,b,c){
	this._traversed = false;
	this._source = a;
	this._cases = b;
	this._fallback = c;
};


subclass$(Switch,ControlFlowStatement);
exports.Switch = Switch; // export class 
Switch.prototype.source = function(v){ return this._source; }
Switch.prototype.setSource = function(v){ this._source = v; return this; };
Switch.prototype.cases = function(v){ return this._cases; }
Switch.prototype.setCases = function(v){ this._cases = v; return this; };
Switch.prototype.fallback = function(v){ return this._fallback; }
Switch.prototype.setFallback = function(v){ this._fallback = v; return this; };


Switch.prototype.visit = function (){
	for (var i = 0, ary = iter$(this.cases()), len = ary.length; i < len; i++) {
		ary[i].traverse();
	};
	if (this.fallback()) { this.fallback().visit() };
	if (this.source()) { this.source().visit() };
	return;
};


Switch.prototype.consume = function (node){
	// TODO work inside tags (like loops)
	this._cases = this._cases.map(function(item) { return item.consume(node); });
	if (this._fallback) { this._fallback = this._fallback.consume(node) };
	return this;
};

Switch.prototype.c = function (o){
	if (this.stack().isExpression() || this.isExpression()) {
		var ast = CALL(FN([],[this]),[]);
		return ast.c(o);
	};
	
	return Switch.__super__.c.call(this,o);
};


Switch.prototype.js = function (o){
	var body = [];
	
	for (var i = 0, ary = iter$(this.cases()), len = ary.length, part; i < len; i++) {
		part = ary[i];
		part.autobreak();
		body.push(part);
	};
	
	if (this.fallback()) {
		body.push("default:\n" + this.fallback().c({indent: true}));
	};
	
	return ("switch (" + (this.source().c()) + ") ") + helpers.bracketize(cary__(body).join("\n"),true);
};



function SwitchCase(test,body){
	this._traversed = false;
	this._test = test;
	this._body = blk__(body);
};

subclass$(SwitchCase,ControlFlowStatement);
exports.SwitchCase = SwitchCase; // export class 
SwitchCase.prototype.test = function(v){ return this._test; }
SwitchCase.prototype.setTest = function(v){ this._test = v; return this; };
SwitchCase.prototype.body = function(v){ return this._body; }
SwitchCase.prototype.setBody = function(v){ this._body = v; return this; };


SwitchCase.prototype.visit = function (){
	return this.body().traverse();
};


SwitchCase.prototype.consume = function (node){
	this.body().consume(node);
	return this;
};


SwitchCase.prototype.autobreak = function (){
	if (!((this.body().last() instanceof BreakStatement))) { this.body().push(new BreakStatement()) };
	return this;
};


SwitchCase.prototype.js = function (o){
	if (!((this._test instanceof Array))) { this._test = [this._test] };
	var cases = this._test.map(function(item) { return ("case " + (item.c()) + ":"); });
	return cases.join("\n") + this.body().c({indent: true}); // .indent
};



function Try(body,c,f){
	this._traversed = false;
	this._body = blk__(body);
	this._catch = c;
	this._finally = f;
};


subclass$(Try,ControlFlowStatement);
exports.Try = Try; // export class 
Try.prototype.body = function(v){ return this._body; }
Try.prototype.setBody = function(v){ this._body = v; return this; };
// prop ncatch
// prop nfinally

Try.prototype.consume = function (node){
	this._body = this._body.consume(node);
	if (this._catch) { this._catch = this._catch.consume(node) };
	if (this._finally) { this._finally = this._finally.consume(node) };
	return this;
};


Try.prototype.visit = function (){
	this._body.traverse();
	if (this._catch) { this._catch.traverse() };
	if (this._finally) { return this._finally.traverse() };
	// no blocks - add an empty catch
};


Try.prototype.js = function (o){
	var out = "try " + this.body().c({braces: true,indent: true});
	if (this._catch) { out += " " + this._catch.c() };
	if (this._finally) { out += " " + this._finally.c() };
	
	if (!(this._catch || this._finally)) {
		out += (" catch (e) \{ \}");
	};
	out += ";";
	return out;
};



function Catch(body,varname){
	this._traversed = false;
	this._body = blk__(body || []);
	this._scope = new CatchScope(this);
	this._varname = varname;
	this;
};

subclass$(Catch,ControlFlowStatement);
exports.Catch = Catch; // export class 
Catch.prototype.body = function(v){ return this._body; }
Catch.prototype.setBody = function(v){ this._body = v; return this; };

Catch.prototype.consume = function (node){
	this._body = this._body.consume(node);
	return this;
};


Catch.prototype.visit = function (){
	this._scope.visit();
	this._variable = this._scope.register(this._varname,this,{pool: 'catchvar'});
	return this._body.traverse();
};


Catch.prototype.js = function (o){
	// only indent if indented by default?
	return ("catch (" + (this._variable.c()) + ") ") + this._body.c({braces: true,indent: true});
};


// repeating myself.. don't deal with it until we move to compact tuple-args
// for all astnodes


function Finally(body){
	this._traversed = false;
	this._body = blk__(body || []);
};


subclass$(Finally,ControlFlowStatement);
exports.Finally = Finally; // export class 
Finally.prototype.visit = function (){
	return this._body.traverse();
};


Finally.prototype.consume = function (node){
	// swallow silently
	return this;
};


Finally.prototype.js = function (o){
	return "finally " + this._body.c({braces: true,indent: true});
};


// RANGE

function Range(){ return Op.apply(this,arguments) };

subclass$(Range,Op);
exports.Range = Range; // export class 
Range.prototype.inclusive = function (){
	return this.op() == '..';
};

Range.prototype.c = function (){
	return "range";
};


function Splat(){ return ValueNode.apply(this,arguments) };

subclass$(Splat,ValueNode);
exports.Splat = Splat; // export class 
Splat.prototype.js = function (o){
	var par = this.stack().parent();
	if ((par instanceof ArgList) || (par instanceof Arr)) {
		return ("[].slice.call(" + (this.value().c()) + ")");
	} else {
		this.p(("what is the parent? " + par));
		return "SPLAT";
	};
};

Splat.prototype.node = function (){
	return this.value();
};





// TAGS

var TAG_TYPES = {};
var TAG_ATTRS = {};

TAG_TYPES.HTML = "a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr".split(" ");

TAG_TYPES.SVG = "circle defs ellipse g line linearGradient mask path pattern polygon polylineradialGradient rect stop svg text tspan".split(" ");

TAG_ATTRS.HTML = "accept accessKey action allowFullScreen allowTransparency alt async autoComplete autoFocus autoPlay cellPadding cellSpacing charSet checked className cols colSpan content contentEditable contextMenu controls coords crossOrigin data dateTime defer dir disabled download draggable encType form formNoValidate frameBorder height hidden href hrefLang htmlFor httpEquiv icon id label lang list loop max maxLength mediaGroup method min multiple muted name noValidate pattern placeholder poster preload radioGroup readOnly rel required role rows rowSpan sandbox scope scrollLeft scrolling scrollTop seamless selected shape size span spellCheck src srcDoc srcSet start step style tabIndex target title type useMap value width wmode";

TAG_ATTRS.SVG = "cx cy d dx dy fill fillOpacity fontFamily fontSize fx fy gradientTransform gradientUnits markerEnd markerMid markerStart offset opacity patternContentUnits patternUnits points preserveAspectRatio r rx ry spreadMethod stopColor stopOpacity stroke strokeDasharray strokeLinecap strokeOpacity strokeWidth textAnchor transform version viewBox x1 x2 x y1 y2 y";


function TagDesc(){
	this.p('TagDesc!!!',arguments);
	this;
};

subclass$(TagDesc,Node);
exports.TagDesc = TagDesc; // export class 
TagDesc.prototype.classes = function (){
	this.p('TagDescClasses',arguments);
	return this;
};

function Tag(o){
	if(o === undefined) o = {};
	this._traversed = false;
	this._parts = [];
	o.classes || (o.classes = []);
	o.attributes || (o.attributes = []);
	o.classes || (o.classes = []);
	this._options = o;
	this._reference = null;
	this._object = null;
	this._tree = null;
	this;
};

subclass$(Tag,Node);
exports.Tag = Tag; // export class 
Tag.prototype.parts = function(v){ return this._parts; }
Tag.prototype.setParts = function(v){ this._parts = v; return this; };
Tag.prototype.object = function(v){ return this._object; }
Tag.prototype.setObject = function(v){ this._object = v; return this; };
Tag.prototype.reactive = function(v){ return this._reactive; }
Tag.prototype.setReactive = function(v){ this._reactive = v; return this; };
Tag.prototype.parent = function(v){ return this._parent; }
Tag.prototype.setParent = function(v){ this._parent = v; return this; };
Tag.prototype.tree = function(v){ return this._tree; }
Tag.prototype.setTree = function(v){ this._tree = v; return this; };

Tag.prototype.set = function (obj){
	for (var v, i = 0, keys = Object.keys(obj), l = keys.length, k; i < l; i++){
		k = keys[i];v = obj[k];if (k == 'attributes') {
			for (var j = 0, ary = iter$(v), len = ary.length; j < len; j++) {
				this.addAttribute(ary[j]);
			};
			continue;
		};
		
		this._options[k] = v;
	};
	return this;
};

Tag.prototype.addClass = function (node){
	if (!((node instanceof TagFlag))) {
		node = new TagFlag(node);
	};
	this._options.classes.push(node);
	this._parts.push(node);
	return this;
};

Tag.prototype.addIndex = function (node){
	this._parts.push(node);
	this._object = node;
	return this;
};

Tag.prototype.addSymbol = function (node){
	if (this._parts.length == 0) {
		this._parts.push(node);
		this._options.ns = node;
	};
	return this;
};


Tag.prototype.addAttribute = function (atr){
	this._parts.push(atr);
	this._options.attributes.push(atr);
	return this;
};

Tag.prototype.enclosing = function (){
	return this._options.close && this._options.close.value();
};

Tag.prototype.type = function (){
	return this._options.type || 'div';
};

Tag.prototype.consume = function (node){
	var o = this._options;
	
	
	if (node instanceof TagTree) {
		this.setParent(node.root());
		
		if (node._loop) {
			// alwatys make items in loop reactive
			this.setReactive(node.reactive() || this.option('key'));
			this.option('loop',node._loop);
			
			if (this.option('ivar')) {
				this.warn(("Tag inside loop can not have a static reference " + this.option('ivar')),{type: 'error',token: this.option('ivar').value()});
			};
		} else {
			this.setReactive(node.reactive() || !(!this.option('ivar')));
		};
		
		return this;
	};
	
	return Tag.__super__.consume.apply(this,arguments);
};


Tag.prototype.visit = function (){
	var o = this._options;
	
	if (o.ivar || o.key) {
		this.setReactive(true);
	};
	
	var typ = this.enclosing();
	
	if (typ == '->' || typ == '=>') {
		this._tree = new TagFragmentTree(this,o.body,{root: this,reactive: true});
		this._fragment = o.body = new TagFragmentFunc([],Block.wrap([this._tree]),null,null,{closed: typ == '->'});
	};
	
	if (o.key) { o.key.traverse() };
	if (o.body) { o.body.traverse() };
	if (o.id) { o.id.traverse() };
	
	for (var i = 0, ary = iter$(this._parts), len = ary.length; i < len; i++) {
		ary[i].traverse();
	};
	
	// remember scope
	this._tagScope = this.scope__();
	// if typ == '->' or typ == '=>'
	// 	@tagScope = o:body.scope
	
	return this;
};

Tag.prototype.reference = function (){
	return this._reference || (this._reference = this._tagScope.closure().temporary(this,{pool: 'tag'}).resolve());
};

Tag.prototype.closureCache = function (){
	return this._closureCache || (this._closureCache = this._tagScope.tagContextCache());
};


Tag.prototype.staticCache = function (){
	if (this._fragment) {
		return this._staticCache || (this._staticCache = this._fragment.scope().declare("__",OP('.',new This(),'__'))); // .tagContextCache
	} else if (this.type() instanceof Self) {
		return this._staticCache || (this._staticCache = this._tagScope.tagContextCache());
	} else if (this.explicitKey() || this.option('loop')) {
		return this._staticCache || (this._staticCache = OP('.',this.reference(),'__'));
	} else if (this._parent) {
		return this._staticCache || (this._staticCache = this._parent.staticCache());
	};
};

Tag.prototype.explicitKey = function (){
	return this.option('ivar') || this.option('key');
};

Tag.prototype.js = function (jso){
	var body, loop_;
	var o = this._options;
	var a = {};
	var enc = this.enclosing();
	
	var setup = [];
	var calls = [];
	var statics = [];
	
	var scope = this.scope__();
	var commit = "end";
	var content = o.body;
	
	var isSelf = (this.type() instanceof Self);
	var bodySetter = isSelf ? "setChildren" : "setContent";
	
	// if we are reactive - find the
	
	// should not cache statics if the node itself is not cached
	// that would only mangle the order in which we set the properties
	var cacheStatics = true;
	
	for (var i = 0, ary = iter$(o.attributes), len = ary.length, atr; i < len; i++) {
		atr = ary[i];
		a[atr.key()] = atr.value();
	};
	
	var quote = function(str) { return helpers.singlequote(str); };
	var id = (o.id instanceof Node) ? o.id.c() : ((o.id && quote(o.id.c())));
	var tree = this._tree || null;
	var parent = this.parent();
	var c_zone = scope.context().c();
	
	var out = isSelf ? (
		commit = "synced",
		this.setReactive(true),
		this._reference = scope.context(),
		scope.context().c()
	) : (this.type().isClass() ? (
		("" + mark__(o.open) + (this.type().name()) + ".build(" + c_zone + ")")
	) : (
		("" + mark__(o.open) + (scope.tagContextPath()) + "." + (this.type().spawner()) + "(" + c_zone + ")")
	));
	
	if (o.id) {
		statics.push((".setId(" + quote(o.id) + ")"));
	};
	
	// this is reactive if it has an ivar
	if (o.ivar) {
		this.setReactive(true);
		statics.push((".ref_(" + quote(o.ivar.name()) + "," + c_zone + ")"));
	};
	
	if (o.body instanceof Func) {
		bodySetter = "setTemplate";
	} else if (o.body) {
		if ((o.body instanceof ArgList) && o.body.count() == 1 && o.body.first().isString()) {
			bodySetter = "setText";
		} else {
			// would probably be better to convert to a tagtree during the initial visit
			tree = new TagTree(this,o.body,{root: this,reactive: this.reactive()});
			content = tree;
			this.setTree(tree);
		};
	};
	
	if (tree) {
		// this is the point where we traverse the inner nodes with our tree
		// should rather happen in visit - long before.
		tree.resolve();
	};
	
	var dynamicFlagIndex = isSelf ? 1 : 0;
	
	for (var j = 0, items = iter$(this._parts), len_ = items.length, part; j < len_; j++) {
		part = items[j];
		var pjs;
		var pcache = false;
		
		if (part instanceof TagAttr) {
			var akey = String(part.key());
			var aval = part.value();
			
			pcache = aval.isPrimitive();
			
			
			if (akey[0] == '.') {
				pcache = false;
				pjs = (".flag(" + quote(akey.substr(1)) + "," + (aval.c()) + ")");
			} else if (akey[0] == ':') {
				pjs = (".setHandler(" + quote(akey.substr(1)) + "," + (aval.c()) + "," + (scope.context().c()) + ")");
			} else if (akey.substr(0,5) == 'data-') {
				pjs = (".dataset('" + akey.slice(5) + "'," + (aval.c()) + ")");
			} else if (part.isNamespaced()) {
				var ns = akey.split(":")[0];
				var k = akey.split(":")[1];
				
				if (ns == 'css') {
					pjs = ("." + mark__(part.key()) + "css('" + k + "'," + (aval.c()) + ")");
				} else {
					pjs = ("." + mark__(part.key()) + "setNestedAttr('" + ns + "','" + k + "'," + (aval.c()) + ")");
				};
			} else {
				pjs = ("." + mark__(part.key()) + helpers.setterSym(akey) + "(" + (aval.c()) + ")");
			};
			
			if (aval instanceof Parens) {
				aval = aval.value();
			};
			
			// if the value is a function which does not refer to any outer
			// variables (besides self), we can make it static, so as to not
			// recreate the function on every render
			if ((aval instanceof Func) && !aval.nonlocals()) {
				pcache = true;
			};
		} else if (part instanceof TagFlag) {
			if (part.value() instanceof Node) {
				if (this.reactive()) {
					var idx = dynamicFlagIndex;
					pjs = (".setFlag(" + idx + "," + (part.value().c()) + ")");
					dynamicFlagIndex = idx + 2;
				} else {
					pjs = part.c();
				};
			} else {
				pjs = part.c();
				pcache = true;
			};
		};
		
		if (pjs) {
			(cacheStatics && pcache) ? statics.push(pjs) : calls.push(pjs);
		};
	};
	
	if (this.object()) {
		calls.push((".setData(" + (this.object().c()) + ")"));
	};
	
	// we need to trigger our own reference before the body does
	// but we do not need a reference if we have no body
	if (this.reactive() && tree && (this.explicitKey() || o.loop)) {
		this.reference();
		// self
	};
	
	if (this.reactive() && parent && parent.tree() && !this.option('ivar')) {
		// not if it has a separate tag?
		o.treeRef = parent.tree().nextCacheKey(this);
		if (parent.option('treeRef') && !parent.explicitKey() && !parent.option('loop') && !(parent.tree() instanceof TagFragmentTree)) {
			o.treeRef = parent.option('treeRef') + o.treeRef;
		};
	};
	
	if (body = content && content.c({expression: true})) {
		var typ = 0;
		
		if (tree) {
			if (tree.static()) {
				typ = 2;
			} else if (this.reactive() || tree.reactive()) {
				if (!tree.single() || (tree.single() instanceof If)) {
					typ = 1;
				} else {
					typ = 3;
				};
			};
		};
		
		
		if (bodySetter == 'setChildren' || bodySetter == 'setContent') {
			calls.push(("." + bodySetter + "(" + body + "," + typ + ")"));
		} else if (bodySetter == 'setText') {
			statics.push(("." + bodySetter + "(" + body + ")"));
		} else {
			calls.push(("." + bodySetter + "(" + body + ")"));
		};
	};
	
	
	calls.push(("." + commit + "()"));
	
	var lineLen = out.length;
	
	if (statics.length) {
		// for item in statics
		// 	if lineLen > 40
		// 		out += "\n\t\t\t"
		// 		lineLen = 0
		// 	out += item
		// 	lineLen += item:length
		
		out = out + statics.join("");
	};
	
	if ((o.ivar || o.key || this.reactive()) && !(this.type() instanceof Self)) {
		// if this is an ivar, we should set the reference relative
		// to the outer reference, or possibly right on context?
		var partree = parent && parent.tree();
		var acc;
		
		var nr = STACK.incr('tagCacheKey');
		var key = o.treeRef || counterToShortRef(nr) + '__';
		var ctx;
		
		if (o.ivar) {
			ctx = scope.context();
			key = o.ivar;
		} else if (o.key && !o.treeRef) {
			// p "has dynamic key but not inside any node",o:key.c
			var method = STACK.method();
			var paths = OP('.',OP('.',new Self(),'__'),'_' + method.name());
			var setter = OP('=',paths,OP('||',paths,LIT('{}')));
			ctx = scope.closure().declare('__',new Parens(setter));
			key = o.key;
		} else if (o.key && !o.loop) {
			key = OP('+',("'" + key + "$$'"),o.key);
			key.cache();
			ctx = parent ? parent.staticCache() : this.closureCache();
		} else if (o.loop || o.key) {
			if (parent) {
				ctx = parent.staticCache();
			} else {
				ctx = this.closureCache();
			};
			
			// ctx = parent and parent.reference
			var s = scope.closure();
			var path = OP('.',ctx,key);
			var kvar = ("$" + key);
			var cacheDefault = LIT('{}');
			
			if (o.key) {
				key = o.key;
			} else {
				kvar = '_$';
				if (o.loop) {
					(loop_ = o.loop)._tagCount || (loop_._tagCount = 0);
					
					if (o.loop._tagCount > 0) {
						kvar += o.loop._tagCount;
					};
					o.loop._tagCount++;
				};
				
				var idx1 = o.loop.option('vars').index;
				cacheDefault = LIT('[]');
				key = idx1;
			};
			
			var setter1 = OP('=',path,OP('||',path,cacheDefault));
			// dont redeclare?
			ctx = s.declare(kvar,new Parens(setter1));
		} else {
			// or the tree-cache no?
			ctx = parent ? parent.staticCache() : this.closureCache();
		};
		
		// unless ctx
		// 	if parent
		// 		var tree = parent.tree
		// 		console.log 'no context!',tree
		// 		ctx = parent.tree.staticCache
		
		// need the context -- might be better to rewrite it for real?
		// parse the whole thing into calls etc
		acc || (acc = OP('.',ctx,key)); // .c
		
		if (o.ivar) {
			out = ("" + (acc.c()) + " || " + out);
		} else {
			out = ("" + (acc.c()) + " = " + (acc.c()) + " || " + out);
		};
		
		if (this._reference) {
			out = ("" + (this.reference().c()) + " = " + out);
		};
		
		out = ("(" + out + ")");
		
		//
		// 	out = "({reference.c} = {acc.c}={acc.c} || {out})"
		// else
		// 	out = "({acc.c} = {acc.c} || {out})"
	};
	
	return out + calls.join("");
};

// This is a helper-node
// Should probably use the same type of listnode everywhere
// and simply flag the type as TagTree instead
function TagTree(owner,list,options){
	if(options === undefined) options = {};
	this._owner = owner;
	this._nodes = this.load(list);
	this._options = options;
	this._conditions = [];
	this._blocks = [this];
	this._counter = 0;
	this;
};

subclass$(TagTree,ListNode);
exports.TagTree = TagTree; // export class 
TagTree.prototype.counter = function(v){ return this._counter; }
TagTree.prototype.setCounter = function(v){ this._counter = v; return this; };
TagTree.prototype.conditions = function(v){ return this._conditions; }
TagTree.prototype.setConditions = function(v){ this._conditions = v; return this; };
TagTree.prototype.blocks = function(v){ return this._blocks; }
TagTree.prototype.setBlocks = function(v){ this._blocks = v; return this; };
TagTree.prototype.cacher = function(v){ return this._cacher; }
TagTree.prototype.setCacher = function(v){ this._cacher = v; return this; };

TagTree.prototype.parent = function (){
	return this._parent || (this._parent = this._owner.parent());
};

TagTree.prototype.staticCache = function (){
	return this._owner.staticCache();
};

TagTree.prototype.nextCacheKey = function (){
	var num = this._counter++;
	var ref = counterToShortRef(num);
	
	if (ref.length > 1) {
		ref = ref + ref.length;
	};
	
	// if @owner.explicitKey or @owner.option(:loop)
	ref = this.cachePrefix() + ref;
	// ref = ref.toLowerCase unless @owner.type isa Self
	return ref;
};

TagTree.prototype.cachePrefix = function (){
	if (this._owner.explicitKey() || this._owner.option('loop')) {
		return '$';
	} else {
		return '';
	};
};

TagTree.prototype.load = function (list){
	if (list instanceof ListNode) {
		// we still want the indentation if we are not in a template
		// or, rather - we want the block to get the indentation - not the tree
		this._indentation || (this._indentation = list._indentation); // if list.count > 1
		return list.nodes();
	} else {
		return compact__((list instanceof Array) ? list : [list]);
	};
};

TagTree.prototype.root = function (){
	return this.option('root');
};

TagTree.prototype.reactive = function (){
	return this.option('reactive');
};

TagTree.prototype.resolve = function (){
	var self = this;
	self.remap(function(c) { return c.consume(self); });
	return self;
};

TagTree.prototype.static = function (){
	// every real node
	return (this._static == null) ? (this._static = this.every(function(c) { return (c instanceof Tag) || (c instanceof Str) || (c instanceof Meta); })) : this._static;
};

TagTree.prototype.single = function (){
	return (this._single == null) ? (this._single = ((this.realCount() == 1) ? this.last() : false)) : this._single;
};

TagTree.prototype.hasTags = function (){
	return this.some(function(c) { return c instanceof Tag; });
};

TagTree.prototype.c = function (o){
	// FIXME TEST what about comments???
	var single = this.single();
	
	// no indentation if this should return
	if (single && (STACK.current() instanceof Return)) {
		this._indentation = null;
	};
	
	var out = TagTree.__super__.c.call(this,o);
	
	if (!(single) || (single instanceof If)) {
		if (this.shouldMarkArray()) {
			return ("" + (this.scope__().imba().c()) + ".static([" + out + "],1)");
		} else {
			return ("[" + out + "]");
		};
	} else {
		return out;
	};
};

TagTree.prototype.shouldMarkArray = function (){
	return false;
};

function TagFragmentTree(){ return TagTree.apply(this,arguments) };

subclass$(TagFragmentTree,TagTree);
exports.TagFragmentTree = TagFragmentTree; // export class 
TagFragmentTree.prototype.cachePrefix = function (){
	return '$';
};

TagFragmentTree.prototype.visit = function (){
	TagFragmentTree.__super__.visit.apply(this,arguments);
	this._closure = this.scope__();
	return this;
};

TagFragmentTree.prototype.staticCache = function (){
	return this._owner.staticCache();
};

TagFragmentTree.prototype.shouldMarkArray = function (){
	return true;
};

function TagWrapper(){ return ValueNode.apply(this,arguments) };

subclass$(TagWrapper,ValueNode);
exports.TagWrapper = TagWrapper; // export class 
TagWrapper.prototype.visit = function (){
	if (this.value() instanceof Array) {
		this.value().map(function(v) { return v.traverse(); });
	} else {
		this.value().traverse();
	};
	return this;
};

TagWrapper.prototype.c = function (){
	return ("" + (this.scope__().imba().c()) + ".getTagForDom(" + this.value().c({expression: true}) + ")");
};

function TagAttributes(){ return ListNode.apply(this,arguments) };

subclass$(TagAttributes,ListNode);
exports.TagAttributes = TagAttributes; // export class 
TagAttributes.prototype.get = function (name){
	for (var i = 0, ary = iter$(this.nodes()), len = ary.length, node, res = []; i < len; i++) {
		node = ary[i];
		if (node.key() == name) { return node };
	};
	return res;
};


function TagAttr(k,v){
	this._traversed = false;
	this._key = k;
	this._value = v;
};

subclass$(TagAttr,Node);
exports.TagAttr = TagAttr; // export class 
TagAttr.prototype.key = function(v){ return this._key; }
TagAttr.prototype.setKey = function(v){ this._key = v; return this; };
TagAttr.prototype.value = function(v){ return this._value; }
TagAttr.prototype.setValue = function(v){ this._value = v; return this; };

TagAttr.prototype.visit = function (){
	if (this.value()) { this.value().traverse() };
	return this;
};

TagAttr.prototype.populate = function (obj){
	obj.add(this.key(),this.value());
	return this;
};

TagAttr.prototype.isNamespaced = function (){
	return String(this.key()).indexOf(':') > 0;
};

TagAttr.prototype.c = function (){
	return "attribute";
};


function TagFlag(value){
	this._traversed = false;
	this._value = value;
	this;
};

subclass$(TagFlag,Node);
exports.TagFlag = TagFlag; // export class 
TagFlag.prototype.value = function(v){ return this._value; }
TagFlag.prototype.setValue = function(v){ this._value = v; return this; };
TagFlag.prototype.toggler = function(v){ return this._toggler; }
TagFlag.prototype.setToggler = function(v){ this._toggler = v; return this; };

TagFlag.prototype.visit = function (){
	if (!((typeof this._value=='string'||this._value instanceof String))) {
		this._value.traverse();
	};
	return this;
};

TagFlag.prototype.c = function (){
	if (this.value() instanceof Node) {
		return (".flag(" + (this.value().c()) + ")");
	} else {
		return (".flag(" + helpers.singlequote(this.value()) + ")");
	};
};



// SELECTORS


function Selector(list,options){
	this._nodes = list || [];
	this._options = options;
};

subclass$(Selector,ListNode);
exports.Selector = Selector; // export class 
Selector.prototype.add = function (part,typ){
	this.push(part);
	return this;
};

Selector.prototype.group = function (){
	// for now we simply add a comma
	// how would this work for dst?
	this._nodes.push(new SelectorGroup(","));
	return this;
};

Selector.prototype.query = function (){
	var str = "";
	var ary = [];
	
	for (var i = 0, items = iter$(this.nodes()), len = items.length; i < len; i++) {
		var val = items[i].c();
		if ((typeof val=='string'||val instanceof String)) {
			str = ("" + str + val);
		};
	};
	
	return ("'" + str + "'");
};


Selector.prototype.js = function (o){
	var typ = this.option('type');
	var q = c__(this.query());
	var imba = this.scope__().imba().c();
	
	if (typ == '%') {
		return ("" + imba + ".q$(" + q + "," + o.scope().context().c({explicit: true}) + ")"); // explicit context
	} else if (typ == '%%') {
		return ("" + imba + ".q$$(" + q + "," + o.scope().context().c({explicit: true}) + ")");
	} else {
		return ("" + imba + ".q" + typ + "(" + q + ")");
	};
	
	// return "{typ} {scoped} - {all}"
};


function SelectorPart(){ return ValueNode.apply(this,arguments) };

subclass$(SelectorPart,ValueNode);
exports.SelectorPart = SelectorPart; // export class 
SelectorPart.prototype.c = function (){
	return c__(this._value);
};

function SelectorGroup(){ return SelectorPart.apply(this,arguments) };

subclass$(SelectorGroup,SelectorPart);
exports.SelectorGroup = SelectorGroup; // export class 
SelectorGroup.prototype.c = function (){
	return ",";
};

function SelectorType(){ return SelectorPart.apply(this,arguments) };

subclass$(SelectorType,SelectorPart);
exports.SelectorType = SelectorType; // export class 
SelectorType.prototype.c = function (){
	var name = this.value().name();
	
	// at least be very conservative about which tags we
	// can drop the tag for?
	// out in TAG_TYPES.HTML ?
	return (idx$(name,TAG_TYPES.HTML) >= 0) ? name : this.value().sel();
};


function SelectorUniversal(){ return SelectorPart.apply(this,arguments) };

subclass$(SelectorUniversal,SelectorPart);
exports.SelectorUniversal = SelectorUniversal; // export class 


function SelectorNamespace(){ return SelectorPart.apply(this,arguments) };

subclass$(SelectorNamespace,SelectorPart);
exports.SelectorNamespace = SelectorNamespace; // export class 


function SelectorClass(){ return SelectorPart.apply(this,arguments) };

subclass$(SelectorClass,SelectorPart);
exports.SelectorClass = SelectorClass; // export class 
SelectorClass.prototype.c = function (){
	if (this._value instanceof Node) {
		return (".'+" + (this._value.c()) + "+'");
	} else {
		return ("." + c__(this._value));
	};
};

function SelectorId(){ return SelectorPart.apply(this,arguments) };

subclass$(SelectorId,SelectorPart);
exports.SelectorId = SelectorId; // export class 
SelectorId.prototype.c = function (){
	if (this._value instanceof Node) {
		return ("#'+" + (this._value.c()) + "+'");
	} else {
		return ("#" + c__(this._value));
	};
};

function SelectorCombinator(){ return SelectorPart.apply(this,arguments) };

subclass$(SelectorCombinator,SelectorPart);
exports.SelectorCombinator = SelectorCombinator; // export class 
SelectorCombinator.prototype.c = function (){
	return ("" + c__(this._value));
};

function SelectorPseudoClass(){ return SelectorPart.apply(this,arguments) };

subclass$(SelectorPseudoClass,SelectorPart);
exports.SelectorPseudoClass = SelectorPseudoClass; // export class 


function SelectorAttribute(left,op,right){
	this._left = left;
	this._op = op;
	this._right = this._value = right;
};

subclass$(SelectorAttribute,SelectorPart);
exports.SelectorAttribute = SelectorAttribute; // export class 
SelectorAttribute.prototype.c = function (){
	// TODO possibly support .toSel or sel$(v) for items inside query
	// could easily do it with a helper-function that is added to the top of the filescope
	if (this._right instanceof Str) {
		return ("[" + (this._left.c()) + (this._op) + (this._right.c()) + "]");
	} else if (this._right) {
		// this is not at all good
		return ("[" + (this._left.c()) + (this._op) + "\"'+" + c__(this._right) + "+'\"]");
	} else {
		return ("[" + (this._left.c()) + "]");
		
		// ...
	};
};




// DEFER

function Await(){ return ValueNode.apply(this,arguments) };

subclass$(Await,ValueNode);
exports.Await = Await; // export class 
Await.prototype.func = function(v){ return this._func; }
Await.prototype.setFunc = function(v){ this._func = v; return this; };

Await.prototype.js = function (o){
	// introduce a util here, no?
	return CALL(OP('.',new Util.Promisify([this.value()]),'then'),[this.func()]).c();
	// value.c
};

Await.prototype.visit = function (o){
	// things are now traversed in a somewhat chaotic order. Need to tighten
	// Create await function - push this value up to block, take the outer
	var self = this;
	self.value().traverse();
	
	var block = o.up(Block); // or up to the closest FUNCTION?
	var outer = o.relative(block,1);
	var par = o.relative(self,-1);
	
	self.setFunc(new AsyncFunc([],[]));
	// now we move this node up to the block
	self.func().body().setNodes(block.defers(outer,self));
	self.func().scope().visit();
	
	// if the outer is a var-assignment, we can simply set the params
	if (par instanceof Assign) {
		par.left().traverse();
		var lft = par.left().node();
		// Can be a tuple as well, no?
		if (lft instanceof VarReference) {
			// the param is already registered?
			// should not force the name already??
			// beware of bugs
			self.func().params().at(0,true,lft.variable().name());
		} else if (lft instanceof Tuple) {
			// if this an unfancy tuple, with only vars
			// we can just use arguments
			
			if (par.type() == 'var' && !lft.hasSplat()) {
				lft.map(function(el,i) {
					return self.func().params().at(i,true,el.value());
				});
			} else {
				// otherwise, do the whole tuple
				// make sure it is a var assignment?
				par.setRight(ARGUMENTS);
				self.func().body().unshift(par);
				self.func().scope().context();
			};
		} else {
			// regular setters
			par.setRight(self.func().params().at(0,true));
			self.func().body().unshift(par);
			self.func().scope().context();
		};
	};
	
	// If it is an advance tuple or something, it should be possible to
	// feed in the paramlist, and let the tuple handle it as if it was any
	// other value
	
	// CASE If this is a tuple / multiset with more than one async value
	// we need to think differently.
	
	// now we need to visit the function as well
	self.func().traverse();
	// pull the outer in
	return self;
};

function AsyncFunc(params,body,name,target,options){
	AsyncFunc.__super__.constructor.call(this,params,body,name,target,options);
};

subclass$(AsyncFunc,Func);
exports.AsyncFunc = AsyncFunc; // export class 
AsyncFunc.prototype.scopetype = function (){
	return LambdaScope;
};


// IMPORTS

function ImportStatement(imports,source,ns){
	this._traversed = false;
	this._imports = imports;
	this._source = source;
	this._ns = ns;
	this;
};

subclass$(ImportStatement,Statement);
exports.ImportStatement = ImportStatement; // export class 
ImportStatement.prototype.ns = function(v){ return this._ns; }
ImportStatement.prototype.setNs = function(v){ this._ns = v; return this; };
ImportStatement.prototype.imports = function(v){ return this._imports; }
ImportStatement.prototype.setImports = function(v){ this._imports = v; return this; };
ImportStatement.prototype.source = function(v){ return this._source; }
ImportStatement.prototype.setSource = function(v){ this._source = v; return this; };


ImportStatement.prototype.visit = function (){
	if (this._ns) {
		this._nsvar || (this._nsvar = this.scope__().register(this._ns,this));
	} else {
		var src = this.source().c();
		var m = src.match(/(\w+)(\.js|imba)?[\"\']$/);
		this._alias = m ? (m[1] + '$') : 'mod$';
	};
	
	// should also register the imported items, no?
	if (this._imports) {
		var dec = this._declarations = new VariableDeclaration([]);
		
		if (this._imports.length == 1) {
			this._alias = this._imports[0];
			dec.add(this._alias,OP('.',new Require(this.source()),this._alias));
			dec.traverse();
			return this;
		};
		
		// @declarations = VariableDeclaration.new([])
		this._moduledecl = dec.add(this._alias,new Require(this.source()));
		this._moduledecl.traverse();
		
		
		if (this._imports.length > 1) {
			for (var i = 0, ary = iter$(this._imports), len = ary.length, imp; i < len; i++) {
				imp = ary[i];
				this._declarations.add(imp,OP('.',this._moduledecl.variable(),imp));
			};
		};
		
		dec.traverse();
	};
	return this;
};


ImportStatement.prototype.js = function (o){
	
	var fname;
	if (this._declarations) {
		return this._declarations.c();
	};
	
	var req = new Require(this.source());
	
	if (this._ns) {
		// must register ns as a real variable
		return ("var " + (this._nsvar.c()) + " = " + (req.c()));
	};
	
	if (this._imports) {
		
		var src = this.source().c();
		var alias = [];
		var vars = new VarBlock([]);
		
		if (fname = src.match(/(\w+)(\.js|imba)?[\"\']$/)) {
			alias.push(fname[1]);
		};
		
		// var alias = src.match(/(\w+)(\.js|imba)?[\"\']$/)
		// create a require for the source, with a temporary name?
		var out = [req.cache({names: alias}).c()];
		
		for (var i = 0, ary = iter$(this._imports), len = ary.length, imp; i < len; i++) {
			// we also need to register these imports as variables, no?
			imp = ary[i];
			var o = OP('=',imp,OP('.',req,imp));
			out.push(("var " + (o.c())));
		};
		
		return out;
	} else {
		return req.c();
	};
};

ImportStatement.prototype.consume = function (node){
	return this;
};


// EXPORT

function ExportStatement(){ return ValueNode.apply(this,arguments) };

subclass$(ExportStatement,ValueNode);
exports.ExportStatement = ExportStatement; // export class 
ExportStatement.prototype.js = function (o){
	var nodes = this._value.map(function(arg) { return ("module.exports." + (arg.c()) + " = " + (arg.c())); });
	
	if (nodes.length > 1 && (this.up() instanceof Return)) {
		return '[' + nodes.join(',') + ']';
	} else {
		return nodes.join(';\n') + ';';
	};
};

function Export(){ return ValueNode.apply(this,arguments) };

subclass$(Export,ValueNode);
exports.Export = Export; // export class 
Export.prototype.addExpression = function (expr){
	this.setValue(this.value().addExpression(expr));
	return this;
};

Export.prototype.consume = function (node){
	if (node instanceof Return) {
		this.option('return',true);
		return this;
	};
	return Export.__super__.consume.apply(this,arguments);
};

Export.prototype.js = function (o){
	// p "Export {value}"
	var self = this;
	self.value().set({export: self,return: self.option('return'),'default': self.option('default')});
	
	if (self.value() instanceof VarOrAccess) {
		return ("exports." + (self.value().c()) + " = " + (self.value().c()) + ";");
	};
	
	if (self.value() instanceof ListNode) {
		self.value().map(function(item) { return item.set({export: self}); });
	};
	
	return self.value().c();
};

function Require(){ return ValueNode.apply(this,arguments) };

subclass$(Require,ValueNode);
exports.Require = Require; // export class 
Require.prototype.js = function (o){
	var out = (this.value() instanceof Parens) ? this.value().value().c() : this.value().c();
	return (out == 'require') ? 'require' : (("require(" + out + ")"));
};

function EnvFlag(){ return ValueNode.apply(this,arguments) };

subclass$(EnvFlag,ValueNode);
exports.EnvFlag = EnvFlag; // export class 
EnvFlag.prototype.raw = function (){
	return (this._raw == null) ? (this._raw = STACK.env("" + this._value)) : this._raw;
};

EnvFlag.prototype.isTruthy = function (){
	var val = this.raw();
	if (val !== undefined) { return !(!(val)) };
	return undefined;
};

EnvFlag.prototype.loc = function (){
	return [0,0];
};

EnvFlag.prototype.c = function (){
	var val = this.raw();
	if (val !== undefined) {
		if ((typeof val=='string'||val instanceof String)) {
			if (val.match(/^\d+(\.\d+)?$/)) {
				return parseFloat(val);
			} else {
				return ("'" + val + "'");
			};
		} else {
			return ("" + val);
		};
	} else {
		return ("ENV_" + (this._value));
	};
};


// UTILS

function Util(args){
	this._args = args;
};

// this is how we deal with it now
subclass$(Util,Node);
exports.Util = Util; // export class 
Util.prototype.args = function(v){ return this._args; }
Util.prototype.setArgs = function(v){ this._args = v; return this; };

Util.extend = function (a,b){
	return new Util.Extend([a,b]);
};

Util.callImba = function (scope,meth,args){
	return CALL(OP('.',scope.imba(),new Identifier(meth)),args);
};

Util.repeat = function (str,times){
	var res = '';
	while (times > 0){
		if (times % 2 == 1) {
			res += str;
		};
		str += str;
		times >>= 1;
	};
	return res;
};



Util.keys = function (obj){
	var l = new Const("Object");
	var r = new Identifier("keys");
	return CALL(OP('.',l,r),[obj]);
};

Util.len = function (obj,cache){
	var r = new Identifier("length");
	var node = OP('.',obj,r);
	if (cache) { node.cache({force: true,pool: 'len'}) };
	return node;
};

Util.indexOf = function (lft,rgt){
	var node = new Util.IndexOf([lft,rgt]);
	// node.cache(force: yes, type: 'iter') if cache
	return node;
};

Util.slice = function (obj,a,b){
	var slice = new Identifier("slice");
	console.log(("slice " + a + " " + b));
	return CALL(OP('.',obj,slice),compact__([a,b]));
};

Util.iterable = function (obj,cache){
	var node = new Util.Iterable([obj]);
	if (cache) { node.cache({force: true,pool: 'iter'}) };
	return node;
};



Util.union = function (a,b){
	return new Util.Union([a,b]);
};

Util.intersect = function (a,b){
	return new Util.Intersect([a,b]);
};

Util.counter = function (start,cache){
	// should it not rather be a variable?!?
	var node = new Num(start); // make sure it really is a number
	if (cache) { node.cache({force: true,pool: 'counter'}) };
	return node;
};

Util.array = function (size,cache){
	var node = new Util.Array([size]);
	if (cache) { node.cache({force: true,pool: 'list'}) };
	return node;
};

Util.defineTag = function (type,ctor,supr){
	return CALL(TAGDEF,[type,ctor,supr]);
};


Util.defineClass = function (name,supr,initor){
	return CALL(CLASSDEF,[name || initor,this.sup()]);
};

Util.prototype.inlineHelpers = function (){
	return !(!OPTS.inlineHelpers);
};

Util.prototype.js = function (o){
	return "helper";
};

// TODO Deprecate and remove
Util.Union = function Union(){ return Util.apply(this,arguments) };

subclass$(Util.Union,Util);
Util.Union.prototype.helper = function (){
	return 'function union$(a,b){\n	if(a && a.__union) return a.__union(b);\n\n	var u = a.slice(0);\n	for(var i=0,l=b.length;i<l;i++) if(u.indexOf(b[i]) == -1) u.push(b[i]);\n	return u;\n};\n';
};

Util.Union.prototype.js = function (o){
	this.scope__().root().helper(this,this.helper());
	// When this is triggered, we need to add it to the top of file?
	return ("union$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
};

// TODO Deprecate and remove
Util.Intersect = function Intersect(){ return Util.apply(this,arguments) };

subclass$(Util.Intersect,Util);
Util.Intersect.prototype.helper = function (){
	return 'function intersect$(a,b){\n	if(a && a.__intersect) return a.__intersect(b);\n	var res = [];\n	for(var i=0, l=a.length; i<l; i++) {\n		var v = a[i];\n		if(b.indexOf(v) != -1) res.push(v);\n	}\n	return res;\n};\n';
};

Util.Intersect.prototype.js = function (o){
	// When this is triggered, we need to add it to the top of file?
	this.scope__().root().helper(this,this.helper());
	return ("intersect$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
};

Util.Extend = function Extend(){ return Util.apply(this,arguments) };

subclass$(Util.Extend,Util);
Util.Extend.prototype.js = function (o){
	// When this is triggered, we need to add it to the top of file?
	return ("extend$(" + compact__(cary__(this.args())).join(',') + ")");
};

Util.IndexOf = function IndexOf(){ return Util.apply(this,arguments) };

subclass$(Util.IndexOf,Util);
Util.IndexOf.prototype.helper = function (){
	return 'function idx$(a,b){\n	return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);\n};';
};

Util.IndexOf.prototype.js = function (o){
	if (this.inlineHelpers()) {
		this.scope__().root().helper(this,this.helper());
		// When this is triggered, we need to add it to the top of file?
		return ("idx$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
	} else {
		return ("" + (this.scope__().imba().c()) + ".indexOf(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
	};
};

Util.Len = function Len(){ return Util.apply(this,arguments) };

subclass$(Util.Len,Util);
Util.Len.prototype.helper = function (){
	return 'function len$(a){\n	return a && (a.len instanceof Function ? a.len() : a.length) || 0;\n};';
};

Util.Len.prototype.js = function (o){
	// 
	 // isStandalone
	this.scope__().root().helper(this,this.helper());
	// When this is triggered, we need to add it to the top of file?
	return ("len$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
	
};


Util.Subclass = function Subclass(){ return Util.apply(this,arguments) };

subclass$(Util.Subclass,Util);
Util.Subclass.prototype.helper = function (){
	// should also check if it is a real promise
	return '// helper for subclassing\nfunction subclass$(obj,sup) {\n	for (var k in sup) {\n		if (sup.hasOwnProperty(k)) obj[k] = sup[k];\n	};\n	// obj.__super__ = sup;\n	obj.prototype = Object.create(sup.prototype);\n	obj.__super__ = obj.prototype.__super__ = sup.prototype;\n	obj.prototype.initialize = obj.prototype.constructor = obj;\n};\n';
};

Util.Subclass.prototype.js = function (o){
	if (this.inlineHelpers()) {
		// When this is triggered, we need to add it to the top of file?
		this.scope__().root().helper(this,this.helper());
		return ("subclass$(" + this.args().map(function(v) { return v.c(); }).join(',') + ");\n");
	} else {
		return ("" + (this.scope__().imba().c()) + ".subclass(" + this.args().map(function(v) { return v.c(); }).join(',') + ");\n");
	};
};

Util.Promisify = function Promisify(){ return Util.apply(this,arguments) };

subclass$(Util.Promisify,Util);
Util.Promisify.prototype.helper = function (){
	// should also check if it is a real promise
	return ("function promise$(a)\{ return a instanceof Array ? Promise.all(a) : (a && a.then ? a : Promise.resolve(a)); \}");
};

Util.Promisify.prototype.js = function (o){
	if (this.inlineHelpers()) {
		// When this is triggered, we need to add it to the top of file?
		this.scope__().root().helper(this,this.helper());
		return ("promise$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
	} else {
		return ("" + (this.scope__().imba().c()) + ".await(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
	};
};

// TODO deprecated: can remove
Util.Class = function Class(){ return Util.apply(this,arguments) };

subclass$(Util.Class,Util);
Util.Class.prototype.js = function (o){
	// When this is triggered, we need to add it to the top of file?
	return ("class$(" + this.args().map(function(v) { return v.c(); }).join(',') + ")");
};

Util.Iterable = function Iterable(){ return Util.apply(this,arguments) };

subclass$(Util.Iterable,Util);
Util.Iterable.prototype.helper = function (){
	// now we want to allow null values as well - just return as empty collection
	// should be the same for for own of I guess
	return ("function iter$(a)\{ return a ? (a.toArray ? a.toArray() : a) : []; \};");
};

Util.Iterable.prototype.js = function (o){
	if (this.args()[0] instanceof Arr) { return this.args()[0].c() }; // or if we know for sure that it is an array
	
	 // isStandalone
	this.scope__().root().helper(this,this.helper());
	return ("iter$(" + (this.args()[0].c()) + ")");
	
};

Util.IsFunction = function IsFunction(){ return Util.apply(this,arguments) };

subclass$(Util.IsFunction,Util);
Util.IsFunction.prototype.js = function (o){
	return ("" + (this.args()[0].c()));
};

Util.Array = function Array(){ return Util.apply(this,arguments) };

subclass$(Util.Array,Util);
Util.Array.prototype.js = function (o){
	// When this is triggered, we need to add it to the top of file?
	return ("new Array(" + this.args().map(function(v) { return v.c(); }) + ")");
};




function Entities(root){
	this._root = root;
	this._map = {};
	return this;
};

Entities.prototype.add = function (path,object){
	this._map[path] = object;
	return this;
};

Entities.prototype.register = function (entity){
	var path = entity.namepath();
	this._map[path] || (this._map[path] = entity);
	return this;
};

Entities.prototype.plain = function (){
	return JSON.parse(JSON.stringify(this._map));
};

Entities.prototype.toJSON = function (){
	return this._map;
};

// SCOPES

// handles local variables, self etc. Should create references to outer scopes
// when needed etc.

// add class for annotations / registering methods, etc?
// class Interface

// should move the whole context-thingie right into scope
function Scope(node,parent){
	this._nr = STACK.incr('scopes');
	this._head = [];
	this._node = node;
	this._parent = parent;
	this._vars = new VariableDeclaration([]);
	this._meta = {};
	this._annotations = [];
	this._closure = this;
	this._virtual = false;
	this._counter = 0;
	this._varmap = {};
	this._varpool = [];
};

exports.Scope = Scope; // export class 
Scope.prototype.level = function(v){ return this._level; }
Scope.prototype.setLevel = function(v){ this._level = v; return this; };
Scope.prototype.context = function(v){ return this._context; }
Scope.prototype.setContext = function(v){ this._context = v; return this; };
Scope.prototype.node = function(v){ return this._node; }
Scope.prototype.setNode = function(v){ this._node = v; return this; };
Scope.prototype.parent = function(v){ return this._parent; }
Scope.prototype.setParent = function(v){ this._parent = v; return this; };
Scope.prototype.varmap = function(v){ return this._varmap; }
Scope.prototype.setVarmap = function(v){ this._varmap = v; return this; };
Scope.prototype.varpool = function(v){ return this._varpool; }
Scope.prototype.setVarpool = function(v){ this._varpool = v; return this; };
Scope.prototype.params = function(v){ return this._params; }
Scope.prototype.setParams = function(v){ this._params = v; return this; };
Scope.prototype.head = function(v){ return this._head; }
Scope.prototype.setHead = function(v){ this._head = v; return this; };
Scope.prototype.vars = function(v){ return this._vars; }
Scope.prototype.setVars = function(v){ this._vars = v; return this; };
Scope.prototype.counter = function(v){ return this._counter; }
Scope.prototype.setCounter = function(v){ this._counter = v; return this; };

Scope.prototype.p = function (){
	if (STACK.loglevel() > 0) {
		console.log.apply(console,arguments);
	};
	return this;
};

Scope.prototype.stack = function (){
	return STACK;
};

Scope.prototype.meta = function (key,value){
	if (value != undefined) {
		this._meta[key] = value;
		return this;
	};
	return this._meta[key];
};

Scope.prototype.namepath = function (){
	return '?';
};

Scope.prototype.imbaTags = function (){
	return ("" + (this.imba().c()) + ".TAGS");
};

Scope.prototype.tagContextPath = function (){
	// bypassing for now
	return this._tagContextPath || (this._tagContextPath = this.imbaTags());
};

Scope.prototype.tagContextCache = function (){
	return this._tagContextCache || (this._tagContextCache = this.closure().declare("__",OP('.',this.context().reference(),'__')));
};

Scope.prototype.context = function (){
	return this._context || (this._context = new ScopeContext(this));
};

Scope.prototype.traverse = function (){
	return this;
};

Scope.prototype.visit = function (){
	if (this._parent) { return this };
	this._parent = STACK.scope(1); // the parent scope
	this._level = STACK.scopes().length - 1;
	
	STACK.addScope(this);
	this.root().scopes().push(this);
	return this;
};

Scope.prototype.wrap = function (scope){
	this._parent = scope._parent;
	scope._parent = this;
	return this;
};

// called for scopes that are not real scopes in js
// must ensure that the local variables inside of the scopes do not
// collide with variables in outer scopes -- rename if needed
Scope.prototype.virtualize = function (){
	return this;
};

Scope.prototype.root = function (){
	return STACK.ROOT;
	
	var scope = this;
	while (scope){
		if (scope instanceof RootScope) { return scope };
		scope = scope.parent();
	};
	return null;
};

Scope.prototype.register = function (name,decl,o){
	// FIXME re-registering a variable should really return the existing one
	// Again, here we should not really have to deal with system-generated vars
	// But again, it is important
	
	if(decl === undefined) decl = null;
	if(o === undefined) o = {};
	name = helpers.symbolize(name);
	
	// also look at outer scopes if this is not closed?
	var existing = this._varmap.hasOwnProperty(name) && this._varmap[name];
	if (existing && !o.unique) { return existing };
	
	var item = new Variable(this,name,decl,o);
	// need to check for duplicates, and handle this gracefully -
	// going to refactor later
	if (!o.system && !(existing)) { this._varmap[name] = item };
	return item;
};

Scope.prototype.annotate = function (obj){
	this._annotations.push(obj);
	return this;
};

// just like register, but we automatically
Scope.prototype.declare = function (name,init,o){
	var declarator_;
	if(init === undefined) init = null;
	if(o === undefined) o = {};
	var variable = this.register(name,null,o);
	// TODO create the variabledeclaration here instead?
	// if this is a sysvar we need it to be renameable
	var dec = this._vars.add(variable,init);
	(declarator_ = variable.declarator()) || ((variable.setDeclarator(dec),dec));
	return variable;
};

// what are the differences here? omj
// we only need a temporary thing with defaults -- that is all
// change these values, no?
Scope.prototype.temporary = function (refnode,o,name){
	
	if(o === undefined) o = {};
	if(name === undefined) name = null;
	if (o.pool) {
		for (var i = 0, ary = iter$(this._varpool), len = ary.length, v; i < len; i++) {
			v = ary[i];
			if (v.pool() == o.pool && v.declarator() == null) {
				return v.reuse(refnode);
			};
		};
	};
	
	var item = new SystemVariable(this,name,refnode,o);
	
	this._varpool.push(item); // It should not be in the pool unless explicitly put there?
	this._vars.push(item); // WARN variables should not go directly into a declaration-list
	return item;
};

Scope.prototype.lookup = function (name){
	this._lookups || (this._lookups = {});
	var ret = null;
	name = helpers.symbolize(name);
	if (this._varmap.hasOwnProperty(name)) {
		ret = this._varmap[name];
	} else {
		ret = this.parent() && this.parent().lookup(name);
		
		if (ret) {
			this._nonlocals || (this._nonlocals = {});
			this._nonlocals[name] = ret;
		};
	};
	return ret;
};

Scope.prototype.requires = function (path,name){
	if(name === undefined) name = '';
	return this.root().requires(path,name);
};

Scope.prototype.imba = function (){
	return this.root().requires('imba','Imba');
};

Scope.prototype.autodeclare = function (variable){
	return this.vars().push(variable); // only if it does not exist here!!!
};

Scope.prototype.free = function (variable){
	variable.free(); // :owner = null
	// @varpool.push(variable)
	return this;
};

Scope.prototype.isClosed = function (){
	return false;
};

Scope.prototype.closure = function (){
	return this._closure;
};

Scope.prototype.finalize = function (){
	return this;
};

Scope.prototype.klass = function (){
	var scope = this;
	while (scope){
		scope = scope.parent();
		if (scope instanceof ClassScope) { return scope };
	};
	return null;
};

Scope.prototype.head = function (){
	return [this._vars,this._params];
};

Scope.prototype.c = function (o){
	var body;
	if(o === undefined) o = {};
	o.expression = false;
	// need to fix this
	this.node().body().setHead(this.head());
	return body = this.node().body().c(o);
};

Scope.prototype.region = function (){
	return this.node().body().region();
};

Scope.prototype.loc = function (){
	return this.node().loc();
};

Scope.prototype.dump = function (){
	var self = this;
	var vars = Object.keys(self._varmap).map(function(k) {
		var v = self._varmap[k];
		// unless v.@declarator isa Scope
		// 	console.log v.name, v.@declarator:constructor:name
		// dump__(v)
		return v.references().length ? dump__(v) : null;
	});
	
	var desc = {
		nr: self._nr,
		type: self.constructor.name,
		level: (self.level() || 0),
		vars: compact__(vars),
		loc: self.loc()
	};
	
	return desc;
};

Scope.prototype.toJSON = function (){
	return this.dump();
};

Scope.prototype.toString = function (){
	return ("" + (this.constructor.name));
};

Scope.prototype.closeScope = function (){
	return this;
};


// RootScope is wrong? Rather TopScope or ProgramScope
function RootScope(){
	RootScope.__super__.constructor.apply(this,arguments);
	
	this.register('global',this,{type: 'global'});
	this.register('module',this,{type: 'global'});
	this.register('window',this,{type: 'global'});
	this.register('document',this,{type: 'global'});
	this.register('exports',this,{type: 'global'});
	this.register('console',this,{type: 'global'});
	this.register('process',this,{type: 'global'});
	this.register('parseInt',this,{type: 'global'});
	this.register('parseFloat',this,{type: 'global'});
	this.register('setTimeout',this,{type: 'global'});
	this.register('setInterval',this,{type: 'global'});
	this.register('setImmediate',this,{type: 'global'});
	this.register('clearTimeout',this,{type: 'global'});
	this.register('clearInterval',this,{type: 'global'});
	this.register('clearImmediate',this,{type: 'global'});
	this.register('__dirname',this,{type: 'global'});
	this.register('__filename',this,{type: 'global'});
	this.register('_',this,{type: 'global'});
	
	// preregister global special variables here
	this._requires = {};
	this._warnings = [];
	this._scopes = [];
	this._helpers = [];
	this._entities = new Entities(this);
	this._head = [this._vars];
};

subclass$(RootScope,Scope);
exports.RootScope = RootScope; // export class 
RootScope.prototype.warnings = function(v){ return this._warnings; }
RootScope.prototype.setWarnings = function(v){ this._warnings = v; return this; };
RootScope.prototype.scopes = function(v){ return this._scopes; }
RootScope.prototype.setScopes = function(v){ this._scopes = v; return this; };
RootScope.prototype.entities = function(v){ return this._entities; }
RootScope.prototype.setEntities = function(v){ this._entities = v; return this; };

RootScope.prototype.context = function (){
	return this._context || (this._context = new RootScopeContext(this));
};

// def tagContextPath
// 	@tagContextPath ||= "_T"

RootScope.prototype.lookup = function (name){
	name = helpers.symbolize(name);
	if (this._varmap.hasOwnProperty(name)) { return this._varmap[name] };
};

RootScope.prototype.visit = function (){
	STACK.addScope(this);
	return this;
};

RootScope.prototype.helper = function (typ,value){
	// log "add helper",typ,value
	if (this._helpers.indexOf(value) == -1) {
		this._helpers.push(value);
		this._head.unshift(value);
	};
	
	return this;
};

RootScope.prototype.head = function (){
	return this._head;
};

RootScope.prototype.warn = function (data){
	// hacky
	data.node = null;
	this._warnings.push(data);
	return this;
};

RootScope.prototype.dump = function (){
	var obj = {warnings: dump__(this._warnings)};
	
	if (OPTS.analysis.scopes) {
		var scopes = this._scopes.map(function(s) { return s.dump(); });
		scopes.unshift(RootScope.__super__.dump.call(this));
		obj.scopes = scopes;
	};
	
	if (OPTS.analysis.entities) {
		obj.entities = this._entities;
	};
	
	return obj;
};

// not yet used
RootScope.prototype.requires = function (path,name){
	var variable, declarator_;
	if (variable = this.lookup(name)) {
		return variable;
	};
	
	if (variable = this._requires[name]) {
		if (variable._requirePath != path) {
			throw new Error(("" + name + " is already defined as require('" + (variable._requirePath) + "')"));
		};
		return variable;
	};
	
	var req = new Require(new Str("'" + path + "'"));
	variable = new Variable(this,name,null,{system: true});
	var dec = this._vars.add(variable,req);
	(declarator_ = variable.declarator()) || ((variable.setDeclarator(dec),dec));
	variable._requirePath = path;
	this._requires[name] = variable;
	return variable;
};

RootScope.prototype.c = function (o){
	if(o === undefined) o = {};
	o.expression = false;
	// need to fix this
	this.node().body().setHead(this.head());
	var body = this.node().body().c(o);
	
	return body;
};



function ClassScope(){ return Scope.apply(this,arguments) };

subclass$(ClassScope,Scope);
exports.ClassScope = ClassScope; // export class 
ClassScope.prototype.namepath = function (){
	return this._node.namepath();
};


// called for scopes that are not real scopes in js
// must ensure that the local variables inside of the scopes do not
// collide with variables in outer scopes -- rename if needed
ClassScope.prototype.virtualize = function (){
	// console.log "virtualizing ClassScope"
	var up = this.parent();
	for (var o = this._varmap, v, i = 0, keys = Object.keys(o), l = keys.length, k; i < l; i++){
		k = keys[i];v = o[k];v.resolve(up,true); // force new resolve
	};
	return this;
};

ClassScope.prototype.isClosed = function (){
	return true;
};

function TagScope(){ return ClassScope.apply(this,arguments) };

subclass$(TagScope,ClassScope);
exports.TagScope = TagScope; // export class 


function ClosureScope(){ return Scope.apply(this,arguments) };

subclass$(ClosureScope,Scope);
exports.ClosureScope = ClosureScope; // export class 


function FunctionScope(){ return Scope.apply(this,arguments) };

subclass$(FunctionScope,Scope);
exports.FunctionScope = FunctionScope; // export class 


function MethodScope(){ return Scope.apply(this,arguments) };

subclass$(MethodScope,Scope);
exports.MethodScope = MethodScope; // export class 
MethodScope.prototype.isClosed = function (){
	return true;
};

MethodScope.prototype.tagContext = function (){
	return this._tagContext || (this._tagContext = this.declare("$",OP('.',new This(),'__')));
};

function LambdaScope(){ return Scope.apply(this,arguments) };

subclass$(LambdaScope,Scope);
exports.LambdaScope = LambdaScope; // export class 
LambdaScope.prototype.context = function (){
	// why do we need to make sure it is referenced?
	if (!this._context) {
		this._context = this.parent().context();
		this._context.reference(this);
	};
	return this._context;
};


function FlowScope(){ return Scope.apply(this,arguments) };

subclass$(FlowScope,Scope);
exports.FlowScope = FlowScope; // export class 
FlowScope.prototype.params = function (){
	if (this._parent) { return this._parent.params() };
};

FlowScope.prototype.register = function (name,decl,o){
	var found;
	if(decl === undefined) decl = null;
	if(o === undefined) o = {};
	if (o.type != 'let' && (this.closure() != this)) {
		if (found = this.lookup(name)) {
			if (found.type() == 'let') {
				this.p(("" + name + " already exists as a block-variable " + decl));
				// TODO should throw error instead
				if (decl) { decl.warn("Variable already exists in block") };
				// root.warn message: "Holy shit"
			};
		};
		return this.closure().register(name,decl,o);
	} else {
		return FlowScope.__super__.register.call(this,name,decl,o);
	};
};

// FIXME should override temporary as well

FlowScope.prototype.autodeclare = function (variable){
	return this.parent().autodeclare(variable);
};

FlowScope.prototype.closure = function (){
	return this._parent.closure(); // this is important?
};

FlowScope.prototype.context = function (){
	return this._context || (this._context = this.parent().context());
};

FlowScope.prototype.closeScope = function (){
	if (this._context) { this._context.reference() };
	return this;
};

function CatchScope(){ return FlowScope.apply(this,arguments) };

subclass$(CatchScope,FlowScope);
exports.CatchScope = CatchScope; // export class 


function WhileScope(){ return FlowScope.apply(this,arguments) };

subclass$(WhileScope,FlowScope);
exports.WhileScope = WhileScope; // export class 
WhileScope.prototype.autodeclare = function (variable){
	return this.vars().push(variable);
};

function ForScope(){ return FlowScope.apply(this,arguments) };

subclass$(ForScope,FlowScope);
exports.ForScope = ForScope; // export class 
ForScope.prototype.autodeclare = function (variable){
	return this.vars().push(variable);
};

function IfScope(){ return FlowScope.apply(this,arguments) };

subclass$(IfScope,FlowScope);
exports.IfScope = IfScope; // export class 
IfScope.prototype.temporary = function (refnode,o,name){
	if(o === undefined) o = {};
	if(name === undefined) name = null;
	return this.parent().temporary(refnode,o,name);
};

function BlockScope(){ return FlowScope.apply(this,arguments) };

subclass$(BlockScope,FlowScope);
exports.BlockScope = BlockScope; // export class 
BlockScope.prototype.temporary = function (refnode,o,name){
	if(o === undefined) o = {};
	if(name === undefined) name = null;
	return this.parent().temporary(refnode,o,name);
};

BlockScope.prototype.region = function (){
	return this.node().region();
};

// lives in scope -- really a node???
function Variable(scope,name,decl,o){
	this._ref = STACK._counter++;
	this._c = null;
	this._scope = scope;
	this._name = name;
	this._alias = null;
	this._initialized = true;
	this._declarator = decl;
	this._autodeclare = false;
	this._declared = o && o.declared || false;
	this._resolved = false;
	this._options = o || {};
	this._type = o && o.type || 'var'; // what about let here=
	this._export = false;
	this._references = []; // only needed when profiling
	this._assignments = [];
	this;
};

subclass$(Variable,Node);
exports.Variable = Variable; // export class 
Variable.prototype.scope = function(v){ return this._scope; }
Variable.prototype.setScope = function(v){ this._scope = v; return this; };
Variable.prototype.name = function(v){ return this._name; }
Variable.prototype.setName = function(v){ this._name = v; return this; };
Variable.prototype.alias = function(v){ return this._alias; }
Variable.prototype.setAlias = function(v){ this._alias = v; return this; };
Variable.prototype.type = function(v){ return this._type; }
Variable.prototype.setType = function(v){ this._type = v; return this; };
Variable.prototype.options = function(v){ return this._options; }
Variable.prototype.setOptions = function(v){ this._options = v; return this; };
Variable.prototype.initialized = function(v){ return this._initialized; }
Variable.prototype.setInitialized = function(v){ this._initialized = v; return this; };
Variable.prototype.declared = function(v){ return this._declared; }
Variable.prototype.setDeclared = function(v){ this._declared = v; return this; };
Variable.prototype.declarator = function(v){ return this._declarator; }
Variable.prototype.setDeclarator = function(v){ this._declarator = v; return this; };
Variable.prototype.autodeclare = function(v){ return this._autodeclare; }
Variable.prototype.setAutodeclare = function(v){ this._autodeclare = v; return this; };
Variable.prototype.references = function(v){ return this._references; }
Variable.prototype.setReferences = function(v){ this._references = v; return this; };
Variable.prototype.export = function(v){ return this._export; }
Variable.prototype.setExport = function(v){ this._export = v; return this; };

Variable.prototype.pool = function (){
	return null;
};

Variable.prototype.closure = function (){
	return this._scope.closure();
};

Variable.prototype.assignments = function (){
	return this._assignments;
};

// Here we can collect lots of type-info about variables
// and show warnings / give advice if variables are ambiguous etc
Variable.prototype.assigned = function (val,source){
	this._assignments.push(val);
	if (val instanceof Arr) {
		// just for testing really
		this._isArray = true;
	} else {
		this._isArray = false;
	};
	return this;
};

Variable.prototype.resolve = function (scope,force){
	if(scope === undefined) scope = this.scope();
	if(force === undefined) force = false;
	if (this._resolved && !(force)) { return this };
	
	this._resolved = true;
	var closure = this._scope.closure();
	var item = scope.lookup(this._name);
	
	// if this is a let-definition inside a virtual scope we do need
	//
	if (this._scope != closure && this._type == 'let') { // or if it is a system-variable
		item = closure.lookup(this._name);
		
		// we now need to ensure that this variable is unique inside
		// the whole closure.
		scope = closure;
	};
	
	if (item == this) {
		scope.varmap()[this._name] = this;
		return this;
	} else if (item) {
		// possibly redefine this inside, use it only in this scope
		// if the item is defined in an outer scope - we reserve the
		if (item.scope() != scope && (this.options().let || this._type == 'let')) {
			scope.varmap()[this._name] = this;
		};
		
		// different rules for different variables?
		if (this._options.proxy) {
			true;
		} else {
			var i = 0;
			var orig = this._name;
			// it is the closure that we should use
			while (scope.lookup(this._name)){
				this._name = ("" + orig + (i += 1));
			};
		};
	};
	
	scope.varmap()[this._name] = this;
	closure.varmap()[this._name] = this;
	return this;
};

Variable.prototype.reference = function (){
	return this;
};

Variable.prototype.node = function (){
	return this;
};

Variable.prototype.cache = function (){
	return this;
};

Variable.prototype.traverse = function (){
	return this;
};

Variable.prototype.free = function (ref){
	this._declarator = null;
	return this;
};

Variable.prototype.reuse = function (ref){
	this._declarator = ref;
	return this;
};

Variable.prototype.proxy = function (par,index){
	this._proxy = [par,index];
	return this;
};

Variable.prototype.refcount = function (){
	return this._references.length;
};

Variable.prototype.c = function (){
	if (this._c) { return this._c };
	// options - proxy??
	if (this._proxy) {
		this._c = this._proxy[0].c() + '[' + this._proxy[1].c() + ']';
	} else {
		if (!this._resolved) this.resolve();
		var v = (this.alias() || this.name());
		this._c = (typeof v == 'string') ? v : v.c();
		// allow certain reserved words
		// should warn on others though (!!!)
		// if @c == 'new'
		// 	@c = '_new'
		// 	# should happen at earlier stage to
		// 	# get around naming conventions
		if (RESERVED_REGEX.test(this._c)) { this._c = ("" + this.c() + "$") }; // @c.match(/^(default)$/)
	};
	return this._c;
};

// variables should probably inherit from node(!)
Variable.prototype.consume = function (node){
	return this;
};

// this should only generate the accessors - not dael with references
Variable.prototype.accessor = function (ref){
	var node = new LocalVarAccess(".",null,this);
	// this is just wrong .. should not be a regular accessor
	// @references.push([ref,el]) if ref # weird temp format
	return node;
};

Variable.prototype.assignment = function (val){
	return new Assign('=',this,val);
};

Variable.prototype.addReference = function (ref){
	if (ref instanceof Identifier) {
		ref.references(this);
	};
	
	if (ref.region && ref.region()) {
		this._references.push(ref);
	};
	
	return this;
};

Variable.prototype.autodeclare = function (){
	if (this._declared) { return this };
	this._autodeclare = true;
	this.scope().autodeclare(this);
	this._declared = true;
	return this;
};

Variable.prototype.predeclared = function (){
	this._declared = true;
	return this;
};


Variable.prototype.toString = function (){
	return String(this.name());
};

Variable.prototype.dump = function (typ){
	var name = this.name();
	if (name[0].match(/[A-Z]/)) { return null };
	
	return {
		type: this.type(),
		name: name,
		refs: dump__(this._references,typ)
	};
};


function SystemVariable(){ return Variable.apply(this,arguments) };

subclass$(SystemVariable,Variable);
exports.SystemVariable = SystemVariable; // export class 
SystemVariable.prototype.pool = function (){
	return this._options.pool;
};

// weird name for this
SystemVariable.prototype.predeclared = function (){
	this.scope().vars().remove(this);
	return this;
};

SystemVariable.prototype.resolve = function (){
	var alias, v_;
	if (this._resolved || this._name) { return this };
	this._resolved = true;
	// unless @name
	// adds a very random initial name
	// the auto-magical goes last, or at least, possibly reuse other names
	// "${Math.floor(Math.random * 1000)}"
	
	var typ = this._options.pool;
	var names = [].concat(this._options.names);
	var alt = null;
	var node = null;
	
	var scope = this.scope();
	
	if (typ == 'tag') {
		var i = 0;
		while (!this._name){
			alt = ("t" + (i++));
			if (!scope.lookup(alt)) { this._name = alt };
		};
	} else if (typ == 'iter') {
		names = ['ary__','ary_','coll','array','items','ary'];
	} else if (typ == 'val') {
		names = ['v_'];
	} else if (typ == 'arguments') {
		names = ['$_','$0'];
	} else if (typ == 'keypars') {
		names = ['opts','options','pars'];
	} else if (typ == 'counter') {
		names = ['i__','i_','k','j','i'];
	} else if (typ == 'len') {
		names = ['len__','len_','len'];
	} else if (typ == 'list') {
		names = ['tmplist_','tmplist','tmp'];
	};
	// or if type placeholder / cacher (add 0)
	
	while (!this._name && (alt = names.pop())){
		if (!scope.lookup(alt)) { this._name = alt };
	};
	
	if (!this._name && this._declarator) {
		if (node = this.declarator().node()) {
			if (alias = node.alias()) { names.push(alias + "_") };
		};
	};
	
	while (!this._name && (alt = names.pop())){
		if (!scope.lookup(alt)) { this._name = alt };
	};
	
	this._name || (this._name = ("$" + (scope.setCounter(v_ = scope.counter() + 1),v_)));
	
	scope.varmap()[this._name] = this;
	this.closure().varmap()[this._name] = this;
	return this;
};

SystemVariable.prototype.name = function (){
	this.resolve();
	return this._name;
};


function ScopeContext(scope,value){
	this._scope = scope;
	this._value = value;
	this._reference = null;
	this;
};

subclass$(ScopeContext,Node);
exports.ScopeContext = ScopeContext; // export class 
ScopeContext.prototype.scope = function(v){ return this._scope; }
ScopeContext.prototype.setScope = function(v){ this._scope = v; return this; };
ScopeContext.prototype.value = function(v){ return this._value; }
ScopeContext.prototype.setValue = function(v){ this._value = v; return this; };
ScopeContext.prototype.reference = function(v){ return this._reference; }
ScopeContext.prototype.setReference = function(v){ this._reference = v; return this; };

ScopeContext.prototype.namepath = function (){
	return this._scope.namepath();
};

// instead of all these references we should probably
// just register when it is accessed / looked up from
// a deeper function-scope, and when it is, we should
// register the variable in scope, and then start to
// use that for further references. Might clean things
// up for the cases where we have yet to decide the
// name of the variable etc?

ScopeContext.prototype.reference = function (){
	return this._reference || (this._reference = this.scope().declare("self",new This()));
};

ScopeContext.prototype.c = function (){
	var val = this._value || this._reference;
	return val ? val.c() : "this";
};

ScopeContext.prototype.cache = function (){
	return this;
};

function RootScopeContext(){ return ScopeContext.apply(this,arguments) };

subclass$(RootScopeContext,ScopeContext);
exports.RootScopeContext = RootScopeContext; // export class 
RootScopeContext.prototype.c = function (o){
	// return "" if o and o:explicit
	var val = this._value || this._reference;
	return (val && val != this) ? val.c() : "this";
	// should be the other way around, no?
	// o and o:explicit ? super : ""
};

function Super(){ return Node.apply(this,arguments) };

subclass$(Super,Node);
exports.Super = Super; // export class 
Super.prototype.c = function (){
	// need to find the stuff here
	// this is really not that good8
	var m = STACK.method();
	var out = null;
	var up = STACK.current();
	var deep = (up instanceof Access);
	
	// TODO optimization for later - problematic if there is a different reference in the end
	if (false) {
		out = ("" + (m.target().c()) + ".superclass");
		if (!(deep)) { out += (".apply(" + (m.scope().context().c()) + ",arguments)") };
	} else {
		out = ("" + (m.target().c()) + ".__super__");
		if (!((up instanceof Access))) {
			out += ("." + c__(m.supername()));
			if (!((up instanceof Call))) { // autocall?
				out += (".apply(" + (m.scope().context().c()) + ",arguments)");
			};
		};
	};
	return out;
};

// constants

var BR = exports.BR = new Newline('\n');
var BR2 = exports.BR2 = new Newline('\n\n');
var SELF = exports.SELF = new Self();
var SUPER = exports.SUPER = new Super();

var TRUE = exports.TRUE = new True('true');
var FALSE = exports.FALSE = new False('false');
var UNDEFINED = exports.UNDEFINED = new Undefined();
var NIL = exports.NIL = new Nil();

var ARGUMENTS = exports.ARGUMENTS = new ArgsReference('arguments');
var EMPTY = exports.EMPTY = '';
var NULL = exports.NULL = 'null';

var RESERVED = exports.RESERVED = ['default','native','enum','with'];
var RESERVED_REGEX = exports.RESERVED_REGEX = /^(default|native|enum|with|new|char)$/;

var UNION = exports.UNION = new Const('union$');
var INTERSECT = exports.INTERSECT = new Const('intersect$');
var CLASSDEF = exports.CLASSDEF = new Const('imba$class');
var TAGDEF = exports.TAGDEF = new Const('Imba.TAGS.define');











/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
// imba$inlineHelpers=1

var path = __webpack_require__(14);
var util = __webpack_require__(1);

function SourceMap(source){
	this._source = source;
	this._maps = [];
	this._map = "";
	this._js = "";
};

exports.SourceMap = SourceMap; // export class 
SourceMap.prototype.source = function (){
	return this._source;
};

SourceMap.prototype.options = function (){
	return this._source;
};

SourceMap.prototype.filename = function (){
	return this.options().options.filename;
};

SourceMap.prototype.sourceCode = function (){
	return this.options().options._source;
};

SourceMap.prototype.targetPath = function (){
	return this.options().options.targetPath;
};

SourceMap.prototype.sourcePath = function (){
	return this.options().options.sourcePath;
};

SourceMap.prototype.sourceName = function (){
	return path.basename(this.sourcePath());
};

SourceMap.prototype.targetName = function (){
	return path.basename(this.targetPath());
};


SourceMap.prototype.sourceFiles = function (){
	return [this.sourceName()];
};

SourceMap.prototype.parse = function (){
	var self = this;
	var matcher = /\%\$(\d*)\$\%/;
	var replacer = /^(.*?)\%\$(\d*)\$\%/;
	var lines = self.options().js.split(/\n/g); // what about js?
	// return self
	var locmap = util.locationToLineColMap(self.sourceCode());
	self._maps = [];
	
	var match;
	// split the code in lines. go through each line 
	// go through the code looking for LOC markers
	// remove markers along the way and keep track of
	// console.log source:js
	
	for (var i = 0, ary = iter$(lines), len = ary.length, line; i < len; i++) {
		// could split on these?
		line = ary[i];
		var col = 0;
		var caret = 0;
		
		self._maps[i] = [];
		while (line.match(matcher)){
			line = line.replace(replacer,function(m,pre,loc) {
				var lc = locmap[parseInt(loc)];
				caret = pre.length;
				var mapping = [[lc[0],lc[1]],[i,caret]]; // source and output
				self._maps[i].push(mapping);
				return pre;
			});
		};
		lines[i] = line;
	};
	
	
	self.source().js = lines.join('\n');
	return self;
};

SourceMap.prototype.generate = function (){
	this.parse();
	
	var lastColumn = 0;
	var lastSourceLine = 0;
	var lastSourceColumn = 0;
	var buffer = "";
	
	for (var lineNumber = 0, ary = iter$(this._maps), len = ary.length; lineNumber < len; lineNumber++) {
		lastColumn = 0;
		
		for (var nr = 0, items = iter$(ary[lineNumber]), len_ = items.length, map1; nr < len_; nr++) {
			map1 = items[nr];
			if (nr != 0) { buffer += ',' };
			var src = map1[0];
			var dest = map1[1];
			
			buffer += this.encodeVlq(dest[1] - lastColumn);
			lastColumn = dest[1];
			// add index
			buffer += this.encodeVlq(0);
			
			// The starting line in the original source, relative to the previous source line.
			buffer += this.encodeVlq(src[0] - lastSourceLine);
			lastSourceLine = src[0];
			// The starting column in the original source, relative to the previous column.
			buffer += this.encodeVlq(src[1] - lastSourceColumn);
			lastSourceColumn = src[1];
		};
		
		buffer += ";";
	};
	
	
	var rel = this.targetPath() && path.relative(path.dirname(this.targetPath()),this.sourcePath());
	
	var map = {
		version: 3,
		file: this.sourceName().replace(/\.imba/,'.js') || '',
		sourceRoot: this.options().sourceRoot || '',
		sources: [rel || this.sourcePath()],
		sourcesContent: [this.sourceCode()],
		names: [],
		mappings: buffer
	};
	
	// source:sourcemap = sourcemap
	// var base64 = Buffer.new(JSON.stringify(map)).toString("base64")
	// source:js += "\n//# sourceMappingURL=data:application/json;base64,{base64}"
	return map;
};

var VLQ_SHIFT = 5;
var VLQ_CONTINUATION_BIT = 1 << VLQ_SHIFT;
var VLQ_VALUE_MASK = VLQ_CONTINUATION_BIT - 1;
var BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

// borrowed from CoffeeScript
SourceMap.prototype.encodeVlq = function (value){
	var answer = '';
	// Least significant bit represents the sign.
	var signBit = (value < 0) ? 1 : 0;
	var nextChunk;
	// The next bits are the actual value.
	var valueToEncode = (Math.abs(value) << 1) + signBit;
	// Make sure we encode at least one character, even if valueToEncode is 0.
	while (valueToEncode || !(answer)){
		nextChunk = valueToEncode & VLQ_VALUE_MASK;
		valueToEncode = valueToEncode >> VLQ_SHIFT;
		if (valueToEncode) {
			nextChunk |= VLQ_CONTINUATION_BIT;
		};
		
		answer += this.encodeBase64(nextChunk);
	};
	
	return answer;
};

SourceMap.prototype.encodeBase64 = function (value){
	return BASE64_CHARS[value]; // or throw Error.new("Cannot Base64 encode value: {value}")
};




/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZWRhYTFhN2ViNGJkYjE3Y2JjMDEiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvc3JjL2NvbXBpbGVyL3Rva2VuLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvc3JjL2NvbXBpbGVyL2hlbHBlcnMuaW1iYSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9pbWJhL3NyYy9jb21waWxlci9lcnJvcnMuaW1iYSIsIndlYnBhY2s6Ly8vLi4vaW1iYS9zcmMvY29tcGlsZXIvY29uc3RhbnRzLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvc3JjL2ltYmEvaW1iYS5pbWJhIiwid2VicGFjazovLy8uLi9pbWJhL3NyYy9pbWJhL2luZGV4LmltYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmltYmxhL3dlYndvcmtlci5pbWJhIiwid2VicGFjazovLy8uLi9pbWJhL3NyYy9jb21waWxlci9jb21waWxlci5pbWJhIiwid2VicGFjazovLy8uLi9pbWJhL3NyYy9jb21waWxlci9sZXhlci5pbWJhIiwid2VicGFjazovLy8uLi9pbWJhL3NyYy9jb21waWxlci9yZXdyaXRlci5pbWJhIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9jb21waWxlci9wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvc3JjL2NvbXBpbGVyL25vZGVzLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvc3JjL2NvbXBpbGVyL3NvdXJjZW1hcC5pbWJhIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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UUFBUSwrS0FBK0ssT0FBTyxrdkNBQWt2QztBQUM1eUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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SDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi93d3cvanMvc2NyaW1ibGEud29ya2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgZWRhYTFhN2ViNGJkYjE3Y2JjMDEiLCIjIGltYmEkaW5saW5lSGVscGVycz0xXG5cbmV4cG9ydCB2YXIgVE9LID0ge31cbnZhciBUVEVSTUlOQVRPUiA9IFRPSy5URVJNSU5BVE9SID0gMVxudmFyIFRJREVOVElGSUVSID0gVE9LLklERU5USUZJRVIgPSBUT0suSVZBUiA9IDJcbnZhciBDT05TVCA9IFRPSy5DT05TVCA9IDNcbnZhciBWQVIgPSBUT0suVkFSID0gNFxudmFyIElGID0gVE9LLklGID0gNVxudmFyIEVMU0UgPSBUT0suRUxTRSA9IDZcbnZhciBERUYgPSBUT0suREVGID0gN1xuXG5leHBvcnQgY2xhc3MgVG9rZW5cblxuXHRkZWYgaW5pdGlhbGl6ZSB0eXBlLCB2YWx1ZSwgbG9jLCBsZW5cblx0XHRAdHlwZSAgPSB0eXBlXG5cdFx0QHZhbHVlID0gdmFsdWVcblx0XHRAbG9jICAgPSBsb2MgIT0gbnVsbCA/IGxvYyA6IC0xXG5cdFx0QGxlbiAgID0gbGVuIG9yIDBcblx0XHRAbWV0YSAgPSBudWxsXG5cdFx0dGhpczpnZW5lcmF0ZWQgPSBub1xuXHRcdHRoaXM6bmV3TGluZSA9IG5vXG5cdFx0dGhpczpzcGFjZWQgPSBub1xuXHRcdHRoaXM6Y2FsbCA9IG5vXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgdHlwZVxuXHRcdEB0eXBlXG5cblx0ZGVmIHZhbHVlXG5cdFx0QHZhbHVlXG5cblx0ZGVmIHRyYXZlcnNlXG5cdFx0cmV0dXJuXG5cdFx0XG5cdGRlZiBjXG5cdFx0XCJcIiArIEB2YWx1ZVxuXG5cdGRlZiB0b1N0cmluZ1xuXHRcdEB2YWx1ZVxuXG5cdGRlZiBjaGFyQXQgaVxuXHRcdEB2YWx1ZS5jaGFyQXQoaSlcblxuXHRkZWYgc2xpY2UgaVxuXHRcdEB2YWx1ZS5zbGljZShpKVxuXG5cdGRlZiByZWdpb25cblx0XHRbQGxvYyxAbG9jICsgKEBsZW4gb3IgQHZhbHVlOmxlbmd0aCldXG5cblx0ZGVmIHNvdXJjZU1hcE1hcmtlclxuXHRcdEBsb2MgPT0gLTEgPyAnOicgOiBcIiUke0Bsb2N9JCVcIlxuXHRcdCMgQGNvbCA9PSAtMSA/ICcnIDogXCIlJXtAbGluZX0ke0Bjb2x9JSVcIlxuXG5cbmV4cG9ydCBkZWYgbGV4XG5cdHZhciB0b2tlbiA9IHRoaXM6dG9rZW5zW3RoaXM6cG9zKytdXG5cdHZhciB0dGFnXG5cblx0aWYgdG9rZW5cblx0XHR0dGFnID0gdG9rZW4uQHR5cGVcblx0XHR0aGlzOnl5dGV4dCA9IHRva2VuXG5cdGVsc2Vcblx0XHR0dGFnID0gJydcblxuXHRyZXR1cm4gdHRhZ1xuXG5cbiMgZXhwb3J0IGRlZiB0b2tlbiB0eXAsIHZhbCwgbGluZSwgY29sLCBsZW4gZG8gVG9rZW4ubmV3KHR5cCx2YWwsbGluZSwgY29sIG9yIDAsIGxlbiBvciAwKSAjIFtudWxsLHR5cCx2YWwsbG9jXVxuZXhwb3J0IGRlZiB0b2tlbiB0eXAsIHZhbCBkbyBUb2tlbi5uZXcodHlwLHZhbCwtMSwwKVxuXG5leHBvcnQgZGVmIHR5cCB0b2sgZG8gdG9rLkB0eXBlXG5leHBvcnQgZGVmIHZhbCB0b2sgZG8gdG9rLkB2YWx1ZSAjIHRva1tvZmZzZXQgKyAxXVxuZXhwb3J0IGRlZiBsaW5lIHRvayBkbyB0b2suQGxpbmUgIyB0b2tbb2Zmc2V0ICsgMl1cbmV4cG9ydCBkZWYgbG9jIHRvayBkbyB0b2suQGxvYyAjIHRva1tvZmZzZXQgKyAyXVxuXG5leHBvcnQgZGVmIHNldFR5cCB0b2ssIHYgZG8gdG9rLkB0eXBlID0gdlxuZXhwb3J0IGRlZiBzZXRWYWwgdG9rLCB2IGRvIHRvay5AdmFsdWUgPSB2XG5leHBvcnQgZGVmIHNldExpbmUgdG9rLCB2IGRvIHRvay5AbGluZSA9IHZcbmV4cG9ydCBkZWYgc2V0TG9jIHRvaywgdiBkbyB0b2suQGxvYyA9IHZcblxuXG5leHBvcnQgdmFyIExCUkFDS0VUID0gVG9rZW4ubmV3KCd7JywneycsMCwwLDApXG5leHBvcnQgdmFyIFJCUkFDS0VUID0gVG9rZW4ubmV3KCd9JywnfScsMCwwLDApXG5cbmV4cG9ydCB2YXIgTFBBUkVOID0gVG9rZW4ubmV3KCcoJywnKCcsMCwwLDApXG5leHBvcnQgdmFyIFJQQVJFTiA9IFRva2VuLm5ldygnKScsJyknLDAsMCwwKVxuXG5MQlJBQ0tFVDpnZW5lcmF0ZWQgPSB5ZXNcblJCUkFDS0VUOmdlbmVyYXRlZCA9IHllc1xuTFBBUkVOOmdlbmVyYXRlZCA9IHllc1xuUlBBUkVOOmdlbmVyYXRlZCA9IHllc1xuXG5leHBvcnQgdmFyIElOREVOVCA9IFRva2VuLm5ldygnSU5ERU5UJywnMicsMCwwLDApXG5leHBvcnQgdmFyIE9VVERFTlQgPSBUb2tlbi5uZXcoJ09VVERFTlQnLCcyJywwLDAsMClcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vaW1iYS9zcmMvY29tcGlsZXIvdG9rZW4uaW1iYSIsIlxuZXhwb3J0IGRlZiBicmFjZSBzdHJcblx0dmFyIGxpbmVzID0gc3RyLm1hdGNoKC9cXG4vKVxuXHQjIHdoYXQgYWJvdXQgaW5kZW50YXRpb24/XG5cblx0aWYgbGluZXNcblx0XHQneycgKyBzdHIgKyAnXFxufSdcblx0ZWxzZVxuXHRcdCd7XFxuJyArIHN0ciArICdcXG59J1xuXG5leHBvcnQgZGVmIG5vcm1hbGl6ZUluZGVudGF0aW9uIHN0clxuXHR2YXIgbVxuXHR2YXIgcmVnID0gL1xcbisoW15cXG5cXFNdKikvZ1xuXHR2YXIgaW5kID0gbnVsbFxuXG5cdHdoaWxlIG0gPSByZWcuZXhlYyhzdHIpXG5cdFx0dmFyIGF0dGVtcHQgPSBtWzFdXG5cdFx0aWYgaW5kIGlzIG51bGwgb3IgMCA8IGF0dGVtcHQ6bGVuZ3RoIDwgaW5kOmxlbmd0aFxuXHRcdFx0aW5kID0gYXR0ZW1wdFxuXG5cdHN0ciA9IHN0ci5yZXBsYWNlKFJlZ0V4cChcIlxcXFxue2luZH1cIixcImdcIiksICdcXG4nKSBpZiBpbmRcblx0cmV0dXJuIHN0clxuXG5cbmV4cG9ydCBkZWYgZmxhdHRlbiBhcnJcblx0dmFyIG91dCA9IFtdXG5cdGFyci5mb3JFYWNoIGRvIHx2fCB2IGlzYSBBcnJheSA/IG91dDpwdXNoLmFwcGx5KG91dCxmbGF0dGVuKHYpKSA6IG91dC5wdXNoKHYpXG5cdHJldHVybiBvdXRcblxuXG5leHBvcnQgZGVmIHBhc2NhbENhc2Ugc3RyXG5cdHN0ci5yZXBsYWNlKC8oXnxbXFwtXFxfXFxzXSkoXFx3KS9nKSBkbyB8bSx2LGx8IGwudG9VcHBlckNhc2VcblxuZXhwb3J0IGRlZiBjYW1lbENhc2Ugc3RyXG5cdHN0ciA9IFN0cmluZyhzdHIpXG5cdCMgc2hvdWxkIGFkZCBzaG9ydGN1dCBvdXRcblx0c3RyLnJlcGxhY2UoLyhbXFwtXFxfXFxzXSkoXFx3KS9nKSBkbyB8bSx2LGx8IGwudG9VcHBlckNhc2VcblxuZXhwb3J0IGRlZiBkYXNoVG9DYW1lbENhc2Ugc3RyXG5cdHN0ciA9IFN0cmluZyhzdHIpXG5cdGlmIHN0ci5pbmRleE9mKCctJykgPj0gMFxuXHRcdCMgc2hvdWxkIGFkZCBzaG9ydGN1dCBvdXRcblx0XHRzdHIgPSBzdHIucmVwbGFjZSgvKFtcXC1cXHNdKShcXHcpL2cpIGRvIHxtLHYsbHwgbC50b1VwcGVyQ2FzZVxuXHRyZXR1cm4gc3RyXG5cbmV4cG9ydCBkZWYgc25ha2VDYXNlIHN0clxuXHR2YXIgc3RyID0gc3RyLnJlcGxhY2UoLyhbXFwtXFxzXSkoXFx3KS9nLCdfJylcblx0c3RyLnJlcGxhY2UoLygpKFtBLVpdKS9nLFwiXyQxXCIpIGRvIHxtLHYsbHwgbC50b1VwcGVyQ2FzZVxuXG5leHBvcnQgZGVmIHNldHRlclN5bSBzeW1cblx0ZGFzaFRvQ2FtZWxDYXNlKFwic2V0LXtzeW19XCIpXG5cbmV4cG9ydCBkZWYgcXVvdGUgc3RyXG5cdCdcIicgKyBzdHIgKyAnXCInXG5cbmV4cG9ydCBkZWYgc2luZ2xlcXVvdGUgc3RyXG5cdFwiJ1wiICsgc3RyICsgXCInXCJcblxuZXhwb3J0IGRlZiBzeW1ib2xpemUgc3RyXG5cdHN0ciA9IFN0cmluZyhzdHIpXG5cdHZhciBlbmQgPSBzdHIuY2hhckF0KHN0cjpsZW5ndGggLSAxKVxuXG5cdGlmIGVuZCA9PSAnPSdcblx0XHRzdHIgPSAnc2V0JyArIHN0clswXS50b1VwcGVyQ2FzZSArIHN0ci5zbGljZSgxLC0xKVxuXG5cdGlmIHN0ci5pbmRleE9mKFwiLVwiKSA+PSAwXG5cdFx0c3RyID0gc3RyLnJlcGxhY2UoLyhbXFwtXFxzXSkoXFx3KS9nKSBkbyB8bSx2LGx8IGwudG9VcHBlckNhc2Vcblx0XHRcdFxuXHRyZXR1cm4gc3RyXG5cblxuZXhwb3J0IGRlZiBpbmRlbnQgc3RyXG5cdFN0cmluZyhzdHIpLnJlcGxhY2UoL14vZyxcIlxcdFwiKS5yZXBsYWNlKC9cXG4vZyxcIlxcblxcdFwiKS5yZXBsYWNlKC9cXG5cXHQkL2csXCJcXG5cIilcblxuZXhwb3J0IGRlZiBicmFja2V0aXplIHN0ciwgaW5kID0geWVzXG5cdHN0ciA9IFwiXFxuXCIgKyBpbmRlbnQoc3RyKSArIFwiXFxuXCIgaWYgaW5kXG5cdCd7JyArIHN0ciArICd9J1xuXHRcbmV4cG9ydCBkZWYgcGFyZW50aGVzaXplIHN0clxuXHQnKCcgKyBTdHJpbmcoc3RyKSArICcpJ1xuXG5leHBvcnQgZGVmIHVuaW9uT2ZMb2NhdGlvbnMgKmxvY3Ncblx0dmFyIGEgPSBJbmZpbml0eVxuXHR2YXIgYiA9IC1JbmZpbml0eVxuXG5cdGZvciBsb2MgaW4gbG9jc1xuXHRcdGlmIGxvYyBhbmQgbG9jLkBsb2MgIT0gdW5kZWZpbmVkXG5cdFx0XHRsb2MgPSBsb2MuQGxvY1xuXG5cdFx0aWYgbG9jIGFuZCBsb2M6bG9jIGlzYSBGdW5jdGlvblxuXHRcdFx0bG9jID0gbG9jLmxvY1xuXG5cdFx0aWYgbG9jIGlzYSBBcnJheVxuXHRcdFx0YSA9IGxvY1swXSBpZiBhID4gbG9jWzBdXG5cdFx0XHRiID0gbG9jWzFdIGlmIGIgPCBsb2NbMF1cblx0XHRlbGlmIGxvYyBpc2EgTnVtYmVyXG5cdFx0XHRhID0gbG9jIGlmIGEgPiBsb2Ncblx0XHRcdGIgPSBsb2MgaWYgYiA8IGxvY1xuXG5cdHJldHVybiBbYSxiXVxuXHRcdFx0XHRcblxuXG5leHBvcnQgZGVmIGxvY2F0aW9uVG9MaW5lQ29sTWFwIGNvZGVcblx0dmFyIGxpbmVzID0gY29kZS5zcGxpdCgvXFxuL2cpXG5cdHZhciBtYXAgPSBbXVxuXG5cdHZhciBjaHJcblx0dmFyIGxvYyA9IDBcblx0dmFyIGNvbCA9IDBcblx0dmFyIGxpbmUgPSAwXG5cblx0d2hpbGUgY2hyID0gY29kZVtsb2NdXG5cdFx0bWFwW2xvY10gPSBbbGluZSxjb2xdXG5cblx0XHRpZiBjaHIgPT0gJ1xcbidcblx0XHRcdGxpbmUrK1xuXHRcdFx0Y29sID0gMFxuXHRcdGVsc2Vcblx0XHRcdGNvbCsrXG5cblx0XHRsb2MrK1xuXG5cdHJldHVybiBtYXBcblxuZXhwb3J0IGRlZiBtYXJrTGluZUNvbEZvclRva2VucyB0b2tlbnMsIGNvZGVcblx0c2VsZlxuXG5leHBvcnQgZGVmIHBhcnNlQXJncyBhcmd2LCBvID0ge31cblx0dmFyIGFsaWFzZXMgPSBvOmFsaWFzIHx8PSB7fVxuXHR2YXIgZ3JvdXBzID0gbzpncm91cHMgfHw9IFtdXG5cdHZhciBzY2hlbWEgPSBvOnNjaGVtYSB8fCB7fVxuXG5cdHNjaGVtYTptYWluID0ge31cblxuXHR2YXIgb3B0aW9ucyA9IHt9XG5cdHZhciBleHBsaWNpdCA9IHt9XG5cdGFyZ3YgPSBhcmd2IHx8IHByb2Nlc3M6YXJndi5zbGljZSgyKVxuXHR2YXIgY3VyciA9IG51bGxcblx0dmFyIGkgPSAwXG5cdHZhciBtXG5cblx0d2hpbGUoaSA8IGFyZ3Y6bGVuZ3RoKVxuXHRcdHZhciBhcmcgPSBhcmd2W2ldXG5cdFx0aSsrXG5cblx0XHRpZiBtID0gYXJnLm1hdGNoKC9eXFwtKFthLXpBLVpdKykkLylcblx0XHRcdGN1cnIgPSBudWxsXG5cdFx0XHRsZXQgY2hhcnMgPSBtWzFdLnNwbGl0KCcnKVxuXG5cdFx0XHRmb3IgaXRlbSxpIGluIGNoYXJzXG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJwYXJzaW5nIHtpdGVtfSBhdCB7aX1cIixhbGlhc2VzXG5cdFx0XHRcdHZhciBrZXkgPSBhbGlhc2VzW2l0ZW1dIG9yIGl0ZW1cblx0XHRcdFx0Y2hhcnNbaV0gPSBrZXlcblx0XHRcdFx0b3B0aW9uc1trZXldID0geWVzXG5cblx0XHRcdGlmIGNoYXJzOmxlbmd0aCA9PSAxXG5cdFx0XHRcdGN1cnIgPSBjaGFyc1xuXG5cdFx0ZWxpZiBtID0gYXJnLm1hdGNoKC9eXFwtXFwtKFthLXowLTlcXC1cXF9BLVpdKykkLylcblx0XHRcdHZhciB2YWwgPSB0cnVlXG5cdFx0XHR2YXIga2V5ID0gbVsxXVxuXG5cdFx0XHRpZiBrZXkuaW5kZXhPZignbm8tJykgPT0gMFxuXHRcdFx0XHRrZXkgPSBrZXkuc3Vic3RyKDMpXG5cdFx0XHRcdHZhbCA9IGZhbHNlXG5cblx0XHRcdGZvciBnIGluIGdyb3Vwc1xuXHRcdFx0XHRpZiBrZXkuc3Vic3RyKDAsZzpsZW5ndGgpID09IGdcblx0XHRcdFx0XHRjb25zb2xlLmxvZyAnc2hvdWxkIGJlIHBhcnQgb2YgZ3JvdXAnXG5cblx0XHRcdGtleSA9IGRhc2hUb0NhbWVsQ2FzZShrZXkpXG5cblx0XHRcdG9wdGlvbnNba2V5XSA9IHZhbFxuXHRcdFx0Y3VyciA9IGtleVxuXG5cdFx0ZWxzZVxuXHRcdFx0dW5sZXNzIGN1cnIgYW5kIHNjaGVtYVtjdXJyXVxuXHRcdFx0XHRjdXJyID0gJ21haW4nXG5cblx0XHRcdGlmIGFyZy5tYXRjaCgvXlxcZCskLylcblx0XHRcdFx0YXJnID0gcGFyc2VJbnQoYXJnKVxuXG5cdFx0XHR2YXIgdmFsID0gb3B0aW9uc1tjdXJyXVxuXHRcdFx0aWYgdmFsID09IHRydWUgb3IgdmFsID09IGZhbHNlXG5cdFx0XHRcdG9wdGlvbnNbY3Vycl0gPSBhcmdcblx0XHRcdGVsaWYgdmFsIGlzYSBTdHJpbmcgb3IgdmFsIGlzYSBOdW1iZXJcblx0XHRcdFx0b3B0aW9uc1tjdXJyXSA9IFt2YWxdLmNvbmNhdChhcmcpXG5cdFx0XHRlbGlmIHZhbCBpc2EgQXJyYXlcblx0XHRcdFx0dmFsLnB1c2goYXJnKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRvcHRpb25zW2N1cnJdID0gYXJnXG5cblxuXHRpZiBvcHRpb25zOmVudiBpc2EgU3RyaW5nXG5cdFx0b3B0aW9uc1tcIkVOVl97b3B0aW9uczplbnZ9XCJdID0geWVzXG5cblx0cmV0dXJuIG9wdGlvbnNcblxuZXhwb3J0IHZhciBhbnNpID1cblx0Ym9sZDogZG8gfHRleHR8ICdcXHUwMDFiWzFtJyArIHRleHQgKyAnXFx1MDAxYlsyMm0nXG5cdHJlZDogZG8gfHRleHR8ICdcXHUwMDFiWzMxbScgK3RleHQgKyAnXFx1MDAxYlszOW0nXG5cdGdyZWVuOiBkbyB8dGV4dHwgJ1xcdTAwMWJbMzJtJyArdGV4dCArICdcXHUwMDFiWzM5bSdcblx0Z3JheTogZG8gfHRleHR8ICdcXHUwMDFiWzkwbScgK3RleHQgKyAnXFx1MDAxYlszOW0nXG5cdHdoaXRlOiBkbyB8dGV4dHwgJ1xcdTAwMWJbMzdtJyArdGV4dCArICdcXHUwMDFiWzM5bSdcblxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vaW1iYS9zcmMvY29tcGlsZXIvaGVscGVycy5pbWJhIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIjIGltYmEkaW5saW5lSGVscGVycz0xXG4jIGNyZWF0ZSBzZXBhcmF0ZSBlcnJvci10eXBlcyB3aXRoIGFsbCB0aGUgbG9naWNcblxudmFyIHV0aWwgPSByZXF1aXJlICcuL2hlbHBlcnMnXG5cbmV4cG9ydCBjbGFzcyBJbWJhUGFyc2VFcnJvciA8IEVycm9yXG5cdFxuXHRkZWYgc2VsZi53cmFwIGVyclxuXHRcdCMgd2hhdCBhYm91dCB0aGUgc3RhY2t0cmFjZT9cblx0XHRJbWJhUGFyc2VFcnJvci5uZXcoZXJyKVxuXG5cdGRlZiBpbml0aWFsaXplIGUsb1xuXHRcdHRoaXM6ZXJyb3IgPSBlXG5cdFx0dGhpczptZXNzYWdlID0gZTptZXNzYWdlXG5cdFx0dGhpczpmaWxlbmFtZSA9IGU6ZmlsZW5hbWVcblx0XHR0aGlzOmxpbmUgPSBlOmxpbmVcblx0XHRAb3B0aW9ucyA9IG8gb3Ige31cblx0XHRzZWxmXG5cblx0ZGVmIHNldCBvcHRzXG5cdFx0QG9wdGlvbnMgfHw9IHt9XG5cdFx0Zm9yIG93biBrLHYgb2Ygb3B0c1xuXHRcdFx0QG9wdGlvbnNba10gPSB2XG5cdFx0c2VsZlxuXG5cdGRlZiBzdGFydFxuXHRcdHZhciBvID0gQG9wdGlvbnNcblx0XHR2YXIgaWR4ID0gbzpwb3MgLSAxXG5cdFx0dmFyIHRvayA9IG86dG9rZW5zIGFuZCBvOnRva2Vuc1tpZHhdXG5cdFx0dG9rID0gbzp0b2tlbnNbLS1pZHhdIHdoaWxlIHRvayBhbmQgdG9rLkBsb2MgPT0gLTFcblx0XHRyZXR1cm4gdG9rXG5cblx0ZGVmIGRlc2Ncblx0XHR2YXIgbyA9IEBvcHRpb25zXG5cdFx0bGV0IG1zZyA9IHNlbGY6bWVzc2FnZVxuXHRcdGlmIG86dG9rZW4gYW5kIG86dG9rZW4uQGxvYyA9PSAtMVxuXHRcdFx0J1N5bnRheCBFcnJvcidcblx0XHRlbHNlXG5cdFx0XHRtc2dcblx0XG5cdGRlZiBsb2Ncblx0XHRzdGFydD8ucmVnaW9uXG5cblx0ZGVmIHRvSlNPTlxuXHRcdHZhciBvID0gQG9wdGlvbnNcblx0XHR2YXIgdG9rID0gc3RhcnRcblx0XHRyZXR1cm4ge3dhcm46IHllcywgbWVzc2FnZTogZGVzYywgbG9jOiBsb2N9XG5cblx0ZGVmIGV4Y2VycHQgZ3V0dGVyOiB5ZXMsIGNvbG9yczogbm8sIGRldGFpbHM6IHllc1xuXG5cdFx0dmFyIGNvZGUgPSBAY29kZVxuXHRcdHZhciBsb2MgPSBsb2Ncblx0XHR2YXIgbGluZXMgID0gY29kZS5zcGxpdCgvXFxuL2cpXG5cdFx0dmFyIGxvY21hcCA9IHV0aWwubG9jYXRpb25Ub0xpbmVDb2xNYXAoY29kZSlcblx0XHR2YXIgbGMgPSBsb2NtYXBbbG9jWzBdXSBvciBbMCwwXVxuXHRcdHZhciBsbiA9IGxjWzBdXG5cdFx0dmFyIGNvbCA9IGxjWzFdXG5cdFx0dmFyIGxpbmUgPSBsaW5lc1tsbl1cblxuXHRcdHZhciBsbjAgPSBNYXRoLm1heCgwLGxuIC0gMilcblx0XHR2YXIgbG4xID0gTWF0aC5taW4obG4wICsgNSxsaW5lczpsZW5ndGgpXG5cdFx0bGV0IGxuaSA9IGxuIC0gbG4wXG5cdFx0dmFyIGwgPSBsbjBcblxuXHRcdHZhciBvdXQgPSB3aGlsZSBsIDwgbG4xXG5cdFx0XHR2YXIgbGluZSA9IGxpbmVzW2wrK11cblxuXHRcdGlmIGd1dHRlclxuXHRcdFx0b3V0ID0gb3V0Lm1hcCBkbyB8bGluZSxpfFxuXHRcdFx0XHRsZXQgcHJlZml4ID0gIFwie2xuMCArIGkgKyAxfVwiXG5cdFx0XHRcdHdoaWxlIHByZWZpeDpsZW5ndGggPCBTdHJpbmcobG4xKTpsZW5ndGhcblx0XHRcdFx0XHRwcmVmaXggPSBcIiB7cHJlZml4fVwiXG5cdFx0XHRcdGlmIGkgPT0gbG5pXG5cdFx0XHRcdFx0XCIgICAtPiB7cHJlZml4fSB8IHtsaW5lfVwiXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcIiAgICAgIHtwcmVmaXh9IHwge2xpbmV9XCJcblxuXHRcdGlmIGNvbG9yc1xuXHRcdFx0b3V0W2xuaV0gPSB1dGlsOmFuc2kucmVkKHV0aWw6YW5zaS5ib2xkKG91dFtsbmldKSlcblxuXHRcdGlmIGRldGFpbHNcblx0XHRcdG91dC51bnNoaWZ0KHNlbGY6bWVzc2FnZSlcblxuXHRcdHJldHVybiBvdXQuam9pbignXFxuJylcblxuXHRkZWYgcHJldHR5TWVzc2FnZVxuXHRcdHZhciBleGNlcnB0ID0gc2VsZi5leGNlcnB0XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2ltYmEvc3JjL2NvbXBpbGVyL2Vycm9ycy5pbWJhIiwiIyBpbWJhJGlubGluZUhlbHBlcnM9MVxuIyBMaXN0IG9mIHRoZSB0b2tlbiBwYWlycyB0aGF0IG11c3QgYmUgYmFsYW5jZWQuXG5leHBvcnQgdmFyIEJBTEFOQ0VEX1BBSVJTID0gW1xuXHRbJygnLCAnKSddXG5cdFsnWycsICddJ11cblx0Wyd7JywgJ30nXVxuXHRbJ3t7JywgJ319J11cblx0WydJTkRFTlQnLCAnT1VUREVOVCddLFxuXHRbJ0NBTExfU1RBUlQnLCAnQ0FMTF9FTkQnXVxuXHRbJ1BBUkFNX1NUQVJUJywgJ1BBUkFNX0VORCddXG5cdFsnSU5ERVhfU1RBUlQnLCAnSU5ERVhfRU5EJ11cblx0WydUQUdfU1RBUlQnLCdUQUdfRU5EJ11cblx0WydCTE9DS19QQVJBTV9TVEFSVCcsJ0JMT0NLX1BBUkFNX0VORCddXG5dXG5cbiMgVGhlIGludmVyc2UgbWFwcGluZ3Mgb2YgYEJBTEFOQ0VEX1BBSVJTYCB3ZSdyZSB0cnlpbmcgdG8gZml4IHVwLCBzbyB3ZSBjYW5cbiMgbG9vayB0aGluZ3MgdXAgZnJvbSBlaXRoZXIgZW5kLlxuZXhwb3J0IHZhciBJTlZFUlNFUyA9IHt9XG5cbiMgVGhlIHRva2VucyB0aGF0IHNpZ25hbCB0aGUgc3RhcnQvZW5kIG9mIGEgYmFsYW5jZWQgcGFpci5cbiMgdmFyIEVYUFJFU1NJT05fU1RBUlQgPSBbXVxuIyB2YXIgRVhQUkVTU0lPTl9FTkQgICA9IFtdXG5cbmZvciBwYWlyIGluIEJBTEFOQ0VEX1BBSVJTXG5cdHZhciBsZWZ0ID0gcGFpclswXVxuXHR2YXIgcml0ZSA9IHBhaXJbMV1cblx0SU5WRVJTRVNbcml0ZV0gPSBsZWZ0XG5cdElOVkVSU0VTW2xlZnRdID0gcml0ZVxuXG5cbmV4cG9ydCB2YXIgQUxMX0tFWVdPUkRTID0gW1xuXHQndHJ1ZScsICdmYWxzZScsICdudWxsJywgJ3RoaXMnLFxuXHQnZGVsZXRlJywgJ3R5cGVvZicsICdpbicsICdpbnN0YW5jZW9mJyxcblx0J3Rocm93JywgJ2JyZWFrJywgJ2NvbnRpbnVlJywgJ2RlYnVnZ2VyJyxcblx0J2lmJywgJ2Vsc2UnLCAnc3dpdGNoJywgJ2ZvcicsICd3aGlsZScsICdkbycsICd0cnknLCAnY2F0Y2gnLCAnZmluYWxseScsXG5cdCdjbGFzcycsICdleHRlbmRzJywgJ3N1cGVyJywgJ3JldHVybicsXG5cdCd1bmRlZmluZWQnLCAndGhlbicsICd1bmxlc3MnLCAndW50aWwnLCAnbG9vcCcsICdvZicsICdieScsXG5cdCd3aGVuJywnZGVmJywndGFnJywnZG8nLCdlbGlmJywnYmVnaW4nLCd2YXInLCdsZXQnLCdzZWxmJywnYXdhaXQnLCdpbXBvcnQnLFxuXHQnYW5kJywnb3InLCdpcycsJ2lzbnQnLCdub3QnLCd5ZXMnLCdubycsJ2lzYScsJ2Nhc2UnLCduaWwnLCdyZXF1aXJlJ1xuXVxuXG5leHBvcnQgdmFyIFRPSyA9XG5cdFRFUk1JTkFUT1I6ICdURVJNSU5BVE9SJ1xuXHRJTkRFTlQ6ICdJTkRFTlQnXG5cdE9VVERFTlQ6ICdPVVRERU5UJ1xuXHRERUZfQk9EWTogJ0RFRl9CT0RZJ1xuXHRUSEVOOiAnVEhFTidcblx0Q0FUQ0g6ICdDQVRDSCdcblx0XG5leHBvcnQgdmFyIE9QRVJBVE9SX0FMSUFTRVMgPVxuXHRhbmQ6ICcmJidcblx0b3I6ICd8fCdcblx0aXM6ICc9PSdcblx0aXNudDogJyE9J1xuXHRpc2E6ICdpbnN0YW5jZW9mJyBcblxuZXhwb3J0IHZhciBIRVJFR0VYX09NSVQgPSAvXFxzKyg/OiMuKik/L2dcbmV4cG9ydCB2YXIgSEVSRUdFWCA9IC8vLyBeIC97M30gKFtcXHNcXFNdKz8pIC97M30gKFtpbWd5XXswLDR9KSAoPyFcXHcpIC8vL1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2ltYmEvc3JjL2NvbXBpbGVyL2NvbnN0YW50cy5pbWJhIiwiIyMjXG5JbWJhIGlzIHRoZSBuYW1lc3BhY2UgZm9yIGFsbCBydW50aW1lIHJlbGF0ZWQgdXRpbGl0aWVzXG5AbmFtZXNwYWNlXG4jIyNcbnZhciBJbWJhID0ge1ZFUlNJT046ICcxLjAuMCd9XG5cbiMjI1xuVHJ1ZSBpZiBydW5uaW5nIGluIGNsaWVudCBlbnZpcm9ubWVudC5cbkByZXR1cm4ge2Jvb2x9XG4jIyNcbmRlZiBJbWJhLmlzQ2xpZW50XG5cdHJldHVybiAkd2ViJFxuXG4jIyNcblRydWUgaWYgcnVubmluZyBpbiBzZXJ2ZXIgZW52aXJvbm1lbnQuXG5AcmV0dXJuIHtib29sfVxuIyMjXG5kZWYgSW1iYS5pc1NlcnZlclxuXHRyZXR1cm4gJG5vZGUkXG5cblxuIyMjXG5cbkxpZ2h0IHdyYXBwZXIgYXJvdW5kIG5hdGl2ZSBzZXRUaW1lb3V0IHRoYXQgZXhwZWN0cyB0aGUgYmxvY2sgLyBmdW5jdGlvblxuYXMgbGFzdCBhcmd1bWVudCAoaW5zdGVhZCBvZiBmaXJzdCkuIEl0IGFsc28gdHJpZ2dlcnMgYW4gZXZlbnQgdG8gSW1iYVxuYWZ0ZXIgdGhlIHRpbWVvdXQgdG8gbGV0IHNjaGVkdWxlcnMgdXBkYXRlICh0byByZXJlbmRlciBldGMpIGFmdGVyd2FyZHMuXG5cbiMjI1xuZGVmIEltYmEuc2V0VGltZW91dCBkZWxheSwgJmJsb2NrXG5cdHNldFRpbWVvdXQoJixkZWxheSkgZG9cblx0XHRibG9jaygpXG5cdFx0SW1iYS5jb21taXRcblxuIyMjXG5cbkxpZ2h0IHdyYXBwZXIgYXJvdW5kIG5hdGl2ZSBzZXRJbnRlcnZhbCB0aGF0IGV4cGVjdHMgdGhlIGJsb2NrIC8gZnVuY3Rpb25cbmFzIGxhc3QgYXJndW1lbnQgKGluc3RlYWQgb2YgZmlyc3QpLiBJdCBhbHNvIHRyaWdnZXJzIGFuIGV2ZW50IHRvIEltYmFcbmFmdGVyIGV2ZXJ5IGludGVydmFsIHRvIGxldCBzY2hlZHVsZXJzIHVwZGF0ZSAodG8gcmVyZW5kZXIgZXRjKSBhZnRlcndhcmRzLlxuXG4jIyNcbmRlZiBJbWJhLnNldEludGVydmFsIGludGVydmFsLCAmYmxvY2tcblx0c2V0SW50ZXJ2YWwoJixpbnRlcnZhbCkgZG9cblx0XHRibG9jaygpXG5cdFx0SW1iYS5jb21taXRcblxuIyMjXG5DbGVhciBpbnRlcnZhbCB3aXRoIHNwZWNpZmllZCBpZFxuIyMjXG5kZWYgSW1iYS5jbGVhckludGVydmFsIGlkXG5cdGNsZWFySW50ZXJ2YWwoaWQpXG5cbiMjI1xuQ2xlYXIgdGltZW91dCB3aXRoIHNwZWNpZmllZCBpZFxuIyMjXG5kZWYgSW1iYS5jbGVhclRpbWVvdXQgaWRcblx0Y2xlYXJUaW1lb3V0KGlkKVxuXG5cbmRlZiBJbWJhLnN1YmNsYXNzIG9iaiwgc3VwXG5cdGZvciBrLHYgb2Ygc3VwXG5cdFx0b2JqW2tdID0gdiBpZiBzdXAuaGFzT3duUHJvcGVydHkoaylcblxuXHRvYmo6cHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXA6cHJvdG90eXBlKVxuXHRvYmo6X19zdXBlcl9fID0gb2JqOnByb3RvdHlwZTpfX3N1cGVyX18gPSBzdXA6cHJvdG90eXBlXG5cdG9iajpwcm90b3R5cGU6aW5pdGlhbGl6ZSA9IG9iajpwcm90b3R5cGU6Y29uc3RydWN0b3IgPSBvYmpcblx0cmV0dXJuIG9ialxuXG4jIyNcbkxpZ2h0d2VpZ2h0IG1ldGhvZCBmb3IgbWFraW5nIGFuIG9iamVjdCBpdGVyYWJsZSBpbiBpbWJhcyBmb3IvaW4gbG9vcHMuXG5JZiB0aGUgY29tcGlsZXIgY2Fubm90IHNheSBmb3IgY2VydGFpbiB0aGF0IGEgdGFyZ2V0IGluIGEgZm9yIGxvb3AgaXMgYW5cbmFycmF5LCBpdCB3aWxsIGNhY2hlIHRoZSBpdGVyYWJsZSB2ZXJzaW9uIGJlZm9yZSBsb29waW5nLlxuXG5gYGBpbWJhXG4jIHRoaXMgaXMgdGhlIHdob2xlIG1ldGhvZFxuZGVmIEltYmEuaXRlcmFibGUgb1xuXHRyZXR1cm4gbyA/IChvOnRvQXJyYXkgPyBvLnRvQXJyYXkgOiBvKSA6IFtdXG5cbmNsYXNzIEN1c3RvbUl0ZXJhYmxlXG5cdGRlZiB0b0FycmF5XG5cdFx0WzEsMiwzXVxuXG4jIHdpbGwgcmV0dXJuIFsyLDQsNl1cbmZvciB4IGluIEN1c3RvbUl0ZXJhYmxlLm5ld1xuXHR4ICogMlxuXG5gYGBcbiMjI1xuZGVmIEltYmEuaXRlcmFibGUgb1xuXHRyZXR1cm4gbyA/IChvOnRvQXJyYXkgPyBvLnRvQXJyYXkgOiBvKSA6IFtdXG5cbiMjI1xuQ29lcmNlcyBhIHZhbHVlIGludG8gYSBwcm9taXNlLiBJZiB2YWx1ZSBpcyBhcnJheSBpdCB3aWxsXG5jYWxsIGBQcm9taXNlLmFsbCh2YWx1ZSlgLCBvciBpZiBpdCBpcyBub3QgYSBwcm9taXNlIGl0IHdpbGxcbndyYXAgdGhlIHZhbHVlIGluIGBQcm9taXNlLnJlc29sdmUodmFsdWUpYC4gVXNlZCBmb3IgZXhwZXJpbWVudGFsXG5hd2FpdCBzeW50YXguXG5AcmV0dXJuIHtQcm9taXNlfVxuIyMjXG5kZWYgSW1iYS5hd2FpdCB2YWx1ZVxuXHRpZiB2YWx1ZSBpc2EgQXJyYXlcblx0XHRQcm9taXNlLmFsbCh2YWx1ZSlcblx0ZWxpZiB2YWx1ZSBhbmQgdmFsdWU6dGhlblxuXHRcdHZhbHVlXG5cdGVsc2Vcblx0XHRQcm9taXNlLnJlc29sdmUodmFsdWUpXG5cbnZhciBkYXNoUmVnZXggPSAvLS4vZ1xuXG5kZWYgSW1iYS50b0NhbWVsQ2FzZSBzdHJcblx0aWYgc3RyLmluZGV4T2YoJy0nKSA+PSAwXG5cdFx0c3RyLnJlcGxhY2UoZGFzaFJlZ2V4KSBkbyB8bXwgbS5jaGFyQXQoMSkudG9VcHBlckNhc2Vcblx0ZWxzZVxuXHRcdHN0clxuXG5kZWYgSW1iYS5pbmRleE9mIGEsYlxuXHRyZXR1cm4gKGIgJiYgYjppbmRleE9mKSA/IGIuaW5kZXhPZihhKSA6IFtdOmluZGV4T2YuY2FsbChhLGIpXG5cbmRlZiBJbWJhLmxlbiBhXG5cdHJldHVybiBhICYmIChhOmxlbiBpc2EgRnVuY3Rpb24gPyBhOmxlbi5jYWxsKGEpIDogYTpsZW5ndGgpIG9yIDBcblxuZGVmIEltYmEucHJvcCBzY29wZSwgbmFtZSwgb3B0c1xuXHRpZiBzY29wZTpkZWZpbmVQcm9wZXJ0eVxuXHRcdHJldHVybiBzY29wZS5kZWZpbmVQcm9wZXJ0eShuYW1lLG9wdHMpXG5cdHJldHVyblxuXG5kZWYgSW1iYS5hdHRyIHNjb3BlLCBuYW1lLCBvcHRzXG5cdGlmIHNjb3BlOmRlZmluZUF0dHJpYnV0ZVxuXHRcdHJldHVybiBzY29wZS5kZWZpbmVBdHRyaWJ1dGUobmFtZSxvcHRzKVxuXG5cdGxldCBnZXROYW1lID0gSW1iYS50b0NhbWVsQ2FzZShuYW1lKVxuXHRsZXQgc2V0TmFtZSA9IEltYmEudG9DYW1lbENhc2UoJ3NldC0nICsgbmFtZSlcblxuXHRzY29wZTpwcm90b3R5cGVbZ2V0TmFtZV0gPSBkb1xuXHRcdHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKVxuXG5cdHNjb3BlOnByb3RvdHlwZVtzZXROYW1lXSA9IGRvIHx2YWx1ZXxcblx0XHR0aGlzLnNldEF0dHJpYnV0ZShuYW1lLHZhbHVlKVxuXHRcdHJldHVybiB0aGlzXG5cdHJldHVyblxuXG5kZWYgSW1iYS5wcm9wRGlkU2V0IG9iamVjdCwgcHJvcGVydHksIHZhbCwgcHJldlxuXHRsZXQgZm4gPSBwcm9wZXJ0eTp3YXRjaFxuXHRpZiBmbiBpc2EgRnVuY3Rpb25cblx0XHRmbi5jYWxsKG9iamVjdCx2YWwscHJldixwcm9wZXJ0eSlcblx0ZWxpZiBmbiBpc2EgU3RyaW5nIGFuZCBvYmplY3RbZm5dXG5cdFx0b2JqZWN0W2ZuXSh2YWwscHJldixwcm9wZXJ0eSlcblx0cmV0dXJuXG5cblxuIyBCYXNpYyBldmVudHNcbmRlZiBlbWl0X18gZXZlbnQsIGFyZ3MsIG5vZGVcblx0IyB2YXIgbm9kZSA9IGNic1tldmVudF1cblx0dmFyIHByZXYsIGNiLCByZXRcblxuXHR3aGlsZSAocHJldiA9IG5vZGUpIGFuZCAobm9kZSA9IG5vZGU6bmV4dClcblx0XHRpZiBjYiA9IG5vZGU6bGlzdGVuZXJcblx0XHRcdGlmIG5vZGU6cGF0aCBhbmQgY2Jbbm9kZTpwYXRoXVxuXHRcdFx0XHRyZXQgPSBhcmdzID8gY2Jbbm9kZTpwYXRoXS5hcHBseShjYixhcmdzKSA6IGNiW25vZGU6cGF0aF0oKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHQjIGNoZWNrIGlmIGl0IGlzIGEgbWV0aG9kP1xuXHRcdFx0XHRyZXQgPSBhcmdzID8gY2IuYXBwbHkobm9kZSwgYXJncykgOiBjYi5jYWxsKG5vZGUpXG5cblx0XHRpZiBub2RlOnRpbWVzICYmIC0tbm9kZTp0aW1lcyA8PSAwXG5cdFx0XHRwcmV2Om5leHQgPSBub2RlOm5leHRcblx0XHRcdG5vZGU6bGlzdGVuZXIgPSBudWxsXG5cdHJldHVyblxuXG4jIG1ldGhvZCBmb3IgcmVnaXN0ZXJpbmcgYSBsaXN0ZW5lciBvbiBvYmplY3RcbmRlZiBJbWJhLmxpc3RlbiBvYmosIGV2ZW50LCBsaXN0ZW5lciwgcGF0aFxuXHR2YXIgY2JzLCBsaXN0LCB0YWlsXG5cdGNicyA9IG9iajpfX2xpc3RlbmVyc19fIHx8PSB7fVxuXHRsaXN0ID0gY2JzW2V2ZW50XSB8fD0ge31cblx0dGFpbCA9IGxpc3Q6dGFpbCB8fCAobGlzdDp0YWlsID0gKGxpc3Q6bmV4dCA9IHt9KSlcblx0dGFpbDpsaXN0ZW5lciA9IGxpc3RlbmVyXG5cdHRhaWw6cGF0aCA9IHBhdGhcblx0bGlzdDp0YWlsID0gdGFpbDpuZXh0ID0ge31cblx0cmV0dXJuIHRhaWxcblxuIyByZWdpc3RlciBhIGxpc3RlbmVyIG9uY2VcbmRlZiBJbWJhLm9uY2Ugb2JqLCBldmVudCwgbGlzdGVuZXJcblx0dmFyIHRhaWwgPSBJbWJhLmxpc3RlbihvYmosZXZlbnQsbGlzdGVuZXIpXG5cdHRhaWw6dGltZXMgPSAxXG5cdHJldHVybiB0YWlsXG5cbiMgcmVtb3ZlIGEgbGlzdGVuZXJcbmRlZiBJbWJhLnVubGlzdGVuIG9iaiwgZXZlbnQsIGNiLCBtZXRoXG5cdHZhciBub2RlLCBwcmV2XG5cdHZhciBtZXRhID0gb2JqOl9fbGlzdGVuZXJzX19cblx0cmV0dXJuIHVubGVzcyBtZXRhXG5cblx0aWYgbm9kZSA9IG1ldGFbZXZlbnRdXG5cdFx0d2hpbGUgKHByZXYgPSBub2RlKSBhbmQgKG5vZGUgPSBub2RlOm5leHQpXG5cdFx0XHRpZiBub2RlID09IGNiIHx8IG5vZGU6bGlzdGVuZXIgPT0gY2Jcblx0XHRcdFx0cHJldjpuZXh0ID0gbm9kZTpuZXh0XG5cdFx0XHRcdCMgY2hlY2sgZm9yIGNvcnJlY3QgcGF0aCBhcyB3ZWxsP1xuXHRcdFx0XHRub2RlOmxpc3RlbmVyID0gbnVsbFxuXHRcdFx0XHRicmVha1xuXHRyZXR1cm5cblxuIyBlbWl0IGV2ZW50XG5kZWYgSW1iYS5lbWl0IG9iaiwgZXZlbnQsIHBhcmFtc1xuXHRpZiB2YXIgY2IgPSBvYmo6X19saXN0ZW5lcnNfX1xuXHRcdGVtaXRfXyhldmVudCxwYXJhbXMsY2JbZXZlbnRdKSBpZiBjYltldmVudF1cblx0XHRlbWl0X18oZXZlbnQsW2V2ZW50LHBhcmFtc10sY2I6YWxsKSBpZiBjYjphbGwgIyBhbmQgZXZlbnQgIT0gJ2FsbCdcblx0cmV0dXJuXG5cbmRlZiBJbWJhLm9ic2VydmVQcm9wZXJ0eSBvYnNlcnZlciwga2V5LCB0cmlnZ2VyLCB0YXJnZXQsIHByZXZcblx0aWYgcHJldiBhbmQgdHlwZW9mIHByZXYgPT0gJ29iamVjdCdcblx0XHRJbWJhLnVubGlzdGVuKHByZXYsJ2FsbCcsb2JzZXJ2ZXIsdHJpZ2dlcilcblx0aWYgdGFyZ2V0IGFuZCB0eXBlb2YgdGFyZ2V0ID09ICdvYmplY3QnXG5cdFx0SW1iYS5saXN0ZW4odGFyZ2V0LCdhbGwnLG9ic2VydmVyLHRyaWdnZXIpXG5cdHNlbGZcblxubW9kdWxlOmV4cG9ydHMgPSBJbWJhXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vaW1iYS9zcmMvaW1iYS9pbWJhLmltYmEiLCJ2YXIgSW1iYSA9IHJlcXVpcmUoXCIuL2ltYmFcIilcbnZhciBhY3RpdmF0ZSA9IG5vXG5pZiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuXHRpZiB3aW5kb3cuSW1iYVxuXHRcdGNvbnNvbGUud2FybiBcIkltYmEgdntJbWJhLlZFUlNJT059IGlzIGFscmVhZHkgbG9hZGVkLlwiXG5cdFx0SW1iYSA9IHdpbmRvdy5JbWJhXG5cdGVsc2Vcblx0XHR3aW5kb3cuSW1iYSA9IEltYmFcblx0XHRhY3RpdmF0ZSA9IHllc1xuXHRcdGlmIHdpbmRvdzpkZWZpbmUgYW5kIHdpbmRvdzpkZWZpbmU6YW1kXG5cdFx0XHR3aW5kb3cuZGVmaW5lKFwiaW1iYVwiLFtdKSBkbyByZXR1cm4gSW1iYVxuXG5tb2R1bGUuZXhwb3J0cyA9IEltYmFcblxudW5sZXNzICR3ZWJ3b3JrZXIkXG5cdHJlcXVpcmUgJy4vc2NoZWR1bGVyJ1xuXHRyZXF1aXJlICcuL2RvbS9pbmRleCdcblxuaWYgYWN0aXZhdGVcblx0SW1iYS5FdmVudE1hbmFnZXIuYWN0aXZhdGVcblx0XG5pZiAkbm9kZSRcblx0dW5sZXNzICR3ZWJwYWNrJFxuXHRcdHJlcXVpcmUgJy4uLy4uL3JlZ2lzdGVyLmpzJ1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2ltYmEvc3JjL2ltYmEvaW5kZXguaW1iYSIsInJlcXVpcmUgJ2ltYmEvc3JjL2ltYmEvaW1iYSdcblxuZXh0ZXJuIHBvc3RNZXNzYWdlXG5cbnZhciBjb21waWxlciA9IHJlcXVpcmUgJ2ltYmEvc3JjL2NvbXBpbGVyL2NvbXBpbGVyJ1xuXG5pbXBvcnQgSW1iYVBhcnNlRXJyb3IgZnJvbSAnaW1iYS9zcmMvY29tcGlsZXIvZXJyb3JzJ1xudmFyIGFwaSA9IHt9XG5cbmRlZiBub3JtYWxpemVFcnJvciBlLCBvXG5cdGlmIGU6bGV4ZXIgYW5kICEoZSBpc2EgSW1iYVBhcnNlRXJyb3IpXG5cdFx0ZSA9IEltYmFQYXJzZUVycm9yLm5ldyhlLCB0b2tlbnM6IGU6bGV4ZXI6dG9rZW5zLCBwb3M6IGU6bGV4ZXI6cG9zKVxuXHQjIGVsc2Vcblx0I1x0Y29uc29sZS5sb2cgJ2Vycm9yIGhhcyBubyBsZXhlciBidXQgaXMgcGFyc2UtZXJyb3InLGU6dG9KU09OXG5cdCNcdGUgPSB7bWVzc2FnZTogZTptZXNzYWdlfVxuXHRcblx0aWYgZTp0b0pTT04gIyBpc2EgSW1iYVBhcnNlRXJyb3Jcblx0XHQjIGNvbnNvbGUubG9nICdjb252ZXJ0aW5nIGVycm9yIHRvIGpzb24nXG5cdFx0ZSA9IGUudG9KU09OXG5cdFxuXHRpZiBlIGlzYSBFcnJvclxuXHRcdGUgPSB7bWVzc2FnZTogZTptZXNzYWdlfVxuXG5cdHJldHVybiBlXG5cbmRlZiBhcGkuY29tcGlsZSBjb2RlLCBvID0ge31cblx0dHJ5XG5cdFx0dmFyIHJlcyA9IGNvbXBpbGVyLmNvbXBpbGUoY29kZSxvKVxuXHRcdHZhciByZXQgPSB7c291cmNlbWFwOiByZXM6c291cmNlbWFwLCBqczoge2JvZHk6IHJlcy50b1N0cmluZ319XG5cdFx0cmV0dXJuIHJldFxuXHRjYXRjaCBlXG5cdFx0cmV0dXJuIHtlcnJvcjogbm9ybWFsaXplRXJyb3IoZSxvKX1cblxuZGVmIGFwaS5idW5kbGUgYnVuZGxlLCBvID0ge31cblx0dmFyIG91dHB1dCA9IHtGSUxFUzoge319XG5cblx0Zm9yIG93biBuYW1lLGZpbGUgb2YgYnVuZGxlLkZJTEVTXG5cdFx0aWYgbmFtZS5tYXRjaCgvXFwuaW1iYSQvKVxuXHRcdFx0dmFyIGpzbmFtZSA9IG5hbWUucmVwbGFjZSgvXFwuaW1iYSQvLCcuanMnKVxuXHRcdFx0dmFyIG91dCA9IG91dHB1dC5GSUxFU1tqc25hbWVdID0ge1xuXHRcdFx0XHRpZDogZmlsZTppZFxuXHRcdFx0XHRuYW1lOiBqc25hbWVcblx0XHRcdH1cblxuXHRcdFx0dHJ5XG5cblx0XHRcdFx0bzpmaWxlbmFtZSA9IG5hbWVcblx0XHRcdFx0bzpzb3VyY2VQYXRoID0gbmFtZVxuXHRcdFx0XHRvOnRhcmdldFBhdGggPSBqc25hbWVcblxuXHRcdFx0XHR2YXIgcmVzID0gY29tcGlsZXIuY29tcGlsZShmaWxlOmJvZHksbylcblx0XHRcdFx0b3V0OnNvdXJjZW1hcCA9IHJlczpzb3VyY2VtYXBcblx0XHRcdFx0b3V0OmJvZHkgPSByZXMudG9TdHJpbmdcblx0XHRcdGNhdGNoIGVcblx0XHRcdFx0b3V0OmVycm9yID0gbm9ybWFsaXplRXJyb3IoZSxvKVxuXHRyZXR1cm4gb3V0cHV0XG5cbmRlZiBhcGkuYW5hbHl6ZSBjb2RlLCBvID0ge31cblx0dmFyIG1ldGFcblx0dHJ5XG5cdFx0dmFyIGFzdCA9IGNvbXBpbGVyLnBhcnNlKGNvZGUsbylcblx0XHRtZXRhID0gYXN0LmFuYWx5emUobG9nbGV2ZWw6IDApXG5cdGNhdGNoIGVcblx0XHQjIGNvbnNvbGUubG9nIFwic29tZXRoaW5nIHdyb25nIHtlOm1lc3NhZ2V9XCIsby5AdG9rZW5zLGU6dG9KU09OXG5cdFx0ZSA9IG5vcm1hbGl6ZUVycm9yKGUsbylcblx0XHRtZXRhID0ge3dhcm5pbmdzOiBbZV19XG5cdHJldHVybiB7bWV0YTogbWV0YX1cblxuZ2xvYmFsIGRlZiBvbm1lc3NhZ2UgZVxuXHQjIGNvbnNvbGUubG9nICdtZXNzYWdlIHRvIHdlYndvcmtlcicsZTpkYXRhXG5cdHZhciBwYXJhbXMgPSBlOmRhdGFcblx0dmFyIGlkID0gcGFyYW1zOmlkXG5cdHZhciBzdGFydCA9IERhdGUubmV3XG5cblx0aWYgYXBpW3BhcmFtc1swXV0gaXNhIEZ1bmN0aW9uXG5cdFx0bGV0IGZuID0gYXBpW3BhcmFtc1swXV1cblx0XHR2YXIgcmVzdWx0ID0gZm4uYXBwbHkoYXBpLHBhcmFtcy5zbGljZSgxKSlcblxuXHRcdHJlc3VsdDp3b3JrZXIgPSB7XG5cdFx0XHRyZWY6IGlkXG5cdFx0XHRhY3Rpb246IHBhcmFtc1swXVxuXHRcdFx0ZWxhcHNlZDogRGF0ZS5uZXcgLSBzdGFydFxuXHRcdH1cblxuXHRcdHBvc3RNZXNzYWdlKHJlc3VsdClcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpbWJsYS93ZWJ3b3JrZXIuaW1iYSIsIiMgaW1iYSRpbmxpbmVIZWxwZXJzPTFcbiMgdmFyIGltYmEgPSByZXF1aXJlICcuLi9pbWJhJ1xudmFyIFQgPSByZXF1aXJlICcuL3Rva2VuJ1xudmFyIHV0aWwgPSByZXF1aXJlICcuL2hlbHBlcnMnXG52YXIgbGV4ZXIgPSByZXF1aXJlICcuL2xleGVyJ1xudmFyIHJld3JpdGVyID0gcmVxdWlyZSAnLi9yZXdyaXRlcidcbmV4cG9ydCB2YXIgcGFyc2VyID0gcmVxdWlyZSgnLi4vLi4vbGliL2NvbXBpbGVyL3BhcnNlcicpWydwYXJzZXInXVxudmFyIGFzdCA9IHJlcXVpcmUgJy4vbm9kZXMnXG5cbmltcG9ydCBJbWJhUGFyc2VFcnJvciBmcm9tICcuL2Vycm9ycydcblxuIyBJbnN0YW50aWF0ZSBhIExleGVyIGZvciBvdXIgdXNlIGhlcmUuXG5leHBvcnQgdmFyIGxleCA9IGxleGVyLkxleGVyLm5ld1xuZXhwb3J0IHZhciBSZXdyaXRlciA9IHJld3JpdGVyLlJld3JpdGVyXG52YXIgcmV3cml0ZXIgPSBSZXdyaXRlci5uZXdcblxucGFyc2VyOmxleGVyID0gbGV4Lmppc29uQnJpZGdlXG5wYXJzZXI6eXkgPSBhc3QgIyBldmVyeXRoaW5nIGlzIGV4cG9ydGVkIHJpZ2h0IGhlcmUgbm93XG5cblxuZXhwb3J0IGRlZiB0b2tlbml6ZSBjb2RlLCBvID0ge31cblx0dHJ5XG5cdFx0IyBjb25zb2xlLmxvZygndG9rZW5pemUnKSBpZiBvOnByb2ZpbGVcblx0XHRjb25zb2xlLnRpbWUoJ3Rva2VuaXplJykgaWYgbzpwcm9maWxlXG5cdFx0by5Ac291cmNlID0gY29kZVxuXHRcdGxleC5yZXNldFxuXHRcdHZhciB0b2tlbnMgPSBsZXgudG9rZW5pemUgY29kZSwgb1xuXHRcdGNvbnNvbGUudGltZUVuZCgndG9rZW5pemUnKSBpZiBvOnByb2ZpbGVcblxuXHRcdHVubGVzcyBvOnJld3JpdGUgPT09IG5vXG5cdFx0XHR0b2tlbnMgPSByZXdyaXRlci5yZXdyaXRlKHRva2VucyxvKVxuXHRcdHJldHVybiB0b2tlbnNcblxuXHRjYXRjaCBlcnJcblx0XHR0aHJvdyBlcnJcblxuZXhwb3J0IGRlZiByZXdyaXRlIHRva2VucywgbyA9IHt9XG5cdHRyeVxuXHRcdGNvbnNvbGUudGltZSgncmV3cml0ZScpIGlmIG86cHJvZmlsZVxuXHRcdHRva2VucyA9IHJld3JpdGVyLnJld3JpdGUgdG9rZW5zLCBvXG5cdFx0Y29uc29sZS50aW1lRW5kKCdyZXdyaXRlJykgaWYgbzpwcm9maWxlXG5cdGNhdGNoIGVyclxuXHRcdHRocm93IGVyclxuXHRyZXR1cm4gdG9rZW5zXG5cblxuZXhwb3J0IGRlZiBwYXJzZSBjb2RlLCBvID0ge31cblx0dmFyIHRva2VucyA9IGNvZGUgaXNhIEFycmF5ID8gY29kZSA6IHRva2VuaXplKGNvZGUsbylcblx0dHJ5XG5cdFx0by5Ac291cmNlIHx8PSBjb2RlIGlmIHRva2VucyAhPSBjb2RlXG5cdFx0by5AdG9rZW5zID0gdG9rZW5zXG5cdFx0cmV0dXJuIHBhcnNlci5wYXJzZSB0b2tlbnNcblx0Y2F0Y2ggZXJyXG5cdFx0ZXJyOl9jb2RlID0gY29kZVxuXHRcdGVycjpfZmlsZW5hbWUgPSBvOmZpbGVuYW1lIGlmIG86ZmlsZW5hbWVcblx0XHR0aHJvdyBlcnJcblxuXG5leHBvcnQgZGVmIGNvbXBpbGUgY29kZSwgbyA9IHt9XG5cdHRyeVxuXHRcdCMgY2hlY2sgaWYgY29kZSBpcyBjb21wbGV0ZWx5IGJsYW5rXG5cdFx0dW5sZXNzIC9cXFMvLnRlc3QoY29kZSlcblx0XHRcdHJldHVybiB7anM6IFwiXCJ9XG5cblx0XHR2YXIgdG9rZW5zID0gdG9rZW5pemUoY29kZSwgbylcblx0XHR2YXIgYXN0ID0gcGFyc2UodG9rZW5zLCBvKVxuXHRcdHJldHVybiBhc3QuY29tcGlsZShvKVxuXHRjYXRjaCBlcnJcblx0XHRlcnI6X2NvZGUgPSBjb2RlXG5cdFx0ZXJyOl9maWxlbmFtZSA9IG86ZmlsZW5hbWUgaWYgbzpmaWxlbmFtZVxuXHRcdGlmIG86ZXZhbGluZ1xuXHRcdFx0Y29uc29sZS5sb2cgXCJlcnJvciBkdXJpbmcgY29tcGlsZVwiLG86ZmlsZW5hbWVcblx0XHR0aHJvdyBlcnJcblxuZXhwb3J0IGRlZiBhbmFseXplIGNvZGUsIG8gPSB7fVxuXHR2YXIgbWV0YVxuXHR0cnlcblx0XHR2YXIgYXN0ID0gcGFyc2UoY29kZSxvKVxuXHRcdG1ldGEgPSBhc3QuYW5hbHl6ZShvKVxuXHRjYXRjaCBlXG5cdFx0dW5sZXNzIGUgaXNhIEltYmFQYXJzZUVycm9yXG5cdFx0XHRpZiBlOmxleGVyXG5cdFx0XHRcdGUgPSBJbWJhUGFyc2VFcnJvci5uZXcoZSwgdG9rZW5zOiBlOmxleGVyOnRva2VucywgcG9zOiBlOmxleGVyOnBvcylcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhyb3cgZVxuXHRcdG1ldGEgPSB7d2FybmluZ3M6IFtlXX1cblx0cmV0dXJuIG1ldGFcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9pbWJhL3NyYy9jb21waWxlci9jb21waWxlci5pbWJhIiwiIyBpbWJhJGlubGluZUhlbHBlcnM9MVxuXG52YXIgVCA9IHJlcXVpcmUgJy4vdG9rZW4nXG52YXIgVG9rZW4gPSBULlRva2VuXG5cbmltcG9ydCBJTlZFUlNFUyBmcm9tICcuL2NvbnN0YW50cydcblxudmFyIEsgPSAwXG5cbnZhciBFUlIgPSByZXF1aXJlICcuL2Vycm9ycydcblxuIyBDb25zdGFudHNcbiMgLS0tLS0tLS0tXG5cbiMgS2V5d29yZHMgdGhhdCBJbWJhIHNoYXJlcyBpbiBjb21tb24gd2l0aCBKYXZhU2NyaXB0LlxudmFyIEpTX0tFWVdPUkRTID0gW1xuXHQndHJ1ZScsICdmYWxzZScsICdudWxsJywgJ3RoaXMnXG5cdCdkZWxldGUnLCAndHlwZW9mJywgJ2luJywgJ2luc3RhbmNlb2YnXG5cdCd0aHJvdycsICdicmVhaycsICdjb250aW51ZScsICdkZWJ1Z2dlcidcblx0J2lmJywgJ2Vsc2UnLCAnc3dpdGNoJywgJ2ZvcicsICd3aGlsZScsICdkbycsICd0cnknLCAnY2F0Y2gnLCAnZmluYWxseSdcblx0J2NsYXNzJywgJ2V4dGVuZHMnLCAnc3VwZXInLCAncmV0dXJuJ1xuXVxuXG4jIG5ldyBjYW4gYmUgdXNlZCBhcyBhIGtleXdvcmQgaW4gaW1iYSwgc2luY2Ugb2JqZWN0IGluaXRpbmcgaXMgZG9uZSB0aHJvdWdoXG4jIE15T2JqZWN0Lm5ldy4gbmV3IGlzIGEgdmVyeSB1c2VmdWwgdmFybmFtZS5cblxuIyBXZSB3YW50IHRvIHRyZWF0IHJldHVybiBsaWtlIGFueSByZWd1bGFyIGNhbGwgZm9yIG5vd1xuIyBNdXN0IGJlIGNhcmVmdWwgdG8gdGhyb3cgdGhlIGV4Y2VwdGlvbnMgaW4gQVNULCBzaW5jZSB0aGUgcGFyc2VyXG4jIHdvbnRcblxuIyBJbWJhLW9ubHkga2V5d29yZHMuIHZhciBzaG91bGQgbW92ZSB0byBKU19LZXl3b3Jkc1xuIyBzb21lIHdvcmRzIChsaWtlIHRva2lkKSBzaG91bGQgYmUgY29udGV4dC1zcGVjaWZpY1xudmFyIElNQkFfS0VZV09SRFMgPSBbXG5cdCd1bmRlZmluZWQnLCAndGhlbicsICd1bmxlc3MnLCAndW50aWwnLCAnbG9vcCcsICdvZicsICdieScsXG5cdCd3aGVuJywnZGVmJywndGFnJywnZG8nLCdlbGlmJywnYmVnaW4nLCd2YXInLCdsZXQnLCdzZWxmJywnYXdhaXQnLCdpbXBvcnQnLCdyZXF1aXJlJ1xuXVxuXG52YXIgSU1CQV9DT05URVhUVUFMX0tFWVdPUkRTID0gWydleHRlbmQnLCdzdGF0aWMnLCdsb2NhbCcsJ2V4cG9ydCcsJ2dsb2JhbCcsJ3Byb3AnXVxuXG4jIEZpeGVkQXJyYXkgZm9yIHBlcmZvcm1hbmNlXG4jIHZhciBBTExfS0VZV09SRFMgPSBKU19LRVlXT1JEUy5jb25jYXQoSU1CQV9LRVlXT1JEUylcbmV4cG9ydCB2YXIgQUxMX0tFWVdPUkRTID0gW1xuXHQndHJ1ZScsICdmYWxzZScsICdudWxsJywgJ3RoaXMnLFxuXHQnZGVsZXRlJywgJ3R5cGVvZicsICdpbicsICdpbnN0YW5jZW9mJyxcblx0J3Rocm93JywgJ2JyZWFrJywgJ2NvbnRpbnVlJywgJ2RlYnVnZ2VyJyxcblx0J2lmJywgJ2Vsc2UnLCAnc3dpdGNoJywgJ2ZvcicsICd3aGlsZScsICdkbycsICd0cnknLCAnY2F0Y2gnLCAnZmluYWxseScsXG5cdCdjbGFzcycsICdleHRlbmRzJywgJ3N1cGVyJywgJ3JldHVybicsXG5cdCd1bmRlZmluZWQnLCAndGhlbicsICd1bmxlc3MnLCAndW50aWwnLCAnbG9vcCcsICdvZicsICdieScsXG5cdCd3aGVuJywnZGVmJywndGFnJywnZG8nLCdlbGlmJywnYmVnaW4nLCd2YXInLCdsZXQnLCdzZWxmJywnYXdhaXQnLCdpbXBvcnQnLFxuXHQnYW5kJywnb3InLCdpcycsJ2lzbnQnLCdub3QnLCd5ZXMnLCdubycsJ2lzYScsJ2Nhc2UnLCduaWwnLCdyZXF1aXJlJ1xuXVxuXG4jIFRoZSBsaXN0IG9mIGtleXdvcmRzIHRoYXQgYXJlIHJlc2VydmVkIGJ5IEphdmFTY3JpcHQsIGJ1dCBub3QgdXNlZCwgb3IgYXJlXG4jIHVzZWQgYnkgSW1iYSBpbnRlcm5hbGx5LiBXZSB0aHJvdyBhbiBlcnJvciB3aGVuIHRoZXNlIGFyZSBlbmNvdW50ZXJlZCxcbiMgdG8gYXZvaWQgaGF2aW5nIGEgSmF2YVNjcmlwdCBlcnJvciBhdCBydW50aW1lLiAgIyAndmFyJywgJ2xldCcsIC0gbm90IGluc2lkZSBoZXJlXG52YXIgUkVTRVJWRUQgPSBbJ2Nhc2UnLCAnZGVmYXVsdCcsICdmdW5jdGlvbicsICd2b2lkJywgJ3dpdGgnLCAnY29uc3QnLCAnZW51bScsICduYXRpdmUnXVxudmFyIFNUUklDVF9SRVNFUlZFRCA9IFsnY2FzZScsJ2Z1bmN0aW9uJywndm9pZCcsJ2NvbnN0J11cblxuIyBUaGUgc3VwZXJzZXQgb2YgYm90aCBKYXZhU2NyaXB0IGtleXdvcmRzIGFuZCByZXNlcnZlZCB3b3Jkcywgbm9uZSBvZiB3aGljaCBtYXlcbiMgYmUgdXNlZCBhcyBpZGVudGlmaWVycyBvciBwcm9wZXJ0aWVzLlxudmFyIEpTX0ZPUkJJRERFTiA9IEpTX0tFWVdPUkRTLmNvbmNhdCBSRVNFUlZFRFxuXG52YXIgTUVUSE9EX0lERU5USUZJRVIgPSAvLy8gXlxuXHQoIFxuXHRcdCgoW1xceDIzXT9bXFwkQS1aYS16X1xceDdmLVxcdWZmZmZdWyRcXC1cXHdcXHg3Zi1cXHVmZmZmXSopKFtcXD1dPykpIHwgXG5cdFx0KDw9PnxcXHwoPyFbXFx8PV0pKVxuXHQpXG4vLy9cbiMgcmVtb3ZlZCB+PXx+fCB8Jig/IVsmPV0pXG5cbiMgVG9rZW4gbWF0Y2hpbmcgcmVnZXhlcy5cbiMgYWRkZWQgaHlwaGVucyB0byBpZGVudGlmaWVycyBub3cgLSB0byB0ZXN0XG52YXIgSURFTlRJRklFUiA9IC8vLyBeXG5cdChcblx0XHQoXFwkfEBAfEB8XFwjKVtcXHdBLVphLXpfXFwtXFx4N2YtXFx1ZmZmZl1bJFxcd1xceDdmLVxcdWZmZmZdKiAoXFwtWyRcXHdcXHg3Zi1cXHVmZmZmXSspKiB8XG5cdFx0WyRBLVphLXpfXVskXFx3XFx4N2YtXFx1ZmZmZl0qIChcXC1bJFxcd1xceDdmLVxcdWZmZmZdKykqXG5cdClcblx0KCBbXlxcblxcU10qIDogKD8hW1xcKlxcPTokXFx3XFx4N2YtXFx1ZmZmZl0pICk/ICAjIElzIHRoaXMgYSBwcm9wZXJ0eSBuYW1lP1xuLy8vXG5cbnZhciBPQkpFQ1RfS0VZID0gLy8vIF5cblx0KCAoXFwkfEBAfEB8KVskQS1aYS16X1xceDdmLVxcdWZmZmZcXC1dWyRcXHdcXHg3Zi1cXHVmZmZmXFwtXSopXG5cdCggW15cXG5cXFNcXHNdKiA6ICg/IVtcXCpcXD06JEEtWmEtelxcX1xceDdmLVxcdWZmZmZdKSApICAjIElzIHRoaXMgYSBwcm9wZXJ0eSBuYW1lP1xuLy8vXG5cbnZhciBUQUcgPSAvLy8gXlxuXHQoXFw8fCUpKD89W0EtWmEtelxcI1xcLlxce1xcQFxcPl0pXG4vLy9cblxudmFyIFRBR19UWVBFID0gL14oXFx3W1xcd1xcZF0qOik/KFxcd1tcXHdcXGRdKikoLVtcXHdcXGRdKykqL1xudmFyIFRBR19JRCA9IC9eIygoXFx3W1xcd1xcZF0qKSgtW1xcd1xcZF0rKSopL1xuXG52YXIgVEFHX0FUVFIgPSAvXihbXFwuXFw6XT9bXFx3XFxfXSsoW1xcLVxcOl1bXFx3XSspKikoXFxzKSpcXD0vXG5cbnZhciBTRUxFQ1RPUiA9IC9eKFslXFwkXXsxLDJ9KShbXFwoXFx3XFwjXFwuXFxbXSkvXG52YXIgU0VMRUNUT1JfUEFSVCA9IC9eKFxcI3xcXC58Onw6Oik/KFtcXHddKyhcXC1bXFx3XSspKikvXG52YXIgU0VMRUNUT1JfQ09NQklOQVRPUiA9IC9eIChcXCt8XFw+fFxcfikqXFxzKig/PVtcXHdcXC5cXCNcXDpcXHtcXCpcXFtdKS9cblxudmFyIFNFTEVDVE9SX1BTRVVET19DTEFTUyA9IC9eKDo6PykoW1xcd10rKFxcLVtcXHddKykqKS9cbnZhciBTRUxFQ1RPUl9BVFRSX09QID0gL14oXFwkPXxcXH49fFxcXj18XFwqPXxcXHw9fD18XFwhPSkvXG52YXIgU0VMRUNUT1JfQVRUUiA9IC9eXFxbKFtcXHdcXF9cXC1dKykoXFwkPXxcXH49fFxcXj18XFwqPXxcXHw9fD18XFwhPSkvXG5cbnZhciBTWU1CT0wgPSAvLy9eXG5cdFxcOigoKFtcXCpcXEAkXFx3XFx4N2YtXFx1ZmZmZl0rKSsoW1xcLVxcXFxcXDpdW1xcd1xceDdmLVxcdWZmZmZdKykqKXw9PXxcXDw9XFw+KVxuLy8vXG5cblxudmFyIE5VTUJFUiA9IC8vL1xuXHReIDB4W1xcZGEtZl0rIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIGhleFxuXHReIDBiWzAxXSsgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgYmluYXJ5XG5cdF4gXFxkKlxcLj9cXGQrICg/OmVbKy1dP1xcZCspPyAgIyBkZWNpbWFsXG4vLy9pXG5cbnZhciBIRVJFRE9DID0gLy8vIF4gKFwiXCJcInwnJycpIChbXFxzXFxTXSo/KSAoPzpcXG5bXlxcblxcU10qKT8gXFwxIC8vL1xuXG52YXIgT1BFUkFUT1IgPSAvLy8gXiAoXG5cdD86IFstPV09PiAgICAgICAgICAgICAjIGZ1bmN0aW9uIC0gd2hhdFxuXHQgfCA9PT1cblx0IHwgLT5cblx0IHwgPT5cblx0IHwgIT09XG5cdCB8IFstKyovJTw+JnxeIT89XT0gICMgY29tcG91bmQgYXNzaWduIC8gY29tcGFyZVxuXHQgfCA9PFxuXHQgfCA+Pj49PyAgICAgICAgICAgICAjIHplcm8tZmlsbCByaWdodCBzaGlmdFxuXHQgfCAoWy0rOl0pXFwxICAgICAgICAgIyBkb3VibGVzXG5cdCB8IChbJnw8Pl0pXFwyPT8gICAgICAjIGxvZ2ljIC8gc2hpZnRcblx0IHwgXFw/XFwuICAgICAgICAgICAgICAjIHNvYWsgYWNjZXNzXG5cdCB8IFxcP1xcOiAgICAgICAgICAgICAgIyBzb2FrIHN5bWJvbFxuXHQgfCBcXC57MiwzfSAgICAgICAgICAgIyByYW5nZSBvciBzcGxhdFxuXHQgfCBcXCooPz1bYS16QS1aXFxfXSkgICAjIHNwbGF0IC0tIFxuKSAvLy9cblxuIyBGSVhNRSBzcGxhdCBzaG91bGQgb25seSBiZSBhbGxvd2VkIHdoZW4gdGhlIHByZXZpb3VzIHRoaW5nIGlzIHNwYWNlZCBvciBpbnNpZGUgY2FsbD9cblxudmFyIFdISVRFU1BBQ0UgPSAvXlteXFxuXFxTXSsvXG5cbnZhciBDT01NRU5UICAgID0gL14jIyMoW14jXVtcXHNcXFNdKj8pKD86IyMjW15cXG5cXFNdKnwoPzojIyMpPyQpL1xuIyBDT01NRU5UICAgID0gL14jIyMoW14jXVtcXHNcXFNdKj8pKD86IyMjW15cXG5cXFNdKnwoPzojIyMpPyQpfF4oPzpcXHMqKCNcXHMuKnwjXFxzKiQpKSsvXG52YXIgSU5MSU5FX0NPTU1FTlQgPSAvXihcXHMqKSgjWyBcXHRcXCFdKC4qKXwjWyBcXHRdPyg/PVxcbnwkKSkrL1xuXG52YXIgQ09ERSAgICAgICA9IC9eWy09XT0+L1xuXG52YXIgTVVMVElfREVOVCA9IC9eKD86XFxuW15cXG5cXFNdKikrL1xuXG52YXIgU0lNUExFU1RSICA9IC9eJ1teXFxcXCddKig/OlxcXFwuW15cXFxcJ10qKSonL1xuXG52YXIgSlNUT0tFTiAgICA9IC9eYFteXFxcXGBdKig/OlxcXFwuW15cXFxcYF0qKSpgL1xuXG4jIFJlZ2V4LW1hdGNoaW5nLXJlZ2V4ZXMuXG52YXIgUkVHRVggPSAvLy8gXlxuXHQoLyAoPyEgW1xccz1dICkgICAjIGRpc2FsbG93IGxlYWRpbmcgd2hpdGVzcGFjZSBvciBlcXVhbHMgc2lnbnNcblx0W14gWyAvIFxcbiBcXFxcIF0qICAjIGV2ZXJ5IG90aGVyIHRoaW5nXG5cdCg/OlxuXHRcdCg/OiBcXFxcW1xcc1xcU10gICAjIGFueXRoaW5nIGVzY2FwZWRcblx0XHRcdHwgXFxbICAgICAgICAgIyBjaGFyYWN0ZXIgY2xhc3Ncblx0XHRcdFx0XHQgW14gXFxdIFxcbiBcXFxcIF0qXG5cdFx0XHRcdFx0ICg/OiBcXFxcW1xcc1xcU10gW14gXFxdIFxcbiBcXFxcIF0qICkqXG5cdFx0XHRcdCBdXG5cdFx0KSBbXiBbIC8gXFxuIFxcXFwgXSpcblx0KSpcblx0LykgKFtpbWd5XXswLDR9KSAoPyFcXHcpXG4vLy9cblxudmFyIEhFUkVHRVggICAgICA9IC8vLyBeIC97M30gKFtcXHNcXFNdKz8pIC97M30gKFtpbWd5XXswLDR9KSAoPyFcXHcpIC8vL1xuXG52YXIgSEVSRUdFWF9PTUlUID0gL1xccysoPzojLiopPy9nXG5cbiMgVG9rZW4gY2xlYW5pbmcgcmVnZXhlcy5cbnZhciBNVUxUSUxJTkVSICAgICAgPSAvXFxuL2dcblxudmFyIEhFUkVET0NfSU5ERU5UICA9IC9cXG4rKFteXFxuXFxTXSopL2dcblxudmFyIEhFUkVET0NfSUxMRUdBTCA9IC9cXCpcXC8vXG5cbiMgZXhwZW5zaXZlP1xudmFyIExJTkVfQ09OVElOVUVSICA9IC8vLyBeIFxccyogKD86ICwgfCBcXD8/XFwuKD8hWy5cXGRdKSB8IDo6ICkgLy8vXG5cbnZhciBUUkFJTElOR19TUEFDRVMgPSAvXFxzKyQvXG5cbnZhciBDT05TVF9JREVOVElGSUVSID0gL15bQS1aXS9cblxudmFyIEVOVl9GTEFHID0gL15cXCRcXHcrXFwkL1xuXG52YXIgQVJHVkFSID0gL15cXCRcXGQkL1xuXG4jIENvbXBvdW5kIGFzc2lnbm1lbnQgdG9rZW5zLlxudmFyIENPTVBPVU5EX0FTU0lHTiA9IFsgJy09JywgJys9JywgJy89JywgJyo9JywgJyU9JywgJ3x8PScsICcmJj0nLCAnPz0nLCAnPDw9JywgJz4+PScsICc+Pj49JywgJyY9JywgJ149JywgJ3w9JywnPTwnXVxuXG4jIFVuYXJ5IHRva2Vucy5cbnZhciBVTkFSWSA9IFsnIScsICd+JywgJ05FVycsICdUWVBFT0YnLCAnREVMRVRFJ11cblxuIyBMb2dpY2FsIHRva2Vucy5cbnZhciBMT0dJQyAgID0gWycmJicsICd8fCcsICcmJywgJ3wnLCAnXicsJ2FuZCcsJ29yJ11cblxuIyBCaXQtc2hpZnRpbmcgdG9rZW5zLlxudmFyIFNISUZUICAgPSBbJzw8JywgJz4+JywgJz4+PiddXG5cbiMgQ29tcGFyaXNvbiB0b2tlbnMuXG52YXIgQ09NUEFSRSA9IFsnPT09JywgJyE9PScsICc9PScsICchPScsICc8JywgJz4nLCAnPD0nLCAnPj0nLCc9PT0nLCchPT0nXVxuXG4jIE92ZXJpZGVhYmxlIG1ldGhvZHNcbnZhciBPUF9NRVRIT0RTID0gWyc8PT4nLCc8PCcsJy4uJ11cblxuIyBNYXRoZW1hdGljYWwgdG9rZW5zLlxudmFyIE1BVEggPSBbJyonLCAnLycsICclJywgJ+KIqicsICfiiKknLCAn4oiaJ11cblxuIyBSZWxhdGlvbmFsIHRva2VucyB0aGF0IGFyZSBuZWdhdGFibGUgd2l0aCBgbm90YCBwcmVmaXguXG52YXIgUkVMQVRJT04gPSBbJ0lOJywgJ09GJywgJ0lOU1RBTkNFT0YnLCdJU0EnXVxuXG4jIEJvb2xlYW4gdG9rZW5zLlxudmFyIEJPT0wgPSBbJ1RSVUUnLCAnRkFMU0UnLCAnTlVMTCcsICdVTkRFRklORUQnXVxuXG4jIE91ciBsaXN0IGlzIHNob3J0ZXIsIGR1ZSB0byBzYW5zLXBhcmVudGhlc2VzIG1ldGhvZCBjYWxscy5cbnZhciBOT1RfUkVHRVggPSBbJ05VTUJFUicsICdSRUdFWCcsICdCT09MJywgJ1RSVUUnLCAnRkFMU0UnLCAnKysnLCAnLS0nLCAnXSddXG5cbiMgSWYgdGhlIHByZXZpb3VzIHRva2VuIGlzIG5vdCBzcGFjZWQsIHRoZXJlIGFyZSBtb3JlIHByZWNlZGluZyB0b2tlbnMgdGhhdFxuIyBmb3JjZSBhIGRpdmlzaW9uIHBhcnNlOlxudmFyIE5PVF9TUEFDRURfUkVHRVggPSBbJ05VTUJFUicsICdSRUdFWCcsICdCT09MJywgJ1RSVUUnLCAnRkFMU0UnLCAnKysnLCAnLS0nLCAnXScsJyknLCAnfScsICdUSElTJywgJ1NFTEYnICwgJ0lERU5USUZJRVInLCAnU1RSSU5HJ11cblxuIyBUb2tlbnMgd2hpY2ggY291bGQgbGVnaXRpbWF0ZWx5IGJlIGludm9rZWQgb3IgaW5kZXhlZC4gQW4gb3BlbmluZ1xuIyBwYXJlbnRoZXNlcyBvciBicmFja2V0IGZvbGxvd2luZyB0aGVzZSB0b2tlbnMgd2lsbCBiZSByZWNvcmRlZCBhcyB0aGUgc3RhcnRcbiMgb2YgYSBmdW5jdGlvbiBpbnZvY2F0aW9uIG9yIGluZGV4aW5nIG9wZXJhdGlvbi5cbiMgcmVhbGx5PyFcblxudmFyIFVORklOSVNIRUQgPSBbJ1xcXFwnLCcuJywgJz8uJywgJz86JywgJ1VOQVJZJywgJ01BVEgnLCAnKycsICctJywgJ1NISUZUJywgJ1JFTEFUSU9OJywgJ0NPTVBBUkUnLCAnTE9HSUMnLCAnQ09NUE9VTkRfQVNTSUdOJywgJ1RIUk9XJywgJ0VYVEVORFMnXVxuXG4jIH0gc2hvdWxkIG5vdCBiZSBjYWxsYWJsZSBhbnltb3JlISEhICd9JywgJzo6JyxcbnZhciBDQUxMQUJMRSAgPSBbJ0lERU5USUZJRVInLCAnU1RSSU5HJywgJ1JFR0VYJywgJyknLCAnXScsICdUSElTJywgJ1NVUEVSJywgJ1RBR19FTkQnLCAnSVZBUicsICdHVkFSJywnU0VMRicsJ0NPTlNUJywnTkVXJywnQVJHVkFSJywnU1lNQk9MJywnUkVUVVJOJ11cblxuIyBvcHRpbWl6ZSBmb3IgRml4ZWRBcnJheVxudmFyIElOREVYQUJMRSA9IFtcblx0J0lERU5USUZJRVInLCAnU1RSSU5HJywgJ1JFR0VYJywgJyknLCAnXScsICdUSElTJywgJ1NVUEVSJywgJ1RBR19FTkQnLCAnSVZBUicsICdHVkFSJywnU0VMRicsJ0NPTlNUJywnTkVXJywnQVJHVkFSJywnU1lNQk9MJywnUkVUVVJOJ1xuXHQnTlVNQkVSJywgJ0JPT0wnLCAnVEFHX1NFTEVDVE9SJywgJ0FSR1VNRU5UUycsJ30nLCdUQUdfVFlQRScsJ1RBR0lEJ1xuXVxuXG52YXIgTk9UX0tFWV9BRlRFUiA9IFsnLicsJz8nLCc/LicsJ1VOQVJZJywnPzonLCcrJywnLScsJyonXVxuXG52YXIgR0xPQkFMX0lERU5USUZJRVJTID0gWydnbG9iYWwnLCdleHBvcnRzJ11cblxuIyBUb2tlbnMgdGhhdCwgd2hlbiBpbW1lZGlhdGVseSBwcmVjZWRpbmcgYSBgV0hFTmAsIGluZGljYXRlIHRoYXQgdGhlIGBXSEVOYFxuIyBvY2N1cnMgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZS4gV2UgZGlzYW1iaWd1YXRlIHRoZXNlIGZyb20gdHJhaWxpbmcgd2hlbnMgdG9cbiMgYXZvaWQgYW4gYW1iaWd1aXR5IGluIHRoZSBncmFtbWFyLlxudmFyIExJTkVfQlJFQUsgPSBbJ0lOREVOVCcsICdPVVRERU5UJywgJ1RFUk1JTkFUT1InXVxuXG5cbmV4cG9ydCBjbGFzcyBMZXhlckVycm9yIDwgU3ludGF4RXJyb3Jcblx0XG5cdGRlZiBpbml0aWFsaXplIG1lc3NhZ2UsIGZpbGUsIGxpbmVcblx0XHRzZWxmOm1lc3NhZ2UgPSBtZXNzYWdlXG5cdFx0c2VsZjpmaWxlID0gZmlsZVxuXHRcdHNlbGY6bGluZSA9IGxpbmVcblx0XHRyZXR1cm4gc2VsZlxuXG5cbmRlZiBsYXN0IGFycmF5LCBiYWNrID0gMFxuXHRhcnJheVthcnJheTpsZW5ndGggLSBiYWNrIC0gMV1cblxuZGVmIGNvdW50IHN0ciwgc3Vic3RyXG5cdHJldHVybiBzdHIuc3BsaXQoc3Vic3RyKTpsZW5ndGggLSAxXG5cdFxuZGVmIHJlcGVhdFN0cmluZyBzdHIsIHRpbWVzXG5cdHZhciByZXMgPSAnJ1xuXHR3aGlsZSB0aW1lcyA+IDBcblx0XHRpZiB0aW1lcyAlIDIgPT0gMVxuXHRcdFx0cmVzICs9IHN0clxuXHRcdHN0ciArPSBzdHJcblx0XHR0aW1lcyA+Pj0gMVxuXHRyZXR1cm4gcmVzXG5cbnZhciB0VCAgPSBUOnR5cFxudmFyIHRWICA9IFQ6dmFsXG52YXIgdFRzID0gVDpzZXRUeXBcbnZhciB0VnMgPSBUOnNldFZhbFxuXG4jIFRoZSBMZXhlciBjbGFzcyByZWFkcyBhIHN0cmVhbSBvZiBJbWJhIGFuZCBkaXZ2aWVzIGl0IHVwIGludG8gdG9raWRnZWRcbiMgdG9rZW5zLiBTb21lIHBvdGVudGlhbCBhbWJpZ3VpdHkgaW4gdGhlIGdyYW1tYXIgaGFzIGJlZW4gYXZvaWRlZCBieVxuIyBwdXNoaW5nIHNvbWUgZXh0cmEgc21hcnRzIGludG8gdGhlIExleGVyLlxuXG4jIEJhc2VkIG9uIHRoZSBvcmlnaW5hbCBsZXhlci5jb2ZmZWUgZnJvbSBDb2ZmZWVTY3JpcHRcbmV4cG9ydCBjbGFzcyBMZXhlclxuXG5cdGRlZiBpbml0aWFsaXplXG5cdFx0cmVzZXRcblx0XHRzZWxmXG5cblx0ZGVmIHJlc2V0XG5cdFx0QGNvZGUgICAgPSBudWxsXG5cdFx0QGNodW5rICAgPSBudWxsICAgICAgICAgICAjIFRoZSByZW1haW5kZXIgb2YgdGhlIHNvdXJjZSBjb2RlLlxuXHRcdEBvcHRzICAgID0gbnVsbFxuXHRcdEBzdGF0ZSA9IHt9XG5cdFx0XG5cdFx0QGluZGVudCAgPSAwICAgICAgICAgICAgICAjIFRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsLlxuXHRcdEBpbmRlYnQgID0gMCAgICAgICAgICAgICAgIyBUaGUgb3Zlci1pbmRlbnRhdGlvbiBhdCB0aGUgY3VycmVudCBsZXZlbC5cblx0XHRAb3V0ZGVidCA9IDAgICAgICAgICAgICAgICMgVGhlIHVuZGVyLW91dGRlbnRhdGlvbiBhdCB0aGUgY3VycmVudCBsZXZlbC5cblxuXHRcdEBpbmRlbnRzICA9IFtdICAgICAgICAgICAgICMgVGhlIHN0YWNrIG9mIGFsbCBjdXJyZW50IGluZGVudGF0aW9uIGxldmVscy5cblx0XHRAZW5kcyAgICAgPSBbXSAjIFRoZSBzdGFjayBmb3IgcGFpcmluZyB1cCB0b2tlbnMuXG5cdFx0QGNvbnRleHRzID0gW10gIyBzdXBsZW1lbnRzIEBlbmRzXG5cdFx0QHNjb3BlcyAgID0gW11cblx0XHRAbmV4dFNjb3BlID0gbnVsbCAjIHRoZSBzY29wZSB0byBhZGQgb24gdGhlIG5leHQgaW5kZW50XG5cdFx0QGNvbnRleHQgPSBudWxsXG5cdFx0IyBzaG91bGQgcmF0aGVyIG1ha2UgaXQgbGlrZSBhIHN0YXRlbWFjaGluZSB0aGF0IG1vdmVzIGZyb20gQ0xBU1NfREVGIHRvIENMQVNTX0JPRFkgZXRjXG5cdFx0IyBUaGluZ3Mgc2hvdWxkIGNvbXBpbGUgZGlmZmVyZW50bHkgd2hlbiB5b3UgYXJlIGluIGEgQ0xBU1NfQk9EWSB0aGFuIHdoZW4gaW4gYSBERUZfQk9EWSsrXG5cblx0XHRAaW5kZW50U3R5bGUgPSBudWxsXG5cdFx0QGluVGFnID0gbm9cblxuXHRcdEB0b2tlbnMgID0gW10gICAgICAgICAgICAgIyBTdHJlYW0gb2YgcGFyc2VkIHRva2VucyBpbiB0aGUgZm9ybSBgWydUWVBFJywgdmFsdWUsIGxpbmVdYC5cblx0XHRAc2VlbkZvciA9IG5vXG5cdFx0QGxvYyA9IDBcblx0XHRAbG9jT2Zmc2V0ID0gMFxuXG5cdFx0QGVuZCAgICAgPSBudWxsXG5cdFx0QGNoYXIgXHQgPSBudWxsXG5cdFx0QGJyaWRnZSAgPSBudWxsXG5cblx0XHRAbGFzdCAgICA9IG51bGxcblx0XHRAbGFzdFR5cCA9ICcnXG5cdFx0QGxhc3RWYWwgPSBudWxsXG5cdFx0c2VsZlxuXG5cdGRlZiBqaXNvbkJyaWRnZSBqaXNvblxuXHRcdEBicmlkZ2UgPSB7XG5cdFx0XHRsZXg6IFQ6bGV4XG5cdFx0XHRzZXRJbnB1dDogZG8gfHRva2Vuc3xcblx0XHRcdFx0dGhpczp0b2tlbnMgPSB0b2tlbnNcblx0XHRcdFx0dGhpczpwb3MgPSAwXG5cblx0XHRcdHVwY29taW5nSW5wdXQ6IGRvIFwiXCJcblx0XHR9XG5cblxuXHRkZWYgdG9rZW5pemUgY29kZSwgbyA9IHt9XG5cblx0XHRpZiBjb2RlOmxlbmd0aCA9PSAwXG5cdFx0XHRyZXR1cm4gW11cblxuXHRcdHVubGVzcyBvOmlubGluZVxuXHRcdFx0aWYgV0hJVEVTUEFDRS50ZXN0KGNvZGUpXG5cdFx0XHRcdGNvZGUgPSBcIlxcbntjb2RlfVwiXG5cdFx0XHRcdHJldHVybiBbXSBpZiBjb2RlLm1hdGNoKC9eXFxzKiQvZylcblxuXHRcdFx0Y29kZSA9IGNvZGUucmVwbGFjZSgvXFxyL2csICcnKS5yZXBsYWNlIC9bXFx0IF0rJC9nLCAnJ1xuXG5cdFx0QGxhc3QgICAgPSBudWxsXG5cdFx0QGxhc3RUeXAgPSBudWxsXG5cdFx0QGxhc3RWYWwgPSBudWxsXG5cblx0XHRAY29kZSAgICA9IGNvZGVcblx0XHRAb3B0cyAgICA9IG9cblx0XHRAbG9jT2Zmc2V0ID0gbzpsb2Mgb3IgMFxuXHRcdEBpbmRlbnRTdHlsZSA9IG86aW5kZW50YXRpb24gb3IgbnVsbFxuXG5cdFx0IyBpZiB0aGUgdmVyeSBmaXJzdCBsaW5lIGlzIGluZGVudGVkLCB0YWtlIHRoaXMgYXMgYSBndXR0ZXJcblx0XHRpZiBsZXQgbSA9IGNvZGUubWF0Y2goL14oW1xcIFxcdF0qKVteXFxuXFxzXFx0XS8pXG5cdFx0XHRAc3RhdGU6Z3V0dGVyID0gbVsxXVxuXHRcdFxuXHRcdGlmIG86Z3V0dGVyICE9PSB1bmRlZmluZWRcblx0XHRcdEBzdGF0ZTpndXR0ZXIgPSBvOmd1dHRlclxuXG5cdFx0by5AdG9rZW5zID0gQHRva2VucyBcblxuXHRcdHBhcnNlKGNvZGUpXG5cblx0XHRjbG9zZUluZGVudGF0aW9uIHVubGVzcyBvOmlubGluZVxuXG5cdFx0aWYgIW86c2lsZW50IGFuZCBAZW5kczpsZW5ndGhcblx0XHRcdGNvbnNvbGUubG9nIEBlbmRzXG5cdFx0XHRlcnJvciBcIm1pc3Npbmcge0BlbmRzLnBvcH1cIlxuXG5cdFx0cmV0dXJuIEB0b2tlbnNcblxuXHRkZWYgcGFyc2UgY29kZVxuXHRcdHZhciBpID0gMFxuXHRcdHZhciBwaSA9IDBcblx0XHRAbG9jID0gQGxvY09mZnNldCArIGlcblxuXHRcdHdoaWxlIEBjaHVuayA9IGNvZGUuc2xpY2UoaSlcblx0XHRcdGlmIEBjb250ZXh0IGFuZCBAY29udGV4dDpwb3Bcblx0XHRcdFx0aWYgQGNvbnRleHQ6cG9wLnRlc3QoQGNodW5rKVxuXHRcdFx0XHRcdHBvcEVuZFxuXG5cdFx0XHRwaSA9IChAZW5kID09ICdUQUcnIGFuZCB0YWdEZWZDb250ZXh0VG9rZW4pIHx8IChAaW5UYWcgYW5kIHRhZ0NvbnRleHRUb2tlbikgfHwgYmFzaWNDb250ZXh0XG5cdFx0XHRpICs9IHBpXG5cdFx0XHRAbG9jID0gQGxvY09mZnNldCArIGlcblxuXHRcdHJldHVyblxuXG5cdGRlZiBiYXNpY0NvbnRleHRcblx0XHRyZXR1cm4gc2VsZWN0b3JUb2tlbiB8fCBzeW1ib2xUb2tlbiB8fCBtZXRob2ROYW1lVG9rZW4gfHwgaWRlbnRpZmllclRva2VuIHx8IHdoaXRlc3BhY2VUb2tlbiB8fCBsaW5lVG9rZW4gfHwgY29tbWVudFRva2VuIHx8IGhlcmVkb2NUb2tlbiB8fCB0YWdUb2tlbiB8fCBzdHJpbmdUb2tlbiB8fCBudW1iZXJUb2tlbiB8fCByZWdleFRva2VuIHx8IGpzVG9rZW4gfHwgbGl0ZXJhbFRva2VuIHx8IDBcblxuXHRkZWYgbW92ZUNhcmV0IGlcblx0XHRAbG9jICs9IGlcblxuXHRkZWYgY29udGV4dFxuXHRcdEBlbmRzW0BlbmRzOmxlbmd0aCAtIDFdXG5cblx0ZGVmIGluQ29udGV4dCBrZXlcblx0XHR2YXIgbyA9IEBjb250ZXh0c1tAY29udGV4dHM6bGVuZ3RoIC0gMV1cblx0XHRyZXR1cm4gbyBhbmQgb1trZXldXG5cblx0ZGVmIHB1c2hFbmQgdmFsLCBjdHhcblx0XHRAZW5kcy5wdXNoKHZhbClcblx0XHRAY29udGV4dHMucHVzaChAY29udGV4dCA9IChjdHggb3Ige30pKVxuXHRcdEBlbmQgPSB2YWxcblx0XHRyZWZyZXNoU2NvcGVcblxuXHRcdGlmIGN0eCBhbmQgY3R4OmlkXG5cdFx0XHRjdHg6c3RhcnQgPSBUb2tlbi5uZXcoY3R4OmlkICsgJ19TVEFSVCcsdmFsLCBAbGFzdC5yZWdpb25bMV0sMClcblx0XHRcdEB0b2tlbnMucHVzaChjdHg6c3RhcnQpXG5cdFx0c2VsZlxuXG5cdGRlZiBwb3BFbmQgdmFsXG5cdFx0dmFyIHBvcHBlZCA9IEBlbmRzLnBvcFxuXHRcdEBlbmQgPSBAZW5kc1tAZW5kczpsZW5ndGggLSAxXVxuXG5cdFx0IyBhdXRvbWF0aWNhbGx5IGFkZGluZyBhIGNsb3NlciBpZiB0aGlzIGlzIGRlZmluZWRcblx0XHR2YXIgY3R4ID0gQGNvbnRleHRcblx0XHRpZiBjdHggYW5kIGN0eDpzdGFydFxuXHRcdFx0Y3R4OmVuZCA9IFRva2VuLm5ldyhjdHg6aWQgKyAnX0VORCcscG9wcGVkLEBsYXN0LnJlZ2lvblsxXSwwKVxuXHRcdFx0Y3R4OmVuZC5Ac3RhcnQgPSBjdHg6c3RhcnRcblx0XHRcdGN0eDpzdGFydC5AZW5kID0gY3R4OmVuZFxuXHRcdFx0QHRva2Vucy5wdXNoKGN0eDplbmQpXG5cblx0XHRAY29udGV4dHMucG9wXG5cdFx0QGNvbnRleHQgPSBAY29udGV4dHNbQGNvbnRleHRzOmxlbmd0aCAtIDFdXG5cblx0XHRyZWZyZXNoU2NvcGVcblx0XHRzZWxmXG5cblx0ZGVmIHJlZnJlc2hTY29wZVxuXHRcdHZhciBjdHgwID0gQGVuZHNbQGVuZHM6bGVuZ3RoIC0gMV1cblx0XHR2YXIgY3R4MSA9IEBlbmRzW0BlbmRzOmxlbmd0aCAtIDJdXG5cdFx0QGluVGFnID0gY3R4MCA9PSAnVEFHX0VORCcgb3IgKGN0eDEgPT0gJ1RBR19FTkQnIGFuZCBjdHgwID09ICdPVVRERU5UJylcblxuXHRcdFxuXG5cdGRlZiBxdWV1ZVNjb3BlIHZhbFxuXHRcdEBzY29wZXNbQGluZGVudHM6bGVuZ3RoXSA9IHZhbFxuXHRcdHNlbGZcblxuXHRkZWYgcG9wU2NvcGUgdmFsXG5cdFx0QHNjb3Blcy5wb3Bcblx0XHRzZWxmXG5cblx0ZGVmIGdldFNjb3BlXG5cdFx0QHNjb3Blc1tAaW5kZW50czpsZW5ndGggLSAxXVxuXHRcdFxuXHRkZWYgc2NvcGUgc3ltLCBvcHRzXG5cdFx0dmFyIGxlbiA9IEBlbmRzLnB1c2goQGVuZCA9IHN5bSlcblx0XHRAY29udGV4dHMucHVzaChvcHRzIG9yIG51bGwpXG5cdFx0cmV0dXJuIHN5bVxuXHRcblxuXHRkZWYgY2xvc2VTZWxlY3RvclxuXHRcdGlmIEBlbmQgPT0gJyUnXG5cdFx0XHR0b2tlbignU0VMRUNUT1JfRU5EJywnJScsMClcblx0XHRcdHBhaXIoJyUnKVxuXHRcblxuXHRkZWYgb3BlbkRlZlxuXHRcdHB1c2hFbmQoJ0RFRicpXG5cblxuXHRkZWYgY2xvc2VEZWZcblx0XHRpZiBjb250ZXh0ID09ICdERUYnXG5cdFx0XHR2YXIgcHJldiA9IGxhc3QoQHRva2VucylcblxuXHRcdFx0aWYgdFQocHJldikgPT0gJ0RFRl9GUkFHTUVOVCdcblx0XHRcdFx0dHJ1ZVxuXHRcdFx0ZWxpZiB0VChwcmV2KSA9PSAnVEVSTUlOQVRPUidcblx0XHRcdFx0bGV0IG4gPSBAdG9rZW5zLnBvcFxuXHRcdFx0XHR0b2tlbignREVGX0JPRFknLCAnREVGX0JPRFknLDApXG5cdFx0XHRcdEB0b2tlbnMucHVzaChuKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0b2tlbignREVGX0JPRFknLCAnREVGX0JPRFknLDApXG5cblx0XHRcdHBhaXIoJ0RFRicpXG5cdFx0cmV0dXJuXG5cblx0ZGVmIHRhZ0NvbnRleHRUb2tlblxuXHRcdGlmIEBjaHVua1swXSA9PSAnIydcblx0XHRcdHRva2VuKCcjJywnIycsMSlcblx0XHRcdHJldHVybiAxXG5cblx0XHRpZiB2YXIgbWF0Y2ggPSBUQUdfQVRUUi5leGVjKEBjaHVuaylcblx0XHRcdHZhciBsID0gbWF0Y2hbMF06bGVuZ3RoXG5cblx0XHRcdHRva2VuICdUQUdfQVRUUicsbWF0Y2hbMV0sbCAtIDEgICMgYWRkIHRvIGxvYz9cblx0XHRcdEBsb2MgKz0gbCAtIDFcblx0XHRcdHRva2VuICc9JywnPScsMVxuXHRcdFx0cHVzaEVuZCgnVEFHX0FUVFInLGlkOiAnVkFMVUUnLCBwb3A6IC9eW1xcc1xcblxcPl0vKSAjICBbJyAnLCdcXG4nLCc+J11cblx0XHRcdHJldHVybiBsXG5cdFx0cmV0dXJuIDBcblxuXHRkZWYgdGFnRGVmQ29udGV4dFRva2VuXG5cdFx0IyBjb25zb2xlLmxvZyBcInRhZ0NvbnRleHRUb2tlblwiXG5cdFx0aWYgdmFyIG1hdGNoID0gVEFHX1RZUEUuZXhlYyhAY2h1bmspXG5cdFx0XHR0b2tlbiAnVEFHX1RZUEUnLCBtYXRjaFswXSwgbWF0Y2hbMF06bGVuZ3RoXG5cdFx0XHRyZXR1cm4gbWF0Y2hbMF06bGVuZ3RoXG5cblx0XHRpZiB2YXIgbWF0Y2ggPSBUQUdfSUQuZXhlYyhAY2h1bmspXG5cdFx0XHR2YXIgaW5wdXQgPSBtYXRjaFswXVxuXHRcdFx0dG9rZW4gJ1RBR19JRCcsIGlucHV0LCBpbnB1dDpsZW5ndGhcblx0XHRcdHJldHVybiBpbnB1dDpsZW5ndGhcblxuXHRcdGlmIEBjaHVua1swXSA9PSAnXFxuJ1xuXHRcdFx0cGFpcignVEFHJylcblxuXHRcdHJldHVybiAwXG5cblxuXHRkZWYgdGFnVG9rZW5cblx0XHRyZXR1cm4gMCB1bmxlc3MgdmFyIG1hdGNoID0gVEFHLmV4ZWMoQGNodW5rKVxuXHRcdHZhciBbaW5wdXQsIHR5cGUsIGlkZW50aWZpZXJdID0gbWF0Y2hcblxuXHRcdGlmIHR5cGUgPT0gJzwnXG5cdFx0XHR0b2tlbignVEFHX1NUQVJUJywgJzwnLDEpXG5cdFx0XHRwdXNoRW5kKElOVkVSU0VTWydUQUdfU1RBUlQnXSlcblxuXHRcdFx0aWYgbWF0Y2ggPSBUQUdfVFlQRS5leGVjKEBjaHVuay5zdWJzdHIoMSw0MCkpXG5cdFx0XHRcdCMgc3BlY2lhbCBjYXNlIHNob3VsZCBwcm9iYWJseSBiZSBoYW5kbGVkIGluIEFTVFxuXHRcdFx0XHRpZiBtYXRjaFswXSAhPSAnc2VsZidcblx0XHRcdFx0XHR0b2tlbignVEFHX1RZUEUnLG1hdGNoWzBdLG1hdGNoWzBdOmxlbmd0aCwxKVxuXHRcdFx0XHRcdHJldHVybiBpbnB1dDpsZW5ndGggKyBtYXRjaFswXTpsZW5ndGhcblxuXHRcdFx0aWYgaWRlbnRpZmllclxuXHRcdFx0XHRpZiBpZGVudGlmaWVyLnN1YnN0cigwLDEpID09ICd7J1xuXHRcdFx0XHRcdHJldHVybiB0eXBlOmxlbmd0aFxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0dG9rZW4oJ1RBR19OQU1FJywgaW5wdXQuc3Vic3RyKDEpLDApXG5cblx0XHRyZXR1cm4gaW5wdXQ6bGVuZ3RoXG5cblxuXHRkZWYgc2VsZWN0b3JUb2tlblxuXHRcdHZhciBtYXRjaFxuXG5cdFx0IyBzcGVjaWFsIGhhbmRsaW5nIGlmIHdlIGFyZSBpbiB0aGlzIGNvbnRleHRcblx0XHRpZiBAZW5kID09ICclJ1xuXHRcdFx0dmFyIGNociA9IEBjaHVua1swXVxuXHRcdFx0dmFyIG9wZW4gPSBpbkNvbnRleHQoJ29wZW4nKVxuXG5cdFx0XHQjIHNob3VsZCBhZGQgZm9yICssIH4gZXRjXG5cdFx0XHQjIHNob3VsZCBtYXliZSByYXRoZXIgbG9vayBmb3IgdGhlIGNvcnJlY3QgdHlwZSBvZiBjaGFyYWN0ZXI/XG5cdFx0XG5cdFx0XHRpZiBvcGVuIGFuZCAoY2hyID09ICcgJyBvciBjaHIgPT0gJ1xcbicgb3IgY2hyID09ICcsJyBvciBjaHIgPT0gJysnIG9yIGNociA9PSAnficgb3IgY2hyID09ICcpJyBvciBjaHIgPT0gJ10nKVxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiY2xvc2UgdGhpcyBzZWxlY3RvciBkaXJlY3RseVwiXG5cdFx0XHRcdHRva2VuKCdTRUxFQ1RPUl9FTkQnLCclJywwKVxuXHRcdFx0XHRwYWlyICclJ1xuXHRcdFx0XHRyZXR1cm4gMFxuXG5cdFx0XHRpZiBtYXRjaCA9IFNFTEVDVE9SX0NPTUJJTkFUT1IuZXhlYyhAY2h1bmspXG5cdFx0XHRcdCMgc3BhY2VzIGJldHdlZW4/IC0tIGluY2x1ZGUgdGhlIHdob2xlXG5cdFx0XHRcdHRva2VuICdTRUxFQ1RPUl9DT01CSU5BVE9SJywgbWF0Y2hbMV0gfHwgXCIgXCIsIG1hdGNoWzBdOmxlbmd0aFxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF06bGVuZ3RoXG5cdFx0XHRcblx0XHRcdGVsaWYgbWF0Y2ggPSBTRUxFQ1RPUl9QQVJULmV4ZWMoQGNodW5rKVxuXHRcdFx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdXG5cdFx0XHRcdHZhciBpZCA9IG1hdGNoWzJdXG5cblx0XHRcdFx0dmFyIHRva2lkID0gc3dpdGNoIHR5cGVcblx0XHRcdFx0XHR3aGVuICcuJyB0aGVuICdTRUxFQ1RPUl9DTEFTUydcblx0XHRcdFx0XHR3aGVuICcjJyB0aGVuICdTRUxFQ1RPUl9JRCdcblx0XHRcdFx0XHR3aGVuICc6JyB0aGVuICdTRUxFQ1RPUl9QU0VVRE9fQ0xBU1MnXG5cdFx0XHRcdFx0d2hlbiAnOjonIHRoZW4gJ1NFTEVDVE9SX1BTRVVET19DTEFTUydcblx0XHRcdFx0XHRlbHNlICdTRUxFQ1RPUl9UQUcnXG5cblx0XHRcdFx0dG9rZW4gdG9raWQsIG1hdGNoWzJdLCBtYXRjaFswXTpsZW5ndGhcblx0XHRcdFx0cmV0dXJuIG1hdGNoWzBdOmxlbmd0aFxuXG5cdFx0XHQjIGVsaWYgbWF0Y2ggPSBTRUxFQ1RPUl9QU0VVRE9fQ0xBU1MuZXhlYyhAY2h1bmspXG5cdFx0XHQjICB0b2tlbiB0b2tpZCwgbWF0Y2hbMl1cblx0XHRcdCMgIHJldHVybiBtYXRjaFswXTpsZW5ndGhcblx0XHRcdFxuXHRcdFx0ZWxpZiBjaHIgPT0gJ1snXG5cdFx0XHRcdHRva2VuKCdbJywnWycsMSlcblx0XHRcdFx0c2VsZi5wdXNoRW5kKCddJylcblx0XHRcdFx0aWYgbWF0Y2ggPSBTRUxFQ1RPUl9BVFRSLmV4ZWMoQGNodW5rKVxuXHRcdFx0XHRcdCMgZnVjayB0aGlzIGxlbmd0aCBzaGl0XG5cdFx0XHRcdFx0dmFyIGlkb2Zmc2V0ID0gbWF0Y2hbMF0uaW5kZXhPZihtYXRjaFsxXSlcblx0XHRcdFx0XHR2YXIgb3BvZmZzZXQgPSBtYXRjaFswXS5pbmRleE9mKG1hdGNoWzJdKVxuXHRcdFx0XHRcdHRva2VuKCdJREVOVElGSUVSJywgbWF0Y2hbMV0sIG1hdGNoWzFdOmxlbmd0aCwgaWRvZmZzZXQpXG5cdFx0XHRcdFx0dG9rZW4oJ1NFTEVDVE9SX0FUVFJfT1AnLCBtYXRjaFsyXSwgbWF0Y2hbMl06bGVuZ3RoLCBvcG9mZnNldClcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF06bGVuZ3RoXG5cdFx0XHRcdHJldHVybiAxXG5cblx0XHRcdGVsaWYgY2hyID09ICd8J1xuXHRcdFx0XHR2YXIgdG9rID0gQHRva2Vuc1tAdG9rZW5zOmxlbmd0aCAtIDFdXG5cdFx0XHRcdHRUcyh0b2ssJ1NFTEVDVE9SX05TJylcblx0XHRcdFx0IyB0b2tbMF0gPSAnU0VMRUNUT1JfTlMnICMgRklYXG5cdFx0XHRcdHJldHVybiAxXG5cblx0XHRcdGVsaWYgY2hyID09ICcsJ1xuXHRcdFx0XHR0b2tlbignU0VMRUNUT1JfR1JPVVAnLCcsJywxKVxuXHRcdFx0XHRyZXR1cm4gMVxuXHRcdFx0ZWxpZiBjaHIgPT0gJyonXG5cdFx0XHRcdHRva2VuKCdVTklWRVJTQUxfU0VMRUNUT1InLCcqJywxKVxuXHRcdFx0XHRyZXR1cm4gMVxuXHRcdFx0XG5cdFx0XHRlbGlmIGNociA9PSAnKSdcblx0XHRcdFx0cGFpciAnJSdcblx0XHRcdFx0dG9rZW4oJ1NFTEVDVE9SX0VORCcsJyknLDEpXG5cdFx0XHRcdHJldHVybiAxXG5cblx0XHRcdGVsaWYgY2hyIGluIFsnKScsJ30nLCddJywnJ11cblx0XHRcdFx0cGFpciAnJSdcblx0XHRcdFx0cmV0dXJuIDBcblxuXHRcdHJldHVybiAwIHVubGVzcyBtYXRjaCA9IFNFTEVDVE9SLmV4ZWMoQGNodW5rKVxuXG5cdFx0dmFyIFtpbnB1dCwgaWQsIGtpbmRdID0gbWF0Y2hcblxuXHRcdCMgdGhpcyBpcyBhIGNsb3NlZCBzZWxlY3RvclxuXHRcdGlmIGtpbmQgPT0gJygnXG5cdFx0XHQjIHRva2VuICcoJywnKCdcblx0XHRcdHRva2VuICdTRUxFQ1RPUl9TVEFSVCcsIGlkLCBpZDpsZW5ndGggKyAxXG5cdFx0XHRwdXNoRW5kKCclJylcblx0XHRcdHJldHVybiBpZDpsZW5ndGggKyAxXG5cblx0XHRlbGlmIGlkID09ICclJ1xuXHRcdFx0IyB3ZSBhcmUgYWxyZWFkeSBzY29wZWQgaW4gb24gYSBzZWxlY3RvclxuXHRcdFx0cmV0dXJuIDEgaWYgY29udGV4dCA9PSAnJSdcblx0XHRcdHRva2VuICdTRUxFQ1RPUl9TVEFSVCcsIGlkLCBpZDpsZW5ndGhcblx0XHRcdCMgdGhpcyBpcyBhIHNlcGFyYXRlIC0gc2NvcGUuIEZ1bGwgc2VsZWN0b3Igc2hvdWxkIHJhdGhlciBiZSAkLCBhbmQga2VlcCB0aGUgc2luZ2xlIHNlbGVjdG9yIGFzICVcblx0XHRcblx0XHRcdHB1c2hFbmQoJyUnLCBvcGVuOiB5ZXMpXG5cdFx0XHQjIEBlbmRzLnB1c2ggJyUnXG5cdFx0XHQjIG1ha2Ugc3VyZSBhIHRlcm1pbmF0b3IgYnJlYWtzIG91dFxuXHRcdFx0cmV0dXJuIGlkOmxlbmd0aFxuXHRcdGVsc2Vcblx0XHRcdHJldHVybiAwXG5cdFxuXHQjIGlzIHRoaXMgcmVhbGx5IG5lZWRlZD8gU2hvdWxkIGJlIHBvc3NpYmxlIHRvXG5cdCMgcGFyc2UgdGhlIGlkZW50aWZpZXJzIGFuZCA9IGV0YyBpIGppc29uP1xuXHQjIHdoYXQgaXMgc3BlY2lhbCBhYm91dCBtZXRob2ROYW1lVG9rZW4/IHJlYWxseT9cblx0IyB0aGlzIHdob2xlIHN0ZXAgc2hvdWxkIGJlIHJlbW92ZWQgLSBpdCdzIGEgaHVnZSBtZXNzXG5cdGRlZiBtZXRob2ROYW1lVG9rZW5cblx0XHQjIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIGJ5IGFmdGVyIGEgZGVmIHNpbXBseVxuXHRcdCMgZmV0Y2hpbmcgYWxsIHRoZSB3YXkgYWZ0ZXIgdGhlIGRlZiB1bnRpbCBhIHNwYWNlIG9yIChcblx0XHQjIGFuZCB0aGVuIGFkZCB0aGlzIHRvIHRoZSBkZWYtdG9rZW4gaXRzZWxmIChhcyB3aXRoIGZyYWdtZW50KVxuXHRcdHJldHVybiAwIGlmIEBjaHVua1swXSA9PSAnICdcblxuXHRcdHZhciBtYXRjaFxuXG5cdFx0aWYgQGVuZCA9PSAnKSdcblx0XHRcdGlmIEBlbmRzOmxlbmd0aCA+IDFcblx0XHRcdFx0dmFyIG91dGVyY3R4ID0gQGVuZHNbQGVuZHM6bGVuZ3RoIC0gMl1cblx0XHRcdFx0aWYgb3V0ZXJjdHggPT0gJyUnIGFuZCBtYXRjaCA9IFRBR19BVFRSLmV4ZWMoQGNodW5rKVxuXHRcdFx0XHRcdHRva2VuKCdUQUdfQVRUUl9TRVQnLG1hdGNoWzFdKVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaFswXTpsZW5ndGhcblxuXHRcdHVubGVzcyBtYXRjaCA9IE1FVEhPRF9JREVOVElGSUVSLmV4ZWMoQGNodW5rKVxuXHRcdFx0cmV0dXJuIDBcdFx0XHRcblx0XHQjIHZhciBwcmV2ID0gbGFzdCBAdG9rZW5zXG5cdFx0dmFyIGxlbmd0aCA9IG1hdGNoWzBdOmxlbmd0aFxuXHRcdFxuXHRcdHZhciBpZCA9IG1hdGNoWzBdXG5cdFx0dmFyIGx0eXAgPSBAbGFzdFR5cFxuXHRcdHZhciB0eXAgPSAnSURFTlRJRklFUidcblx0XHR2YXIgcHJlID0gaWQuY2hhckF0KDApXG5cdFx0dmFyIHNwYWNlID0gbm9cblxuXHRcdHZhciBtNCA9IG1hdGNoWzRdICMgbWlnaHQgYmUgb3V0IG9mIGJvdW5kcz8gc2hvdWxkIHJhdGhlciBjaGVjayBjaGFyQXRcblx0XHQjIGRyb3AgbWF0Y2ggND8/XG5cblx0XHQjIHNob3VsZCB0aGlzIG5vdCBxdWl0IGhlcmUgaW4gcHJhY3RpY2FsbHkgYWxsIGNhc2VzP1xuXHRcdHVubGVzcyAobHR5cCA9PSAnLicgb3IgbHR5cCA9PSAnREVGJykgb3IgKG00ID09ICchJykgb3IgbWF0Y2hbNV1cblx0XHRcdHJldHVybiAwXG5cblx0XHQjIGFnYWluLCB3aHk/XG5cdFx0aWYgaWQgPT0gJ3NlbGYnIG9yIGlkID09ICd0aGlzJyBvciBpZCA9PSAnc3VwZXInICMgaW4gWydTRUxGJywnVEhJUyddXG5cdFx0XHRyZXR1cm4gMFxuXG5cdFx0aWYgaWQgPT0gJ25ldydcblx0XHRcdCMgY29uc29sZS5sb2cgJ05FVyBoZXJlPydcblx0XHRcdCMgdGhpcyBpcyB3cm9uZyAtLSBpbiB0aGUgY2FzZSBvZiA8ZGl2IHZhbHVlPURhdGUubmV3PlxuXHRcdFx0IyB3ZSBhcmUgYmFzaWNhbGx5IGluIGEgbmVzdGVkIHNjb3BlIHVudGlsIHRoZSBuZXh0IHNwYWNlIG9yID5cblx0XHRcdHR5cCA9ICdORVcnIHVubGVzcyBsdHlwID09ICcuJyBhbmQgaW5UYWdcblxuXHRcdGlmIGlkID09ICcuLi4nIGFuZCBbJywnLCcoJywnQ0FMTF9TVEFSVCcsJ0JMT0NLX1BBUkFNX1NUQVJUJywnUEFSQU1fU1RBUlQnXS5pbmRleE9mKGx0eXApID49IDBcblx0XHRcdHJldHVybiAwXG5cblx0XHRpZiBpZCA9PSAnfCdcblx0XHRcdCMgaGFja3kgd2F5IHRvIGltcGxlbWVudCB0aGlzXG5cdFx0XHQjIHdpdGggbmV3IGxleGVyIHdlJ2xsIHVzZSB7IC4uLiB9IGluc3RlYWQsIGFuZCBhc3N1bWUgb2JqZWN0LWNvbnRleHQsXG5cdFx0XHQjIHRoZW4gZ28gYmFjayBhbmQgY29ycmVjdCB3aGVuIHdlIHNlZSB0aGUgY29udGV4dCBpcyBpbnZhbGlkXG5cdFx0XHRpZiBsdHlwID09ICcoJyBvciBsdHlwID09ICdDQUxMX1NUQVJUJ1xuXHRcdFx0XHR0b2tlbignRE8nLCAnRE8nLDApXG5cdFx0XHRcdHNlbGYucHVzaEVuZCgnfCcpXG5cdFx0XHRcdHRva2VuKCdCTE9DS19QQVJBTV9TVEFSVCcsIGlkLDEpXG5cdFx0XHRcdHJldHVybiBsZW5ndGhcblxuXHRcdFx0ZWxpZiBsdHlwID09ICdETycgb3IgbHR5cCA9PSAneydcblx0XHRcdFx0c2VsZi5wdXNoRW5kKCd8Jylcblx0XHRcdFx0dG9rZW4oJ0JMT0NLX1BBUkFNX1NUQVJUJywgaWQsMSlcblx0XHRcdFx0cmV0dXJuIGxlbmd0aFxuXHRcdFx0XHRcblx0XHRcdGVsaWYgQGVuZHNbQGVuZHM6bGVuZ3RoIC0gMV0gPT0gJ3wnXG5cdFx0XHRcdHRva2VuKCdCTE9DS19QQVJBTV9FTkQnLCAnfCcsMSlcblx0XHRcdFx0cGFpciAnfCdcblx0XHRcdFx0cmV0dXJuIGxlbmd0aFxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZXR1cm4gMFxuXG5cdFx0IyB3aGFhdD9cblx0XHQjIGNvbnNvbGUubG9nKFwibWV0aG9kIGlkZW50aWZpZXJcIixpZClcblx0XHRpZiAoWycmJywnXicsJzw8JywnPDw8JywnPj4nXS5pbmRleE9mKGlkKSA+PSAwIG9yIChpZCA9PSAnfCcgYW5kIGNvbnRleHQgIT0gJ3wnKSlcblx0XHRcdHJldHVybiAwXG5cblx0XHRpZiBPUF9NRVRIT0RTLmluZGV4T2YoaWQpID49IDBcblx0XHRcdHNwYWNlID0geWVzXG5cblx0XHQjIG5vdCBldmVuIGFueXRoaW5nIHdlIHNob3VsZCB1c2U/IT9cblx0XHRpZiBwcmUgPT0gJ0AnXG5cdFx0XHR0eXAgPSAnSVZBUidcblxuXHRcdGVsaWYgcHJlID09ICckJ1xuXHRcdFx0eWVzXG5cblxuXHRcdGVsaWYgcHJlID09ICcjJ1xuXHRcdFx0dHlwID0gJ1RBR0lEJ1xuXG5cdFx0ZWxpZiBDT05TVF9JREVOVElGSUVSLnRlc3QocHJlKSBvciBpZCA9PSAnZ2xvYmFsJyBvciBpZCA9PSAnZXhwb3J0cydcblx0XHRcdCMgcmVhbGx5PyBzZWVtcyB2ZXJ5IHN0cmFuZ2Vcblx0XHRcdCMgY29uc29sZS5sb2coJ2dsb2JhbCEhJyx0eXAsaWQpXG5cdFx0XHR0eXAgPSAnQ09OU1QnXG5cdFx0XG5cdFx0IyB3aGF0IGlzIHRoaXMgcmVhbGx5IGZvcj9cblx0XHRpZiBtYXRjaFs1XSBhbmQgWydJREVOVElGSUVSJywnQ09OU1QnLCdHVkFSJywnQ1ZBUicsJ0lWQVInLCdTRUxGJywnVEhJUycsJ10nLCd9JywnKScsJ05VTUJFUicsJ1NUUklORyddLmluZGV4T2YobHR5cCkgPj0gMFxuXHRcdFx0dG9rZW4oJy4nLCcuJywwKVxuXHRcblx0XHR0b2tlbih0eXAsIGlkLCBsZW5ndGgpXG5cblx0XHRpZiBzcGFjZVxuXHRcdFx0QGxhc3Q6c3BhY2VkID0geWVzXG5cblx0XHRyZXR1cm4gbGVuZ3RoXG5cblxuXHRkZWYgaW5UYWdcblx0XHR2YXIgbGVuID0gQGVuZHM6bGVuZ3RoXG5cdFx0aWYgbGVuID4gMFxuXHRcdFx0dmFyIGN0eDAgPSBAZW5kc1tsZW4gLSAxXVxuXHRcdFx0dmFyIGN0eDEgPSBsZW4gPiAxID8gQGVuZHNbbGVuIC0gMl0gOiBjdHgwXG5cdFx0XHRyZXR1cm4gY3R4MCA9PSAnVEFHX0VORCcgb3IgKGN0eDEgPT0gJ1RBR19FTkQnIGFuZCBjdHgwID09ICdPVVRERU5UJylcblx0XHRyZXR1cm4gZmFsc2VcblxuXHRkZWYgaXNLZXl3b3JkIGlkXG5cdFx0aWYgKGlkID09ICdhdHRyJyBvciBpZCA9PSAncHJvcCcpXG5cdFx0XHR2YXIgc2NvcCA9IGdldFNjb3BlXG5cdFx0XHR2YXIgaW5jbHMgPSBzY29wID09ICdDTEFTUycgb3Igc2NvcCA9PSAnVEFHJ1xuXHRcdFx0cmV0dXJuIHRydWUgaWYgaW5jbHNcblxuXHRcdGlmIEBsYXN0VHlwID09ICdBVFRSJyBvciBAbGFzdFR5cCA9PSAnUFJPUCdcblx0XHRcdHJldHVybiBmYWxzZVxuXG5cdFx0QUxMX0tFWVdPUkRTLmluZGV4T2YoaWQpID49IDBcblxuXHQjIE1hdGNoZXMgaWRlbnRpZnlpbmcgbGl0ZXJhbHM6IHZhcmlhYmxlcywga2V5d29yZHMsIG1ldGhvZCBuYW1lcywgZXRjLlxuXHQjIENoZWNrIHRvIGVuc3VyZSB0aGF0IEphdmFTY3JpcHQgcmVzZXJ2ZWQgd29yZHMgYXJlbid0IGJlaW5nIHVzZWQgYXNcblx0IyBpZGVudGlmaWVycy4gQmVjYXVzZSBJbWJhIHJlc2VydmVzIGEgaGFuZGZ1bCBvZiBrZXl3b3JkcyB0aGF0IGFyZVxuXHQjIGFsbG93ZWQgaW4gSmF2YVNjcmlwdCwgd2UncmUgY2FyZWZ1bCBub3QgdG8gdG9raWQgdGhlbSBhcyBrZXl3b3JkcyB3aGVuXG5cdCMgcmVmZXJlbmNlZCBhcyBwcm9wZXJ0eSBuYW1lcyBoZXJlLCBzbyB5b3UgY2FuIHN0aWxsIGRvIGBqUXVlcnkuaXMoKWAgZXZlblxuXHQjIHRob3VnaCBgaXNgIG1lYW5zIGA9PT1gIG90aGVyd2lzZS5cblx0ZGVmIGlkZW50aWZpZXJUb2tlblxuXHRcdHZhciBtYXRjaFxuXG5cdFx0dmFyIGN0eDAgPSBAZW5kczpsZW5ndGggPiAwID8gQGVuZHNbQGVuZHM6bGVuZ3RoIC0gMV0gOiBudWxsXG5cdFx0dmFyIGN0eDEgPSBAZW5kczpsZW5ndGggPiAxID8gQGVuZHNbQGVuZHM6bGVuZ3RoIC0gMl0gOiBudWxsXG5cdFx0dmFyIGlubmVyY3R4ID0gY3R4MFxuXHRcdHZhciB0eXBcblx0XHR2YXIgcmVzZXJ2ZWQgPSBub1xuXG5cdFx0dmFyIGFkZExvYyA9IGZhbHNlXG5cdFx0dmFyIGluVGFnID0gY3R4MCA9PSAnVEFHX0VORCcgb3IgKGN0eDEgPT0gJ1RBR19FTkQnIGFuZCBjdHgwID09ICdPVVRERU5UJylcblxuXHRcdCMgY29uc29sZS5sb2cgY3R4MSxjdHgwXG5cdFxuXHRcdGlmIGluVGFnICYmIG1hdGNoID0gVEFHX0FUVFIuZXhlYyhAY2h1bmspXG5cdFx0XHQjIGNvbnNvbGUubG9nICdUQUdfQVRUUiBJTiB0b2tpZCcsbWF0Y2hcblx0XHRcdCMgdmFyIHByZXYgPSBsYXN0IEB0b2tlbnNcblx0XHRcdCMgaWYgdGhlIHByZXYgaXMgYSB0ZXJtaW5hdG9yLCB3ZSBkb250IHJlYWxseSBuZWVkIHRvIGNhcmU/XG5cdFx0XHRpZiBAbGFzdFR5cCAhPSAnVEFHX05BTUUnXG5cdFx0XHRcdGlmIEBsYXN0VHlwID09ICdURVJNSU5BVE9SJ1xuXHRcdFx0XHRcdCMgY29uc29sZS5sb2coJ3ByZXYgd2FzIHRlcm1pbmF0b3IgLS0gZHJvcCBpdD8nKVxuXHRcdFx0XHRcdHRydWVcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHRva2VuKFwiLFwiLCBcIixcIilcblxuXHRcdFx0dmFyIGwgPSBtYXRjaFswXTpsZW5ndGhcblxuXHRcdFx0dG9rZW4gJ1RBR19BVFRSJyxtYXRjaFsxXSxsIC0gMSAgIyBhZGQgdG8gbG9jP1xuXHRcdFx0QGxvYyArPSBsIC0gMVxuXHRcdFx0dG9rZW4gJz0nLCc9JywxXG5cdFx0XHRyZXR1cm4gbFxuXG5cdFx0IyBzZWUgaWYgdGhpcyBpcyBhIHBsYWluIG9iamVjdC1rZXlcblx0XHQjIHdheSB0b28gbXVjaCBsb2dpYyBnb2luZyBvbiBoZXJlP1xuXHRcdCMgdGhlIGFzdCBzaG91bGQgbm9ybWFsaXplIHdoZXRoZXIga2V5c1xuXHRcdCMgYXJlIGFjY2Vzc2FibGUgYXMga2V5cyBvciBzdHJpbmdzIGV0Y1xuXHRcdGlmIG1hdGNoID0gT0JKRUNUX0tFWS5leGVjKEBjaHVuaylcblx0XHRcdHZhciBpZCA9IG1hdGNoWzFdXG5cdFx0XHR2YXIgdHlwID0gJ0tFWSdcblxuXHRcdFx0dG9rZW4odHlwLCBpZCwgaWQ6bGVuZ3RoKVxuXHRcdFx0bW92ZUNhcmV0KGlkOmxlbmd0aClcblx0XHRcdCMgY29uc29sZS5sb2cgXCJNQVRDSFwiLG1hdGNoXG5cdFx0XHR0b2tlbiAnOicsICc6JywgbWF0Y2hbM106bGVuZ3RoXG5cdFx0XHRtb3ZlQ2FyZXQoLWlkOmxlbmd0aClcblx0XHRcdHJldHVybiBtYXRjaFswXTpsZW5ndGhcblxuXHRcdHVubGVzcyBtYXRjaCA9IElERU5USUZJRVIuZXhlYyhAY2h1bmspXG5cdFx0XHRyZXR1cm4gMFxuXG5cdFx0dmFyIFtpbnB1dCwgaWQsIHR5cCwgbTMsIG00LCBjb2xvbl0gPSBtYXRjaFxuXHRcdHZhciBpZGxlbiA9IGlkOmxlbmd0aFxuXG5cdFx0IyBXaGF0IGlzIHRoZSBsb2dpYyBoZXJlP1xuXHRcdGlmIGlkIGlzICdvd24nIGFuZCBsYXN0VG9rZW5UeXBlID09ICdGT1InXG5cdFx0XHR0b2tlbiAnT1dOJywgaWQsIGlkOmxlbmd0aFxuXHRcdFx0cmV0dXJuIGlkOmxlbmd0aFxuXG5cdFx0dmFyIHByZXYgPSBsYXN0KEB0b2tlbnMpXG5cdFx0dmFyIGxhc3RUeXAgPSBAbGFzdFR5cFxuXG5cdFx0aWYgbGFzdFR5cCA9PSAnIydcblx0XHRcdHRva2VuKCdJREVOVElGSUVSJywgaWQsIGlkbGVuKVxuXHRcdFx0cmV0dXJuIGlkbGVuXG5cblx0XHQjIHNob3VsZCB3ZSBmb3JjZSB0aGlzIHRvIGJlIGFuIGlkZW50aWZpZXIgZXZlbiBpZiBpdCBpcyBhIHJlc2VydmVkIHdvcmQ/XG5cdFx0IyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBmb3Igd2hlbiBwYXJ0IG9mIG9iamVjdCBldGNcblx0XHQjIHdpbGwgcHJldiBldmVyIGJlIEA/Pz9cblx0XHR2YXIgZm9yY2VkSWRlbnRpZmllclxuXG5cdFx0IyBhZ2FpblxuXHRcdGZvcmNlZElkZW50aWZpZXIgPSBjb2xvbiB8fCBsYXN0VHlwID09ICcuJyBvciBsYXN0VHlwID09ICc/LicgIyBpbiBbJy4nLCAnPy4nXG5cblxuXHRcdCMgdGVtcCBoYWNrISBuZWVkIHRvIHNvbHZlIGZvciBvdGhlciBrZXl3b3JkcyBldGMgYXMgd2VsbFxuXHRcdCMgcHJvYmxlbSBhcHBlYXJzIHdpdGggdGVybmFyeSBjb25kaXRpb25zLlxuXG5cdFx0IyB3ZWxsIC0tIGl0IHNob3VsZCBzdGlsbCBiZSBhbiBpbmRlbnRpZmllciBpZiBpbiBvYmplY3Q/XG5cdFx0IyBmb3JjZWRJZGVudGlmaWVyID0gbm8gaWYgaWQgaW4gWyd1bmRlZmluZWQnLCdicmVhayddXG5cblx0XHRmb3JjZWRJZGVudGlmaWVyID0gbm8gaWYgY29sb24gYW5kIGxhc3RUeXAgPT0gJz8nICMgZm9yIHRlcm5hcnlcblxuXHRcdCMgaWYgd2UgYXJlIG5vdCBhdCB0aGUgdG9wIGxldmVsPyAtLSBoYWNreVxuXHRcdGlmIGlkID09ICd0YWcnIGFuZCBAY2h1bmsuaW5kZXhPZihcInRhZyhcIikgPT0gMCAjIEBjaHVuay5tYXRjaCgvXnRva2lkXFwoLylcblx0XHRcdGZvcmNlZElkZW50aWZpZXIgPSB5ZXNcblxuXHRcdHZhciBpc0tleXdvcmQgPSBub1xuXG5cdFx0IyBjb25zb2xlLmxvZyBcIm1hdGNoXCIsbWF0Y2hcblx0XHQjIGNvbnNvbGUubG9nIFwidHlwIGlzIHt0eXB9XCJcblx0XHQjIGxpdHRsZSByZWFzb24gdG8gY2hlY2sgZm9yIHRoaXMgcmlnaHQgaGVyZT8gYnV0IEkgZ3Vlc3MgaXQgaXMgb25seSBhIHNpbXBsZSBjaGVja1xuXHRcdGlmIHR5cCA9PSAnJCcgYW5kIEFSR1ZBUi50ZXN0KGlkKSAjIGlkLm1hdGNoKC9eXFwkXFxkJC8pXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiVFlQICRcIlxuXHRcdFx0aWYgaWQgPT0gJyQwJ1xuXHRcdFx0XHR0eXAgPSAnQVJHVU1FTlRTJ1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0eXAgPSAnQVJHVkFSJ1xuXHRcdFx0XHRpZCA9IGlkLnN1YnN0cigxKVxuXG5cdFx0ZWxpZiB0eXAgPT0gJyQnIGFuZCBFTlZfRkxBRy50ZXN0KGlkKVxuXHRcdFx0dHlwID0gJ0VOVl9GTEFHJ1xuXHRcdFx0aWQgPSBpZC50b1VwcGVyQ2FzZS5zbGljZSgxLCAtMSlcblxuXHRcdGVsaWYgdHlwID09ICdAJ1xuXHRcdFx0dHlwID0gJ0lWQVInXG5cdFx0XHQjIGlkOnJlc2VydmVkID0geWVzIGlmIGNvbG9uXG5cdFx0ZWxpZiB0eXAgPT0gJyMnXG5cdFx0XHR0eXAgPSAnVEFHSUQnXG5cblx0XHRlbGlmIHR5cCA9PSAnQEAnXG5cdFx0XHR0eXAgPSAnQ1ZBUidcblxuXHRcdGVsaWYgdHlwID09ICckJyBhbmQgIWNvbG9uXG5cdFx0XHR0eXAgPSAnSURFTlRJRklFUidcblx0XHRcdCMgdHlwID0gJ0dWQVInXG5cblx0XHRlbGlmIENPTlNUX0lERU5USUZJRVIudGVzdChpZCkgb3IgaWQgPT0gJ2dsb2JhbCcgb3IgaWQgPT0gJ2V4cG9ydHMnXG5cdFx0XHQjIHRob3VzIHNob3VsZCByZWFsbHkgYmUgaGFuZGxlZCBieSB0aGUgYXN0IGluc3RlYWRcblx0XHRcdHR5cCA9ICdDT05TVCdcblxuXHRcdGVsaWYgaWQgPT0gJ2VsaWYnXG5cdFx0XHR0b2tlbiAnRUxTRScsICdlbGlmJywgaWQ6bGVuZ3RoXG5cdFx0XHR0b2tlbiAnSUYnLCAnaWYnXG5cdFx0XHRyZXR1cm4gaWQ6bGVuZ3RoXG5cblx0XHRlbHNlXG5cdFx0XHR0eXAgPSAnSURFTlRJRklFUidcblxuXG5cblx0XHQjIHRoaXMgY2F0Y2hlcyBhbGwgXG5cdFx0aWYgIWZvcmNlZElkZW50aWZpZXIgYW5kIGlzS2V5d29yZCA9IHNlbGYuaXNLZXl3b3JkKGlkKVxuXHRcdFx0IyAoaWQgaW4gSlNfS0VZV09SRFMgb3IgaWQgaW4gSU1CQV9LRVlXT1JEUylcblxuXHRcdFx0dHlwID0gaWQudG9VcHBlckNhc2Vcblx0XHRcdGFkZExvYyA9IHRydWVcblxuXHRcdFx0IyBjbHVtc3kgLSBidXQgdGVzdGluZyBwZXJmb3JtYW5jZVxuXHRcdFx0aWYgdHlwID09ICdZRVMnXG5cdFx0XHRcdHR5cCA9ICdUUlVFJ1xuXHRcdFx0ZWxpZiB0eXAgPT0gJ05PJ1xuXHRcdFx0XHR0eXAgPSAnRkFMU0UnXG5cdFx0XHRlbGlmIHR5cCA9PSAnTklMJ1xuXHRcdFx0XHR0eXAgPSAnTlVMTCdcblxuXHRcdFx0ZWxpZiB0eXAgPT0gJ1ZBUidcblx0XHRcdFx0aWYgQGxhc3RWYWwgPT0gJ2V4cG9ydCdcblx0XHRcdFx0XHR0VHMocHJldiwnRVhQT1JUJylcblxuXHRcdFx0IyBza2lwcGluZyBcblx0XHRcdGVsaWYgdHlwID09ICdJRicgb3IgdHlwID09ICdFTFNFJyBvciB0eXAgPT0gJ1RSVUUnIG9yIHR5cCA9PSAnRkFMU0UnIG9yIHR5cCA9PSAnTlVMTCdcblx0XHRcdFx0dHJ1ZVxuXG5cdFx0XHRlbGlmIHR5cCA9PSAnVEFHJ1xuXHRcdFx0XHRzZWxmLnB1c2hFbmQoJ1RBRycpXG5cdFx0XHQjIEZJWE1FIEBlbmRzIGlzIG5vdCB1c2VkIHRoZSB3YXkgaXQgaXMgc3VwcG9zZWQgdG8uLlxuXHRcdFx0IyB3aGF0IHdlIHdhbnQgaXMgYSBjb250ZXh0LXN0YWNrXG5cdFx0XHRlbGlmIHR5cCA9PSAnREVGJ1xuXHRcdFx0XHQjIHNob3VsZCBwcm9iYWJseSBzaGlmdCBjb250ZXh0IGFuZCBvcHRpbWl6ZSB0aGlzXG5cdFx0XHRcdG9wZW5EZWZcblxuXHRcdFx0ZWxpZiB0eXAgPT0gJ0RPJ1xuXHRcdFx0XHRjbG9zZURlZiBpZiBjb250ZXh0ID09ICdERUYnXG5cblx0XHRcdGVsaWYgdHlwIGlzICdXSEVOJyBhbmQgTElORV9CUkVBSy5pbmRleE9mKGxhc3RUb2tlblR5cGUpID49IDBcblx0XHRcdFx0dHlwID0gJ0xFQURJTkdfV0hFTidcblxuXHRcdFx0ZWxpZiB0eXAgaXMgJ0ZPUidcblx0XHRcdFx0QHNlZW5Gb3IgPSB5ZXNcblxuXHRcdFx0ZWxpZiB0eXAgaXMgJ1VOTEVTUydcblx0XHRcdFx0dHlwID0gJ0lGJyAjIFdBUk5cblxuXHRcdFx0ZWxpZiBVTkFSWS5pbmRleE9mKHR5cCkgPj0gMFxuXHRcdFx0XHR0eXAgPSAnVU5BUlknXG5cblx0XHRcdGVsaWYgUkVMQVRJT04uaW5kZXhPZih0eXApID49IDBcblx0XHRcdFx0aWYgdHlwICE9ICdJTlNUQU5DRU9GJyBhbmQgdHlwICE9ICdJU0EnIGFuZCBAc2VlbkZvclxuXHRcdFx0XHRcdHR5cCA9ICdGT1InICsgdHlwICMgP1xuXHRcdFx0XHRcdEBzZWVuRm9yID0gbm9cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHR5cCA9ICdSRUxBVElPTidcblxuXHRcdFx0XHRcdGlmIHByZXYuQHR5cGUgPT0gJ1VOQVJZJ1xuXHRcdFx0XHRcdFx0cHJldi5AdHlwZSA9ICdOT1QnXG5cblx0XHRpZiBpZCA9PSAnc3VwZXInXG5cdFx0XHR0eXAgPSAnU1VQRVInXG5cblx0XHQjIGRvIHdlIHJlYWxseSB3YW50IHRvIGNoZWNrIHRoaXMgaGVyZVxuXHRcdGlmICFmb3JjZWRJZGVudGlmaWVyXG5cdFx0XHQjIHNob3VsZCBhbHJlYWR5IGhhdmUgZGVhbHQgd2l0aCB0aGlzXG5cblx0XHRcdGlmIEBsYXN0VmFsID09ICdleHBvcnQnIGFuZCBpZCA9PSAnZGVmYXVsdCdcblx0XHRcdFx0IyBjb25zb2xlLmxvZyAnaWQgaXMgZGVmYXVsdCEhISdcblx0XHRcdFx0dFRzKHByZXYsJ0VYUE9SVCcpXG5cdFx0XHRcdHR5cCA9ICdERUZBVUxUJ1xuXG5cdFx0XHQjIHRoZXNlIHJlYWxseSBzaG91bGQgbm90IGdvIGhlcmU/IT9cblx0XHRcdHN3aXRjaCBpZFxuXHRcdFx0XHR3aGVuICchJywnbm90JyAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIHR5cCA9ICdVTkFSWSdcblx0XHRcdFx0d2hlbiAnPT0nLCAnIT0nLCAnPT09JywgJyE9PScsJ2lzJywnaXNudCcgdGhlbiB0eXAgPSAnQ09NUEFSRSdcblx0XHRcdFx0d2hlbiAnJiYnLCAnfHwnLCdhbmQnLCdvcicgICAgICAgICAgICAgICAgdGhlbiB0eXAgPSAnTE9HSUMnXG5cdFx0XHRcdHdoZW4gJ2JyZWFrJywgJ2NvbnRpbnVlJywgJ2RlYnVnZ2VyJywnYXJndW1lbnRzJyB0aGVuIHR5cCA9IGlkLnRvVXBwZXJDYXNlXG5cdFx0XHRcdCMgd2hlbiAndHJ1ZScsICdmYWxzZScsICdudWxsJywgJ3VuZGVmaW5lZCcgdGhlbiB0eXAgPSAnQk9PTCdcblx0XHRcdFx0IyByZWFsbHk/XG5cblx0XHQjIHByZXYgPSBsYXN0IEB0b2tlbnNcblx0XHR2YXIgbGVuID0gaW5wdXQ6bGVuZ3RoXG5cblx0XHQjIHNob3VsZCBiZSBzdHJpY3QgYWJvdXQgdGhlIG9yZGVyLCBjaGVjayB0aGlzIG1hbnVhbGx5IGluc3RlYWRcblx0XHRpZiB0eXAgPT0gJ0NMQVNTJyBvciB0eXAgPT0gJ0RFRicgb3IgdHlwID09ICdUQUcnXG5cdFx0XHRxdWV1ZVNjb3BlKHR5cClcblxuXHRcdFx0dmFyIGkgPSBAdG9rZW5zOmxlbmd0aFxuXG5cdFx0XHR3aGlsZSBpXG5cdFx0XHRcdHZhciBwcmV2ID0gQHRva2Vuc1stLWldXG5cdFx0XHRcdHZhciBjdHJsID0gXCJcIiArIHRWKHByZXYpXG5cdFx0XHRcdGlmIGN0cmwgaW4gSU1CQV9DT05URVhUVUFMX0tFWVdPUkRTXG5cdFx0XHRcdFx0dFRzKHByZXYsY3RybC50b1VwcGVyQ2FzZSlcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGJyZWFrXG5cblx0XHRlbGlmIHR5cCA9PSAnSUYnXG5cdFx0XHRxdWV1ZVNjb3BlKHR5cClcblxuXHRcdGVsaWYgdHlwID09ICdJTVBPUlQnXG5cdFx0XHQjIGNvdWxkIG1hbnVhbGx5IHBhcnNlIHRoZSB3aG9sZSB0aW5nIGhlcmU/XG5cdFx0XHRwdXNoRW5kKCdJTVBPUlQnKVxuXG5cdFx0ZWxpZiBpZCA9PSAnZnJvbScgYW5kIGN0eDAgPT0gJ0lNUE9SVCdcblx0XHRcdHR5cCA9ICdGUk9NJ1xuXHRcdFx0cGFpciAnSU1QT1JUJ1xuXG5cdFx0IyB3aWxsIGJlIG11Y2ggY2xlYW5lciB3aXRoIHRoZSBuZXcgaGFuZG1hZGUgY29tYmluZWQgbGV4ZXIrcGFyc2VyXG5cdFx0IyBmb3Igbm93IHdlIG5lZWQgdG8gZG8gc29tZSB0ZXN0aW5nXG5cdFx0ZWxpZiBpZCA9PSAnYXMnIGFuZCBjdHgwID09ICdJTVBPUlQnXG5cdFx0XHR0eXAgPSAnQVMnXG5cdFx0XHRwYWlyICdJTVBPUlQnXG5cblx0XHRpZiB0eXAgPT0gJ0lERU5USUZJRVInXG5cdFx0XHQjIHNlZSBpZiBwcmV2aW91cyB3YXMgY2F0Y2ggLS0gYmVsb25ncyBpbiByZXdyaXRlcj9cblx0XHRcdGlmIGxhc3RUeXAgPT0gJ0NBVENIJ1xuXHRcdFx0XHR0eXAgPSAnQ0FUQ0hfVkFSJ1xuXHRcdFxuXHRcdGlmIGNvbG9uXG5cdFx0XHQjIGNvbnNvbGUubG9nICdjb2xvbicsY29sb24sdHlwXG5cdFx0XHRpZiB0eXAgPT0gJ0lERU5USUZJRVInIGFuZCBOT1RfS0VZX0FGVEVSLmluZGV4T2YoQGxhc3RUeXApID09IC0xXG5cdFx0XHRcdHR5cCA9ICdLRVknXG5cblx0XHRcdHRva2VuKHR5cCwgaWQsIGlkbGVuKVxuXHRcdFx0dmFyIGNvbG9uT2Zmc2V0ID0gY29sb24uaW5kZXhPZignOicpXG5cblx0XHRcdG1vdmVDYXJldChpZGxlbiArIGNvbG9uT2Zmc2V0KVxuXHRcdFx0IyBUT0RPIFN0b3AgbW92aW5nIGNhcmV0IGJhY2sgYW5kIGZvcnRoXG5cdFx0XHQjIGNvbnNvbGUubG9nIGlkbGVuLGNvbG9uLGNvbG9uT2Zmc2V0XG5cdFx0XHR0b2tlbignOicsICc6JywxKVxuXHRcdFx0bW92ZUNhcmV0KC0oaWRsZW4gKyBjb2xvbk9mZnNldCkpXG5cdFx0ZWxzZVxuXHRcdFx0dG9rZW4odHlwLCBpZCwgaWRsZW4pXG5cblx0XHRyZXR1cm4gbGVuXG5cblx0IyBNYXRjaGVzIG51bWJlcnMsIGluY2x1ZGluZyBkZWNpbWFscywgaGV4LCBhbmQgZXhwb25lbnRpYWwgbm90YXRpb24uXG5cdCMgQmUgY2FyZWZ1bCBub3QgdG8gaW50ZXJmZXJlIHdpdGggcmFuZ2VzLWluLXByb2dyZXNzLlxuXHRkZWYgbnVtYmVyVG9rZW5cblx0XHR2YXIgbWF0Y2gsIG51bWJlciwgbGV4ZWRMZW5ndGhcblxuXHRcdHJldHVybiAwIHVubGVzcyBtYXRjaCA9IE5VTUJFUi5leGVjKEBjaHVuaylcblxuXHRcdG51bWJlciA9IG1hdGNoWzBdXG5cdFx0bGV4ZWRMZW5ndGggPSBudW1iZXI6bGVuZ3RoXG5cblx0XHRpZiB2YXIgYmluYXJ5TGl0ZXJhbCA9IC8wYihbMDFdKykvLmV4ZWMobnVtYmVyKVxuXHRcdFx0XG5cdFx0XHRudW1iZXIgPSBcIlwiICsgcGFyc2VJbnQoYmluYXJ5TGl0ZXJhbFsxXSwgMilcblxuXHRcdHZhciBwcmV2ID0gbGFzdChAdG9rZW5zKVxuXG5cdFx0aWYgbWF0Y2hbMF1bMF0gPT0gJy4nICYmIHByZXYgJiYgIXByZXY6c3BhY2VkICYmIFsnSURFTlRJRklFUicsJyknLCd9JywnXScsJ05VTUJFUiddLmluZGV4T2YodFQocHJldikpID49IDBcblx0XHRcdCMgY29uc29sZS5sb2cgXCJnb3QgaGVyZVwiXG5cdFx0XHR0b2tlbiBcIi5cIixcIi5cIlxuXHRcdFx0bnVtYmVyID0gbnVtYmVyLnN1YnN0cigxKVxuXHRcdFxuXG5cdFx0dG9rZW4oJ05VTUJFUicsbnVtYmVyLGxleGVkTGVuZ3RoKVxuXHRcdHJldHVybiBsZXhlZExlbmd0aFxuXHRcblx0ZGVmIHN5bWJvbFRva2VuXG5cdFx0dmFyIG1hdGNoLCBzeW1ib2wsIHByZXZcblxuXHRcdHJldHVybiAwIHVubGVzcyBtYXRjaCA9IFNZTUJPTC5leGVjKEBjaHVuaylcblx0XHRzeW1ib2wgPSBtYXRjaFswXVxuXHRcdHByZXYgPSBsYXN0KEB0b2tlbnMpXG5cblx0XHQjIGlzIHRoaXMgYSBwcm9wZXJ0eS1hY2Nlc3M/XG5cdFx0IyBzaG91bGQgaW52ZXJ0IHRoaXMgLS0gb25seSBhbGxvdyB3aGVuIHByZXYgSVMgLi4gXG5cdFx0IyA6IHNob3VsZCBiZSBhIHRva2VuIGl0c2VsZiwgd2l0aCBhIHNwZWNpZmljYXRpb24gb2Ygc3BhY2luZyAoTFIsUixMLE5PTkUpXG5cdFx0aWYgcHJldiBhbmQgIXByZXY6c3BhY2VkIGFuZCB0VChwcmV2KSAhaW4gWycoJywneycsJ1snLCcuJywnQ0FMTF9TVEFSVCcsJ0lOREVYX1NUQVJUJywnLCcsJz0nLCdJTkRFTlQnLCdURVJNSU5BVE9SJywnVkFMVUVfU1RBUlQnXVxuXHRcdFx0dmFyIGFjY2VzcyA9IHN5bWJvbC5zcGxpdCgnOicpWzFdICMgcmVhbGx5P1xuXHRcdFx0XG5cdFx0XHR0b2tlbiAnLjonLCc6JywgMVxuXHRcdFx0XG5cdFx0XHR0b2tlbiAnSURFTlRJRklFUicsIGFjY2VzcywgYWNjZXNzOmxlbmd0aCwgMVxuXHRcdFx0cmV0dXJuIGFjY2VzczpsZW5ndGggKyAxXG5cdFx0ZWxzZVxuXHRcdFx0dG9rZW4gJ1NZTUJPTCcsIHN5bWJvbCwgbWF0Y2hbMF06bGVuZ3RoXG5cdFx0XHRtYXRjaFswXTpsZW5ndGhcblxuXHRkZWYgZXNjYXBlU3RyIHN0ciwgaGVyZWRvYywgcVxuXHRcdHN0ciA9IHN0ci5yZXBsYWNlIE1VTFRJTElORVIsIChoZXJlZG9jID8gJ1xcXFxuJyA6ICcnKVxuXHRcdGlmIHFcblx0XHRcdHZhciByID0gUmVnRXhwKFwiXFxcXFxcXFxbe3F9XVwiLFwiZ1wiKVxuXHRcdFx0c3RyID0gc3RyLnJlcGxhY2UocixxKVxuXHRcdFx0c3RyID0gc3RyLnJlcGxhY2UgUmVnRXhwKFwie3F9XCIsXCJnXCIpLCAnXFxcXCQmJ1xuXHRcdHJldHVybiBzdHJcblxuXHRcdCMgc3RyID0gc3RyLnJlcGxhY2UoTVVMVElMSU5FUiwgJ1xcXFxuJylcblx0XHQjIHN0ciA9IHN0ci5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0Jylcblx0IyBNYXRjaGVzIHN0cmluZ3MsIGluY2x1ZGluZyBtdWx0aS1saW5lIHN0cmluZ3MuIEVuc3VyZXMgdGhhdCBxdW90YXRpb24gbWFya3Ncblx0IyBhcmUgYmFsYW5jZWQgd2l0aGluIHRoZSBzdHJpbmcncyBjb250ZW50cywgYW5kIHdpdGhpbiBuZXN0ZWQgaW50ZXJwb2xhdGlvbnMuXG5cdGRlZiBzdHJpbmdUb2tlblxuXHRcdHZhciBtYXRjaCwgc3RyaW5nXG5cblx0XHRzd2l0Y2ggQGNodW5rLmNoYXJBdCgwKVxuXHRcdFx0d2hlbiBcIidcIlxuXHRcdFx0XHRyZXR1cm4gMCB1bmxlc3MgbWF0Y2ggPSBTSU1QTEVTVFIuZXhlYyhAY2h1bmspXG5cdFx0XHRcdHN0cmluZyA9IG1hdGNoWzBdXG5cdFx0XHRcdHRva2VuICdTVFJJTkcnLCBlc2NhcGVTdHIoc3RyaW5nKSwgc3RyaW5nOmxlbmd0aFxuXHRcdFx0XHQjIHRva2VuICdTVFJJTkcnLCAoc3RyaW5nID0gbWF0Y2hbMF0pLnJlcGxhY2UoTVVMVElMSU5FUiwgJ1xcXFxcXG4nKSwgc3RyaW5nOmxlbmd0aFxuXG5cdFx0XHR3aGVuICdcIidcblx0XHRcdFx0cmV0dXJuIDAgdW5sZXNzIHN0cmluZyA9IGJhbGFuY2VkU3RyaW5nKEBjaHVuaywgJ1wiJylcblx0XHRcdFx0IyB3aGF0IGFib3V0IHRyaXBlIHF1b3RlZCBzdHJpbmdzP1xuXG5cdFx0XHRcdGlmIHN0cmluZy5pbmRleE9mKCd7JykgPj0gMFxuXHRcdFx0XHRcdHZhciBsZW4gPSBzdHJpbmc6bGVuZ3RoXG5cdFx0XHRcdFx0IyBpZiB0aGlzIGhhcyBubyBpbnRlcnBvbGF0aW9uP1xuXHRcdFx0XHRcdCMgd2UgYXJlIG5vdyBtZXNzaW5nIHdpdGggbG9jYXRpb25zIC0gYmV3YXJlXG5cdFx0XHRcdFx0dG9rZW4gJ1NUUklOR19TVEFSVCcsIHN0cmluZy5jaGFyQXQoMCksIDFcblx0XHRcdFx0XHRpbnRlcnBvbGF0ZVN0cmluZyhzdHJpbmcuc2xpY2UgMSwgLTEpXG5cdFx0XHRcdFx0dG9rZW4gJ1NUUklOR19FTkQnLCBzdHJpbmcuY2hhckF0KGxlbiAtIDEpLCAxLCBzdHJpbmc6bGVuZ3RoIC0gMVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0dmFyIGxlbiA9IHN0cmluZzpsZW5ndGhcblx0XHRcdFx0XHQjIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKE1VTFRJTElORVIsICdcXFxcXFxuJylcblx0XHRcdFx0XHR0b2tlbiAnU1RSSU5HJywgZXNjYXBlU3RyKHN0cmluZyksIGxlblxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZXR1cm4gMFxuXG5cdFx0bW92ZUhlYWQoc3RyaW5nKVxuXHRcdHJldHVybiBzdHJpbmc6bGVuZ3RoXG5cblx0IyBNYXRjaGVzIGhlcmVkb2NzLCBhZGp1c3RpbmcgaW5kZW50YXRpb24gdG8gdGhlIGNvcnJlY3QgbGV2ZWwsIGFzIGhlcmVkb2NzXG5cdCMgcHJlc2VydmUgd2hpdGVzcGFjZSwgYnV0IGlnbm9yZSBpbmRlbnRhdGlvbiB0byB0aGUgbGVmdC5cblx0ZGVmIGhlcmVkb2NUb2tlblxuXHRcdHZhciBtYXRjaCwgaGVyZWRvYywgcXVvdGUsIGRvY1xuXG5cdFx0cmV0dXJuIDAgdW5sZXNzIG1hdGNoID0gSEVSRURPQy5leGVjKEBjaHVuaylcblxuXHRcdGhlcmVkb2MgPSBtYXRjaFswXVxuXHRcdHF1b3RlID0gaGVyZWRvYy5jaGFyQXQgMFxuXHRcdHZhciBvcHRzID0ge3F1b3RlOiBxdW90ZSwgaW5kZW50OiBudWxsLCBvZmZzZXQ6IDB9XG5cdFx0ZG9jID0gc2FuaXRpemVIZXJlZG9jKG1hdGNoWzJdLCBvcHRzKVxuXHRcdCMgZG9jID0gbWF0Y2hbMl1cblx0XHQjIGNvbnNvbGUubG9nIFwiZm91bmQgaGVyZWRvYyB7bWF0Y2hbMF06bGVuZ3RofSB7ZG9jOmxlbmd0aH1cIlxuXG5cdFx0aWYgcXVvdGUgPT0gJ1wiJyAmJiBkb2MuaW5kZXhPZigneycpID49IDBcblx0XHRcdHZhciBvcGVuID0gbWF0Y2hbMV1cblx0XHRcdCMgY29uc29sZS5sb2cgZG9jLnN1YnN0cigwLDMpLG1hdGNoWzFdXG5cdFx0XHQjIGNvbnNvbGUubG9nICdoZXJlZG9jIGhlcmUnLG9wZW46bGVuZ3RoLG9wZW5cblxuXHRcdFx0dG9rZW4gJ1NUUklOR19TVEFSVCcsIG9wZW4sIG9wZW46bGVuZ3RoXG5cdFx0XHRpbnRlcnBvbGF0ZVN0cmluZyhkb2MsIGhlcmVkb2M6IHllcywgb2Zmc2V0OiAob3BlbjpsZW5ndGggKyBvcHRzOm9mZnNldCksIHF1b3RlOiBxdW90ZSwgaW5kZW50OiBvcHRzOnJlYWxJbmRlbnQpXG5cdFx0XHR0b2tlbiAnU1RSSU5HX0VORCcsIG9wZW4sIG9wZW46bGVuZ3RoLCBoZXJlZG9jOmxlbmd0aCAtIG9wZW46bGVuZ3RoXG5cdFx0ZWxzZVxuXHRcdFx0dG9rZW4oJ1NUUklORycsIG1ha2VTdHJpbmcoZG9jLCBxdW90ZSwgeWVzKSwgMClcblxuXHRcdG1vdmVIZWFkKGhlcmVkb2MpXG5cdFx0cmV0dXJuIGhlcmVkb2M6bGVuZ3RoXG5cblx0ZGVmIHBhcnNlTWFnaWNhbE9wdGlvbnMgc3RyXG5cdFx0aWYgc3RyLmluZGV4T2YoJ2ltYmEkJykgPj0gMFxuXHRcdFx0c3RyLnJlcGxhY2UoL2ltYmFcXCQoXFx3KylcXD0oLiopXFxiL2cpIGRvIHxtLG5hbWUsdmFsfFxuXHRcdFx0XHRpZiAoL15cXGQrJC8pLnRlc3QodmFsKVxuXHRcdFx0XHRcdHZhbCA9IHBhcnNlSW50KHZhbClcblx0XHRcdFx0QG9wdHNbbmFtZV0gPSB2YWxcblx0XHRzZWxmXG5cblx0IyBNYXRjaGVzIGFuZCBjb25zdW1lcyBjb21tZW50cy5cblx0ZGVmIGNvbW1lbnRUb2tlblxuXHRcdHZhciBtYXRjaCwgbGVuZ3RoLCBjb21tZW50LCBpbmRlbnQsIHByZXZcblxuXHRcdHZhciB0eXAgPSAnSEVSRUNPTU1FTlQnXG5cblx0XHRpZiBtYXRjaCA9IElOTElORV9DT01NRU5ULmV4ZWMoQGNodW5rKSAjIC5tYXRjaChJTkxJTkVfQ09NTUVOVClcblx0XHRcdCMgY29uc29sZS5sb2cgXCJtYXRjaCBpbmxpbmUgY29tbWVudFwiXG5cdFx0XHRsZW5ndGggPSBtYXRjaFswXTpsZW5ndGhcblx0XHRcdGluZGVudCA9IG1hdGNoWzFdXG5cdFx0XHRjb21tZW50ID0gbWF0Y2hbMl1cblxuXHRcdFx0cHJldiA9IGxhc3QoQHRva2Vucylcblx0XHRcdHZhciBwdCA9IHByZXYgYW5kIHRUKHByZXYpXG5cdFx0XHR2YXIgbm90ZSA9ICcvLycgKyBjb21tZW50LnN1YnN0cigxKVxuXG5cdFx0XHRwYXJzZU1hZ2ljYWxPcHRpb25zKG5vdGUpXG5cblx0XHRcdGlmIEBsYXN0IGFuZCBAbGFzdDpzcGFjZWRcblx0XHRcdFx0bm90ZSA9ICcgJyArIG5vdGVcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcInRoZSBwcmV2aW91cyBub2RlIHdhcyBTUEFDRURcIlxuXHRcdFx0IyBjb25zb2xlLmxvZyBcImNvbW1lbnQge25vdGV9IC0gaW5kZW50KHtpbmRlbnR9KSAtIHtsZW5ndGh9IHtjb21tZW50Omxlbmd0aH1cIlxuXG5cdFx0XHRpZiAocHQgYW5kIHB0ICE9ICdJTkRFTlQnIGFuZCBwdCAhPSAnVEVSTUlOQVRPUicpIG9yICFwdFxuXHRcdFx0XHQjIGNvbnNvbGUubG9nIFwic2tpcCBjb21tZW50XCJcblx0XHRcdFx0IyB0b2tlbiAnSU5MSU5FQ09NTUVOVCcsIGNvbW1lbnQuc3Vic3RyKDIpXG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJhZGRpbmcgYXMgdGVybWluYXRvclwiXG5cdFx0XHRcdHRva2VuKCdURVJNSU5BVE9SJywgbm90ZSwgbGVuZ3RoKSAjICsgJ1xcbidcblx0XHRcdGVsc2Vcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcImFkZCBjb21tZW50ICh7bm90ZX0pXCJcblx0XHRcdFx0aWYgcHQgPT0gJ1RFUk1JTkFUT1InXG5cdFx0XHRcdFx0dFZzKHByZXYsdFYocHJldikgKyBub3RlKVxuXHRcdFx0XHRcdCMgcHJldlsxXSArPSBub3RlXG5cdFx0XHRcdGVsaWYgcHQgPT0gJ0lOREVOVCdcblx0XHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiYWRkaW5nIGNvbW1lbnQgdG8gSU5ERU5UOiB7bm90ZX1cIiAjIHdoeSBub3QgYWRkIGRpcmVjdGx5IGhlcmU/XG5cdFx0XHRcdFx0YWRkTGluZWJyZWFrcygxLG5vdGUpXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHQjIGNvbnNvbGUubG9nIFwiY29tbWVudCBoZXJlXCJcblx0XHRcdFx0XHQjIHNob3VsZCB3ZSBldmVyIGdldCBoZXJlP1xuXHRcdFx0XHRcdHRva2VuKHR5cCwgY29tbWVudC5zdWJzdHIoMiksIGxlbmd0aCkgIyBhcmUgd2Ugc3VyZT9cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGxlbmd0aCAjIGRpc2FibGUgbm93IHdoaWxlIGNvbXBpbGluZ1xuXG5cdFx0IyBzaG91bGQgdXNlIGV4ZWM/XG5cdFx0cmV0dXJuIDAgdW5sZXNzIG1hdGNoID0gQ09NTUVOVC5leGVjKEBjaHVuaylcblxuXHRcdHZhciBjb21tZW50ID0gbWF0Y2hbMF1cblx0XHR2YXIgaGVyZSA9IG1hdGNoWzFdXG5cblx0XHRpZiBoZXJlXG5cdFx0XHR0b2tlbiAnSEVSRUNPTU1FTlQnLCBzYW5pdGl6ZUhlcmVkb2MoaGVyZSwgaGVyZWNvbW1lbnQ6IHRydWUsIGluZGVudDogQXJyYXkoQGluZGVudCArIDEpLmpvaW4oJyAnKSksIGNvbW1lbnQ6bGVuZ3RoXG5cdFx0XHR0b2tlbiAnVEVSTUlOQVRPUicsICdcXG4nXG5cdFx0ZWxzZVxuXHRcdFx0dG9rZW4gJ0hFUkVDT01NRU5UJywgY29tbWVudCwgY29tbWVudDpsZW5ndGhcblx0XHRcdHRva2VuICdURVJNSU5BVE9SJywgJ1xcbicgIyBhdXRvPyByZWFsbHk/XG5cblx0XHRtb3ZlSGVhZChjb21tZW50KVxuXHRcdHJldHVybiBjb21tZW50Omxlbmd0aFxuXG5cdCMgTWF0Y2hlcyBKYXZhU2NyaXB0IGludGVycG9sYXRlZCBkaXJlY3RseSBpbnRvIHRoZSBzb3VyY2UgdmlhIGJhY2t0aWNrcy5cblx0ZGVmIGpzVG9rZW5cblx0XHR2YXIgbWF0Y2gsIHNjcmlwdFxuXG5cdFx0cmV0dXJuIDAgdW5sZXNzIEBjaHVuay5jaGFyQXQoMCkgaXMgJ2AnIGFuZCBtYXRjaCA9IEpTVE9LRU4uZXhlYyhAY2h1bmspXG5cdFx0dG9rZW4gJ0pTJywgKHNjcmlwdCA9IG1hdGNoWzBdKS5zbGljZSAxLCAtMVxuXHRcdHNjcmlwdDpsZW5ndGhcblxuXHQjIE1hdGNoZXMgcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWxzLiBMZXhpbmcgcmVndWxhciBleHByZXNzaW9ucyBpcyBkaWZmaWN1bHRcblx0IyB0byBkaXN0aW5ndWlzaCBmcm9tIGRpdmlzaW9uLCBzbyB3ZSBib3Jyb3cgc29tZSBiYXNpYyBoZXVyaXN0aWNzIGZyb21cblx0IyBKYXZhU2NyaXB0IGFuZCBSdWJ5LlxuXHRkZWYgcmVnZXhUb2tlblxuXHRcdHZhciBtYXRjaCwgbGVuZ3RoLCBwcmV2XG5cblx0XHRyZXR1cm4gMCBpZiBAY2h1bmsuY2hhckF0KDApICE9ICcvJ1xuXHRcdGlmIG1hdGNoID0gSEVSRUdFWC5leGVjKEBjaHVuaylcblx0XHRcdGxlbmd0aCA9IGhlcmVnZXhUb2tlbihtYXRjaClcblx0XHRcdG1vdmVIZWFkKG1hdGNoWzBdKVxuXHRcdFx0cmV0dXJuIGxlbmd0aFxuXG5cdFx0cHJldiA9IGxhc3QgQHRva2Vuc1xuXHRcdCMgRklYXG5cdFx0cmV0dXJuIDAgaWYgcHJldiBhbmQgKHRUKHByZXYpIGluIChpZiBwcmV2OnNwYWNlZCB0aGVuIE5PVF9SRUdFWCBlbHNlIE5PVF9TUEFDRURfUkVHRVgpKVxuXHRcdHJldHVybiAwIHVubGVzcyBtYXRjaCA9IFJFR0VYLmV4ZWMoQGNodW5rKVxuXHRcdHZhciBbbSwgcmVnZXgsIGZsYWdzXSA9IG1hdGNoXG5cblx0XHR0b2tlbiAnUkVHRVgnLCBcIntyZWdleH17ZmxhZ3N9XCIsIG06bGVuZ3RoXG5cdFx0bTpsZW5ndGhcblxuXHQjIE1hdGNoZXMgbXVsdGlsaW5lIGV4dGVuZGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG5cdCMgVGhlIGVzY2FwaW5nIHNob3VsZCByYXRoZXIgaGFwcGVuIGluIEFTVCAtIHBvc3NpYmx5IGFzIGFuIGFkZGl0aW9uYWwgZmxhZz9cblx0ZGVmIGhlcmVnZXhUb2tlbiBtYXRjaFxuXHRcdHZhciBbaGVyZWdleCwgYm9keSwgZmxhZ3NdID0gbWF0Y2hcblx0XHR0b2tlbiAnUkVHRVgnLCBoZXJlZ2V4LCBoZXJlZ2V4Omxlbmd0aFxuXHRcdHJldHVybiBoZXJlZ2V4Omxlbmd0aFxuXG5cdCMgTWF0Y2hlcyBuZXdsaW5lcywgaW5kZW50cywgYW5kIG91dGRlbnRzLCBhbmQgZGV0ZXJtaW5lcyB3aGljaCBpcyB3aGljaC5cblx0IyBJZiB3ZSBjYW4gZGV0ZWN0IHRoYXQgdGhlIGN1cnJlbnQgbGluZSBpcyBjb250aW51ZWQgb250byB0aGUgdGhlIG5leHQgbGluZSxcblx0IyB0aGVuIHRoZSBuZXdsaW5lIGlzIHN1cHByZXNzZWQ6XG5cdCNcblx0IyAgICAgZWxlbWVudHNcblx0IyAgICAgICAuZWFjaCggLi4uIClcblx0IyAgICAgICAubWFwKCAuLi4gKVxuXHQjXG5cdCMgS2VlcHMgdHJhY2sgb2YgdGhlIGxldmVsIG9mIGluZGVudGF0aW9uLCBiZWNhdXNlIGEgc2luZ2xlIG91dGRlbnQgdG9rZW5cblx0IyBjYW4gY2xvc2UgbXVsdGlwbGUgaW5kZW50cywgc28gd2UgbmVlZCB0byBrbm93IGhvdyBmYXIgaW4gd2UgaGFwcGVuIHRvIGJlLlxuXHRkZWYgbGluZVRva2VuXG5cdFx0dmFyIG1hdGNoXG5cblx0XHRyZXR1cm4gMCB1bmxlc3MgbWF0Y2ggPSBNVUxUSV9ERU5ULmV4ZWMoQGNodW5rKVxuXG5cdFx0dmFyIGluZGVudCA9IG1hdGNoWzBdXG5cdFx0dmFyIGJyQ291bnQgPSBtb3ZlSGVhZChpbmRlbnQpXG5cblx0XHRAc2VlbkZvciA9IG5vXG5cdFx0IyByZXNldCBjb2x1bW4gYXMgd2VsbD9cblx0XHR2YXIgcHJldiA9IGxhc3QgQHRva2VucywgMVxuXHRcdGxldCB3aGl0ZXNwYWNlID0gaW5kZW50LnN1YnN0cihpbmRlbnQubGFzdEluZGV4T2YoJ1xcbicpICsgMSlcblx0XHR2YXIgbm9OZXdsaW5lcyA9IHNlbGYudW5maW5pc2hlZFxuXG5cdFx0aWYgKC9eXFxuI1xccy8pLnRlc3QoQGNodW5rKVxuXHRcdFx0YWRkTGluZWJyZWFrcygxKVxuXHRcdFx0cmV0dXJuIDBcblxuXHRcdCMgZGVjaWRlIHRoZSBnZW5lcmFsIGxpbmUtcHJlZml4IGJ5IHRoZSB2ZXJ5IGZpcnN0IGxpbmUgd2l0aCBjaGFyYWN0ZXJzXG5cblx0XHQjIGlmIGd1dHRlciBpcyB1bmRlZmluZWQgLSB3ZSBjcmVhdGUgaXQgb24gdGhlIHZlcnkgZmlyc3QgY2hhbmNlIHdlIGhhdmVcblx0XHRpZiBAc3RhdGU6Z3V0dGVyID09IHVuZGVmaW5lZFxuXHRcdFx0QHN0YXRlOmd1dHRlciA9IHdoaXRlc3BhY2VcblxuXHRcdCMgaWYgd2UgaGF2ZSBhIGd1dHRlciAtLSByZW1vdmUgaXRcblx0XHRpZiB2YXIgZ3V0dGVyID0gQHN0YXRlOmd1dHRlciBvciBAb3B0czpndXR0ZXJcblx0XHRcdGlmIHdoaXRlc3BhY2UuaW5kZXhPZihndXR0ZXIpID09IDBcblx0XHRcdFx0d2hpdGVzcGFjZSA9IHdoaXRlc3BhY2Uuc2xpY2UoZ3V0dGVyOmxlbmd0aClcblxuXHRcdFx0ZWxpZiBAY2h1bmtbaW5kZW50Omxlbmd0aF0gPT09IHVuZGVmaW5lZFxuXHRcdFx0XHQjIGlmIHRoaXMgaXMgdGhlIGVuZCBvZiBjb2RlIHdlJ3JlIG9rYXlcblx0XHRcdFx0eWVzXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHdhcm4oJ2luY29ycmVjdCBpbmRlbnRhdGlvbicpXG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJHVVRURVIgSVMgSU5DT1JSRUNUISFcIixKU09OLnN0cmluZ2lmeShpbmRlbnQpLEpTT04uc3RyaW5naWZ5KEBjaHVua1tpbmRlbnQ6bGVuZ3RoXSksQGxhc3QgIyBAY2h1bmtbaW5kZW50Omxlbmd0aCAtIDFdXG5cblx0XHRcdCMgc2hvdWxkIHRocm93IGVycm9yIG90aGVyd2lzZT9cblxuXHRcdHZhciBzaXplID0gd2hpdGVzcGFjZTpsZW5ndGhcblx0XHRcblx0XHRpZiBAb3B0czpkcm9wSW5kZW50YXRpb25cblx0XHRcdHJldHVybiBzaXplXG5cblx0XHRpZiBzaXplID4gMFxuXHRcdFx0IyBzZWVuIGluZGVudD9cblxuXHRcdFx0dW5sZXNzIEBpbmRlbnRTdHlsZVxuXHRcdFx0XHRAb3B0czppbmRlbnQgPSBAaW5kZW50U3R5bGUgPSB3aGl0ZXNwYWNlXG5cblx0XHRcdGxldCBpbmRlbnRTaXplID0gMFxuXHRcdFx0bGV0IG9mZnNldCA9IDBcblxuXHRcdFx0d2hpbGUgdHJ1ZVxuXHRcdFx0XHRsZXQgaWR4ID0gd2hpdGVzcGFjZS5pbmRleE9mKEBpbmRlbnRTdHlsZSxvZmZzZXQpXG5cdFx0XHRcdGlmIGlkeCA9PSBvZmZzZXRcblx0XHRcdFx0XHRpbmRlbnRTaXplKytcblx0XHRcdFx0XHRvZmZzZXQgKz0gQGluZGVudFN0eWxlWydsZW5ndGgnXVxuXHRcdFx0XHRlbGlmIG9mZnNldCA9PSB3aGl0ZXNwYWNlOmxlbmd0aFxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGVsaWYgQG9wdHM6c2lsZW50XG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdCMgd29ya2Fyb3VuZCB0byByZXBvcnQgY29ycmVjdCBsb2NhdGlvblxuXHRcdFx0XHRcdEBsb2MgKz0gaW5kZW50Omxlbmd0aCAtIHdoaXRlc3BhY2U6bGVuZ3RoXG5cdFx0XHRcdFx0dG9rZW4oJ0lOREVOVCcsIHdoaXRlc3BhY2Usd2hpdGVzcGFjZTpsZW5ndGgpXG5cdFx0XHRcdFx0dW5sZXNzIEBvcHRzOnNpbGVudFxuXHRcdFx0XHRcdFx0cmV0dXJuIGVycm9yKFwiaW5jb25zaXN0ZW50IHtAaW5kZW50U3R5bGV9IGluZGVudGF0aW9uXCIpXG5cblx0XHRcdHNpemUgPSBpbmRlbnRTaXplXG5cblxuXHRcdGlmIChzaXplIC0gQGluZGVidCkgPT0gQGluZGVudFxuXHRcdFx0aWYgbm9OZXdsaW5lc1xuXHRcdFx0XHRzdXBwcmVzc05ld2xpbmVzKClcblx0XHRcdGVsc2Vcblx0XHRcdFx0bmV3bGluZVRva2VuKGJyQ291bnQpXG5cdFx0XHRyZXR1cm4gaW5kZW50Omxlbmd0aFxuXG5cdFx0aWYgc2l6ZSA+IEBpbmRlbnRcblx0XHRcdGlmIG5vTmV3bGluZXNcblx0XHRcdFx0QGluZGVidCA9IHNpemUgLSBAaW5kZW50XG5cdFx0XHRcdHN1cHByZXNzTmV3bGluZXNcblx0XHRcdFx0cmV0dXJuIGluZGVudDpsZW5ndGhcblxuXHRcdFx0aWYgaW5UYWdcblx0XHRcdFx0cmV0dXJuIGluZGVudDpsZW5ndGhcblxuXHRcdFx0dmFyIGRpZmYgPSBzaXplIC0gQGluZGVudCArIEBvdXRkZWJ0XG5cdFx0XHRjbG9zZURlZigpXG5cblx0XHRcdHZhciBpbW1lZGlhdGUgPSBsYXN0KEB0b2tlbnMpXG5cblx0XHRcdGlmIGltbWVkaWF0ZSBhbmQgdFQoaW1tZWRpYXRlKSA9PSAnVEVSTUlOQVRPUidcblx0XHRcdFx0dFRzKGltbWVkaWF0ZSwnSU5ERU5UJylcblx0XHRcdFx0IyBzaG91bGQgYWRkIHRlcm1pbmF0b3IgaW5zaWRlIGluZGVudD9cblx0XHRcdFx0aW1tZWRpYXRlLkBtZXRhIHx8PSB7cHJlOiB0VihpbW1lZGlhdGUpLCBwb3N0OiAnJ31cblxuXHRcdFx0XHQjIHNob3VsZCByYXRoZXIgYWRkIHRvIG1ldGEgc29tZWhvdz8hP1xuXHRcdFx0XHQjIHRWcyhpbW1lZGlhdGUsdFYoaW1tZWRpYXRlKSArICclfCUnKSAjIGNyYXp5XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRva2VuKCdJTkRFTlQnLCBcIlwiICsgZGlmZiwwKVxuXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiaW5kZW50aW5nXCIsIHByZXYsIGxhc3QoQHRva2VucywxKVxuXHRcdFx0IyBpZiBwcmV2IGFuZCBwcmV2WzBdID09ICdURVJNSU5BVE9SJ1xuXHRcdFx0IyAgIGNvbnNvbGUubG9nIFwidGVybWluYXRvciBiZWZvcmUgaW5kZW50Pz9cIlxuXG5cdFx0XHQjIGNoZWNrIGZvciBjb21tZW50cyBhcyB3ZWxsID9cblxuXHRcdFx0QGluZGVudHMucHVzaCBkaWZmXG5cdFx0XHRwdXNoRW5kKCdPVVRERU5UJylcblx0XHRcdEBvdXRkZWJ0ID0gQGluZGVidCA9IDBcblx0XHRcdGFkZExpbmVicmVha3MoYnJDb3VudClcblx0XHRlbHNlXG5cdFx0XHRAaW5kZWJ0ID0gMFxuXHRcdFx0b3V0ZGVudFRva2VuKEBpbmRlbnQgLSBzaXplLCBub05ld2xpbmVzLCBickNvdW50KVxuXHRcdFx0YWRkTGluZWJyZWFrcyhickNvdW50IC0gMSlcblx0XHRcdCMgY29uc29sZS5sb2cgXCJvdXRkZW50XCIsbm9OZXdsaW5lcyx0b2tpZCgpXG5cblx0XHRAaW5kZW50ID0gc2l6ZVxuXHRcdHJldHVybiBpbmRlbnQ6bGVuZ3RoXG5cblx0IyBSZWNvcmQgYW4gb3V0ZGVudCB0b2tlbiBvciBtdWx0aXBsZSB0b2tlbnMsIGlmIHdlIGhhcHBlbiB0byBiZSBtb3ZpbmcgYmFja1xuXHQjIGlud2FyZHMgcGFzdCBzZXZlcmFsIHJlY29yZGVkIGluZGVudHMuXG5cdGRlZiBvdXRkZW50VG9rZW4gbW92ZU91dCwgbm9OZXdsaW5lcywgbmV3bGluZUNvdW50XG5cdFx0IyBoZXJlIHdlIHNob3VsZCBhbHNvIHRha2UgY2FyZSB0byBwb3AgLyByZXNldCB0aGUgc2NvcGUtYm9keVxuXHRcdCMgb3IgY29udGV4dC10eXBlIGZvciBpbmRlbnRhdGlvbiBcblx0XHR2YXIgZGVudCA9IDBcblx0XHR3aGlsZSBtb3ZlT3V0ID4gMFxuXHRcdFx0dmFyIGxlbiA9IEBpbmRlbnRzOmxlbmd0aCAtIDFcblx0XHRcdGlmIEBpbmRlbnRzW2xlbl0gaXMgdW5kZWZpbmVkXG5cdFx0XHRcdG1vdmVPdXQgPSAwXG5cdFx0XHRlbGlmIEBpbmRlbnRzW2xlbl0gaXMgQG91dGRlYnRcblx0XHRcdFx0bW92ZU91dCAtPSBAb3V0ZGVidFxuXHRcdFx0XHRAb3V0ZGVidCA9IDBcblx0XHRcdGVsaWYgQGluZGVudHNbbGVuXSA8IEBvdXRkZWJ0XG5cdFx0XHRcdEBvdXRkZWJ0IC09IEBpbmRlbnRzW2xlbl1cblx0XHRcdFx0bW92ZU91dCAgLT0gQGluZGVudHNbbGVuXVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRkZW50ID0gQGluZGVudHMucG9wIC0gQG91dGRlYnRcblx0XHRcdFx0bW92ZU91dCAtPSBkZW50XG5cdFx0XHRcdEBvdXRkZWJ0ID0gMFxuXG5cdFx0XHRcdGFkZExpbmVicmVha3MoMSkgdW5sZXNzIG5vTmV3bGluZXNcblxuXHRcdFx0XHRwYWlyICdPVVRERU5UJ1xuXHRcdFx0XHR0b2tlbignT1VUREVOVCcsIFwiXCIgKyBkZW50LCAwKVxuXG5cdFx0QG91dGRlYnQgLT0gbW92ZU91dCBpZiBkZW50XG5cblx0XHRAdG9rZW5zLnBvcCB3aGlsZSBsYXN0VG9rZW5WYWx1ZSA9PSAnOydcblxuXHRcdHRva2VuKCdURVJNSU5BVE9SJywnXFxuJywwKSB1bmxlc3MgbGFzdFRva2VuVHlwZSA9PSAnVEVSTUlOQVRPUicgb3Igbm9OZXdsaW5lc1xuXHRcdCMgY2FwcGluZyBzY29wZXMgc28gdGhleSBkb250IGhhbmcgYXJvdW5kIFxuXHRcdEBzY29wZXM6bGVuZ3RoID0gQGluZGVudHM6bGVuZ3RoXG5cblx0XHR2YXIgY3R4ID0gY29udGV4dFxuXHRcdHBhaXIoY3R4KSBpZiBjdHggPT0gJyUnIG9yIGN0eCA9PSAnVEFHJyAjIHJlYWxseT9cblx0XHRjbG9zZURlZlxuXHRcdHJldHVybiB0aGlzXG5cblx0IyBNYXRjaGVzIGFuZCBjb25zdW1lcyBub24tbWVhbmluZ2Z1bCB3aGl0ZXNwYWNlLiB0b2tpZCB0aGUgcHJldmlvdXMgdG9rZW5cblx0IyBhcyBiZWluZyBcInNwYWNlZFwiLCBiZWNhdXNlIHRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZXJlIGl0IG1ha2VzIGEgZGlmZmVyZW5jZS5cblx0ZGVmIHdoaXRlc3BhY2VUb2tlblxuXHRcdHZhciBtYXRjaCwgbmxpbmUsIHByZXZcblx0XHRyZXR1cm4gMCB1bmxlc3MgKG1hdGNoID0gV0hJVEVTUEFDRS5leGVjKEBjaHVuaykpIHx8IChubGluZSA9IEBjaHVuay5jaGFyQXQoMCkgaXMgJ1xcbicpXG5cdFx0cHJldiA9IGxhc3QgQHRva2Vuc1xuXG5cdFx0IyBGSVggLSB3aHkgb2ggd2h5P1xuXHRcdGlmIHByZXZcblx0XHRcdGlmIG1hdGNoXG5cdFx0XHRcdHByZXY6c3BhY2VkID0geWVzXG5cdFx0XHRcdCMgcHJldi5AcyA9IG1hdGNoWzBdXG5cdFx0XHRcdHJldHVybiBtYXRjaFswXTpsZW5ndGhcblx0XHRcdGVsc2Vcblx0XHRcdFx0cHJldjpuZXdMaW5lID0geWVzXG5cdFx0XHRcdHJldHVybiAwXG5cblx0ZGVmIGFkZE5ld2xpbmVcblx0XHR0b2tlbiAnVEVSTUlOQVRPUicsICdcXG4nXG5cblx0ZGVmIG1vdmVIZWFkIHN0clxuXHRcdHZhciBiciA9IGNvdW50KHN0ciwnXFxuJylcblx0XHRyZXR1cm4gYnJcblx0XHRcblxuXHRkZWYgYWRkTGluZWJyZWFrcyBjb3VudCwgcmF3XG5cdFx0dmFyIGJyXG5cblx0XHRyZXR1cm4gdGhpcyBpZiAhcmF3IGFuZCBjb3VudCA9PSAwICMgbm8gdGVybWluYXRvcnM/XG5cblx0XHR2YXIgcHJldiA9IEBsYXN0XG5cblx0XHRpZiAhcmF3XG5cdFx0XHRpZiBjb3VudCA9PSAxXG5cdFx0XHRcdGJyID0gJ1xcbidcblx0XHRcdGVsaWYgY291bnQgPT0gMlxuXHRcdFx0XHRiciA9ICdcXG5cXG4nXG5cdFx0XHRlbGlmIGNvdW50ID09IDNcblx0XHRcdFx0YnIgPSAnXFxuXFxuXFxuJ1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRiciA9IHJlcGVhdFN0cmluZygnXFxuJyxjb3VudClcblx0XHQjIEZJWFxuXHRcdGlmIHByZXZcblx0XHRcdHZhciB0ID0gcHJldi5AdHlwZSAjIEBsYXN0VHlwXG5cdFx0XHR2YXIgdiA9IHRWKHByZXYpXG5cblx0XHRcdCMgd2UgcmVhbGx5IHdhbnQgdG8gYWRkIHRoaXNcblx0XHRcdGlmIHQgPT0gJ0lOREVOVCdcblx0XHRcdFx0IyBUT0RPIHdlIHdhbnQgdG8gYWRkIHRvIHRoZSBpbmRlbnRcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcImFkZCB0aGUgY29tbWVudCB0byB0aGUgaW5kZW50IC0tIHByZT8ge3Jhd30ge2JyfVwiXG5cdFx0XHRcblx0XHRcdFx0dmFyIG1ldGEgPSBwcmV2LkBtZXRhIHx8PSB7cHJlOiAnJywgcG9zdDogJyd9XG5cdFx0XHRcdG1ldGE6cG9zdCArPSAocmF3IG9yIGJyKVxuXHRcdFx0XHQjIHRWcyh2ICsgKHJhdyBvciBicikpXG5cdFx0XHRcdHJldHVybiB0aGlzXG5cblx0XHRcdGVsaWYgdCA9PSAnVEVSTUlOQVRPUidcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcImFscmVhZHkgZXhpc3RzIHRlcm1pbmF0b3Ige2JyfSB7cmF3fVwiXG5cdFx0XHRcdHRWcyhwcmV2LHYgKyAocmF3IG9yIGJyKSlcblx0XHRcdFx0cmV0dXJuIHRoaXNcblx0XHRcblx0XHR0b2tlbignVEVSTUlOQVRPUicsIGJyLCAwKVxuXHRcdHJldHVyblxuXG5cdCMgR2VuZXJhdGUgYSBuZXdsaW5lIHRva2VuLiBDb25zZWN1dGl2ZSBuZXdsaW5lcyBnZXQgbWVyZ2VkIHRvZ2V0aGVyLlxuXHRkZWYgbmV3bGluZVRva2VuIGxpbmVzXG5cdFx0XG5cdFx0IyB3aGlsZSBsYXN0VG9rZW5WYWx1ZSA9PSAnOydcblx0XHQjXHRAdG9rZW5zLnBvcFxuXG5cdFx0YWRkTGluZWJyZWFrcyhsaW5lcylcblxuXHRcdHZhciBjdHggPSBjb250ZXh0XG5cdFx0IyBXQVJOIG5vdyBpbXBvcnQgY2Fubm90IGdvIG92ZXIgbXVsdGlwbGUgbGluZXNcblx0XHRwYWlyKGN0eCkgaWYgY3R4ID09ICdUQUcnIG9yIGN0eCA9PSAnSU1QT1JUJ1xuXHRcdGNsb3NlRGVmKCkgICMgY2xvc2UgZGVmIC0tIHJlYWxseT9cblx0XHR0aGlzXG5cblx0IyBVc2UgYSBgXFxgIGF0IGEgbGluZS1lbmRpbmcgdG8gc3VwcHJlc3MgdGhlIG5ld2xpbmUuXG5cdCMgVGhlIHNsYXNoIGlzIHJlbW92ZWQgaGVyZSBvbmNlIGl0cyBqb2IgaXMgZG9uZS5cblx0ZGVmIHN1cHByZXNzTmV3bGluZXNcblx0XHRAdG9rZW5zLnBvcCBpZiB2YWx1ZSgpIGlzICdcXFxcJ1xuXHRcdHRoaXNcblxuXHQjIFdlIHRyZWF0IGFsbCBvdGhlciBzaW5nbGUgY2hhcmFjdGVycyBhcyBhIHRva2VuLiBFLmcuOiBgKCApICwgLiAhYFxuXHQjIE11bHRpLWNoYXJhY3RlciBvcGVyYXRvcnMgYXJlIGFsc28gbGl0ZXJhbCB0b2tlbnMsIHNvIHRoYXQgSmlzb24gY2FuIGFzc2lnblxuXHQjIHRoZSBwcm9wZXIgb3JkZXIgb2Ygb3BlcmF0aW9ucy4gVGhlcmUgYXJlIHNvbWUgc3ltYm9scyB0aGF0IHdlIHRva2lkIHNwZWNpYWxseVxuXHQjIGhlcmUuIGA7YCBhbmQgbmV3bGluZXMgYXJlIGJvdGggdHJlYXRlZCBhcyBhIGBURVJNSU5BVE9SYCwgd2UgZGlzdGluZ3Vpc2hcblx0IyBwYXJlbnRoZXNlcyB0aGF0IGluZGljYXRlIGEgbWV0aG9kIGNhbGwgZnJvbSByZWd1bGFyIHBhcmVudGhlc2VzLCBhbmQgc28gb24uXG5cdGRlZiBsaXRlcmFsVG9rZW5cblx0XHR2YXIgbWF0Y2gsIHZhbHVlXG5cdFx0aWYgbWF0Y2ggPSBPUEVSQVRPUi5leGVjKEBjaHVuaylcblx0XHRcdHZhbHVlID0gbWF0Y2hbMF1cblx0XHRcdHRhZ1BhcmFtZXRlcnMgaWYgQ09ERS50ZXN0KHZhbHVlKVxuXHRcdGVsc2Vcblx0XHRcdHZhbHVlID0gQGNodW5rLmNoYXJBdCgwKVxuXHRcdFxuXHRcdHZhciBlbmQxID0gQGVuZHNbQGVuZHM6bGVuZ3RoIC0gMV1cblx0XHR2YXIgZW5kMiA9IEBlbmRzW0BlbmRzOmxlbmd0aCAtIDJdXG5cblx0XHR2YXIgaW5UYWcgPSBlbmQxID09ICdUQUdfRU5EJyBvciBlbmQxICA9PSAnT1VUREVOVCcgYW5kIGVuZDIgPT0gJ1RBR19FTkQnXG5cblx0XHR2YXIgdG9raWQgPSB2YWx1ZVxuXHRcdHZhciBwcmV2ICA9IGxhc3QgQHRva2Vuc1xuXHRcdHZhciBwdCA9IHByZXYgYW5kIHRUKHByZXYpXG5cdFx0dmFyIHB2ID0gcHJldiBhbmQgdFYocHJldilcblx0XHR2YXIgbGVuZ3RoID0gdmFsdWU6bGVuZ3RoXG5cblx0XHQjIGlzIHRoaXMgbmVlZGVkP1xuXHRcdGlmIHZhbHVlID09ICc9JyBhbmQgcHJldlxuXG5cdFx0XHRpZiBwdiA9PSAnfHwnIG9yIHB2ID09ICcmJicgIyBpbiBbJ3x8JywgJyYmJ11cblx0XHRcdFx0dFRzKHByZXYsJ0NPTVBPVU5EX0FTU0lHTicpXG5cdFx0XHRcdHRWcyhwcmV2LHB2ICsgJz0nKSAjIG5lZWQgdG8gY2hhbmdlIHRoZSBsZW5ndGggYXMgd2VsbFxuXHRcdFx0XHRwcmV2LkBsZW4gPSBAbG9jIC0gcHJldi5AbG9jICsgdmFsdWU6bGVuZ3RoXG5cdFx0XHRcdHJldHVybiB2YWx1ZTpsZW5ndGhcblxuXHRcdGlmIHZhbHVlIGlzICc7JyAgICAgICAgICAgICBcblx0XHRcdEBzZWVuRm9yID0gbm9cblx0XHRcdHRva2lkID0gJ1RFUk1JTkFUT1InXG5cblx0XHRlbGlmIHZhbHVlIGlzICcoJyBhbmQgaW5UYWcgYW5kIHB0ICE9ICc9JyBhbmQgcHJldjpzcGFjZWQgIyBGSVhlZFxuXHRcdFx0IyBjb25zb2xlLmxvZyAnc3BhY2VkIGJlZm9yZSAoIGluIHRva2lkJ1xuXHRcdFx0IyBGSVhNRSAtIHNob3VsZCByYXRoZXIgYWRkIGEgc3BlY2lhbCB0b2tlbiBsaWtlIFRBR19QQVJBTVNfU1RBUlRcblx0XHRcdHRva2VuICcsJywnLCdcblxuXHRcdGVsaWYgdmFsdWUgaXMgJy0+JyBhbmQgaW5UYWdcblx0XHRcdHRva2lkID0gJ1RBR19FTkQnXG5cdFx0XHRwYWlyICdUQUdfRU5EJ1xuXG5cdFx0ZWxpZiB2YWx1ZSBpcyAnPT4nIGFuZCBpblRhZ1xuXHRcdFx0dG9raWQgPSAnVEFHX0VORCdcblx0XHRcdHBhaXIgJ1RBR19FTkQnXG5cblx0XHRlbGlmIHZhbHVlIGlzICcvPicgYW5kIGluVGFnXG5cdFx0XHR0b2tpZCA9ICdUQUdfRU5EJ1xuXHRcdFx0cGFpciAnVEFHX0VORCdcblxuXHRcdGVsaWYgdmFsdWUgaXMgJz4nIGFuZCBpblRhZ1xuXHRcdFx0dG9raWQgPSAnVEFHX0VORCdcblx0XHRcdHBhaXIgJ1RBR19FTkQnXG5cblx0XHQjIHRoaXMgaXMgYSB0b2tpZC1tZXRob2Rcblx0XHRlbGlmIHZhbHVlIGlzICc+JyBhbmQgY29udGV4dCA9PSAnREVGJ1xuXHRcdFx0IyBjb25zb2xlLmxvZygncGlja2VkIHVwID4hIScpXG5cdFx0XHR0b2tpZCA9ICdERUZfRlJBR01FTlQnXG5cdFxuXHRcdFx0IyBlbGlmIHZhbHVlIGlzICdURVJNSU5BVE9SJyBhbmQgZW5kMSBpcyAnJScgXG5cdFx0XHQjIFx0Y2xvc2VTZWxlY3RvcigpXG5cblx0XHRlbGlmIHZhbHVlIGlzICdURVJNSU5BVE9SJyBhbmQgZW5kMSBpcyAnREVGJ1xuXHRcdFx0Y2xvc2VEZWYoKVxuXG5cdFx0IyBUT0RPIEJMT0NLIFBBUkFNIEJVR1xuXHRcdCMgcmVhbGx5K1xuXHRcdGVsaWYgdmFsdWUgaXMgJyYnIGFuZCBjb250ZXh0ID09ICdERUYnXG5cdFx0XHQjIGNvbnNvbGUubG9nKFwib2theSFcIilcblx0XHRcdHRva2lkID0gJ0JMT0NLX0FSRydcblx0XHRcdCMgY2hhbmdlIHRoZSBuZXh0IGlkZW50aWZpZXIgaW5zdGVhZD9cblxuXHRcdCMgZWxpZiB2YWx1ZS5tYXRjaCgpXG5cdFx0ZWxpZiB2YWx1ZSA9PSAnKicgYW5kIEBjaHVuay5jaGFyQXQoMSkubWF0Y2goL1tBLVphLXpcXF9cXEBcXFtdLykgYW5kIChwcmV2OnNwYWNlZCBvciBbJywnLCcoJywnWycsJ3snLCd8JywnXFxuJywnXFx0J10uaW5kZXhPZihwdikgPj0gMClcblx0XHRcdHRva2lkID0gXCJTUExBVFwiXG5cblx0XHRlbGlmIHZhbHVlID09ICfiiJonXG5cdFx0XHR0b2tpZCA9ICdTUVJUJ1xuXHRcdGVsaWYgdmFsdWUgPT0gJ8aSJ1xuXHRcdFx0dG9raWQgPSAnRE8nXG5cdFx0ZWxpZiB2YWx1ZSBpbiBNQVRIXG5cdFx0XHR0b2tpZCA9ICdNQVRIJ1xuXHRcdGVsaWYgdmFsdWUgaW4gQ09NUEFSRVxuXHRcdFx0dG9raWQgPSAnQ09NUEFSRSdcblx0XHRlbGlmIHZhbHVlIGluIENPTVBPVU5EX0FTU0lHTlxuXHRcdFx0dG9raWQgPSAnQ09NUE9VTkRfQVNTSUdOJ1xuXHRcdGVsaWYgdmFsdWUgaW4gVU5BUllcblx0XHRcdHRva2lkID0gJ1VOQVJZJ1xuXHRcdGVsaWYgdmFsdWUgaW4gU0hJRlRcblx0XHRcdHRva2lkID0gJ1NISUZUJ1xuXHRcdGVsaWYgdmFsdWUgaW4gTE9HSUNcblx0XHRcdHRva2lkID0gJ0xPR0lDJyAjIG9yIHZhbHVlIGlzICc/JyBhbmQgcHJldj86c3BhY2VkIFxuXG5cdFx0ZWxpZiBwcmV2IGFuZCAhcHJldjpzcGFjZWRcblx0XHRcdGlmIHZhbHVlIGlzICcoJyBhbmQgcHQgaW4gQ0FMTEFCTEVcblx0XHRcdFx0IyBub3QgdXNpbmcgdGhpcyA/Pz9cblx0XHRcdFx0IyBwcmV2WzBdID0gJ0ZVTkNfRVhJU1QnIGlmIHByZXZbMF0gaXMgJz8nXG5cdFx0XHRcdHRva2lkID0gJ0NBTExfU1RBUlQnXG5cblx0XHRcdGVsaWYgdmFsdWUgaXMgJ1snIGFuZCBwdCBpbiBJTkRFWEFCTEVcblx0XHRcdFx0dG9raWQgPSAnSU5ERVhfU1RBUlQnXG5cdFx0XHRcdHRUcyhwcmV2LCdJTkRFWF9TT0FLJykgaWYgcHQgPT0gJz8nXG5cdFx0XHRcdCMgcHJldlswXSA9ICdJTkRFWF9TT0FLJyBpZiBwcmV2WzBdID09ICc/J1xuXG5cdFx0c3dpdGNoIHZhbHVlXG5cdFx0XHR3aGVuICcoJywgJ3snLCAnWycgdGhlbiBwdXNoRW5kKElOVkVSU0VTW3ZhbHVlXSlcblx0XHRcdHdoZW4gJyknLCAnfScsICddJyB0aGVuIHBhaXIgdmFsdWVcblxuXHRcdCMgaGFja3kgcnVsZSB0byB0cnkgdG8gYWxsb3cgZm9yIHR1cGxlLWFzc2lnbm1lbnRzIGluIGJsb2Nrc1xuXHRcdCMgaWYgdmFsdWUgaXMgJywnIGFuZCBwcmV2WzBdIGlzICdJREVOVElGSUVSJyBhbmQgQHRva2Vuc1tAdG9rZW5zOmxlbmd0aCAtIDJdWzBdIGluIFsnVEVSTUlOQVRPUicsJ0lOREVOVCddXG5cdFx0IyAgICMgdG9rZW4gXCJUVVBMRVwiLCBcInR1cGxlXCIgIyBzaG91bGQgcmF0aGVyIGluc2VydCBpdCBzb21ld2hlcmUgZWxzZSwgbm8/XG5cdFx0IyAgIGNvbnNvbGUubG9nKFwiZm91bmQgY29tbWFcIilcblxuXHRcdHRva2VuKHRva2lkLCB2YWx1ZSwgdmFsdWU6bGVuZ3RoKVxuXHRcdHJldHVybiB2YWx1ZTpsZW5ndGhcblxuXHQjIFRva2VuIE1hbmlwdWxhdG9yc1xuXHQjIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdCMgU2FuaXRpemUgYSBoZXJlZG9jIG9yIGhlcmVjb21tZW50IGJ5XG5cdCMgZXJhc2luZyBhbGwgZXh0ZXJuYWwgaW5kZW50YXRpb24gb24gdGhlIGxlZnQtaGFuZCBzaWRlLlxuXHRkZWYgc2FuaXRpemVIZXJlZG9jIGRvYywgb3B0aW9uc1xuXHRcdHZhciBtYXRjaFxuXHRcdHZhciBpbmRlbnQgPSBvcHRpb25zOmluZGVudFxuXHRcdHZhciBoZXJlY29tbWVudCA9IG9wdGlvbnM6aGVyZWNvbW1lbnRcblxuXHRcdGlmIGhlcmVjb21tZW50XG5cdFx0XHRpZiBIRVJFRE9DX0lMTEVHQUwudGVzdChkb2MpXG5cdFx0XHRcdGVycm9yIFwiYmxvY2sgY29tbWVudCBjYW5ub3QgY29udGFpbiAnKi8nIHN0YXJ0aW5nXCJcblx0XHRcdHJldHVybiBkb2MgaWYgZG9jLmluZGV4T2YoJ1xcbicpIDw9IDBcblx0XHRlbHNlXG5cdFx0XHR3aGlsZSBtYXRjaCA9IEhFUkVET0NfSU5ERU5ULmV4ZWMoZG9jKVxuXHRcdFx0XHR2YXIgYXR0ZW1wdCA9IG1hdGNoWzFdXG5cdFx0XHRcdGlmIGluZGVudCBpcyBudWxsIG9yIDAgPCBhdHRlbXB0Omxlbmd0aCA8IGluZGVudDpsZW5ndGhcblx0XHRcdFx0XHRpbmRlbnQgPSBhdHRlbXB0XG5cblx0XHRkb2MgPSBkb2MucmVwbGFjZSBSZWdFeHAoXCJcXFxcbntpbmRlbnR9XCIsXCJnXCIpLCAnXFxuJyBpZiBpbmRlbnRcblx0XHR1bmxlc3MgaGVyZWNvbW1lbnRcblx0XHRcdGlmIGRvY1swXSA9PSAnXFxuJ1xuXHRcdFx0XHRvcHRpb25zOm9mZnNldCA9IGluZGVudDpsZW5ndGggKyAxXG5cdFx0XHRkb2MgPSBkb2MucmVwbGFjZSgvXlxcbi8sICcnKVxuXHRcdG9wdGlvbnM6cmVhbEluZGVudCA9IGluZGVudFxuXHRcdHJldHVybiBkb2NcblxuXHQjIEEgc291cmNlIG9mIGFtYmlndWl0eSBpbiBvdXIgZ3JhbW1hciB1c2VkIHRvIGJlIHBhcmFtZXRlciBsaXN0cyBpbiBmdW5jdGlvblxuXHQjIGRlZmluaXRpb25zIHZlcnN1cyBhcmd1bWVudCBsaXN0cyBpbiBmdW5jdGlvbiBjYWxscy4gV2FsayBiYWNrd2FyZHMsIHRva2lkZ2luZ1xuXHQjIHBhcmFtZXRlcnMgc3BlY2lhbGx5IGluIG9yZGVyIHRvIG1ha2UgdGhpbmdzIGVhc2llciBmb3IgdGhlIHBhcnNlci5cblx0ZGVmIHRhZ1BhcmFtZXRlcnNcblx0XHRyZXR1cm4gdGhpcyBpZiBsYXN0VG9rZW5UeXBlICE9ICcpJ1xuXHRcdHZhciBzdGFjayA9IFtdXG5cdFx0dmFyIHRva2VucyA9IEB0b2tlbnNcblx0XHR2YXIgaSA9IHRva2VuczpsZW5ndGhcblxuXHRcdHRUcyh0b2tlbnNbLS1pXSwgJ1BBUkFNX0VORCcpXG5cblx0XHR3aGlsZSB2YXIgdG9rID0gdG9rZW5zWy0taV1cblx0XHRcdHZhciB0ID0gdFQodG9rKVxuXHRcdFx0c3dpdGNoIHRcblx0XHRcdFx0d2hlbiAnKSdcblx0XHRcdFx0XHRzdGFjay5wdXNoIHRva1xuXHRcdFx0XHR3aGVuICcoJywgJ0NBTExfU1RBUlQnXG5cdFx0XHRcdFx0aWYgc3RhY2s6bGVuZ3RoXG5cdFx0XHRcdFx0XHRzdGFjay5wb3Bcblx0XHRcdFx0XHRlbGlmIHQgaXMgJygnXG5cdFx0XHRcdFx0XHR0VHModG9rLCdQQVJBTV9TVEFSVCcpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpc1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzXG5cblx0XHRyZXR1cm4gdGhpc1xuXG5cdCMgQ2xvc2UgdXAgYWxsIHJlbWFpbmluZyBvcGVuIGJsb2NrcyBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlLlxuXHRkZWYgY2xvc2VJbmRlbnRhdGlvblxuXHRcdHBhaXIoY29udGV4dCkgaWYgY29udGV4dCA9PSAnSU1QT1JUJ1xuXHRcdGNsb3NlRGVmXG5cdFx0Y2xvc2VTZWxlY3RvclxuXHRcdG91dGRlbnRUb2tlbihAaW5kZW50LG5vLDApXG5cblx0IyBNYXRjaGVzIGEgYmFsYW5jZWQgZ3JvdXAgc3VjaCBhcyBhIHNpbmdsZSBvciBkb3VibGUtcXVvdGVkIHN0cmluZy4gUGFzcyBpblxuXHQjIGEgc2VyaWVzIG9mIGRlbGltaXRlcnMsIGFsbCBvZiB3aGljaCBtdXN0IGJlIG5lc3RlZCBjb3JyZWN0bHkgd2l0aGluIHRoZVxuXHQjIGNvbnRlbnRzIG9mIHRoZSBzdHJpbmcuIFRoaXMgbWV0aG9kIGFsbG93cyB1cyB0byBoYXZlIHN0cmluZ3Mgd2l0aGluXG5cdCMgaW50ZXJwb2xhdGlvbnMgd2l0aGluIHN0cmluZ3MsIGFkIGluZmluaXR1bS5cblx0ZGVmIGJhbGFuY2VkU3RyaW5nIHN0ciwgZW5kXG5cdFx0dmFyIG1hdGNoLCBsZXR0ZXIsIHByZXZcblxuXHRcdHZhciBzdGFjayA9IFtlbmRdXG5cdFx0dmFyIGkgPSAwXG5cblx0XHQjIGNvdWxkIGl0IG5vdCBoYXBwZW4gaGVyZT9cblx0XHR3aGlsZSBpIDwgKHN0cjpsZW5ndGggLSAxKVxuXHRcdFx0aSsrXG5cdFx0XHR2YXIgbGV0dGVyID0gc3RyLmNoYXJBdChpKVxuXHRcdFx0c3dpdGNoIGxldHRlclxuXHRcdFx0XHR3aGVuICdcXFxcJ1xuXHRcdFx0XHRcdGkrK1xuXHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdHdoZW4gZW5kXG5cdFx0XHRcdFx0c3RhY2sucG9wXG5cdFx0XHRcdFx0dW5sZXNzIHN0YWNrOmxlbmd0aFxuXHRcdFx0XHRcdFx0dmFyIHYgPSBzdHIuc2xpY2UoMCwgaSArIDEpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdlxuXHRcdFx0XHRcdGVuZCA9IHN0YWNrW3N0YWNrOmxlbmd0aCAtIDFdXG5cdFx0XHRcdFx0Y29udGludWVcblxuXHRcdFx0aWYgZW5kIGlzICd9JyBhbmQgKGxldHRlciA9PSAnXCInIG9yIGxldHRlciA9PSBcIidcIilcblx0XHRcdFx0c3RhY2sucHVzaChlbmQgPSBsZXR0ZXIpXG5cblx0XHRcdGVsaWYgZW5kIGlzICd9JyBhbmQgbGV0dGVyIGlzICcvJyBhbmQgbWF0Y2ggPSAoSEVSRUdFWC5leGVjKHN0ci5zbGljZSBpKSBvciBSRUdFWC5leGVjKHN0ci5zbGljZSBpKSlcblx0XHRcdFx0aSArPSBtYXRjaFswXTpsZW5ndGggLSAxXG5cblx0XHRcdGVsaWYgZW5kIGlzICd9JyBhbmQgbGV0dGVyIGlzICd7J1xuXHRcdFx0XHRzdGFjay5wdXNoIGVuZCA9ICd9J1xuXHRcdFx0ZWxpZiBlbmQgaXMgJ1wiJyBhbmQgbGV0dGVyIGlzICd7J1xuXHRcdFx0XHRzdGFjay5wdXNoIGVuZCA9ICd9J1xuXHRcdFx0cHJldiA9IGxldHRlclxuXG5cdFx0ZXJyb3IgXCJtaXNzaW5nIHsgc3RhY2sucG9wIH0sIHN0YXJ0aW5nXCIgdW5sZXNzIEBvcHRzOnNpbGVudFxuXG5cdCMgRXhwYW5kIHZhcmlhYmxlcyBhbmQgZXhwcmVzc2lvbnMgaW5zaWRlIGRvdWJsZS1xdW90ZWQgc3RyaW5ncyB1c2luZ1xuXHQjIGJyYWNlcyBmb3Igc3Vic3RpdHV0aW9uIG9mIGFyYml0cmFyeSBleHByZXNzaW9ucy5cblx0I1xuXHQjICAgICBcIkhlbGxvIHtuYW1lLmNhcGl0YWxpemV9LlwiXG5cdCNcblx0IyBJZiBpdCBlbmNvdW50ZXJzIGFuIGludGVycG9sYXRpb24sIHRoaXMgbWV0aG9kIHdpbGwgcmVjdXJzaXZlbHkgY3JlYXRlIGFcblx0IyBuZXcgTGV4ZXIsIHRva2VuaXplIHRoZSBpbnRlcnBvbGF0ZWQgY29udGVudHMsIGFuZCBtZXJnZSB0aGVtIGludG8gdGhlXG5cdCMgdG9rZW4gc3RyZWFtLlxuXHRkZWYgaW50ZXJwb2xhdGVTdHJpbmcgc3RyLCBvcHRpb25zID0ge31cblxuXHRcdHZhciBoZXJlZG9jID0gb3B0aW9uczpoZXJlZG9jXG5cdFx0dmFyIHF1b3RlID0gb3B0aW9uczpxdW90ZVxuXHRcdHZhciByZWdleCA9IG9wdGlvbnM6cmVnZXhcblx0XHR2YXIgcHJlZml4ID0gb3B0aW9uczpwcmVmaXhcblx0XHR2YXIgaW5kZW50ID0gb3B0aW9uczppbmRlbnRcblxuXHRcdHZhciBzdGFydExvYyA9IEBsb2Ncblx0XHR2YXIgdG9rZW5zID0gW11cblx0XHR2YXIgcGkgPSAwXG5cdFx0dmFyIGkgID0gLTFcblx0XHR2YXIgbG9jT2Zmc2V0ID0gb3B0aW9uczpvZmZzZXQgb3IgMVxuXHRcdHZhciBzdHJsZW4gPSBzdHI6bGVuZ3RoXG5cdFx0dmFyIGxldHRlclxuXHRcdHZhciBleHByXG5cblx0XHR2YXIgaXNJbnRlcnBvbGF0ZWQgPSBub1xuXHRcdCMgb3V0IG9mIGJvdW5kc1xuXG5cdFx0d2hpbGUgbGV0dGVyID0gc3RyW2kgKz0gMV1cblx0XHRcdGlmIGxldHRlciBpcyAnXFxcXCdcblx0XHRcdFx0aSArPSAxXG5cdFx0XHRcdGNvbnRpbnVlXG5cblx0XHRcdGlmIGxldHRlciBpcyAnXFxuJyBhbmQgaW5kZW50XG5cdFx0XHRcdGxvY09mZnNldCArPSBpbmRlbnQ6bGVuZ3RoXG5cblx0XHRcdHVubGVzcyBzdHJbaV0gPT0gJ3snIGFuZCAoZXhwciA9IGJhbGFuY2VkU3RyaW5nKHN0ci5zbGljZShpKSwgJ30nKSlcblx0XHRcdFx0Y29udGludWVcblxuXHRcdFx0aXNJbnRlcnBvbGF0ZWQgPSB5ZXNcblxuXHRcdFx0IyB0aGVzZSBoYXZlIG5vIHJlYWwgc2Vuc2Ugb2YgbG9jYXRpb24gb3IgYW55dGhpbmc/XG5cdFx0XHRpZiBwaSA8IGlcblx0XHRcdFx0IyB0aGlzIGlzIHRoZSBwcmVmaXgtc3RyaW5nIC0gYmVmb3JlIGFueSBpdGVtXG5cdFx0XHRcdHZhciB0b2sgPSBUb2tlbi5uZXcoJ05FT1NUUklORycsIGVzY2FwZVN0cihzdHIuc2xpY2UocGksIGkpLGhlcmVkb2MscXVvdGUpLEBsb2MgKyBwaSArIGxvY09mZnNldCxpIC0gcGkpXG5cdFx0XHRcdCMgdG9rLkBsb2MgPSBAbG9jICsgcGlcblx0XHRcdFx0IyB0b2suQGxlbiA9IGkgLSBwaSArIDJcblx0XHRcdFx0dG9rZW5zLnB1c2godG9rKVxuXG5cdFx0XHR0b2tlbnMucHVzaCBUb2tlbi5uZXcoJ3t7JywneycsQGxvYyArIGkgKyBsb2NPZmZzZXQsMSlcblxuXHRcdFx0dmFyIGlubmVyID0gZXhwci5zbGljZSgxLCAtMSlcblxuXHRcdFx0IyByZW1vdmUgbGVhZGluZyBzcGFjZXMgXG5cdFx0XHQjIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBob3cgbXVjaCB3aGl0ZXNwYWNlIHdlIGRyb3BwZWQgZnJvbSB0aGUgc3RhcnRcblx0XHRcdGlubmVyID0gaW5uZXIucmVwbGFjZSgvXlteXFxuXFxTXSsvLCcnKVxuXG5cdFx0XHRpZiBpbm5lcjpsZW5ndGhcblx0XHRcdFx0IyB3ZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBsb2Mgd2Ugc3RhcnQgYXRcblx0XHRcdFx0IyBjb25zb2xlLmxvZygnaW50ZXJwb2xhdGUgZnJvbSBsb2MnLEBsb2MsaSlcblx0XHRcdFx0IyByZWFsbHk/IHdoeSBub3QganVzdCBhZGQgdG8gdGhlIHN0YWNrPz9cblx0XHRcdFx0IyB3aGF0IGFib3V0IHRoZSBhZGRlZCBcblx0XHRcdFx0IyBzaG91bGQgc2hhcmUgd2l0aCB0aGUgc2VsZWN0b3Igbm8/XG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJ0b2tlbml6ZSBpbm5lciBwYXJ0cyBvZiBzdHJpbmdcIixpbm5lclxuXHRcdFx0XHR2YXIgc3BhY2VzID0gMFxuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gQGxvYyArIGkgKyAoZXhwcjpsZW5ndGggLSBpbm5lcjpsZW5ndGgpIC0gMVxuXHRcdFx0XHQjIHdoeSBjcmVhdGUgYSB3aG9sZSBuZXcgbGV4ZXI/IFNob3VsZCByYXRoZXIgcmV1c2Ugb25lXG5cdFx0XHRcdCMgbXVjaCBiZXR0ZXIgdG8gc2ltcGx5IG1vdmUgaW50byBpbnRlcnBvbGF0aW9uIG1vZGUgd2hlcmVcblx0XHRcdFx0IyB3ZSBjb250aW51ZSBwYXJzaW5nIHVudGlsIHdlIG1lZXQgdW5wYWlyZWQgfVxuXHRcdFx0XHR2YXIgbmVzdGVkID0gTGV4ZXIubmV3LnRva2VuaXplIGlubmVyLCBpbmxpbmU6IHllcywgcmV3cml0ZTogbm8sIGxvYzogb2Zmc2V0ICsgbG9jT2Zmc2V0XG5cdFx0XHRcdCMgY29uc29sZS5sb2cgbmVzdGVkLnBvcFxuXG5cdFx0XHRcdGlmIG5lc3RlZFswXSBhbmQgdFQobmVzdGVkWzBdKSA9PSAnVEVSTUlOQVRPUidcblx0XHRcdFx0XHRuZXN0ZWQuc2hpZnRcblxuXHRcdFx0XHRpZiBuZXN0ZWQ6bGVuZ3RoXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2ggKm5lc3RlZCAjIFQudG9rZW4oJ1RPS0VOUycsbmVzdGVkLDApXG5cdFx0XHRcblx0XHRcdCMgc2hvdWxkIHJhdGhlciBhZGQgdGhlIGFtb3VudCBieSB3aGljaCBvdXIgbGV4ZXIgaGFzIG1vdmVkP1xuXHRcdFx0aSArPSBleHByOmxlbmd0aCAtIDFcblx0XHRcdHRva2Vucy5wdXNoIFRva2VuLm5ldygnfX0nLCd9JyxAbG9jICsgaSArIGxvY09mZnNldCwxKVxuXHRcdFx0cGkgPSBpICsgMVxuXG5cdFx0IyBhZGRpbmcgdGhlIGxhc3QgcGFydCBvZiB0aGUgc3RyaW5nIGhlcmVcblx0XHRpZiBpID49IHBpIGFuZCBwaSA8IHN0cjpsZW5ndGhcblx0XHRcdCMgc2V0IHRoZSBsZW5ndGggYXMgd2VsbCAtIG9yP1xuXHRcdFx0IyB0aGUgc3RyaW5nIGFmdGVyP1xuXHRcdFx0IyBjb25zb2xlLmxvZyAncHVzaCBuZW9zdHJpbmcnXG5cdFx0XHR0b2tlbnMucHVzaCBUb2tlbi5uZXcoJ05FT1NUUklORycsIGVzY2FwZVN0cihzdHIuc2xpY2UocGkpLGhlcmVkb2MscXVvdGUpLEBsb2MgKyBwaSArIGxvY09mZnNldCwgc3RyOmxlbmd0aCAtIHBpKVxuXG5cdFx0IyBjb25zb2xlLmxvZyB0b2tlbnM6bGVuZ3RoXG5cdFx0cmV0dXJuIHRva2VucyBpZiByZWdleFxuXG5cdFx0cmV0dXJuIHRva2VuICdORU9TVFJJTkcnLCAnXCJcIicgdW5sZXNzIHRva2VuczpsZW5ndGhcblxuXHRcdEB0b2tlbnMucHVzaCh0b2spIGZvciB0b2sgaW4gdG9rZW5zXG5cblx0XHRyZXR1cm4gdG9rZW5zXG5cblx0IyBNYXRjaGVzIGEgYmFsYW5jZWQgZ3JvdXAgc3VjaCBhcyBhIHNpbmdsZSBvciBkb3VibGUtcXVvdGVkIHN0cmluZy4gUGFzcyBpblxuXHQjIGEgc2VyaWVzIG9mIGRlbGltaXRlcnMsIGFsbCBvZiB3aGljaCBtdXN0IGJlIG5lc3RlZCBjb3JyZWN0bHkgd2l0aGluIHRoZVxuXHQjIGNvbnRlbnRzIG9mIHRoZSBzdHJpbmcuIFRoaXMgbWV0aG9kIGFsbG93cyB1cyB0byBoYXZlIHN0cmluZ3Mgd2l0aGluXG5cdCMgaW50ZXJwb2xhdGlvbnMgd2l0aGluIHN0cmluZ3MsIGFkIGluZmluaXR1bS5cblx0ZGVmIGJhbGFuY2VkU2VsZWN0b3Igc3RyLCBlbmRcblx0XHR2YXIgcHJldlxuXHRcdHZhciBsZXR0ZXJcblx0XHR2YXIgc3RhY2sgPSBbZW5kXVxuXHRcdCMgRklYTUVcblx0XHRmb3IgaSBpbiBbMS4uLnN0cjpsZW5ndGhdXG5cdFx0XHRzd2l0Y2ggbGV0dGVyID0gc3RyLmNoYXJBdChpKVxuXHRcdFx0XHR3aGVuICdcXFxcJ1xuXHRcdFx0XHRcdGkrK1xuXHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdHdoZW4gZW5kXG5cdFx0XHRcdFx0c3RhY2sucG9wXG5cdFx0XHRcdFx0dW5sZXNzIHN0YWNrOmxlbmd0aFxuXHRcdFx0XHRcdFx0cmV0dXJuIHN0ci5zbGljZSgwLCBpICsgMSlcblxuXHRcdFx0XHRcdGVuZCA9IHN0YWNrW3N0YWNrOmxlbmd0aCAtIDFdXG5cdFx0XHRcdFx0Y29udGludWVcblx0XHRcdGlmIGVuZCBpcyAnfScgYW5kIGxldHRlciBpcyBbJyknXVxuXHRcdFx0XHRzdGFjay5wdXNoIGVuZCA9IGxldHRlclxuXHRcdFx0ZWxpZiBlbmQgaXMgJ30nIGFuZCBsZXR0ZXIgaXMgJ3snXG5cdFx0XHRcdHN0YWNrLnB1c2ggZW5kID0gJ30nXG5cdFx0XHRlbGlmIGVuZCBpcyAnKScgYW5kIGxldHRlciBpcyAneydcblx0XHRcdFx0c3RhY2sucHVzaCBlbmQgPSAnfSdcblx0XHRcdHByZXYgPSBsZXR0ZXIgIyB3aGF0LCB3aHk/XG5cblx0XHRlcnJvciBcIm1pc3NpbmcgeyBzdGFjay5wb3AgfSwgc3RhcnRpbmdcIlxuXG5cdCMgUGFpcnMgdXAgYSBjbG9zaW5nIHRva2VuLCBlbnN1cmluZyB0aGF0IGFsbCBsaXN0ZWQgcGFpcnMgb2YgdG9rZW5zIGFyZVxuXHQjIGNvcnJlY3RseSBiYWxhbmNlZCB0aHJvdWdob3V0IHRoZSBjb3Vyc2Ugb2YgdGhlIHRva2VuIHN0cmVhbS5cblx0ZGVmIHBhaXIgdG9rXG5cdFx0dmFyIHdhbnRlZCA9IGxhc3QoQGVuZHMpXG5cdFx0dW5sZXNzIHRvayA9PSB3YW50ZWRcblx0XHRcdGVycm9yIFwidW5tYXRjaGVkIHt0b2t9XCIgdW5sZXNzICdPVVRERU5UJyBpcyB3YW50ZWRcblx0XHRcdHZhciBzaXplID0gbGFzdChAaW5kZW50cylcblx0XHRcdEBpbmRlbnQgLT0gc2l6ZVxuXHRcdFx0b3V0ZGVudFRva2VuKHNpemUsIHRydWUsIDApXG5cdFx0XHRyZXR1cm4gcGFpcih0b2spXG5cdFx0c2VsZi5wb3BFbmRcblxuXG5cdCMgSGVscGVyc1xuXHQjIC0tLS0tLS1cblxuXHQjIEFkZCBhIHRva2VuIHRvIHRoZSByZXN1bHRzLCB0YWtpbmcgbm90ZSBvZiB0aGUgbGluZSBudW1iZXIuXG5cdGRlZiB0b2tlbiBpZCwgdmFsdWUsIGxlbiwgb2Zmc2V0XG5cdFx0QGxhc3RUeXAgPSBpZFxuXHRcdEBsYXN0VmFsID0gdmFsdWVcblx0XHR2YXIgdG9rID0gQGxhc3QgPSBUb2tlbi5uZXcoaWQsIHZhbHVlLCBAbG9jICsgKG9mZnNldCBvciAwKSwgbGVuIG9yIDApXG5cdFx0QHRva2Vucy5wdXNoIHRva1xuXHRcdHJldHVyblxuXG5cdGRlZiBsYXN0VG9rZW5UeXBlXG5cdFx0dmFyIHRva2VuID0gQHRva2Vuc1tAdG9rZW5zOmxlbmd0aCAtIDFdXG5cdFx0dG9rZW4gPyB0VCh0b2tlbikgOiAnTk9ORSdcblxuXHRkZWYgbGFzdFRva2VuVmFsdWVcblx0XHR2YXIgdG9rZW4gPSBAdG9rZW5zW0B0b2tlbnM6bGVuZ3RoIC0gMV1cblx0XHR0b2tlbiA/IHRva2VuLkB2YWx1ZSA6ICcnXG5cdFx0XG5cdCMgUGVlayBhdCBhIHRva2lkIGluIHRoZSBjdXJyZW50IHRva2VuIHN0cmVhbS5cblx0ZGVmIHRva2lkIGluZGV4LCB2YWxcblx0XHRpZiB2YXIgdG9rID0gbGFzdChAdG9rZW5zLCBpbmRleClcblx0XHRcdHRUcyh0b2ssdmFsKSBpZiB2YWxcblx0XHRcdHJldHVybiB0VCh0b2spXG5cdFx0ZWxzZSBudWxsXG5cblx0IyBQZWVrIGF0IGEgdmFsdWUgaW4gdGhlIGN1cnJlbnQgdG9rZW4gc3RyZWFtLlxuXHRkZWYgdmFsdWUgaW5kZXgsIHZhbFxuXHRcdGlmIHZhciB0b2sgPSBsYXN0KEB0b2tlbnMsIGluZGV4KVxuXHRcdFx0dFZzKHRvayx2YWwpIGlmIHZhbFxuXHRcdFx0cmV0dXJuIHRWKHRvaylcblx0XHRlbHNlIG51bGxcblx0XHRcblxuXHQjIEFyZSB3ZSBpbiB0aGUgbWlkc3Qgb2YgYW4gdW5maW5pc2hlZCBleHByZXNzaW9uP1xuXHRkZWYgdW5maW5pc2hlZFxuXHRcdHJldHVybiB0cnVlIGlmIExJTkVfQ09OVElOVUVSLnRlc3QoQGNodW5rKVx0XG5cdFx0cmV0dXJuIFVORklOSVNIRUQuaW5kZXhPZihAbGFzdFR5cCkgPj0gMFxuXHRcblx0IyBDb252ZXJ0cyBuZXdsaW5lcyBmb3Igc3RyaW5nIGxpdGVyYWxzLlxuXHRkZWYgZXNjYXBlTGluZXMgc3RyLCBoZXJlZG9jXG5cdFx0c3RyLnJlcGxhY2UgTVVMVElMSU5FUiwgKGhlcmVkb2MgPyAnXFxcXG4nIDogJycpXG5cblx0IyBDb25zdHJ1Y3RzIGEgc3RyaW5nIHRva2VuIGJ5IGVzY2FwaW5nIHF1b3RlcyBhbmQgbmV3bGluZXMuXG5cdGRlZiBtYWtlU3RyaW5nIGJvZHksIHF1b3RlLCBoZXJlZG9jXG5cdFx0cmV0dXJuIHF1b3RlICsgcXVvdGUgdW5sZXNzIGJvZHlcblx0XHRib2R5ID0gYm9keS5yZXBsYWNlKC9cXFxcKFtcXHNcXFNdKS9nKSBkbyB8bWF0Y2gsIGNvbnRlbnRzfFxuXHRcdFx0KGNvbnRlbnRzID09ICdcXG4nIG9yIGNvbnRlbnRzID09IHF1b3RlKSA/IGNvbnRlbnRzIDogbWF0Y2hcblx0XHQjIERvZXMgbm90IHdvcmsgbm93XG5cdFx0Ym9keSA9IGJvZHkucmVwbGFjZSBSZWdFeHAoXCJ7cXVvdGV9XCIsXCJnXCIpLCAnXFxcXCQmJ1xuXHRcdHF1b3RlICsgZXNjYXBlTGluZXMoYm9keSwgaGVyZWRvYykgKyBxdW90ZVxuXHRcdFxuXHQjIFRocm93cyBhIHN5bnRheCBlcnJvciBvbiB0aGUgY3VycmVudCBgQGxpbmVgLlxuXHRkZWYgZXJyb3IgbWVzc2FnZSwgbGVuXG5cdFx0bWVzc2FnZSA9IFwie21lc3NhZ2V9IG9uIGxpbmUge0BsaW5lfVwiIGlmIEBsaW5lIGlzYSBOdW1iZXJcblxuXHRcdGlmIGxlblxuXHRcdFx0bWVzc2FnZSArPSBcIiBbe0Bsb2N9OntAbG9jICsgbGVufV1cIlxuXG5cdFx0dmFyIGVyciA9IFN5bnRheEVycm9yLm5ldyhtZXNzYWdlKVxuXHRcdGVycjpsaW5lID0gQGxpbmVcblx0XHQjIGVycjpjb2x1bW5OdW1iZXJcblx0XHR2YXIgZXJyID0gRVJSLkltYmFQYXJzZUVycm9yLm5ldyhlcnIsIHRva2VuczogQHRva2VucywgcG9zOiBAdG9rZW5zOmxlbmd0aClcblx0XHRlcnI6cmVnaW9uID0gW0Bsb2MsQGxvYyArIChsZW4gb3IgMCldXG5cdFx0dGhyb3cgZXJyXG5cblx0ZGVmIHdhcm4gbWVzc2FnZVxuXHRcdHZhciBhcnkgPSBAdG9rZW5zOndhcm5pbmdzIHx8PSBbXVxuXHRcdGFyeS5wdXNoKG1lc3NhZ2UpXG5cdFx0Y29uc29sZS53YXJuIG1lc3NhZ2Vcblx0XHRzZWxmXG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9pbWJhL3NyYy9jb21waWxlci9sZXhlci5pbWJhIiwiIyBpbWJhJGlubGluZUhlbHBlcnM9MVxuIyBUaGUgSW1iYSBsYW5ndWFnZSBoYXMgYSBnb29kIGRlYWwgb2Ygb3B0aW9uYWwgc3ludGF4LCBpbXBsaWNpdCBzeW50YXgsXG4jIGFuZCBzaG9ydGhhbmQgc3ludGF4LiBUaGlzIGNhbiBncmVhdGx5IGNvbXBsaWNhdGUgYSBncmFtbWFyIGFuZCBibG9hdFxuIyB0aGUgcmVzdWx0aW5nIHBhcnNlIHRhYmxlLiBJbnN0ZWFkIG9mIG1ha2luZyB0aGUgcGFyc2VyIGhhbmRsZSBpdCBhbGwsIHdlIHRha2VcbiMgYSBzZXJpZXMgb2YgcGFzc2VzIG92ZXIgdGhlIHRva2VuIHN0cmVhbSwgdXNpbmcgdGhpcyAqKlJld3JpdGVyKiogdG8gY29udmVydFxuIyBzaG9ydGhhbmQgaW50byB0aGUgdW5hbWJpZ3VvdXMgbG9uZyBmb3JtLCBhZGQgaW1wbGljaXQgaW5kZW50YXRpb24gYW5kXG4jIHBhcmVudGhlc2VzLCBhbmQgZ2VuZXJhbGx5IGNsZWFuIHRoaW5ncyB1cC5cblxuXG52YXIgVCA9IHJlcXVpcmUgJy4vdG9rZW4nXG52YXIgVG9rZW4gPSBULlRva2VuXG5cbnZhciB2OFxuaWYgJHY4cHJvZiRcblx0djggPSByZXF1aXJlICd2OC1uYXRpdmVzJ1x0XG5cbmltcG9ydCBJTlZFUlNFUyxCQUxBTkNFRF9QQUlSUyxUT0sgZnJvbSAnLi9jb25zdGFudHMnXG5cbiMgdmFyIFRFUk1JTkFUT1IgPSBURVJNSU5BVE9SXG5cbnZhciBURVJNSU5BVE9SID0gJ1RFUk1JTkFUT1InXG52YXIgSU5ERU5UID0gJ0lOREVOVCdcbnZhciBPVVRERU5UID0gJ09VVERFTlQnXG52YXIgREVGX0JPRFkgPSAnREVGX0JPRFknXG52YXIgVEhFTiA9ICdUSEVOJ1xudmFyIENBVENIID0gJ0NBVENIJ1xuXG52YXIgYXJyYXlUb0hhc2ggPSBkbyB8YXJ5fFxuXHR2YXIgaGFzaCA9IHt9XG5cdGZvciBpdGVtIGluIGFyeVxuXHRcdGhhc2hbaXRlbV0gPSAxXG5cdHJldHVybiBoYXNoXG5cbiMgdmFyIEVYUFJFU1NJT05fU1RBUlQgPSBbJygnLCdbJywneycsJ0lOREVOVCcsJ0NBTExfU1RBUlQnLCdQQVJBTV9TVEFSVCcsJ0lOREVYX1NUQVJUJywnQkxPQ0tfUEFSQU1fU1RBUlQnLCdTVFJJTkdfU1RBUlQnLCd7eycsICdUQUdfU1RBUlQnXVxuIyB2YXIgRVhQUkVTU0lPTl9FTkQgICA9IFsnKScsJ10nLCd9JywnT1VUREVOVCcsJ0NBTExfRU5EJywnUEFSQU1fRU5EJywnSU5ERVhfRU5EJywnQkxPQ0tfUEFSQU1fRU5EJywnU1RSSU5HX0VORCcsJ319JywgJ1RBR19FTkQnXVxuIyBUb2tlbnMgdGhhdCBpbmRpY2F0ZSB0aGUgY2xvc2Ugb2YgYSBjbGF1c2Ugb2YgYW4gZXhwcmVzc2lvbi5cbnZhciBFWFBSRVNTSU9OX0NMT1NFID0gWycpJywnXScsJ30nLCdPVVRERU5UJywnQ0FMTF9FTkQnLCdQQVJBTV9FTkQnLCdJTkRFWF9FTkQnLCdCTE9DS19QQVJBTV9FTkQnLCdTVFJJTkdfRU5EJywnfX0nLCAnVEFHX0VORCcsJ0NBVENIJywgJ1dIRU4nLCAnRUxTRScsICdGSU5BTExZJ11cblxudmFyIEVYUFJFU1NJT05fQ0xPU0VfSEFTSCA9IGFycmF5VG9IYXNoKEVYUFJFU1NJT05fQ0xPU0UpXG5cbnZhciBFWFBSRVNTSU9OX1NUQVJUID1cblx0JygnOiAxLFxuXHQnWyc6IDEsXG5cdCd7JzogMSxcblx0J3t7JzogMSxcblx0J0lOREVOVCc6IDEsXG5cdCdDQUxMX1NUQVJUJzogMSxcblx0J1BBUkFNX1NUQVJUJzogMSxcblx0J0lOREVYX1NUQVJUJzogMSxcblx0J0JMT0NLX1BBUkFNX1NUQVJUJzogMSxcblx0J1NUUklOR19TVEFSVCc6IDEsXG5cdCdUQUdfU1RBUlQnOiAxXG5cbnZhciBFWFBSRVNTSU9OX0VORCA9XG5cdCcpJzogMSxcblx0J10nOiAxLFxuXHQnfSc6IDEsXG5cdCd9fSc6IDEsXG5cdCdPVVRERU5UJzogMSxcblx0J0NBTExfRU5EJzogMSxcblx0J1BBUkFNX0VORCc6IDEsXG5cdCdJTkRFWF9FTkQnOiAxLFxuXHQnQkxPQ0tfUEFSQU1fRU5EJzogMSxcblx0J1NUUklOR19FTkQnOiAxLFxuXHQnVEFHX0VORCc6IDFcblxudmFyIFNJTkdMRV9MSU5FUlMgPVxuXHRFTFNFOiAxXG5cdFRSWTogMVxuXHRGSU5BTExZOiAxXG5cdFRIRU46IDFcblx0QkxPQ0tfUEFSQU1fRU5EOiAxXG5cdERPOiAxXG5cdEJFR0lOOiAxXG5cdENBVENIX1ZBUjogMVxuXG52YXIgU0lOR0xFX0NMT1NFUlNfTUFQID0gXG5cdFRFUk1JTkFUT1I6IHllc1xuXHRDQVRDSDogeWVzXG5cdEZJTkFMTFk6IHllc1xuXHRFTFNFOiB5ZXNcblx0T1VUREVOVDogeWVzXG5cdExFQURJTkdfV0hFTjogeWVzXG5cbnZhciBJTVBMSUNJVF9GVU5DX01BUCA9XG5cdCdJREVOVElGSUVSJzogMVxuXHQnU1VQRVInOiAxXG5cdCdAJzogMVxuXHQnVEhJUyc6IDFcblx0J1NFTEYnOiAxXG5cdCdUQUdfRU5EJzogMVxuXHQnSVZBUic6IDFcblx0J0dWQVInOiAxXG5cdCdDT05TVCc6IDFcblx0J0FSR1ZBUic6IDFcblx0J05FVyc6IDFcblx0J0JSRUFLJzogMVxuXHQnQ09OVElOVUUnOiAxXG5cdCdSRVRVUk4nOiAxXG5cbnZhciBJTVBMSUNJVF9DQUxMX01BUCA9XG5cdCdTRUxFQ1RPUic6IDFcblx0J0lERU5USUZJRVInOiAxXG5cdCdOVU1CRVInOiAxXG5cdCdTVFJJTkcnOiAxXG5cdCdTWU1CT0wnOiAxXG5cdCdKUyc6IDFcblx0J1JFR0VYJzogMVxuXHQnTkVXJzogMVxuXHQnQ0xBU1MnOiAxXG5cdCdJRic6IDFcblx0J1VOTEVTUyc6IDFcblx0J1RSWSc6IDFcblx0J1NXSVRDSCc6IDFcblx0J1RISVMnOiAxXG5cdCdCT09MJzogMVxuXHQnVFJVRSc6IDFcblx0J0ZBTFNFJzogMVxuXHQnTlVMTCc6IDFcblx0J1VOREVGSU5FRCc6IDFcblx0J1VOQVJZJzogMVxuXHQnU1VQRVInOiAxXG5cdCdJVkFSJzogMVxuXHQnR1ZBUic6IDFcblx0J0NPTlNUJzogMVxuXHQnQVJHVkFSJzogMVxuXHQnU0VMRic6IDFcblx0J0AnOiAxXG5cdCdbJzogMVxuXHQnKCc6IDFcblx0J3snOiAxXG5cdCctLSc6IDFcblx0JysrJzogMVxuXHQnVEFHSUQnOiAxXG5cdCcjJzogMVxuXHQnVEFHX1NUQVJUJzogMVxuXHQnUEFSQU1fU1RBUlQnOiAxXG5cdCdTRUxFQ1RPUl9TVEFSVCc6IDFcblx0J1NUUklOR19TVEFSVCc6IDFcblx0J0lEUkVGJzogMVxuXHQnU1BMQVQnOiAxXG5cdCdETyc6IDFcblx0J0JMT0NLX0FSRyc6IDFcblx0J0ZPUic6IDFcblx0J0NPTlRJTlVFJzogMVxuXHQnQlJFQUsnOiAxXG5cblxudmFyIElERU5USUZJRVJTID0gWydJREVOVElGSUVSJywgJ0dWQVInLCAnSVZBUicsICdDVkFSJywgJ0NPTlNUJywgJ0FSR1ZBUiddXG5cblxuXG4jIFRva2VucyB0aGF0LCBpZiBmb2xsb3dlZCBieSBhbiBgSU1QTElDSVRfQ0FMTGAsIGluZGljYXRlIGEgZnVuY3Rpb24gaW52b2NhdGlvbi5cbnZhciBJTVBMSUNJVF9GVU5DICAgID0gWydJREVOVElGSUVSJywgJ1NVUEVSJywgIyAnKScsICdJTkRFWF9FTkQnLCAjICAnQ0FMTF9FTkQnLFxuXHQnQCcsICdUSElTJywnU0VMRicsICdFVkVOVCcsJ1RSSUdHRVInLCdUQUdfRU5EJywgJ0lWQVInLCBcblx0J0dWQVInLCAnQ09OU1QnLCAnQVJHVkFSJywgJ05FVycsICdCUkVBSycsICdDT05USU5VRScsJ1JFVFVSTidcbl1cblxuIyBJZiBwcmVjZWRlZCBieSBhbiBgSU1QTElDSVRfRlVOQ2AsIGluZGljYXRlcyBhIGZ1bmN0aW9uIGludm9jYXRpb24uXG52YXIgSU1QTElDSVRfQ0FMTCAgICA9IFtcblx0J1NFTEVDVE9SJywnSURFTlRJRklFUicsICdOVU1CRVInLCAnU1RSSU5HJywgJ1NZTUJPTCcsICdKUycsICdSRUdFWCcsICdORVcnLCAnUEFSQU1fU1RBUlQnLCAnQ0xBU1MnXG5cdCdJRicsICdVTkxFU1MnLCAnVFJZJywgJ1NXSVRDSCcsICdUSElTJywgJ0JPT0wnLCAnVFJVRScsJ0ZBTFNFJywgJ05VTEwnLCAnVU5ERUZJTkVEJywgJ1VOQVJZJywgJ1NVUEVSJywgJ0lWQVInLCAnR1ZBUicsICdDT05TVCcsICdBUkdWQVInLCdTRUxGJywgXG5cdCdAJywgJ1snLCAnKCcsICd7JywgJy0tJywgJysrJywnU0VMRUNUT1InLCAnVEFHX1NUQVJUJywgJ1RBR0lEJywgJyMnLCAnU0VMRUNUT1JfU1RBUlQnLCAnSURSRUYnLCAnU1BMQVQnLCAnRE8nLCAnQkxPQ0tfQVJHJ1xuXHQnRk9SJywgJ1NUUklOR19TVEFSVCcsJ0NPTlRJTlVFJywnQlJFQUsnXG5dICMgJy0+JywgJz0+Jywgd2h5IGRvZXMgaXQgbm90IHdvcmsgd2l0aCBzeW1ib2w/XG5cbnZhciBJTVBMSUNJVF9JTkRFTlRfQ0FMTCA9IFtcblx0J0ZPUidcbl1cbiMgaXMgbm90IGRvIGFuIGltcGxpY2l0IGNhbGw/P1xuXG52YXIgSU1QTElDSVRfVU5TUEFDRURfQ0FMTCA9IFsnKycsICctJ11cblxuIyBUb2tlbnMgaW5kaWNhdGluZyB0aGF0IHRoZSBpbXBsaWNpdCBjYWxsIG11c3QgZW5jbG9zZSBhIGJsb2NrIG9mIGV4cHJlc3Npb25zLlxudmFyIElNUExJQ0lUX0JMT0NLICAgPSBbJ3snLCAnWycsICcsJywnQkxPQ0tfUEFSQU1fRU5EJywgJ0RPJ10gIyAnLT4nLCAnPT4nLCBcblxudmFyIElNUExJQ0lUX0JMT0NLX01BUCA9IGFycmF5VG9IYXNoKElNUExJQ0lUX0JMT0NLKVxuXG52YXIgQ09ORElUSU9OQUxfQVNTSUdOID0gWyd8fD0nLCAnJiY9JywgJz89JywgJyY9JywgJ3w9J11cbnZhciBDT01QT1VORF9BU1NJR04gPSBbJy09JywgJys9JywgJy89JywgJyo9JywgJyU9JywgJ3x8PScsICcmJj0nLCAnPz0nLCAnPDw9JywgJz4+PScsICc+Pj49JywgJyY9JywgJ149JywgJ3w9J11cbnZhciBVTkFSWSA9IFsnIScsICd+JywgJ05FVycsICdUWVBFT0YnLCAnREVMRVRFJ11cbnZhciBMT0dJQyAgID0gWycmJicsICd8fCcsICcmJywgJ3wnLCAnXiddXG5cbiMgb3B0aW1pemUgZm9yIGZpeGVkIGFycmF5c1xudmFyIE5PX0lNUExJQ0lUX0JMT0NLX0NBTEwgPSBbXG5cdCdDQUxMX0VORCcsJz0nLCdERUZfQk9EWScsJygnLCdDQUxMX1NUQVJUJywnLCcsJzonLCdSRVRVUk4nXG5cdCctPScsICcrPScsICcvPScsICcqPScsICclPScsICd8fD0nLCAnJiY9JywgJz89JywgJzw8PScsICc+Pj0nLCAnPj4+PScsICcmPScsICdePScsICd8PSdcbl0gIyAuY29uY2F0KENPTVBPVU5EX0FTU0lHTilcblxudmFyIE5PX0NBTExfVEFHID0gWydDTEFTUycsICdJRicsJ1VOTEVTUycsJ1RBRycsJ1dISUxFJywnRk9SJywnVU5USUwnLCdDQVRDSCcsJ0ZJTkFMTFknLCdNT0RVTEUnLCdMRUFESU5HX1dIRU4nXVxuXG52YXIgTk9fQ0FMTF9UQUdfTUFQID0gYXJyYXlUb0hhc2goTk9fQ0FMTF9UQUcpXG5cblxuIyBjb25zb2xlLmxvZyBOT19JTVBMSUNJVF9CTE9DS19DQUxMOmxlbmd0aFxuIyBOT19JTVBMSUNJVF9CTE9DS19DQUxMXG4jIElNUExJQ0lUX0NPTU1BID0gWyctPicsICc9PicsICd7JywgJ1snLCAnTlVNQkVSJywgJ1NUUklORycsICdTWU1CT0wnLCAnSURFTlRJRklFUicsJ0RPJ11cblxudmFyIElNUExJQ0lUX0NPTU1BID0gWydETyddXG5cbiMgVG9rZW5zIHRoYXQgYWx3YXlzIG1hcmsgdGhlIGVuZCBvZiBhbiBpbXBsaWNpdCBjYWxsIGZvciBzaW5nbGUtbGluZXJzLlxudmFyIElNUExJQ0lUX0VORCAgICAgPSBbJ1BPU1RfSUYnLCAnUE9TVF9VTkxFU1MnLCAnUE9TVF9GT1InLCAnV0hJTEUnLCAnVU5USUwnLCAnV0hFTicsICdCWScsICdMT09QJywgJ1RFUk1JTkFUT1InLCdERUZfQk9EWScsJ0RFRl9GUkFHTUVOVCddXG5cbnZhciBJTVBMSUNJVF9FTkRfTUFQID1cblx0UE9TVF9JRjogeWVzXG5cdFBPU1RfVU5MRVNTOiB5ZXNcblx0UE9TVF9GT1I6IHllc1xuXHRXSElMRTogeWVzXG5cdFVOVElMOiB5ZXNcblx0V0hFTjogeWVzXG5cdEJZOiB5ZXNcblx0TE9PUDogeWVzXG5cdFRFUk1JTkFUT1I6IHllc1xuXHRERUZfQk9EWTogeWVzXG5cdERFRl9GUkFHTUVOVDogeWVzXG5cbiMgU2luZ2xlLWxpbmUgZmxhdm9ycyBvZiBibG9jayBleHByZXNzaW9ucyB0aGF0IGhhdmUgdW5jbG9zZWQgZW5kaW5ncy5cbiMgVGhlIGdyYW1tYXIgY2FuJ3QgZGlzYW1iaWd1YXRlIHRoZW0sIHNvIHdlIGluc2VydCB0aGUgaW1wbGljaXQgaW5kZW50YXRpb24uXG4jIHZhciBTSU5HTEVfTElORVJTICAgID0gWydFTFNFJywgJ1RSWScsICdGSU5BTExZJywgJ1RIRU4nLCdCTE9DS19QQVJBTV9FTkQnLCdETycsJ0JFR0lOJywnQ0FUQ0hfVkFSJ10gIyAnLT4nLCAnPT4nLCByZWFsbHk/XG52YXIgU0lOR0xFX0NMT1NFUlMgICA9IFsnVEVSTUlOQVRPUicsICdDQVRDSCcsICdGSU5BTExZJywgJ0VMU0UnLCAnT1VUREVOVCcsICdMRUFESU5HX1dIRU4nXVxudmFyIExJTkVCUkVBS1MgICAgICAgPSBbJ1RFUk1JTkFUT1InLCAnSU5ERU5UJywgJ09VVERFTlQnXSAjIFRva2VucyB0aGF0IGVuZCBhIGxpbmUuXG5cbnZhciBDQUxMQ09VTlQgPSAwXG4jIEJhc2VkIG9uIHRoZSBvcmlnaW5hbCByZXdyaXRlci5jb2ZmZWUgZnJvbSBDb2ZmZWVTY3JpcHRcbmV4cG9ydCBjbGFzcyBSZXdyaXRlclxuXHRcblx0ZGVmIGluaXRpYWxpemVcblx0XHRAdG9rZW5zID0gW11cblx0XHRAb3B0aW9ucyA9IHt9XG5cdFx0QGxlbiA9IDBcblx0XHRAc3RhcnRlciA9IG51bGxcblx0XHRzZWxmXG5cblx0ZGVmIHJlc2V0XG5cdFx0c2VsZlxuXHRcblx0ZGVmIHRva2Vuc1xuXHRcdEB0b2tlbnNcblx0XHRcblx0IyBIZWxwZnVsIHNuaXBwZXQgZm9yIGRlYnVnZ2luZzpcblx0IyAgICAgY29uc29sZS5sb2cgKHRbMF0gKyAnLycgKyB0WzFdIGZvciB0IGluIEB0b2tlbnMpLmpvaW4gJyAnXG5cdCMgUmV3cml0ZSB0aGUgdG9rZW4gc3RyZWFtIGluIG11bHRpcGxlIHBhc3Nlcywgb25lIGxvZ2ljYWwgZmlsdGVyIGF0XG5cdCMgYSB0aW1lLiBUaGlzIGNvdWxkIGNlcnRhaW5seSBiZSBjaGFuZ2VkIGludG8gYSBzaW5nbGUgcGFzcyB0aHJvdWdoIHRoZVxuXHQjIHN0cmVhbSwgd2l0aCBhIGJpZyBvbCcgZWZmaWNpZW50IHN3aXRjaCwgYnV0IGl0J3MgbXVjaCBuaWNlciB0byB3b3JrIHdpdGhcblx0IyBsaWtlIHRoaXMuIFRoZSBvcmRlciBvZiB0aGVzZSBwYXNzZXMgbWF0dGVycyAtLSBpbmRlbnRhdGlvbiBtdXN0IGJlXG5cdCMgY29ycmVjdGVkIGJlZm9yZSBpbXBsaWNpdCBwYXJlbnRoZXNlcyBjYW4gYmUgd3JhcHBlZCBhcm91bmQgYmxvY2tzIG9mIGNvZGUuXG5cdGRlZiByZXdyaXRlIHRva2Vucywgb3B0cyA9IHt9XG5cdFx0cmVzZXRcblxuXHRcdEB0b2tlbnMgID0gdG9rZW5zXG5cdFx0QG9wdGlvbnMgPSBvcHRzXG5cblx0XHR2YXIgaSA9IDBcblx0XHR2YXIgayA9IHRva2VuczpsZW5ndGhcblx0XHQjIGZsYWcgZW1wdHkgbWV0aG9kc1xuXHRcdHdoaWxlIGkgPCAoayAtIDEpXG5cdFx0XHR2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblx0XHRcdFxuXHRcdFx0aWYgdG9rZW4uQHR5cGUgPT0gJ0RFRl9CT0RZJ1xuXHRcdFx0XHR2YXIgbmV4dCA9IHRva2Vuc1tpICsgMV1cblx0XHRcdFx0aWYgbmV4dCBhbmQgbmV4dC5AdHlwZSA9PSBURVJNSU5BVE9SXG5cdFx0XHRcdFx0dG9rZW4uQHR5cGUgPSAnREVGX0VNUFRZJ1xuXHRcdFx0aSsrXG5cblx0XHRzdGVwKFwiYWxsXCIpXG5cdFx0Y29uc29sZS5sb2coQ0FMTENPVU5UKSBpZiBDQUxMQ09VTlRcblx0XHRyZXR1cm4gQHRva2Vuc1xuXG5cdGRlZiBhbGxcblx0XHRzdGVwKFwiZW5zdXJlRmlyc3RMaW5lXCIpXG5cdFx0c3RlcChcInJlbW92ZUxlYWRpbmdOZXdsaW5lc1wiKVxuXHRcdHN0ZXAoXCJyZW1vdmVNaWRFeHByZXNzaW9uTmV3bGluZXNcIilcblx0XHRzdGVwKFwidGFnRGVmQXJndW1lbnRzXCIpXG5cdFx0c3RlcChcImNsb3NlT3BlbkNhbGxzXCIpXG5cdFx0c3RlcChcImNsb3NlT3BlbkluZGV4ZXNcIilcblx0XHRzdGVwKFwiY2xvc2VPcGVuVGFnc1wiKVxuXHRcdHN0ZXAoXCJhZGRJbXBsaWNpdEluZGVudGF0aW9uXCIpXG5cdFx0c3RlcChcInRhZ1Bvc3RmaXhDb25kaXRpb25hbHNcIilcblx0XHRzdGVwKFwiYWRkSW1wbGljaXRCcmFjZXNcIilcblx0XHRzdGVwKFwiYWRkSW1wbGljaXRQYXJlbnRoZXNlc1wiKVxuXG5cdGRlZiBzdGVwIGZuXG5cdFx0aWYgJGltYmFjX3Byb2ZpbGUkXG5cdFx0XHRjb25zb2xlLnRpbWUoZm4pXG5cblx0XHR0aGlzW2ZuXSgpXG5cblx0XHRpZiB2OFxuXHRcdFx0dmFyIG9wdCA9IHY4LmdldE9wdGltaXphdGlvblN0YXR1cyh0aGlzW2ZuXSlcblx0XHRcdGlmIG9wdCAhPSAxXG5cdFx0XHRcdHByb2Nlc3M6c3Rkb3V0LndyaXRlIFwie2ZufToge29wdH1cXG5cIiBcblx0XHRcdFx0djgub3B0aW1pemVGdW5jdGlvbk9uTmV4dENhbGwodGhpc1tmbl0pXG5cblx0XHRcdCMgaWYgb3B0ID09IDJcblx0XHRcdCMgdjgub3B0aW1pemVGdW5jdGlvbk9uTmV4dENhbGwodGhpc1tmbl0pXG5cdFx0XHQjXHR2ODpoZWxwZXJzLnByaW50U3RhdHVzKHRoaXNbZm5dKVxuXHRcdFx0IyBjb25zb2xlLmxvZyB2OC5nZXRPcHRpbWl6YXRpb25TdGF0dXModGhpc1tmbl0pXG5cblx0XHRpZiAkaW1iYWNfcHJvZmlsZSRcblx0XHRcdGNvbnNvbGUudGltZUVuZChmbilcblxuXHRcdHJldHVyblxuXG5cdCMgUmV3cml0ZSB0aGUgdG9rZW4gc3RyZWFtLCBsb29raW5nIG9uZSB0b2tlbiBhaGVhZCBhbmQgYmVoaW5kLlxuXHQjIEFsbG93IHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGJsb2NrIHRvIHRlbGwgdXMgaG93IG1hbnkgdG9rZW5zIHRvIG1vdmVcblx0IyBmb3J3YXJkcyAob3IgYmFja3dhcmRzKSBpbiB0aGUgc3RyZWFtLCB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgbWlzcyBhbnl0aGluZ1xuXHQjIGFzIHRva2VucyBhcmUgaW5zZXJ0ZWQgYW5kIHJlbW92ZWQsIGFuZCB0aGUgc3RyZWFtIGNoYW5nZXMgbGVuZ3RoIHVuZGVyXG5cdCMgb3VyIGZlZXQuXG5cdGRlZiBzY2FuVG9rZW5zIGJsb2NrXG5cdFx0dmFyIHRva2VucyA9IEB0b2tlbnNcblxuXHRcdHZhciBpID0gMFxuXHRcdHdoaWxlIGkgPCB0b2tlbnM6bGVuZ3RoXG5cdFx0XHRpICs9IGJsb2NrLmNhbGwoc2VsZiwgdG9rZW5zW2ldLCBpLCB0b2tlbnMpXG5cdFx0dHJ1ZVxuXG5cdGRlZiBkZXRlY3RFbmQgaSwgY29uZGl0aW9uLCBhY3Rpb24sIHN0YXRlID0ge31cblxuXHRcdHZhciB0b2tlbnMgPSBAdG9rZW5zXG5cdFx0dmFyIGxldmVscyA9IDBcblx0XHR2YXIgdG9rZW5cblx0XHR2YXIgdCx2XG4gXG5cdFx0d2hpbGUgaSA8IHRva2VuczpsZW5ndGhcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldXG5cblx0XHRcdGlmIGxldmVscyA9PSAwIGFuZCBjb25kaXRpb24uY2FsbCh0aGlzLHRva2VuLGksdG9rZW5zLHN0YXRlKVxuXHRcdFx0XHRyZXR1cm4gYWN0aW9uLmNhbGwoc2VsZiwgdG9rZW4sIGksdG9rZW5zLHN0YXRlKVxuXG5cdFx0XHRpZiAhdG9rZW4gb3IgbGV2ZWxzIDwgMFxuXHRcdFx0XHRyZXR1cm4gYWN0aW9uLmNhbGwoc2VsZiwgdG9rZW4sIGkgLSAxLHRva2VucyxzdGF0ZSlcblxuXHRcdFx0dCA9IHRva2VuLkB0eXBlXG5cblx0XHRcdGlmIEVYUFJFU1NJT05fU1RBUlRbdF1cblx0XHRcdFx0bGV2ZWxzICs9IDFcblxuXHRcdFx0ZWxpZiBFWFBSRVNTSU9OX0VORFt0XVxuXHRcdFx0XHRsZXZlbHMgLT0gMVxuXHRcdFx0aSArPSAxXG5cblx0XHRpIC0gMVxuXG5cdGRlZiBlbnN1cmVGaXJzdExpbmVcblx0XHR2YXIgdG9rZW4gPSBAdG9rZW5zWzBdXG5cblx0XHRpZiB0b2tlbi5AdHlwZSA9PT0gVEVSTUlOQVRPUlxuXHRcdFx0QHRva2Vucy51bnNoaWZ0KFQudG9rZW4oJ0JPRFlTVEFSVCcsJ0JPRFlTVEFSVCcpKVxuXHRcdFx0IyBAdG9rZW5zID0gW1QudG9rZW4oJ0JPRFlTVEFSVCcsJ0JPRFlTVEFSVCcpXS5jb25jYXQoQHRva2Vucylcblx0XHRyZXR1cm5cblxuXHQjIExlYWRpbmcgbmV3bGluZXMgd291bGQgaW50cm9kdWNlIGFuIGFtYmlndWl0eSBpbiB0aGUgZ3JhbW1hciwgc28gd2Vcblx0IyBkaXNwYXRjaCB0aGVtIGhlcmUuXG5cdGRlZiByZW1vdmVMZWFkaW5nTmV3bGluZXNcblx0XHR2YXIgYXQgPSAwXG5cblx0XHR2YXIgaSA9IDAgIyBAdG9rZW5zOmxlbmd0aFxuXHRcdHZhciB0b2tlbnMgPSBAdG9rZW5zXG5cdFx0dmFyIHRva2VuXG5cdFx0dmFyIGwgPSB0b2tlbnM6bGVuZ3RoXG5cblx0XHR3aGlsZSBpIDwgbFxuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV1cblx0XHRcdGlmIHRva2VuLkB0eXBlICE9PSBURVJNSU5BVE9SXG5cdFx0XHRcdGJyZWFrIGF0ID0gaVxuXHRcdFx0aSsrXG5cdFx0XG5cdFx0dG9rZW5zLnNwbGljZSgwLCBhdCkgaWYgYXRcblx0XHRyZXR1cm5cblxuXHQjIFNvbWUgYmxvY2tzIG9jY3VyIGluIHRoZSBtaWRkbGUgb2YgZXhwcmVzc2lvbnMgLS0gd2hlbiB3ZSdyZSBleHBlY3Rpbmdcblx0IyB0aGlzLCByZW1vdmUgdGhlaXIgdHJhaWxpbmcgbmV3bGluZXMuXG5cdGRlZiByZW1vdmVNaWRFeHByZXNzaW9uTmV3bGluZXNcblxuXHRcdHNjYW5Ub2tlbnMgZG8gfHRva2VuLGksdG9rZW5zfCAjIGRvIHx0b2tlbixpLHRva2Vuc3xcblx0XHRcdHZhciBuZXh0ID0gdG9rZW5zOmxlbmd0aCA+IChpICsgMSkgPyB0b2tlbnNbaSArIDFdIDogbnVsbFxuXHRcdFx0cmV0dXJuIDEgdW5sZXNzIHRva2VuLkB0eXBlID09PSBURVJNSU5BVE9SIGFuZCBuZXh0IGFuZCBFWFBSRVNTSU9OX0NMT1NFX0hBU0hbbmV4dC5AdHlwZV0gIyAuaW5kZXhPZihuZXh0KSA+PSAwXG5cdFx0XHRyZXR1cm4gMSBpZiBuZXh0IGFuZCBuZXh0LkB0eXBlID09IE9VVERFTlRcblx0XHRcdCMgcmV0dXJuIDFcblx0XHRcdHRva2Vucy5zcGxpY2UoaSwgMSlcblx0XHRcdDBcblxuXG5cdGRlZiB0YWdEZWZBcmd1bWVudHNcblx0XHR5ZXNcblxuXHQjIFRoZSBsZXhlciBoYXMgdGFnZ2VkIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzIG9mIGEgbWV0aG9kIGNhbGwuIE1hdGNoIGl0IHdpdGhcblx0IyBpdHMgcGFpcmVkIGNsb3NlLiBXZSBoYXZlIHRoZSBtaXMtbmVzdGVkIG91dGRlbnQgY2FzZSBpbmNsdWRlZCBoZXJlIGZvclxuXHQjIGNhbGxzIHRoYXQgY2xvc2Ugb24gdGhlIHNhbWUgbGluZSwganVzdCBiZWZvcmUgdGhlaXIgb3V0ZGVudC5cblx0ZGVmIGNsb3NlT3BlbkNhbGxzXG5cdFx0dmFyIGNvbmRpdGlvbiA9IGRvIHx0b2tlbixpLHRva2Vuc3xcblx0XHRcdHZhciB0ID0gdG9rZW4uQHR5cGVcblx0XHRcdCh0ID09ICcpJyBvciB0ID09ICdDQUxMX0VORCcpIHx8IHQgPT0gT1VUREVOVCBhbmQgdGhpcy50b2tlblR5cGUoaSAtIDEpID09ICcpJ1xuXG5cdFx0dmFyIGFjdGlvbiA9IGRvIHx0b2tlbiwgaSwgdG9rZW5zfFxuXHRcdFx0dmFyIHQgPSB0b2tlbi5AdHlwZVxuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaSAtIDFdIGlmIHQgPT09IE9VVERFTlRcblx0XHRcdCMgdmFyIHRvayA9IEB0b2tlbnNbdCA9PSBPVVRERU5UID8gaSAtIDEgOiBpXVxuXHRcdFx0dG9rZW4uQHR5cGUgPSAnQ0FMTF9FTkQnXG5cdFx0XHRyZXR1cm5cblx0XHRcdCMgVC5zZXRUeXAodG9rLCdDQUxMX0VORCcpXG5cblx0XHRzY2FuVG9rZW5zIGRvIHx0b2tlbixpLHRva2Vuc3xcblx0XHRcdHRoaXMuZGV0ZWN0RW5kKGkgKyAxLCBjb25kaXRpb24sIGFjdGlvbikgaWYgdG9rZW4uQHR5cGUgPT09ICdDQUxMX1NUQVJUJ1xuXHRcdFx0cmV0dXJuIDFcblxuXHRcdHJldHVyblxuXG5cdCMgVGhlIGxleGVyIGhhcyB0YWdnZWQgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMgb2YgYW4gaW5kZXhpbmcgb3BlcmF0aW9uIGNhbGwuXG5cdCMgTWF0Y2ggaXQgd2l0aCBpdHMgcGFpcmVkIGNsb3NlLlxuXHRkZWYgY2xvc2VPcGVuSW5kZXhlc1xuXHRcdCMgd2h5IGRpZmZlcmVudGlhdGUgYmV0d2VlbiBpbmRleCBhbmQgW11cblx0XHR2YXIgY29uZGl0aW9uID0gZG8gfHRva2VuLCBpfCB0b2tlbi5AdHlwZSA9PT0gJ10nIG9yIHRva2VuLkB0eXBlID09PSAnSU5ERVhfRU5EJ1xuXHRcdHZhciBhY3Rpb24gICAgPSBkbyB8dG9rZW4sIGl8IHRva2VuLkB0eXBlID0gJ0lOREVYX0VORCdcblx0XHRcblx0XHRzY2FuVG9rZW5zIGRvIHx0b2tlbixpLHRva2Vuc3xcblx0XHRcdGRldGVjdEVuZChpICsgMSwgY29uZGl0aW9uLCBhY3Rpb24pIGlmIHRva2VuLkB0eXBlID09PSAnSU5ERVhfU1RBUlQnXG5cdFx0XHRyZXR1cm4gMVxuXG5cdCMgVGhlIGxleGVyIGhhcyB0YWdnZWQgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMgb2YgYW4gaW5kZXhpbmcgb3BlcmF0aW9uIGNhbGwuXG5cdCMgTWF0Y2ggaXQgd2l0aCBpdHMgcGFpcmVkIGNsb3NlLiBTaG91bGQgYmUgZG9uZSBpbiBsZXhlciBkaXJlY3RseVxuXHRkZWYgY2xvc2VPcGVuVGFnc1xuXHRcdHZhciBjb25kaXRpb24gPSBkbyB8dG9rZW4sIGl8IHRva2VuLkB0eXBlID09ICc+JyBvciB0b2tlbi5AdHlwZSA9PSAnVEFHX0VORCdcblx0XHR2YXIgYWN0aW9uICAgID0gZG8gfHRva2VuLCBpfCB0b2tlbi5AdHlwZSA9ICdUQUdfRU5EJ1xuXG5cdFx0c2NhblRva2VucyBkbyB8dG9rZW4saSx0b2tlbnN8XG5cdFx0XHRkZXRlY3RFbmQoaSArIDEsIGNvbmRpdGlvbiwgYWN0aW9uKSBpZiB0b2tlbi5AdHlwZSA9PT0gJ1RBR19TVEFSVCdcblx0XHRcdHJldHVybiAxXG5cblx0ZGVmIGFkZEltcGxpY2l0QmxvY2tDYWxsc1xuXHRcdHZhciBpID0gMVxuXHRcdHZhciB0b2tlbnMgPSBAdG9rZW5zXG5cblx0XHQjIGNhbiB1c2Ugc2hhcmVkIHN0YXRlcyBmb3IgdGhlc2Vcblx0XHR3aGlsZSBpIDwgdG9rZW5zOmxlbmd0aFxuXG5cdFx0XHR2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblx0XHRcdHZhciB0ID0gdG9rZW4uQHR5cGVcblx0XHRcdHZhciB2ID0gdG9rZW4uQHZhbHVlXG5cdFx0XHQjIGhtbVxuXHRcdFx0aWYgdCA9PSAnRE8nIGFuZCAodiA9PSAnSU5ERVhfRU5EJyBvciB2ID09ICdJREVOVElGSUVSJyBvciB2ID09ICdORVcnKVxuXHRcdFx0XHR0b2tlbnMuc3BsaWNlIGkgKyAxLCAwLCBULnRva2VuKCdDQUxMX0VORCcsJyknKVxuXHRcdFx0XHR0b2tlbnMuc3BsaWNlIGkgKyAxLCAwLCBULnRva2VuKCdDQUxMX1NUQVJUJywnKCcpXG5cdFx0XHRcdGkrK1xuXHRcdFx0aSsrXG5cblx0XHRyZXR1cm5cblxuXHQjIE9iamVjdCBsaXRlcmFscyBtYXkgYmUgd3JpdHRlbiB3aXRoIGltcGxpY2l0IGJyYWNlcywgZm9yIHNpbXBsZSBjYXNlcy5cblx0IyBJbnNlcnQgdGhlIG1pc3NpbmcgYnJhY2VzIGhlcmUsIHNvIHRoYXQgdGhlIHBhcnNlciBkb2Vzbid0IGhhdmUgdG8uXG5cblx0ZGVmIGFkZExlZnRCcmFjZVxuXHRcdHNlbGZcblxuXHRkZWYgYWRkSW1wbGljaXRCcmFjZXNcblx0XHR2YXIgc3RhY2sgICAgICAgPSBbXVxuXHRcdHZhciBzdGFydCAgICAgICA9IG51bGxcblx0XHR2YXIgc3RhcnRJbmRlbnQgPSAwXG5cdFx0dmFyIHN0YXJ0SWR4ID0gbnVsbFxuXHRcdHZhciBiYXNlQ3R4ID0gWydST09UJywwXVxuXG5cdFx0dmFyIG5vQnJhY2VDb250ZXh0ID0gWydJRicsJ1RFUk5BUlknLCdGT1InXVxuXG5cdFx0dmFyIG5vQnJhY2UgPSBub1xuXG5cdFx0dmFyIGFjdGlvbiA9IGRvIHx0b2tlbixpfFxuXHRcdFx0QHRva2Vucy5zcGxpY2UgaSwgMCwgVC5SQlJBQ0tFVFxuXG5cdFx0dmFyIG9wZW4gPSBkbyB8dG9rZW4saXxcblx0XHRcdEB0b2tlbnMuc3BsaWNlIGksIDAsIFQuTEJSQUNLRVRcblxuXHRcdHZhciBjbG9zZSA9IGRvIHx0b2tlbixpfFxuXHRcdFx0QHRva2Vucy5zcGxpY2UgaSwgMCwgVC5SQlJBQ0tFVFxuXG5cdFx0dmFyIHN0YWNrVG9rZW4gPSBkbyB8YSxifFxuXHRcdFx0cmV0dXJuIFthLGJdXG5cblx0XHQjIG1ldGhvZCBpcyBjYWxsZWQgc28gbWFueSB0aW1lc1xuXHRcdHNjYW5Ub2tlbnMgZG8gfHRva2VuLGksdG9rZW5zfFxuXHRcdFx0dmFyIHR5cGUgPSB0b2tlbi5AdHlwZVxuXHRcdFx0dmFyIHYgPSB0b2tlbi5AdmFsdWVcblxuXHRcdFx0dmFyIGN0eCA9IHN0YWNrOmxlbmd0aCA/IHN0YWNrW3N0YWNrOmxlbmd0aCAtIDFdIDogYmFzZUN0eFxuXHRcdFx0dmFyIGlkeFxuXG5cdFx0XHRpZiBub0JyYWNlQ29udGV4dC5pbmRleE9mKHR5cGUpID49IDBcblx0XHRcdFx0c3RhY2sucHVzaCBzdGFja1Rva2VuKHR5cGUsaSlcblx0XHRcdFx0cmV0dXJuIDFcblxuXHRcdFx0aWYgdiA9PSAnPydcblx0XHRcdFx0c3RhY2sucHVzaCBzdGFja1Rva2VuKCdURVJOQVJZJyxpKVxuXHRcdFx0XHRyZXR1cm4gMVxuXHRcdFx0XG5cdFx0XHQjIG5vIG5lZWQgdG8gdGVzdCBmb3IgdGhpcyBoZXJlIGFzIHdlbGwgYXMgaW5cblx0XHRcdGlmIEVYUFJFU1NJT05fU1RBUlRbdHlwZV1cblx0XHRcdFx0aWYgdHlwZSA9PT0gSU5ERU5UIGFuZCBub0JyYWNlQ29udGV4dC5pbmRleE9mKGN0eFswXSkgPj0gMFxuXHRcdFx0XHRcdHN0YWNrLnBvcFxuXG5cdFx0XHRcdGlmIHR5cGUgPT09IElOREVOVCBhbmQgdG9rZW5UeXBlKGkgLSAxKSA9PSAneydcblx0XHRcdFx0XHRzdGFjay5wdXNoIHN0YWNrVG9rZW4oJ3snLCBpKSAjIHNob3VsZCBub3QgYXV0b2dlbmVyYXRlIGFub3RoZXI/XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRzdGFjay5wdXNoIHN0YWNrVG9rZW4odHlwZSwgaSlcblx0XHRcdFx0cmV0dXJuIDFcblxuXHRcdFx0aWYgRVhQUkVTU0lPTl9FTkRbdHlwZV1cblx0XHRcdFx0aWYgY3R4WzBdID09ICdURVJOQVJZJ1xuXHRcdFx0XHRcdHN0YWNrLnBvcFxuXG5cdFx0XHRcdHN0YXJ0ID0gc3RhY2sucG9wXG5cdFx0XHRcdHN0YXJ0WzJdID0gaVxuXG5cdFx0XHRcdCMgc2VlbXMgbGlrZSB0aGUgc3RhY2sgc2hvdWxkIHVzZSB0b2tlbnMsIG5vPylcblx0XHRcdFx0aWYgc3RhcnRbMF0gPT0gJ3snIGFuZCBzdGFydDpnZW5lcmF0ZWRcblx0XHRcdFx0XHRjbG9zZSh0b2tlbixpKVxuXHRcdFx0XHRcdHJldHVybiAxXG5cblx0XHRcdFx0cmV0dXJuIDFcblx0XHRcdFxuXHRcdFx0IyBpcyB0aGlzIGNvcnJlY3Q/IHNhbWUgZm9yIGlmL2NsYXNzIGV0Yz9cblx0XHRcdGlmIGN0eFswXSA9PSAnVEVSTkFSWScgYW5kICh0eXBlID09PSBURVJNSU5BVE9SIG9yIHR5cGUgPT09IE9VVERFTlQpXG5cdFx0XHRcdHN0YWNrLnBvcFxuXHRcdFx0XHRyZXR1cm4gMVxuXG5cdFx0XHRpZiBub0JyYWNlQ29udGV4dC5pbmRleE9mKGN0eFswXSkgPj0gMCBhbmQgdHlwZSA9PT0gSU5ERU5UXG5cdFx0XHRcdHN0YWNrLnBvcFxuXHRcdFx0XHRyZXR1cm4gMVxuXG5cblx0XHRcdGlmIHR5cGUgPT0gJywnXG5cdFx0XHRcdGlmIGN0eFswXSA9PSAneycgYW5kIGN0eDpnZW5lcmF0ZWRcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKGksIDAsIFQuUkJSQUNLRVQpXG5cdFx0XHRcdFx0c3RhY2sucG9wXG5cdFx0XHRcdFx0cmV0dXJuIDJcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHJldHVybiAxXG5cdFx0XHRcdHRydWVcblxuXHRcdFx0IyBmb3VuZCBhIHR5cGVcblx0XHRcdGlmIHR5cGUgPT0gJzonIGFuZCBjdHhbMF0gIT0gJ3snIGFuZCBjdHhbMF0gIT0gJ1RFUk5BUlknIGFuZCAobm9CcmFjZUNvbnRleHQuaW5kZXhPZihjdHhbMF0pID09IC0xKVxuXHRcdFx0XHQjIGNvdWxkIGp1c3QgY2hlY2sgaWYgdGhlIGVuZCB3YXMgcmlnaHQgYmVmb3JlIHRoaXM/XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiBzdGFydCBhbmQgc3RhcnRbMl0gPT0gaSAtIDFcblx0XHRcdFx0XHRpZHggPSBzdGFydFsxXSAtIDEgIyB0aGVzZSBhcmUgdGhlIHN0YWNrVG9rZW5zXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRpZHggPSBpIC0gMiAjIGlmIHN0YXJ0IHRoZW4gc3RhcnRbMV0gLSAxIGVsc2UgaSAtIDJcblx0XHRcdFx0XHQjIGlkeCA9IGlkeCAtIDEgaWYgdG9rZW5UeXBlKGlkeCkgaXMgVEVSTUlOQVRPUlxuXG5cdFx0XHRcdHdoaWxlIHRva2VuVHlwZShpZHggLSAxKSA9PT0gJ0hFUkVDT01NRU5UJ1xuXHRcdFx0XHRcdGlkeCAtPSAyXG5cblx0XHRcdFx0dmFyIHQwID0gdG9rZW5zW2lkeCAtIDFdXG5cblx0XHRcdFx0aWYgdDAgYW5kIFQudHlwKHQwKSA9PSAnfScgYW5kIHQwOmdlbmVyYXRlZFxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoaWR4IC0gMSwxKVxuXHRcdFx0XHRcdHZhciBzID0gc3RhY2tUb2tlbigneycpXG5cdFx0XHRcdFx0czpnZW5lcmF0ZWQgPSB5ZXNcblx0XHRcdFx0XHRzdGFjay5wdXNoIHNcblx0XHRcdFx0XHRyZXR1cm4gMFxuXG5cdFx0XHRcdCMgaGFja3kgZWRnZWNhc2UgZm9yIGluZGVudHNcblx0XHRcdFx0ZWxpZiB0MCBhbmQgVC50eXAodDApID09ICcsJyBhbmQgdG9rZW5UeXBlKGlkeCAtIDIpID09ICd9J1xuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoaWR4IC0gMiwxKVxuXHRcdFx0XHRcdHZhciBzID0gc3RhY2tUb2tlbigneycpXG5cdFx0XHRcdFx0czpnZW5lcmF0ZWQgPSB5ZXNcblx0XHRcdFx0XHRzdGFjay5wdXNoIHNcblx0XHRcdFx0XHRyZXR1cm4gMFxuXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR2YXIgcyA9IHN0YWNrVG9rZW4oJ3snKVxuXHRcdFx0XHRcdHM6Z2VuZXJhdGVkID0geWVzXG5cdFx0XHRcdFx0c3RhY2sucHVzaCBzXG5cdFx0XHRcdFx0b3Blbih0b2tlbixpZHggKyAxKVxuXHRcdFx0XHRcdHJldHVybiAyXG5cblx0XHRcdCMgd2UgcHJvYmFibHkgbmVlZCB0byBydW4gdGhyb3VnaCBhdXRvY2FsbCBmaXJzdD8hXG5cblx0XHRcdGlmIHR5cGUgPT0gJ0RPJyAjIGFuZCBjdHg6Z2VuZXJhdGVkXG5cdFx0XHRcdHZhciBwcmV2ID0gVC50eXAodG9rZW5zW2kgLSAxXSlcblx0XHRcdFx0aWYgWydOVU1CRVInLCdTVFJJTkcnLCdSRUdFWCcsJ1NZTUJPTCcsJ10nLCd9JywnKScsJ1NUUklOR19FTkQnXS5pbmRleE9mKHByZXYpID49IDBcblxuXHRcdFx0XHRcdHZhciB0b2sgPSBULnRva2VuKCcsJywgJywnKVxuXHRcdFx0XHRcdHRvazpnZW5lcmF0ZWQgPSB5ZXNcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKGksMCx0b2spXG5cblx0XHRcdFx0XHRpZiBjdHg6Z2VuZXJhdGVkXG5cdFx0XHRcdFx0XHRjbG9zZSh0b2tlbixpKVxuXHRcdFx0XHRcdFx0c3RhY2sucG9wXG5cdFx0XHRcdFx0XHRyZXR1cm4gMlxuXG5cdFx0XHRpZiBjdHg6Z2VuZXJhdGVkIGFuZCAodHlwZSA9PT0gVEVSTUlOQVRPUiBvciB0eXBlID09PSBPVVRERU5UIG9yIHR5cGUgPT09ICdERUZfQk9EWScpXG5cdFx0XHRcdGNsb3NlKHRva2VuLGkpXG5cdFx0XHRcdHN0YWNrLnBvcFxuXHRcdFx0XHRyZXR1cm4gMlxuXG5cdFx0XHRyZXR1cm4gMVxuXG5cdCMgTWV0aG9kcyBtYXkgYmUgb3B0aW9uYWxseSBjYWxsZWQgd2l0aG91dCBwYXJlbnRoZXNlcywgZm9yIHNpbXBsZSBjYXNlcy5cblx0IyBJbnNlcnQgdGhlIGltcGxpY2l0IHBhcmVudGhlc2VzIGhlcmUsIHNvIHRoYXQgdGhlIHBhcnNlciBkb2Vzbid0IGhhdmUgdG9cblx0IyBkZWFsIHdpdGggdGhlbS5cblx0IyBQcmFjdGljYWxseSBldmVyeXRoaW5nIHdpbGwgbm93IGJlIGNhbGxhYmxlIHRoaXMgd2F5IChldmVyeSBpZGVudGlmaWVyKVxuXHRkZWYgYWRkSW1wbGljaXRQYXJlbnRoZXNlc1xuXHRcdHZhciB0b2tlbnMgPSBAdG9rZW5zXG5cblx0XHR2YXIgbm9DYWxsID0gbm9cblx0XHR2YXIgc2VlbkZvciA9IG5vXG5cdFx0dmFyIGVuZENhbGxBdFRlcm1pbmF0b3IgPSBub1xuXG5cdFx0dmFyIHNlZW5TaW5nbGUgID0gbm9cblx0XHR2YXIgc2VlbkNvbnRyb2wgPSBub1xuXG5cdFx0dmFyIGNhbGxPYmplY3QgPSBub1xuXHRcdHZhciBjYWxsSW5kZW50ID0gbm9cblxuXHRcdHZhciBwYXJlbnNBY3Rpb24gPSBkbyB8dG9rZW4saSx0b2tlbnN8XG5cdFx0XHR0b2tlbnMuc3BsaWNlIGksIDAsIFQudG9rZW4oJ0NBTExfRU5EJywgJyknKVxuXG5cdFx0IyBmdW5jdGlvbiB3aWxsIG5vdCBiZSBvcHRpbWl6ZWQgaW4gc2luZ2xlIHJ1blxuXHRcdCMgY291bGQgdHJvIHRvIG1vdmUgdGhpcyBvdXRcblx0XHR2YXIgcGFyZW5zQ29uZCA9IGRvIHx0b2tlbixpLHRva2Vuc3xcblx0XHRcdFxuXHRcdFx0dmFyIHR5cGUgPSB0b2tlbi5AdHlwZVxuXG5cdFx0XHRpZiAhc2VlblNpbmdsZSBhbmQgdG9rZW46ZnJvbVRoZW5cblx0XHRcdFx0cmV0dXJuIHllc1xuXG5cdFx0XHR2YXIgaWZlbHNlID0gdHlwZSA9PSAnSUYnIG9yIHR5cGUgPT0gJ1VOTEVTUycgb3IgdHlwZSA9PSAnRUxTRSdcblxuXHRcdFx0aWYgaWZlbHNlIG9yIHR5cGUgPT09ICdDQVRDSCdcblx0XHRcdFx0c2VlblNpbmdsZSAgPSB5ZXNcblxuXHRcdFx0aWYgaWZlbHNlIG9yIHR5cGUgPT09ICdTV0lUQ0gnIG9yIHR5cGUgPT0gJ1RSWSdcblx0XHRcdFx0c2VlbkNvbnRyb2wgPSB5ZXMgXG5cblx0XHRcdHZhciBwcmV2ID0gdG9rZW5UeXBlKGkgLSAxKVxuXG5cdFx0XHRpZiAodHlwZSA9PSAnLicgb3IgdHlwZSA9PSAnPy4nIG9yIHR5cGUgPT0gJzo6JykgYW5kIHByZXYgPT09IE9VVERFTlRcblx0XHRcdFx0cmV0dXJuIHllc1xuXG5cdFx0XHRpZiBlbmRDYWxsQXRUZXJtaW5hdG9yIGFuZCAodHlwZSA9PT0gSU5ERU5UIG9yIHR5cGUgPT09IFRFUk1JTkFUT1IpXG5cdFx0XHRcdHJldHVybiB5ZXNcblxuXHRcdFx0aWYgKHR5cGUgPT0gJ1dIRU4nIG9yIHR5cGUgPT0gJ0JZJykgYW5kICFzZWVuRm9yXG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJkb250IGNsb3NlIGltcGxpY2l0IGNhbGwgb3V0c2lkZSBmb3JcIlxuXHRcdFx0XHRyZXR1cm4gbm8gXG5cblx0XHRcdHZhciBwb3N0ID0gdG9rZW5zOmxlbmd0aCA+IChpICsgMSkgPyB0b2tlbnNbaSArIDFdIDogbnVsbFxuXHRcdFx0dmFyIHBvc3RUeXAgPSBwb3N0IGFuZCBwb3N0LkB0eXBlXG5cblx0XHRcdGlmIHRva2VuOmdlbmVyYXRlZCBvciBwcmV2ID09PSAnLCdcblx0XHRcdFx0cmV0dXJuIG5vXG5cblx0XHRcdHZhciBjb25kMSA9IChJTVBMSUNJVF9FTkRfTUFQW3R5cGVdIG9yICh0eXBlID09IElOREVOVCBhbmQgIXNlZW5Db250cm9sKSBvciAodHlwZSA9PSAnRE9TJyBhbmQgcHJldiAhPSAnPScpKVxuXG5cdFx0XHR1bmxlc3MgY29uZDFcblx0XHRcdFx0cmV0dXJuIG5vXG5cblx0XHRcdGlmIHR5cGUgIT09IElOREVOVFxuXHRcdFx0XHRyZXR1cm4geWVzXG5cblx0XHRcdGlmICFJTVBMSUNJVF9CTE9DS19NQVBbcHJldl0gJiYgdG9rZW5UeXBlKGkgLSAyKSAhPSAnQ0xBU1MnICYmICEocG9zdCAmJiAoKHBvc3Q6Z2VuZXJhdGVkICYmIHBvc3RUeXAgPT0gJ3snKSB8fCBJTVBMSUNJVF9DQUxMX01BUFtwb3N0VHlwXSkpXG5cdFx0XHRcdHJldHVybiB5ZXNcblxuXHRcdFx0cmV0dXJuIG5vXG5cblx0XHR2YXIgaSA9IDBcblxuXHRcdHdoaWxlIHRva2VuczpsZW5ndGggPiAoaSArIDEpXG5cdFx0XHR2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblx0XHRcdHZhciB0eXBlID0gdG9rZW4uQHR5cGVcblxuXHRcdFx0dmFyIHByZXYgICAgPSBpID4gMCA/IHRva2Vuc1tpIC0gMV0gOiBudWxsXG5cdFx0XHR2YXIgbmV4dCAgICA9IHRva2Vuc1tpICsgMV1cblxuXHRcdFx0dmFyIHB0ID0gcHJldiBhbmQgcHJldi5AdHlwZVxuXHRcdFx0dmFyIG50ID0gbmV4dCBhbmQgbmV4dC5AdHlwZVxuXG5cdFx0XHRpZiB0eXBlID09PSBJTkRFTlQgYW5kIChwdCA9PSAnKScgb3IgcHQgPT0gJ10nKVxuXHRcdFx0XHRub0NhbGwgPSB5ZXNcblxuXHRcdFx0aWYgTk9fQ0FMTF9UQUdfTUFQW3B0XSAjIC5pbmRleE9mKHB0KSA+PSAwXG5cdFx0XHRcdCMgQ0FMTENPVU5UKytcblx0XHRcdFx0IyBjb25zb2xlLmxvZyhcInNlZW4gbm9jYWxsIHRhZyB7cHR9ICh7cHR9IHt0eXBlfSB7bnR9KVwiKVxuXHRcdFx0XHRlbmRDYWxsQXRUZXJtaW5hdG9yID0geWVzXG5cdFx0XHRcdG5vQ2FsbCAgPSB5ZXNcblx0XHRcdFx0aWYgcHQgPT0gJ0ZPUidcblx0XHRcdFx0XHRzZWVuRm9yID0geWVzXG5cblx0XHRcdGNhbGxPYmplY3QgPSBub1xuXHRcdFx0Y2FsbEluZGVudCA9IG5vXG5cblx0XHRcdGlmICFub0NhbGwgYW5kIHR5cGUgPT0gSU5ERU5UIGFuZCBuZXh0XG5cdFx0XHRcdHZhciBwcmV2SW1wRnVuYyA9IHB0IGFuZCBJTVBMSUNJVF9GVU5DX01BUFtwdF1cblx0XHRcdFx0dmFyIG5leHRJbXBDYWxsID0gbnQgYW5kIElNUExJQ0lUX0NBTExfTUFQW250XVxuXG5cdFx0XHRcdGNhbGxPYmplY3QgPSAoKG5leHQ6Z2VuZXJhdGVkIGFuZCBudCA9PSAneycpIG9yIG5leHRJbXBDYWxsKSBhbmQgcHJldkltcEZ1bmNcblx0XHRcdFx0Y2FsbEluZGVudCA9IG5leHRJbXBDYWxsIGFuZCBwcmV2SW1wRnVuY1xuXG5cdFx0XHRzZWVuU2luZ2xlICA9IG5vXG5cdFx0XHRzZWVuQ29udHJvbCA9IG5vXG5cblx0XHRcdCMgdGhpcyBpcyBub3QgY29ycmVjdCBpZiB0aGlzIGlzIGluc2lkZSBhIGJsb2NrLG5vP1xuXHRcdFx0aWYgKHR5cGUgPT0gVEVSTUlOQVRPUiBvciB0eXBlID09IE9VVERFTlQgb3IgdHlwZSA9PSBJTkRFTlQpXG5cdFx0XHRcdGVuZENhbGxBdFRlcm1pbmF0b3IgPSBub1xuXHRcdFx0XHRub0NhbGwgPSBubyBcblxuXHRcdFx0aWYgdHlwZSA9PSAnPycgYW5kIHByZXYgYW5kICFwcmV2OnNwYWNlZFxuXHRcdFx0XHR0b2tlbjpjYWxsID0geWVzXG5cblx0XHRcdCMgd2hlcmUgZG9lcyBmcm9tVGhlbSBjb21lIGZyb20/XG5cdFx0XHRpZiB0b2tlbjpmcm9tVGhlblxuXHRcdFx0XHRjb250aW51ZSBpICs9IDEgXG5cblx0XHRcdCMgaGVyZSB3ZSBkZWFsIHdpdGggOnNwYWNlZCBhbmQgOm5ld0xpbmVcblx0XHRcdHVubGVzcyBjYWxsT2JqZWN0IG9yIGNhbGxJbmRlbnQgb3IgKHByZXYgYW5kIHByZXY6c3BhY2VkKSBhbmQgKHByZXY6Y2FsbCBvciBJTVBMSUNJVF9GVU5DX01BUFtwdF0pIGFuZCAoSU1QTElDSVRfQ0FMTF9NQVBbdHlwZV0gb3IgISh0b2tlbjpzcGFjZWQgb3IgdG9rZW46bmV3TGluZSkgYW5kIElNUExJQ0lUX1VOU1BBQ0VEX0NBTEwuaW5kZXhPZih0eXBlKSA+PSAwKVxuXHRcdFx0XHRjb250aW51ZSBpICs9IDFcblxuXHRcdFx0IyBjYWNoZSB3aGVyZSB3ZSB3YW50IHRvIHNwbGljZSAtLSBhZGQgdGhlbSBsYXRlclxuXHRcdFx0dG9rZW5zLnNwbGljZSBpLCAwLCBULnRva2VuKCdDQUxMX1NUQVJUJywgJygnKVxuXHRcdFx0IyBDQUxMQ09VTlQrK1xuXG5cdFx0XHRkZXRlY3RFbmQoaSArIDEsIHBhcmVuc0NvbmQsIHBhcmVuc0FjdGlvbilcblxuXHRcdFx0aWYgcHJldi5AdHlwZSA9PSAnPydcblx0XHRcdFx0cHJldi5AdHlwZSAgPSAnRlVOQ19FWElTVCdcblxuXHRcdFx0aSArPSAyXG5cblx0XHRcdCMgbmVlZCB0byByZXNldCBhZnRlciBhIG1hdGNoXG5cdFx0XHRlbmRDYWxsQXRUZXJtaW5hdG9yID0gbm9cblx0XHRcdG5vQ2FsbCA9IG5vXG5cdFx0XHRzZWVuRm9yID0gbm9cblxuXHRcdHJldHVyblxuXG5cblxuXHRkZWYgaW5kZW50Q29uZGl0aW9uIHRva2VuLGksdG9rZW5zXG5cdFx0dmFyIHQgPSB0b2tlbi5AdHlwZVxuXHRcdFNJTkdMRV9DTE9TRVJTX01BUFt0XSBhbmQgdG9rZW4uQHZhbHVlICE9PSAnOycgYW5kIG5vdCAodCA9PSAnRUxTRScgYW5kIEBzdGFydGVyICE9ICdJRicgYW5kIEBzdGFydGVyICE9ICdUSEVOJylcblxuXHRkZWYgaW5kZW50QWN0aW9uIHRva2VuLCBpLCB0b2tlbnNcblx0XHR2YXIgaWR4ID0gdG9rZW5UeXBlKGkgLSAxKSA9PT0gJywnID8gKGkgLSAxKSA6IGlcblx0XHR0b2tlbnMuc3BsaWNlIGlkeCwgMCwgVC5PVVRERU5UXG5cdFx0cmV0dXJuXG5cblxuXHQjIEJlY2F1c2Ugb3VyIGdyYW1tYXIgaXMgTEFMUigxKSwgaXQgY2FuJ3QgaGFuZGxlIHNvbWUgc2luZ2xlLWxpbmVcblx0IyBleHByZXNzaW9ucyB0aGF0IGxhY2sgZW5kaW5nIGRlbGltaXRlcnMuIFRoZSAqKlJld3JpdGVyKiogYWRkcyB0aGUgaW1wbGljaXRcblx0IyBibG9ja3MsIHNvIGl0IGRvZXNuJ3QgbmVlZCB0by4gJyknIGNhbiBjbG9zZSBhIHNpbmdsZS1saW5lIGJsb2NrLFxuXHQjIGJ1dCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBpdCdzIGJhbGFuY2VkLlxuXHRkZWYgYWRkSW1wbGljaXRJbmRlbnRhdGlvblxuXG5cdFx0dmFyIGxvb2t1cDEgPVxuXHRcdFx0T1VUREVOVDogMVxuXHRcdFx0VEVSTUlOQVRPUjogMVxuXHRcdFx0RklOQUxMWTogMVxuXG5cdFx0dmFyIGkgPSAwXG5cdFx0dmFyIHRva2VucyA9IEB0b2tlbnNcblx0XHR2YXIgc3RhcnRlciBcblxuXHRcdHdoaWxlIGkgPCB0b2tlbnM6bGVuZ3RoXG5cdFx0XHR2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblx0XHRcdHZhciB0eXBlID0gdG9rZW4uQHR5cGVcblx0XHRcdHZhciBuZXh0ID0gdG9rZW5UeXBlKGkgKyAxKVxuXG5cdFx0XHQjIHdoeSBhcmUgd2UgcmVtb3ZpbmcgdGVybWluYXRvcnMgYWZ0ZXIgdGhlbj8gc2hvdWxkIGJlIGFibGUgdG8gaGFuZGxlXG5cdFx0XHRpZiB0eXBlID09PSBURVJNSU5BVE9SIGFuZCBuZXh0ID09PSBUSEVOXG5cdFx0XHRcdHRva2Vucy5zcGxpY2UoaSwgMSlcblx0XHRcdFx0Y29udGludWVcblxuXHRcdFx0aWYgdHlwZSA9PT0gQ0FUQ0ggYW5kIGxvb2t1cDFbdG9rZW5UeXBlKGkgKyAyKV1cblx0XHRcdFx0dG9rZW5zLnNwbGljZSBpICsgMiwgMCwgVC50b2tlbihJTkRFTlQsICcyJyksIFQudG9rZW4oT1VUREVOVCwgJzInKVxuXHRcdFx0XHRpICs9IDRcblx0XHRcdFx0Y29udGludWVcblxuXHRcdFx0aWYgU0lOR0xFX0xJTkVSU1t0eXBlXSBhbmQgKG5leHQgIT0gSU5ERU5UIGFuZCBuZXh0ICE9ICdCTE9DS19QQVJBTV9TVEFSVCcpIGFuZCAhKHR5cGUgPT0gJ0VMU0UnIGFuZCBuZXh0ID09ICdJRicpIGFuZCB0eXBlICE9ICdFTElGJ1xuXHRcdFx0XHRAc3RhcnRlciA9IHN0YXJ0ZXIgPSB0eXBlXG5cblx0XHRcdFx0dmFyIGluZGVudCA9IFQudG9rZW4oSU5ERU5ULCAnMicpXG5cdFx0XHRcdGluZGVudDpmcm9tVGhlbiAgID0gdHJ1ZSBpZiBzdGFydGVyID09PSBUSEVOXG5cdFx0XHRcdGluZGVudDpnZW5lcmF0ZWQgID0gdHJ1ZVxuXHRcdFx0XHR0b2tlbnMuc3BsaWNlIGkgKyAxLCAwLCBpbmRlbnRcblx0XHRcdFx0ZGV0ZWN0RW5kKGkgKyAyLCBzZWxmOmluZGVudENvbmRpdGlvbiwgc2VsZjppbmRlbnRBY3Rpb24pXG5cdFx0XHRcdHRva2Vucy5zcGxpY2UgaSwgMSBpZiB0eXBlID09PSBUSEVOXG5cdFx0XHRpKytcblxuXHRcdHJldHVyblxuXG5cdCMgVGFnIHBvc3RmaXggY29uZGl0aW9uYWxzIGFzIHN1Y2gsIHNvIHRoYXQgd2UgY2FuIHBhcnNlIHRoZW0gd2l0aCBhXG5cdCMgZGlmZmVyZW50IHByZWNlZGVuY2UuXG5cdGRlZiB0YWdQb3N0Zml4Q29uZGl0aW9uYWxzXG5cdFx0dmFyIGNvbmRpdGlvbiA9IGRvIHx0b2tlbixpLHRva2Vuc3wgdG9rZW4uQHR5cGUgPT09IFRFUk1JTkFUT1Igb3IgdG9rZW4uQHR5cGUgPT09IElOREVOVFxuXHRcdHZhciBhY3Rpb24gPSBkbyB8dG9rZW4saSx0b2tlbnMsc3xcblx0XHRcdFQuc2V0VHlwKHM6b3JpZ2luYWwsICdQT1NUXycgKyBzOm9yaWdpbmFsLkB0eXBlKSBpZiB0b2tlbi5AdHlwZSAhPSBJTkRFTlRcblxuXHRcdHNjYW5Ub2tlbnMgZG8gfHRva2VuLCBpLCB0b2tlbnN8XG5cdFx0XHR2YXIgdHlwID0gdG9rZW4uQHR5cGVcblx0XHRcdHJldHVybiAxIHVubGVzcyB0eXAgPT0gJ0lGJyBvciB0eXAgPT0gJ0ZPUidcblx0XHRcdGRldGVjdEVuZChpICsgMSwgY29uZGl0aW9uLGFjdGlvbixvcmlnaW5hbDogdG9rZW4pXG5cdFx0XHQxXG5cblx0IyBMb29rIHVwIGEgdHlwZSBieSB0b2tlbiBpbmRleC5cblx0ZGVmIHR5cGUgaSBcblx0XHQjIGlmIGkgPCAwIHRoZW4gcmV0dXJuIG51bGxcblx0XHR0aHJvdyBcImRlcHJlY2F0ZWRcIlxuXHRcdHZhciB0b2sgPSBAdG9rZW5zW2ldXG5cdFx0dG9rIGFuZCB0b2suQHR5cGVcblxuXHRkZWYgaW5qZWN0VG9rZW4gaW5kZXgsIHRva2VuXG5cdFx0c2VsZlxuXG5cdGRlZiB0b2tlblR5cGUgaVxuXHRcdGlmIGkgPCAwIG9yIGkgPj0gQHRva2VuczpsZW5ndGhcblx0XHRcdCMgQ0FMTENPVU5UKytcblx0XHRcdHJldHVybiBudWxsXG5cblx0XHR2YXIgdG9rID0gQHRva2Vuc1tpXVxuXHRcdHRvayBhbmQgdG9rLkB0eXBlXG5cbiMgQ29uc3RhbnRzXG4jIC0tLS0tLS0tLVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2ltYmEvc3JjL2NvbXBpbGVyL3Jld3JpdGVyLmltYmEiLCIvKiBwYXJzZXIgZ2VuZXJhdGVkIGJ5IGppc29uLWZvcmsgKi9cbnZhciBwYXJzZXIgPSAoZnVuY3Rpb24oKXtcbnZhciBvPWZ1bmN0aW9uKGssdixvLGwpe2ZvcihvPW98fHt9LGw9ay5sZW5ndGg7bC0tO29ba1tsXV09dik7cmV0dXJuIG99LCRWMD1bMSw0XSwkVjE9WzEsNl0sJFYyPVsxLDMzXSwkVjM9WzEsMzRdLCRWND1bMSwzNV0sJFY1PVsxLDM2XSwkVjY9WzEsNzddLCRWNz1bMSwxMTldLCRWOD1bMSw5NV0sJFY5PVsxLDEzMl0sJFZhPVsxLDEyNV0sJFZiPVsxLDEyNl0sJFZjPVsxLDEyN10sJFZkPVsxLDEyNF0sJFZlPVsxLDEyOF0sJFZmPVsxLDEzNV0sJFZnPVsxLDExOF0sJFZoPVsxLDEzNl0sJFZpPVsxLDgyXSwkVmo9WzEsODNdLCRWaz1bMSw4NF0sJFZsPVsxLDg1XSwkVm09WzEsODZdLCRWbj1bMSw4N10sJFZvPVsxLDg4XSwkVnA9WzEsNzVdLCRWcT1bMSwxMjJdLCRWcj1bMSwxMTddLCRWcz1bMSw5MF0sJFZ0PVsxLDczXSwkVnU9WzEsMzhdLCRWdj1bMSw2OF0sJFZ3PVsxLDY5XSwkVng9WzEsNzBdLCRWeT1bMSwxMTRdLCRWej1bMSw5Ml0sJFZBPVsxLDkzXSwkVkI9WzEsODldLCRWQz1bMSwyOV0sJFZEPVsxLDMwXSwkVkU9WzEsOThdLCRWRj1bMSw5N10sJFZHPVsxLDExNV0sJFZIPVsxLDExNl0sJFZJPVsxLDEyM10sJFZKPVsxLDEyXSwkVks9WzEsMTMwXSwkVkw9WzEsMTMxXSwkVk09WzEsOTldLCRWTj1bMSw4MF0sJFZPPVsxLDM5XSwkVlA9WzEsNDVdLCRWUT1bMSwxMTNdLCRWUj1bMSw3MV0sJFZTPVsxLDkxXSwkVlQ9WzEsMTI5XSwkVlU9WzEsNjJdLCRWVj1bMSw3Nl0sJFZXPVsxLDEwOF0sJFZYPVsxLDEwOV0sJFZZPVsxLDExMF0sJFZaPVsxLDEzM10sJFZfPVsxLDEzNF0sJFYkPVsxLDY2XSwkVjAxPVsxLDEwN10sJFYxMT1bMSw1NF0sJFYyMT1bMSw1NV0sJFYzMT1bMSw1Nl0sJFY0MT1bMSw1N10sJFY1MT1bMSw1OF0sJFY2MT1bMSw1OV0sJFY3MT1bMSwxMzhdLCRWODE9WzEsNiwxMSwxNDhdLCRWOTE9WzEsMTQwXSwkVmExPVsxLDYsMTEsMTQsMTQ4XSwkVmIxPVsxLDE0OF0sJFZjMT1bMSwxNDldLCRWZDE9WzEsMTUyXSwkVmUxPVsxLDE1M10sJFZmMT1bMSwxNDVdLCRWZzE9WzEsMTQ0XSwkVmgxPVsxLDE0Nl0sJFZpMT1bMSwxNDddLCRWajE9WzEsMTUwXSwkVmsxPVsxLDE1MV0sJFZsMT1bMSwxNTZdLCRWbTE9WzEsNiwxMCwxMSwxNCwyMyw3OSw5NywxMDQsMTE4LDEyNSwxMzYsMTQ2LDE0OCwxNTgsMTc4LDIwOCwyMDksMjIwLDIyMSwyMjIsMjI3LDIyOCwyMzcsMjQ2LDI0NywyNTAsMjUxLDI1NCwyNTUsMjU2LDI1N10sJFZuMT1bMiwyNjhdLCRWbzE9WzEsMTYzXSwkVnAxPVsxLDE2N10sJFZxMT1bMSwxNjVdLCRWcjE9WzEsMTY2XSwkVnMxPVsxLDE2OV0sJFZ0MT1bMSwxNjhdLCRWdTE9WzEsNiwxMCwxMSwxNCwyMyw5NywxMDQsMTQ4XSwkVnYxPVsxLDYsMTEsMTQsMTQ4LDIyMCwyMjIsMjI3LDIyOCwyNDZdLCRWdzE9WzEsNiwxMCwxMSwxNCwyMiwyMyw3OSw5NSw5NywxMDQsMTE3LDExOCwxMjUsMTM2LDE0NiwxNDgsMTU1LDE1OCwxNzgsMTg5LDE5MCwxOTIsMjA0LDIwOCwyMDksMjIwLDIyMSwyMjIsMjI3LDIyOCwyMzcsMjQ2LDI0NywyNTAsMjUxLDI1NCwyNTUsMjU2LDI1N10sJFZ4MT1bMiwyMzddLCRWeTE9WzEsNiwxMCwxMSwxNCwyMiwyMyw3OSw5NSw5NywxMDQsMTE3LDExOCwxMjIsMTI1LDEzNiwxNDYsMTQ4LDE1NSwxNTgsMTc4LDE4OSwxOTAsMTkyLDIwNCwyMDgsMjA5LDIyMCwyMjEsMjIyLDIyNywyMjgsMjM3LDI0NiwyNDcsMjUwLDI1MSwyNTQsMjU1LDI1NiwyNTddLCRWejE9WzIsMjMzXSwkVkExPVs2MSw2Miw5NSw5OCwxMTIsMTE3LDExOSwxMjFdLCRWQjE9WzEsMjEzXSwkVkMxPVsxLDIxOF0sJFZEMT1bMSw2LDEwLDExLDE0LDIyLDIzLDc5LDk1LDk3LDEwNCwxMTcsMTE4LDEyMiwxMjUsMTM2LDE0NiwxNDgsMTU1LDE1OCwxNzgsMTg5LDE5MCwxOTIsMjA0LDIwOCwyMDksMjIwLDIyMSwyMjIsMjI3LDIyOCwyMzcsMjQ2LDI0NywyNTAsMjUxLDI1MiwyNTMsMjU0LDI1NSwyNTYsMjU3LDI1OF0sJFZFMT1bMSwyMjhdLCRWRjE9WzEsMjI1XSwkVkcxPVsxLDIzMF0sJFZIMT1bMSwyNjhdLCRWSTE9WzEsMjY5XSwkVkoxPVs1Nyw5Nl0sJFZLMT1bMiwyNTFdLCRWTDE9WzEsMjgxXSwkVk0xPVsxLDI4MF0sJFZOMT1bOTIsOTMsOTQsOTUsOTgsOTksMTAwLDEwMSwxMDIsMTAzLDEwNywxMDldLCRWTzE9WzEsMjkzXSwkVlAxPVsxLDYsMTAsMTEsMTQsMjIsMjMsNjEsNjIsNzksOTUsOTcsOTgsMTA0LDExMiwxMTcsMTE4LDExOSwxMjEsMTIyLDEyNSwxMzYsMTQ2LDE0OCwxNTUsMTU4LDE3OCwxODksMTkwLDE5MiwyMDQsMjA4LDIwOSwyMjAsMjIxLDIyMiwyMjcsMjI4LDIzNywyNDYsMjQ3LDI1MCwyNTEsMjUyLDI1MywyNTQsMjU1LDI1NiwyNTcsMjU4XSwkVlExPVsxLDI5OV0sJFZSMT1bNTcsOTYsMTAzLDIzM10sJFZTMT1bMSw2LDEwLDExLDE0LDIyLDIzLDc1LDc3LDc4LDc5LDk1LDk3LDEwNCwxMTcsMTE4LDEyNSwxMzYsMTQ2LDE0OCwxNTUsMTU4LDE3OCwxODksMTkwLDE5MiwyMDQsMjA4LDIwOSwyMjAsMjIxLDIyMiwyMjcsMjI4LDIzNywyNDYsMjQ3LDI1MCwyNTEsMjU0LDI1NSwyNTYsMjU3XSwkVlQxPVsxLDYsMTAsMTEsMTQsMjIsMjMsNzksOTUsOTcsMTA0LDExNywxMTgsMTI1LDEzNiwxNDYsMTQ4LDE1NSwxNTgsMTc4LDE4OSwxOTAsMTkyLDIwNCwyMDgsMjA5LDIxNSwyMTYsMjIwLDIyMSwyMjIsMjI3LDIyOCwyMzcsMjQwLDI0MiwyNDUsMjQ2LDI0NywyNTAsMjUxLDI1NCwyNTUsMjU2LDI1N10sJFZVMT1bNTcsNjEsNjIsNjZdLCRWVjE9WzEsMzMxXSwkVlcxPVsxLDMzMl0sJFZYMT1bMSw2LDEwLDExLDE0LDIzLDc5LDk3LDEwNCwxMTgsMTI1LDE0NiwxNDgsMTU4LDIwOCwyMDksMjIwLDIyMSwyMjIsMjI3LDIyOCwyMzcsMjQ2XSwkVlkxPVsxLDYsMTAsMTEsMTQsMjMsNzksOTcsMTA0LDExOCwxMjUsMTM2LDE0NiwxNDgsMTU4LDE3OCwyMDgsMjA5LDIyMCwyMjEsMjIyLDIyNywyMjgsMjM3LDI0NiwyNDcsMjUwLDI1MSwyNTQsMjU1LDI1N10sJFZaMT1bMSwzNDZdLCRWXzE9WzEsMzUwXSwkViQxPVsxLDYsMTEsMTQsMjMsNzksOTcsMTA0LDExOCwxMjUsMTM2LDE0NiwxNDgsMTU4LDE3OCwyMDgsMjA5LDIyMCwyMjEsMjIyLDIyNywyMjgsMjM3LDI0NiwyNDcsMjUwLDI1MSwyNTQsMjU1LDI1NiwyNTddLCRWMDI9WzEsNiwxMCwxMSwxNCwyMiwyMyw3OSw5Niw5NywxMDQsMTE4LDEyNSwxMzYsMTQ2LDE0OCwxNTgsMTc4LDIwOCwyMDksMjIwLDIyMSwyMjIsMjI3LDIyOCwyMzcsMjQ2LDI0NywyNTAsMjUxLDI1NCwyNTUsMjU2LDI1N10sJFYxMj1bMTQsMjldLCRWMjI9WzEsNiwxMSwxNCwyOSwxNDgsMjIwLDIyMiwyMjcsMjI4LDI0Nl0sJFYzMj1bMiwyODldLCRWNDI9WzEsNiwxMCwxMSwxNCwyMiwyMyw3OSw5NSw5NywxMDQsMTE3LDExOCwxMjIsMTI1LDEzNiwxNDYsMTQ4LDE1NSwxNTgsMTc4LDE4OSwxOTAsMTkyLDIwNCwyMDgsMjA5LDIyMCwyMjEsMjIyLDIyNywyMjgsMjM1LDIzNiwyMzcsMjQ2LDI0NywyNTAsMjUxLDI1MiwyNTMsMjU0LDI1NSwyNTYsMjU3LDI1OF0sJFY1Mj1bMiwxOTBdLCRWNjI9WzEsMzc0XSwkVjcyPVs2LDEwLDExLDE0LDIzLDEwNF0sJFY4Mj1bMiwxOTJdLCRWOTI9WzEsMzg0XSwkVmEyPVsxLDM4NV0sJFZiMj1bMSwzODZdLCRWYzI9WzEsNiwxMCwxMSwxNCwyMyw3OSw5NywxMDQsMTE4LDEyNSwxNDYsMTQ4LDE1OCwyMDgsMjA5LDIyOCwyMzcsMjQ2XSwkVmQyPVsxLDYsMTAsMTEsMTQsMjMsNzksOTcsMTA0LDExOCwxMjUsMTQ2LDE0OCwxNTgsMjA4LDIwOSwyMjEsMjI4LDIzNywyNDZdLCRWZTI9WzIzNSwyMzZdLCRWZjI9WzE0LDIzNSwyMzZdLCRWZzI9WzEsNiwxMSwxNCwyMyw3OSw5NywxMDQsMTE4LDEyNSwxNDYsMTQ4LDE1OCwxNzgsMjA4LDIwOSwyMjAsMjIxLDIyMiwyMjcsMjI4LDIzNywyNDYsMjQ3LDI1MCwyNTEsMjU0LDI1NSwyNTYsMjU3XSwkVmgyPVsxLDQwMF0sJFZpMj1bNiwxMCwxMSwxNCw5N10sJFZqMj1bNiwxMCwxMSwxNCw5NywxNDZdLCRWazI9Wzk1LDk4XSwkVmwyPVsxLDQxMF0sJFZtMj1bMSw0MTFdLCRWbjI9WzIyLDk1LDk4LDE3MCwxNzFdLCRWbzI9WzEsNiwxMCwxMSwxNCwyMyw3OSw5NywxMDQsMTE4LDEyNSwxMzYsMTQ2LDE0OCwxNTgsMTc4LDIwOCwyMDksMjIwLDIyMSwyMjIsMjI3LDIyOCwyMzcsMjQ2LDI0NywyNTAsMjUxLDI1NSwyNTddLCRWcDI9WzEsNiwxMCwxMSwxNCwyMyw3OSw5NywxMDQsMTE4LDEyNSwxNDYsMTQ4LDE1OCwyMDgsMjA5LDIyMSwyMzddLCRWcTI9WzIwLDIxLDI0LDI1LDI3LDMzLDM2LDU3LDYxLDYyLDY0LDY2LDY4LDcwLDcyLDc0LDgwLDgxLDgyLDgzLDg0LDg1LDg2LDg3LDkwLDk2LDEwMywxMTAsMTE4LDEzMSwxMzIsMTMzLDEzNCwxNDAsMTQxLDE0NywxNTQsMTU1LDE2MiwxNjMsMTY1LDE4MSwxODMsMTg1LDE5MywxOTQsMTk2LDIwMSwyMDIsMjA1LDIwNiwyMTIsMjE4LDIyMCwyMjIsMjI0LDIyNywyMjgsMjM4LDI0NCwyNDgsMjQ5LDI1MCwyNTEsMjUyLDI1M10sJFZyMj1bMSw2LDEwLDExLDE0LDIzLDc5LDk3LDEwNCwxMTgsMTI1LDEzNiwxNDYsMTQ4LDE1OCwxNzgsMjA4LDIwOSwyMjAsMjIxLDIyMiwyMjcsMjI4LDIzNywyNDAsMjQ1LDI0NiwyNDcsMjUwLDI1MSwyNTQsMjU1LDI1NiwyNTddLCRWczI9WzExLDI0MCwyNDJdLCRWdDI9WzEsNDYwXSwkVnUyPVsyLDE5MV0sJFZ2Mj1bNiwxMCwxMV0sJFZ3Mj1bMSw0NjhdLCRWeDI9WzE0LDIzLDE1OF0sJFZ5Mj1bMSw2LDEwLDExLDE0LDIzLDc5LDk3LDEwNCwxMTgsMTI1LDE0NiwxNDgsMTU4LDIwOCwyMDksMjIwLDIyMiwyMjcsMjI4LDIzNywyNDZdLCRWejI9WzEsNDgzXSwkVkEyPVs1Nyw2Niw5Nl0sJFZCMj1bMTQsMjNdLCRWQzI9WzEsNDk4XSwkVkQyPVsxMCwxNF0sJFZFMj1bMSw1NDRdLCRWRjI9WzYsMTBdO1xudmFyIHBhcnNlciA9IHt0cmFjZTogZnVuY3Rpb24gdHJhY2UoKSB7IH0sXG55eToge30sXG5zeW1ib2xzXzoge1wiZXJyb3JcIjoyLFwiUm9vdFwiOjMsXCJCb2R5XCI6NCxcIkJsb2NrXCI6NSxcIlRFUk1JTkFUT1JcIjo2LFwiQk9EWVNUQVJUXCI6NyxcIkxpbmVcIjo4LFwiVGVybWluYXRvclwiOjksXCJJTkRFTlRcIjoxMCxcIk9VVERFTlRcIjoxMSxcIlNwbGF0XCI6MTIsXCJFeHByZXNzaW9uXCI6MTMsXCIsXCI6MTQsXCJDb21tZW50XCI6MTUsXCJTdGF0ZW1lbnRcIjoxNixcIkV4cG9ydFN0YXRlbWVudFwiOjE3LFwiUmV0dXJuXCI6MTgsXCJUaHJvd1wiOjE5LFwiU1RBVEVNRU5UXCI6MjAsXCJCUkVBS1wiOjIxLFwiQ0FMTF9TVEFSVFwiOjIyLFwiQ0FMTF9FTkRcIjoyMyxcIkNPTlRJTlVFXCI6MjQsXCJERUJVR0dFUlwiOjI1LFwiSW1wb3J0U3RhdGVtZW50XCI6MjYsXCJJTVBPUlRcIjoyNyxcIkltcG9ydEFyZ0xpc3RcIjoyOCxcIkZST01cIjoyOSxcIkltcG9ydEZyb21cIjozMCxcIkFTXCI6MzEsXCJJbXBvcnRBcmdcIjozMixcIlNUUklOR1wiOjMzLFwiVmFySWRlbnRpZmllclwiOjM0LFwiUmVxdWlyZVwiOjM1LFwiUkVRVUlSRVwiOjM2LFwiUmVxdWlyZUFyZ1wiOjM3LFwiTGl0ZXJhbFwiOjM4LFwiUGFyZW50aGV0aWNhbFwiOjM5LFwiQXdhaXRcIjo0MCxcIlZhbHVlXCI6NDEsXCJDb2RlXCI6NDIsXCJPcGVyYXRpb25cIjo0MyxcIkFzc2lnblwiOjQ0LFwiSWZcIjo0NSxcIlRlcm5hcnlcIjo0NixcIlRyeVwiOjQ3LFwiV2hpbGVcIjo0OCxcIkZvclwiOjQ5LFwiU3dpdGNoXCI6NTAsXCJDbGFzc1wiOjUxLFwiTW9kdWxlXCI6NTIsXCJUYWdEZWNsYXJhdGlvblwiOjUzLFwiVGFnXCI6NTQsXCJQcm9wZXJ0eVwiOjU1LFwiSWRlbnRpZmllclwiOjU2LFwiSURFTlRJRklFUlwiOjU3LFwiS2V5XCI6NTgsXCJLRVlcIjo1OSxcIkl2YXJcIjo2MCxcIklWQVJcIjo2MSxcIkNWQVJcIjo2MixcIkd2YXJcIjo2MyxcIkdWQVJcIjo2NCxcIkNvbnN0XCI6NjUsXCJDT05TVFwiOjY2LFwiQXJndmFyXCI6NjcsXCJBUkdWQVJcIjo2OCxcIlN5bWJvbFwiOjY5LFwiU1lNQk9MXCI6NzAsXCJBbHBoYU51bWVyaWNcIjo3MSxcIk5VTUJFUlwiOjcyLFwiSW50ZXJwb2xhdGVkU3RyaW5nXCI6NzMsXCJTVFJJTkdfU1RBUlRcIjo3NCxcIk5FT1NUUklOR1wiOjc1LFwiSW50ZXJwb2xhdGlvblwiOjc2LFwiU1RSSU5HX0VORFwiOjc3LFwie3tcIjo3OCxcIn19XCI6NzksXCJKU1wiOjgwLFwiUkVHRVhcIjo4MSxcIkJPT0xcIjo4MixcIlRSVUVcIjo4MyxcIkZBTFNFXCI6ODQsXCJOVUxMXCI6ODUsXCJVTkRFRklORURcIjo4NixcIlJFVFVSTlwiOjg3LFwiQXJndW1lbnRzXCI6ODgsXCJUYWdTZWxlY3RvclwiOjg5LFwiU0VMRUNUT1JfU1RBUlRcIjo5MCxcIlRhZ1NlbGVjdG9yVHlwZVwiOjkxLFwiU0VMRUNUT1JfTlNcIjo5MixcIlNFTEVDVE9SX0lEXCI6OTMsXCJTRUxFQ1RPUl9DTEFTU1wiOjk0LFwiLlwiOjk1LFwie1wiOjk2LFwifVwiOjk3LFwiI1wiOjk4LFwiU0VMRUNUT1JfQ09NQklOQVRPUlwiOjk5LFwiU0VMRUNUT1JfUFNFVURPX0NMQVNTXCI6MTAwLFwiU0VMRUNUT1JfR1JPVVBcIjoxMDEsXCJVTklWRVJTQUxfU0VMRUNUT1JcIjoxMDIsXCJbXCI6MTAzLFwiXVwiOjEwNCxcIlNFTEVDVE9SX0FUVFJfT1BcIjoxMDUsXCJUYWdTZWxlY3RvckF0dHJWYWx1ZVwiOjEwNixcIlNFTEVDVE9SX1RBR1wiOjEwNyxcIlNlbGVjdG9yXCI6MTA4LFwiU0VMRUNUT1JfRU5EXCI6MTA5LFwiVEFHX1NUQVJUXCI6MTEwLFwiVGFnT3B0aW9uc1wiOjExMSxcIlRBR19FTkRcIjoxMTIsXCJUYWdCb2R5XCI6MTEzLFwiVGFnVHlwZU5hbWVcIjoxMTQsXCJTZWxmXCI6MTE1LFwiVEFHX1RZUEVcIjoxMTYsXCJJTkRFWF9TVEFSVFwiOjExNyxcIklOREVYX0VORFwiOjExOCxcIkBcIjoxMTksXCJUYWdBdHRyXCI6MTIwLFwiVEFHX0FUVFJcIjoxMjEsXCI9XCI6MTIyLFwiVGFnQXR0clZhbHVlXCI6MTIzLFwiVkFMVUVfU1RBUlRcIjoxMjQsXCJWQUxVRV9FTkRcIjoxMjUsXCJBcmdMaXN0XCI6MTI2LFwiVGFnVHlwZURlZlwiOjEyNyxcIkVYUE9SVFwiOjEyOCxcIkRFRkFVTFRcIjoxMjksXCJUYWdEZWNsYXJhdGlvbkJsb2NrXCI6MTMwLFwiRVhURU5EXCI6MTMxLFwiTE9DQUxcIjoxMzIsXCJHTE9CQUxcIjoxMzMsXCJUQUdcIjoxMzQsXCJUYWdUeXBlXCI6MTM1LFwiQ09NUEFSRVwiOjEzNixcIlRhZ0RlY2xLZXl3b3Jkc1wiOjEzNyxcIlRBR19JRFwiOjEzOCxcIlRhZ0lkXCI6MTM5LFwiSURSRUZcIjoxNDAsXCJUQUdJRFwiOjE0MSxcIkFzc2lnbmFibGVcIjoxNDIsXCJPdXRkZW50XCI6MTQzLFwiQXNzaWduT2JqXCI6MTQ0LFwiT2JqQXNzaWduYWJsZVwiOjE0NSxcIjpcIjoxNDYsXCIoXCI6MTQ3LFwiKVwiOjE0OCxcIkhFUkVDT01NRU5UXCI6MTQ5LFwiQ09NTUVOVFwiOjE1MCxcIk1ldGhvZFwiOjE1MSxcIkRvXCI6MTUyLFwiQmVnaW5cIjoxNTMsXCJCRUdJTlwiOjE1NCxcIkRPXCI6MTU1LFwiQkxPQ0tfUEFSQU1fU1RBUlRcIjoxNTYsXCJQYXJhbUxpc3RcIjoxNTcsXCJCTE9DS19QQVJBTV9FTkRcIjoxNTgsXCJQcm9wVHlwZVwiOjE1OSxcIlByb3BlcnR5SWRlbnRpZmllclwiOjE2MCxcIk9iamVjdFwiOjE2MSxcIlBST1BcIjoxNjIsXCJBVFRSXCI6MTYzLFwiTWV0aG9kRGVjbGFyYXRpb25cIjoxNjQsXCJERUZcIjoxNjUsXCJNZXRob2RTY29wZVwiOjE2NixcIk1ldGhvZFNjb3BlVHlwZVwiOjE2NyxcIk1ldGhvZElkZW50aWZpZXJcIjoxNjgsXCJNZXRob2RCb2R5XCI6MTY5LFwiREVGX0JPRFlcIjoxNzAsXCJERUZfRU1QVFlcIjoxNzEsXCJUaGlzXCI6MTcyLFwiT3B0Q29tbWFcIjoxNzMsXCJQYXJhbVwiOjE3NCxcIkFycmF5XCI6MTc1LFwiUGFyYW1WYXJcIjoxNzYsXCJTUExBVFwiOjE3NyxcIkxPR0lDXCI6MTc4LFwiQkxPQ0tfQVJHXCI6MTc5LFwiVmFyUmVmZXJlbmNlXCI6MTgwLFwiVkFSXCI6MTgxLFwiVmFyQXNzaWduYWJsZVwiOjE4MixcIkxFVFwiOjE4MyxcIlNpbXBsZUFzc2lnbmFibGVcIjoxODQsXCJFTlZfRkxBR1wiOjE4NSxcIk5FV1wiOjE4NixcIlN1cGVyXCI6MTg3LFwiU29ha2FibGVPcFwiOjE4OCxcIj86XCI6MTg5LFwiLjpcIjoxOTAsXCJJbmRleFZhbHVlXCI6MTkxLFwiPy5cIjoxOTIsXCJTVVBFUlwiOjE5MyxcIkFXQUlUXCI6MTk0LFwiUmFuZ2VcIjoxOTUsXCJBUkdVTUVOVFNcIjoxOTYsXCJJbnZvY2F0aW9uXCI6MTk3LFwiU2xpY2VcIjoxOTgsXCJBc3NpZ25MaXN0XCI6MTk5LFwiQ2xhc3NTdGFydFwiOjIwMCxcIkNMQVNTXCI6MjAxLFwiTU9EVUxFXCI6MjAyLFwiT3B0RnVuY0V4aXN0XCI6MjAzLFwiRlVOQ19FWElTVFwiOjIwNCxcIlRISVNcIjoyMDUsXCJTRUxGXCI6MjA2LFwiUmFuZ2VEb3RzXCI6MjA3LFwiLi5cIjoyMDgsXCIuLi5cIjoyMDksXCJBcmdcIjoyMTAsXCJTaW1wbGVBcmdzXCI6MjExLFwiVFJZXCI6MjEyLFwiQ2F0Y2hcIjoyMTMsXCJGaW5hbGx5XCI6MjE0LFwiRklOQUxMWVwiOjIxNSxcIkNBVENIXCI6MjE2LFwiQ0FUQ0hfVkFSXCI6MjE3LFwiVEhST1dcIjoyMTgsXCJXaGlsZVNvdXJjZVwiOjIxOSxcIldISUxFXCI6MjIwLFwiV0hFTlwiOjIyMSxcIlVOVElMXCI6MjIyLFwiTG9vcFwiOjIyMyxcIkxPT1BcIjoyMjQsXCJGb3JCb2R5XCI6MjI1LFwiRm9yS2V5d29yZFwiOjIyNixcIkZPUlwiOjIyNyxcIlBPU1RfRk9SXCI6MjI4LFwiRm9yQmxvY2tcIjoyMjksXCJGb3JTdGFydFwiOjIzMCxcIkZvclNvdXJjZVwiOjIzMSxcIkZvclZhcmlhYmxlc1wiOjIzMixcIk9XTlwiOjIzMyxcIkZvclZhbHVlXCI6MjM0LFwiRk9SSU5cIjoyMzUsXCJGT1JPRlwiOjIzNixcIkJZXCI6MjM3LFwiU1dJVENIXCI6MjM4LFwiV2hlbnNcIjoyMzksXCJFTFNFXCI6MjQwLFwiV2hlblwiOjI0MSxcIkxFQURJTkdfV0hFTlwiOjI0MixcIklmQmxvY2tcIjoyNDMsXCJJRlwiOjI0NCxcIkVMSUZcIjoyNDUsXCJQT1NUX0lGXCI6MjQ2LFwiP1wiOjI0NyxcIlVOQVJZXCI6MjQ4LFwiU1FSVFwiOjI0OSxcIi1cIjoyNTAsXCIrXCI6MjUxLFwiLS1cIjoyNTIsXCIrK1wiOjI1MyxcIk1BVEhcIjoyNTQsXCJTSElGVFwiOjI1NSxcIk5PVFwiOjI1NixcIlJFTEFUSU9OXCI6MjU3LFwiQ09NUE9VTkRfQVNTSUdOXCI6MjU4LFwiJGFjY2VwdFwiOjAsXCIkZW5kXCI6MX0sXG50ZXJtaW5hbHNfOiB7MjpcImVycm9yXCIsNjpcIlRFUk1JTkFUT1JcIiw3OlwiQk9EWVNUQVJUXCIsMTA6XCJJTkRFTlRcIiwxMTpcIk9VVERFTlRcIiwxNDpcIixcIiwyMDpcIlNUQVRFTUVOVFwiLDIxOlwiQlJFQUtcIiwyMjpcIkNBTExfU1RBUlRcIiwyMzpcIkNBTExfRU5EXCIsMjQ6XCJDT05USU5VRVwiLDI1OlwiREVCVUdHRVJcIiwyNzpcIklNUE9SVFwiLDI5OlwiRlJPTVwiLDMxOlwiQVNcIiwzMzpcIlNUUklOR1wiLDM2OlwiUkVRVUlSRVwiLDU3OlwiSURFTlRJRklFUlwiLDU5OlwiS0VZXCIsNjE6XCJJVkFSXCIsNjI6XCJDVkFSXCIsNjQ6XCJHVkFSXCIsNjY6XCJDT05TVFwiLDY4OlwiQVJHVkFSXCIsNzA6XCJTWU1CT0xcIiw3MjpcIk5VTUJFUlwiLDc0OlwiU1RSSU5HX1NUQVJUXCIsNzU6XCJORU9TVFJJTkdcIiw3NzpcIlNUUklOR19FTkRcIiw3ODpcInt7XCIsNzk6XCJ9fVwiLDgwOlwiSlNcIiw4MTpcIlJFR0VYXCIsODI6XCJCT09MXCIsODM6XCJUUlVFXCIsODQ6XCJGQUxTRVwiLDg1OlwiTlVMTFwiLDg2OlwiVU5ERUZJTkVEXCIsODc6XCJSRVRVUk5cIiw5MDpcIlNFTEVDVE9SX1NUQVJUXCIsOTI6XCJTRUxFQ1RPUl9OU1wiLDkzOlwiU0VMRUNUT1JfSURcIiw5NDpcIlNFTEVDVE9SX0NMQVNTXCIsOTU6XCIuXCIsOTY6XCJ7XCIsOTc6XCJ9XCIsOTg6XCIjXCIsOTk6XCJTRUxFQ1RPUl9DT01CSU5BVE9SXCIsMTAwOlwiU0VMRUNUT1JfUFNFVURPX0NMQVNTXCIsMTAxOlwiU0VMRUNUT1JfR1JPVVBcIiwxMDI6XCJVTklWRVJTQUxfU0VMRUNUT1JcIiwxMDM6XCJbXCIsMTA0OlwiXVwiLDEwNTpcIlNFTEVDVE9SX0FUVFJfT1BcIiwxMDc6XCJTRUxFQ1RPUl9UQUdcIiwxMDk6XCJTRUxFQ1RPUl9FTkRcIiwxMTA6XCJUQUdfU1RBUlRcIiwxMTI6XCJUQUdfRU5EXCIsMTE2OlwiVEFHX1RZUEVcIiwxMTc6XCJJTkRFWF9TVEFSVFwiLDExODpcIklOREVYX0VORFwiLDExOTpcIkBcIiwxMjE6XCJUQUdfQVRUUlwiLDEyMjpcIj1cIiwxMjQ6XCJWQUxVRV9TVEFSVFwiLDEyNTpcIlZBTFVFX0VORFwiLDEyODpcIkVYUE9SVFwiLDEyOTpcIkRFRkFVTFRcIiwxMzE6XCJFWFRFTkRcIiwxMzI6XCJMT0NBTFwiLDEzMzpcIkdMT0JBTFwiLDEzNDpcIlRBR1wiLDEzNjpcIkNPTVBBUkVcIiwxMzg6XCJUQUdfSURcIiwxNDA6XCJJRFJFRlwiLDE0MTpcIlRBR0lEXCIsMTQ2OlwiOlwiLDE0NzpcIihcIiwxNDg6XCIpXCIsMTQ5OlwiSEVSRUNPTU1FTlRcIiwxNTA6XCJDT01NRU5UXCIsMTU0OlwiQkVHSU5cIiwxNTU6XCJET1wiLDE1NjpcIkJMT0NLX1BBUkFNX1NUQVJUXCIsMTU4OlwiQkxPQ0tfUEFSQU1fRU5EXCIsMTYyOlwiUFJPUFwiLDE2MzpcIkFUVFJcIiwxNjU6XCJERUZcIiwxNzA6XCJERUZfQk9EWVwiLDE3MTpcIkRFRl9FTVBUWVwiLDE3NzpcIlNQTEFUXCIsMTc4OlwiTE9HSUNcIiwxNzk6XCJCTE9DS19BUkdcIiwxODE6XCJWQVJcIiwxODM6XCJMRVRcIiwxODU6XCJFTlZfRkxBR1wiLDE4NjpcIk5FV1wiLDE4OTpcIj86XCIsMTkwOlwiLjpcIiwxOTI6XCI/LlwiLDE5MzpcIlNVUEVSXCIsMTk0OlwiQVdBSVRcIiwxOTY6XCJBUkdVTUVOVFNcIiwyMDE6XCJDTEFTU1wiLDIwMjpcIk1PRFVMRVwiLDIwNDpcIkZVTkNfRVhJU1RcIiwyMDU6XCJUSElTXCIsMjA2OlwiU0VMRlwiLDIwODpcIi4uXCIsMjA5OlwiLi4uXCIsMjEyOlwiVFJZXCIsMjE1OlwiRklOQUxMWVwiLDIxNjpcIkNBVENIXCIsMjE3OlwiQ0FUQ0hfVkFSXCIsMjE4OlwiVEhST1dcIiwyMjA6XCJXSElMRVwiLDIyMTpcIldIRU5cIiwyMjI6XCJVTlRJTFwiLDIyNDpcIkxPT1BcIiwyMjc6XCJGT1JcIiwyMjg6XCJQT1NUX0ZPUlwiLDIzMzpcIk9XTlwiLDIzNTpcIkZPUklOXCIsMjM2OlwiRk9ST0ZcIiwyMzc6XCJCWVwiLDIzODpcIlNXSVRDSFwiLDI0MDpcIkVMU0VcIiwyNDI6XCJMRUFESU5HX1dIRU5cIiwyNDQ6XCJJRlwiLDI0NTpcIkVMSUZcIiwyNDY6XCJQT1NUX0lGXCIsMjQ3OlwiP1wiLDI0ODpcIlVOQVJZXCIsMjQ5OlwiU1FSVFwiLDI1MDpcIi1cIiwyNTE6XCIrXCIsMjUyOlwiLS1cIiwyNTM6XCIrK1wiLDI1NDpcIk1BVEhcIiwyNTU6XCJTSElGVFwiLDI1NjpcIk5PVFwiLDI1NzpcIlJFTEFUSU9OXCIsMjU4OlwiQ09NUE9VTkRfQVNTSUdOXCJ9LFxucHJvZHVjdGlvbnNfOiBbMCxbMywwXSxbMywxXSxbMywyXSxbNCwxXSxbNCwxXSxbNCwzXSxbNCwyXSxbOSwxXSxbNSwyXSxbNSwzXSxbNSw0XSxbOCwxXSxbOCwxXSxbOCwzXSxbOCwzXSxbOCwxXSxbOCwxXSxbOCwxXSxbMTYsMV0sWzE2LDFdLFsxNiwxXSxbMTYsMV0sWzE2LDRdLFsxNiwxXSxbMTYsNF0sWzE2LDFdLFsxNiwxXSxbMjYsNF0sWzI2LDRdLFsyNiwyXSxbMzAsMV0sWzI4LDFdLFsyOCwzXSxbMzIsMV0sWzM1LDJdLFszNywxXSxbMzcsMV0sWzM3LDBdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbNTYsMV0sWzU4LDFdLFs2MCwxXSxbNjAsMV0sWzYzLDFdLFs2NSwxXSxbNjcsMV0sWzY5LDFdLFs3MSwxXSxbNzEsMV0sWzcxLDFdLFs3MSwxXSxbNzMsMV0sWzczLDJdLFs3MywyXSxbNzMsMl0sWzc2LDJdLFs3NiwzXSxbMzgsMV0sWzM4LDFdLFszOCwxXSxbMzgsMV0sWzM4LDFdLFszOCwxXSxbMzgsMV0sWzM4LDFdLFsxOCwyXSxbMTgsMl0sWzE4LDFdLFs4OSwxXSxbODksMl0sWzg5LDJdLFs4OSwyXSxbODksMl0sWzg5LDVdLFs4OSw1XSxbODksMl0sWzg5LDJdLFs4OSwyXSxbODksMl0sWzg5LDRdLFs4OSw2XSxbOTEsMV0sWzEwOCwyXSxbMTA2LDFdLFsxMDYsMV0sWzEwNiwzXSxbNTQsM10sWzU0LDRdLFs1NCw1XSxbMTE0LDFdLFsxMTQsMV0sWzExNCwxXSxbMTE0LDBdLFsxMTEsMV0sWzExMSwzXSxbMTExLDRdLFsxMTEsM10sWzExMSwzXSxbMTExLDVdLFsxMTEsNV0sWzExMSwzXSxbMTExLDJdLFsxMTEsNV0sWzExMSwyXSxbMTIwLDFdLFsxMjAsM10sWzEyMywzXSxbMTEzLDNdLFsxMTMsM10sWzExMywxXSxbMTI3LDFdLFsxMjcsM10sWzE3LDNdLFsxNywyXSxbNTMsMV0sWzUzLDJdLFs1MywyXSxbNTMsMl0sWzEzMCwyXSxbMTMwLDNdLFsxMzAsNF0sWzEzMCw1XSxbMTM3LDBdLFsxMzcsMV0sWzEzNSwxXSxbMTM1LDFdLFsxMzksMV0sWzEzOSwxXSxbNDQsM10sWzQ0LDVdLFsxNDQsMV0sWzE0NCwzXSxbMTQ0LDVdLFsxNDQsMV0sWzE0NSwxXSxbMTQ1LDFdLFsxNDUsMV0sWzE0NSwxXSxbMTQ1LDFdLFsxNDUsMV0sWzE0NSwzXSxbMTUsMV0sWzE1LDFdLFs0MiwxXSxbNDIsMV0sWzQyLDFdLFsxNTMsMl0sWzE1MiwyXSxbMTUyLDVdLFs1NSwzXSxbNTUsNV0sWzU1LDJdLFsxNTksMV0sWzE1OSwxXSxbMTYwLDFdLFsxNjAsM10sWzE1MSwxXSxbMTUxLDJdLFsxNjQsOF0sWzE2NCw1XSxbMTY0LDZdLFsxNjQsM10sWzE2NywxXSxbMTY3LDFdLFsxNjgsMV0sWzE2OCwxXSxbMTY4LDNdLFsxNjksMl0sWzE2OSwyXSxbMTY5LDFdLFsxNjYsMV0sWzE2NiwxXSxbMTY2LDFdLFsxNjYsMV0sWzE3MywwXSxbMTczLDFdLFsxNTcsMF0sWzE1NywxXSxbMTU3LDNdLFsxNzQsMV0sWzE3NCwxXSxbMTc0LDFdLFsxNzQsMl0sWzE3NCwyXSxbMTc0LDJdLFsxNzQsM10sWzE3NiwxXSxbMTIsMl0sWzE4MCwzXSxbMTgwLDJdLFsxODAsMl0sWzE4MCwzXSxbMzQsMV0sWzM0LDFdLFsxODIsMV0sWzE4MiwxXSxbMTgyLDFdLFsxODQsMV0sWzE4NCwxXSxbMTg0LDFdLFsxODQsMV0sWzE4NCwxXSxbMTg0LDFdLFsxODQsMV0sWzE4NCwxXSxbMTg0LDNdLFsxODQsM10sWzE4NCwzXSxbMTg0LDNdLFsxODQsM10sWzE4NCwzXSxbMTg0LDNdLFsxODQsM10sWzE4NCw0XSxbMTg4LDFdLFsxODgsMV0sWzE4NywxXSxbMTQyLDFdLFsxNDIsMV0sWzE0MiwxXSxbNDAsMl0sWzQxLDFdLFs0MSwxXSxbNDEsMV0sWzQxLDFdLFs0MSwxXSxbNDEsMV0sWzQxLDFdLFs0MSwxXSxbNDEsMV0sWzQxLDFdLFs0MSwxXSxbMTkxLDFdLFsxOTEsMV0sWzE2MSw0XSxbMTk5LDBdLFsxOTksMV0sWzE5OSwzXSxbMTk5LDRdLFsxOTksNl0sWzUxLDFdLFs1MSwyXSxbNTEsMl0sWzUxLDJdLFsyMDAsMl0sWzIwMCwzXSxbMjAwLDRdLFsyMDAsNV0sWzUyLDJdLFs1MiwzXSxbMTk3LDNdLFsxOTcsMl0sWzIwMywwXSxbMjAzLDFdLFs4OCwyXSxbODgsNF0sWzE3MiwxXSxbMTE1LDFdLFsxNzUsMl0sWzE3NSw0XSxbMjA3LDFdLFsyMDcsMV0sWzE5NSw1XSxbMTk4LDNdLFsxOTgsMl0sWzE5OCwyXSxbMTI2LDFdLFsxMjYsM10sWzEyNiw0XSxbMTI2LDRdLFsxMjYsNl0sWzE0MywyXSxbMTQzLDFdLFsyMTAsMV0sWzIxMCwxXSxbMjEwLDFdLFsyMTAsMV0sWzIxMSwxXSxbMjExLDNdLFs0NywyXSxbNDcsM10sWzQ3LDNdLFs0Nyw0XSxbMjE0LDJdLFsyMTMsM10sWzE5LDJdLFszOSwzXSxbMzksNV0sWzIxOSwyXSxbMjE5LDRdLFsyMTksMl0sWzIxOSw0XSxbNDgsMl0sWzQ4LDJdLFs0OCwyXSxbNDgsMV0sWzIyMywyXSxbMjIzLDJdLFs0OSwyXSxbNDksMl0sWzQ5LDJdLFsyMjYsMV0sWzIyNiwxXSxbMjI5LDJdLFsyMjUsMl0sWzIyNSwyXSxbMjMwLDJdLFsyMzAsM10sWzIzNCwxXSxbMjM0LDFdLFsyMzQsMV0sWzIzMiwxXSxbMjMyLDNdLFsyMzEsMl0sWzIzMSwyXSxbMjMxLDRdLFsyMzEsNF0sWzIzMSw0XSxbMjMxLDZdLFsyMzEsNl0sWzUwLDVdLFs1MCw3XSxbNTAsNF0sWzUwLDZdLFsyMzksMV0sWzIzOSwyXSxbMjQxLDNdLFsyNDEsNF0sWzI0MywzXSxbMjQzLDVdLFsyNDMsNF0sWzI0MywzXSxbNDUsMV0sWzQ1LDNdLFs0NSwzXSxbNDYsNV0sWzQzLDJdLFs0MywyXSxbNDMsMl0sWzQzLDJdLFs0MywyXSxbNDMsMl0sWzQzLDJdLFs0MywyXSxbNDMsM10sWzQzLDNdLFs0MywzXSxbNDMsM10sWzQzLDNdLFs0MywzXSxbNDMsNF0sWzQzLDNdLFs0MywzXSxbNDMsNV1dLFxucGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gcGVyZm9ybUFjdGlvbihzZWxmLCB5eXRleHQsIHl5LCB5eXN0YXRlIC8qIGFjdGlvblsxXSAqLywgJCQgLyogdnN0YWNrICovKSB7XG4vKiBzZWxmID09IHl5dmFsICovXG5cbnZhciAkMCA9ICQkLmxlbmd0aCAtIDE7XG5zd2l0Y2ggKHl5c3RhdGUpIHtcbmNhc2UgMTpcbnJldHVybiBzZWxmLiQgPSBuZXcgeXkuUm9vdChbXSk7XG5icmVhaztcbmNhc2UgMjpcbnJldHVybiBzZWxmLiQgPSBuZXcgeXkuUm9vdCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDM6XG5yZXR1cm4gc2VsZi4kID0gJCRbJDAtMV07XG5icmVhaztcbmNhc2UgNDpcbnNlbGYuJCA9IG5ldyB5eS5CbG9jayhbXSk7XG5icmVhaztcbmNhc2UgNTpcbnNlbGYuJCA9IG5ldyB5eS5CbG9jayhbJCRbJDBdXSk7XG5icmVhaztcbmNhc2UgNjpcbnNlbGYuJCA9ICQkWyQwLTJdLmJyZWFrKCQkWyQwLTFdKS5hZGQoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA3Olxuc2VsZi4kID0gJCRbJDAtMV0uYnJlYWsoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA4Olxuc2VsZi4kID0gbmV3IHl5LlRlcm1pbmF0b3IoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA5Olxuc2VsZi4kID0gbmV3IHl5LkJsb2NrKFtdKS5pbmRlbnRlZCgkJFskMC0xXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDEwOiBjYXNlIDEyMzpcbnNlbGYuJCA9ICQkWyQwLTFdLmluZGVudGVkKCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTE6XG5zZWxmLiQgPSAkJFskMC0xXS5wcmVicmVhaygkJFskMC0yXSkuaW5kZW50ZWQoJCRbJDAtM10sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMjogY2FzZSAxMzogY2FzZSAxNjogY2FzZSAxNzogY2FzZSAxODogY2FzZSAxOTogY2FzZSAyMDogY2FzZSAyNzogY2FzZSAzMTogY2FzZSAzNDogY2FzZSAzNjogY2FzZSAzNzogY2FzZSAzODogY2FzZSAzOTogY2FzZSA0MDogY2FzZSA0MTogY2FzZSA0MjogY2FzZSA0MzogY2FzZSA0NDogY2FzZSA0NTogY2FzZSA0NjogY2FzZSA0NzogY2FzZSA0ODogY2FzZSA0OTogY2FzZSA1MDogY2FzZSA1MTogY2FzZSA1MjogY2FzZSA1MzogY2FzZSA1NDogY2FzZSA2NTogY2FzZSA2NjogY2FzZSA3MzogY2FzZSA5OTogY2FzZSAxMDA6IGNhc2UgMTA1OiBjYXNlIDEzMDogY2FzZSAxMzg6IGNhc2UgMTQ5OiBjYXNlIDE1MDogY2FzZSAxNTE6IGNhc2UgMTUyOiBjYXNlIDE1MzogY2FzZSAxNTQ6IGNhc2UgMTU1OiBjYXNlIDE1OTogY2FzZSAxNjA6IGNhc2UgMTYxOiBjYXNlIDE2ODogY2FzZSAxNjk6IGNhc2UgMTcwOiBjYXNlIDE3MjogY2FzZSAxODA6IGNhc2UgMTgxOiBjYXNlIDE4MzogY2FzZSAxODY6IGNhc2UgMTg3OiBjYXNlIDE4ODogY2FzZSAxODk6IGNhc2UgMTkwOiBjYXNlIDE5MTogY2FzZSAyMDI6IGNhc2UgMjA4OiBjYXNlIDIwOTogY2FzZSAyMTA6IGNhc2UgMjExOiBjYXNlIDIxMjogY2FzZSAyMTQ6IGNhc2UgMjE2OiBjYXNlIDIxNzogY2FzZSAyMTg6IGNhc2UgMjE5OiBjYXNlIDIzMzogY2FzZSAyMzQ6IGNhc2UgMjM1OiBjYXNlIDIzNzogY2FzZSAyMzg6IGNhc2UgMjM5OiBjYXNlIDI0MDogY2FzZSAyNDE6IGNhc2UgMjQzOiBjYXNlIDI0NDogY2FzZSAyNDU6IGNhc2UgMjQ2OiBjYXNlIDI0NzogY2FzZSAyNTY6IGNhc2UgMjg4OiBjYXNlIDI4OTogY2FzZSAyOTA6IGNhc2UgMjkxOiBjYXNlIDI5MjogY2FzZSAyOTM6IGNhc2UgMzExOiBjYXNlIDMxNzogY2FzZSAzMTg6IGNhc2UgMzI0OiBjYXNlIDM0MDogY2FzZSAzNDg6XG5zZWxmLiQgPSAkJFskMF07XG5icmVhaztcbmNhc2UgMTQ6IGNhc2UgMTU6XG5zZWxmLiQgPSAkJFskMC0yXS5hZGRFeHByZXNzaW9uKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjE6IGNhc2UgNzQ6XG5zZWxmLiQgPSBuZXcgeXkuTGl0ZXJhbCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDIyOlxuc2VsZi4kID0gbmV3IHl5LkJyZWFrU3RhdGVtZW50KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjM6XG5zZWxmLiQgPSBuZXcgeXkuQnJlYWtTdGF0ZW1lbnQoJCRbJDAtM10sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDI0Olxuc2VsZi4kID0gbmV3IHl5LkNvbnRpbnVlU3RhdGVtZW50KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjU6XG5zZWxmLiQgPSBuZXcgeXkuQ29udGludWVTdGF0ZW1lbnQoJCRbJDAtM10sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDI2Olxuc2VsZi4kID0gbmV3IHl5LkRlYnVnZ2VyU3RhdGVtZW50KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjg6XG5zZWxmLiQgPSBuZXcgeXkuSW1wb3J0U3RhdGVtZW50KCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjk6XG5zZWxmLiQgPSBuZXcgeXkuSW1wb3J0U3RhdGVtZW50KG51bGwsJCRbJDAtMl0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzMDpcbnNlbGYuJCA9IG5ldyB5eS5JbXBvcnRTdGF0ZW1lbnQobnVsbCwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDMyOiBjYXNlIDE5MzogY2FzZSAzMjc6XG5zZWxmLiQgPSBbJCRbJDBdXTtcbmJyZWFrO1xuY2FzZSAzMzogY2FzZSAxOTQ6XG5zZWxmLiQgPSAkJFskMC0yXS5jb25jYXQoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzNTpcbnNlbGYuJCA9IG5ldyB5eS5SZXF1aXJlKCQkWyQwXSkuc2V0KHtrZXl3b3JkOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDU1OiBjYXNlIDU2Olxuc2VsZi4kID0gbmV3IHl5LklkZW50aWZpZXIoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA1NzogY2FzZSA1ODpcbnNlbGYuJCA9IG5ldyB5eS5JdmFyKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNTk6XG5zZWxmLiQgPSBuZXcgeXkuR3ZhcigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDYwOlxuc2VsZi4kID0gbmV3IHl5LkNvbnN0KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNjE6XG5zZWxmLiQgPSBuZXcgeXkuQXJndmFyKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNjI6XG5zZWxmLiQgPSBuZXcgeXkuU3ltYm9sKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNjM6XG5zZWxmLiQgPSBuZXcgeXkuTnVtKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNjQ6XG5zZWxmLiQgPSBuZXcgeXkuU3RyKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNjc6XG5zZWxmLiQgPSBuZXcgeXkuSW50ZXJwb2xhdGVkU3RyaW5nKFtdLHtvcGVuOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSA2ODpcbnNlbGYuJCA9ICQkWyQwLTFdLmFkZCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDY5Olxuc2VsZi4kID0gJCRbJDBdID8gKCQkWyQwLTFdLmFkZCgkJFskMF0pKSA6ICgkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgNzA6XG5zZWxmLiQgPSAkJFskMC0xXS5vcHRpb24oJ2Nsb3NlJywkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDcxOlxuc2VsZi4kID0gbnVsbDtcbmJyZWFrO1xuY2FzZSA3MjogY2FzZSA5ODogY2FzZSAxMDE6IGNhc2UgMTIyOiBjYXNlIDEyNDogY2FzZSAxNTY6IGNhc2UgMTcxOiBjYXNlIDE4MjogY2FzZSAyODc6XG5zZWxmLiQgPSAkJFskMC0xXTtcbmJyZWFrO1xuY2FzZSA3NTpcbnNlbGYuJCA9IG5ldyB5eS5SZWdFeHAoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA3NjpcbnNlbGYuJCA9IG5ldyB5eS5Cb29sKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNzc6XG5zZWxmLiQgPSBuZXcgeXkuVHJ1ZSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDc4Olxuc2VsZi4kID0gbmV3IHl5LkZhbHNlKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNzk6XG5zZWxmLiQgPSBuZXcgeXkuTmlsKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgODA6XG5zZWxmLiQgPSBuZXcgeXkuVW5kZWZpbmVkKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgODE6IGNhc2UgODI6XG5zZWxmLiQgPSBuZXcgeXkuUmV0dXJuKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgODM6XG5zZWxmLiQgPSBuZXcgeXkuUmV0dXJuKCk7XG5icmVhaztcbmNhc2UgODQ6XG5zZWxmLiQgPSBuZXcgeXkuU2VsZWN0b3IoW10se3R5cGU6ICQkWyQwXX0pO1xuYnJlYWs7XG5jYXNlIDg1Olxuc2VsZi4kID0gJCRbJDAtMV0uYWRkKG5ldyB5eS5TZWxlY3RvclR5cGUoJCRbJDBdKSwndGFnJyk7XG5icmVhaztcbmNhc2UgODY6XG5zZWxmLiQgPSAkJFskMC0xXS5hZGQobmV3IHl5LlNlbGVjdG9yTmFtZXNwYWNlKCQkWyQwXSksJ25zJyk7XG5icmVhaztcbmNhc2UgODc6XG5zZWxmLiQgPSAkJFskMC0xXS5hZGQobmV3IHl5LlNlbGVjdG9ySWQoJCRbJDBdKSwnaWQnKTtcbmJyZWFrO1xuY2FzZSA4ODpcbnNlbGYuJCA9ICQkWyQwLTFdLmFkZChuZXcgeXkuU2VsZWN0b3JDbGFzcygkJFskMF0pLCdjbGFzcycpO1xuYnJlYWs7XG5jYXNlIDg5Olxuc2VsZi4kID0gJCRbJDAtNF0uYWRkKG5ldyB5eS5TZWxlY3RvckNsYXNzKCQkWyQwLTFdKSwnY2xhc3MnKTtcbmJyZWFrO1xuY2FzZSA5MDpcbnNlbGYuJCA9ICQkWyQwLTRdLmFkZChuZXcgeXkuU2VsZWN0b3JJZCgkJFskMC0xXSksJ2lkJyk7XG5icmVhaztcbmNhc2UgOTE6XG5zZWxmLiQgPSAkJFskMC0xXS5hZGQobmV3IHl5LlNlbGVjdG9yQ29tYmluYXRvcigkJFskMF0pLCdzZXAnKTtcbmJyZWFrO1xuY2FzZSA5MjpcbnNlbGYuJCA9ICQkWyQwLTFdLmFkZChuZXcgeXkuU2VsZWN0b3JQc2V1ZG9DbGFzcygkJFskMF0pLCdwc2V1ZG9jbGFzcycpO1xuYnJlYWs7XG5jYXNlIDkzOlxuc2VsZi4kID0gJCRbJDAtMV0uZ3JvdXAoKTtcbmJyZWFrO1xuY2FzZSA5NDpcbnNlbGYuJCA9ICQkWyQwLTFdLmFkZChuZXcgeXkuU2VsZWN0b3JVbml2ZXJzYWwoJCRbJDBdKSwndW5pdmVyc2FsJyk7XG5icmVhaztcbmNhc2UgOTU6XG5zZWxmLiQgPSAkJFskMC0zXS5hZGQobmV3IHl5LlNlbGVjdG9yQXR0cmlidXRlKCQkWyQwLTFdKSwnYXR0cicpO1xuYnJlYWs7XG5jYXNlIDk2Olxuc2VsZi4kID0gJCRbJDAtNV0uYWRkKG5ldyB5eS5TZWxlY3RvckF0dHJpYnV0ZSgkJFskMC0zXSwkJFskMC0yXSwkJFskMC0xXSksJ2F0dHInKTtcbmJyZWFrO1xuY2FzZSA5NzogY2FzZSAxMDY6IGNhc2UgMTA3OiBjYXNlIDE0MDogY2FzZSAxNDE6XG5zZWxmLiQgPSBuZXcgeXkuVGFnVHlwZUlkZW50aWZpZXIoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxMDI6XG5zZWxmLiQgPSAkJFskMC0xXS5zZXQoe29wZW46ICQkWyQwLTJdLGNsb3NlOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAxMDM6XG5zZWxmLiQgPSAkJFskMC0yXS5zZXQoe2JvZHk6ICQkWyQwXSxvcGVuOiAkJFskMC0zXSxjbG9zZTogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAxMDQ6XG5zZWxmLiQgPSBuZXcgeXkuVGFnV3JhcHBlcigkJFskMC0yXSwkJFskMC00XSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDEwODpcbnNlbGYuJCA9IG5ldyB5eS5UYWdUeXBlSWRlbnRpZmllcignZGl2Jyk7XG5icmVhaztcbmNhc2UgMTA5Olxuc2VsZi4kID0gbmV3IHl5LlRhZyh7dHlwZTogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgMTEwOlxuc2VsZi4kID0gJCRbJDAtMl0uYWRkU3ltYm9sKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTExOlxuc2VsZi4kID0gJCRbJDAtM10uYWRkSW5kZXgoJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDExMjogY2FzZSAxMTM6XG5zZWxmLiQgPSAkJFskMC0yXS5hZGRDbGFzcygkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDExNDpcbnNlbGYuJCA9ICQkWyQwLTRdLmFkZENsYXNzKCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAxMTU6XG5zZWxmLiQgPSAkJFskMC00XS5zZXQoe2tleTogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAxMTY6XG5zZWxmLiQgPSAkJFskMC0yXS5zZXQoe2lkOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAxMTc6XG5zZWxmLiQgPSAkJFskMC0xXS5zZXQoe2l2YXI6ICQkWyQwXX0pO1xuYnJlYWs7XG5jYXNlIDExODpcbnNlbGYuJCA9ICQkWyQwLTRdLnNldCh7aWQ6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMTE5Olxuc2VsZi4kID0gJCRbJDAtMV0uYWRkQXR0cmlidXRlKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTIwOlxuc2VsZi4kID0gbmV3IHl5LlRhZ0F0dHIoJCRbJDBdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTIxOlxuc2VsZi4kID0gbmV3IHl5LlRhZ0F0dHIoJCRbJDAtMl0sJCRbJDBdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAxMjU6IGNhc2UgMjgyOlxuc2VsZi4kID0gbmV3IHl5LkFyZ0xpc3QoWyQkWyQwXV0pO1xuYnJlYWs7XG5jYXNlIDEyNjpcbnNlbGYuJCA9IG5ldyB5eS5UYWdEZXNjKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTI3Olxuc2VsZi4kID0gJCRbJDAtMl0uY2xhc3NlcygkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDEyODpcbnNlbGYuJCA9IG5ldyB5eS5FeHBvcnQoJCRbJDBdKS5zZXQoeydkZWZhdWx0JzogJCRbJDAtMV0sa2V5d29yZDogJCRbJDAtMl19KTtcbmJyZWFrO1xuY2FzZSAxMjk6XG5zZWxmLiQgPSBuZXcgeXkuRXhwb3J0KCQkWyQwXSkuc2V0KHtrZXl3b3JkOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDEzMTpcbnNlbGYuJCA9ICQkWyQwXS5zZXQoe2V4dGVuc2lvbjogdHJ1ZX0pO1xuYnJlYWs7XG5jYXNlIDEzMjpcbnNlbGYuJCA9ICQkWyQwXS5zZXQoe2xvY2FsOiB0cnVlfSk7XG5icmVhaztcbmNhc2UgMTMzOiBjYXNlIDE3MzogY2FzZSAyNTk6XG5zZWxmLiQgPSAkJFskMF0uc2V0KHtnbG9iYWw6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMTM0Olxuc2VsZi4kID0gbmV3IHl5LlRhZ0RlY2xhcmF0aW9uKCQkWyQwXSkuc2V0KHtrZXl3b3JkOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDEzNTpcbnNlbGYuJCA9IG5ldyB5eS5UYWdEZWNsYXJhdGlvbigkJFskMC0xXSxudWxsLCQkWyQwXSkuc2V0KHtrZXl3b3JkOiAkJFskMC0yXX0pO1xuYnJlYWs7XG5jYXNlIDEzNjpcbnNlbGYuJCA9IG5ldyB5eS5UYWdEZWNsYXJhdGlvbigkJFskMC0yXSwkJFskMF0pLnNldCh7a2V5d29yZDogJCRbJDAtM119KTtcbmJyZWFrO1xuY2FzZSAxMzc6XG5zZWxmLiQgPSBuZXcgeXkuVGFnRGVjbGFyYXRpb24oJCRbJDAtM10sJCRbJDAtMV0sJCRbJDBdKS5zZXQoe2tleXdvcmQ6ICQkWyQwLTRdfSk7XG5icmVhaztcbmNhc2UgMTM5Olxuc2VsZi4kID0gWyd5eS5leHRlbmQnXTtcbmJyZWFrO1xuY2FzZSAxNDI6IGNhc2UgMTQzOlxuc2VsZi4kID0gbmV3IHl5LlRhZ0lkKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMTQ0Olxuc2VsZi4kID0gbmV3IHl5LkFzc2lnbigkJFskMC0xXSwkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDE0NTpcbnNlbGYuJCA9IG5ldyB5eS5Bc3NpZ24oJCRbJDAtM10sJCRbJDAtNF0sJCRbJDAtMV0uaW5kZW50ZWQoJCRbJDAtMl0sJCRbJDBdKSk7XG5icmVhaztcbmNhc2UgMTQ2Olxuc2VsZi4kID0gbmV3IHl5Lk9iakF0dHIoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxNDc6XG5zZWxmLiQgPSBuZXcgeXkuT2JqQXR0cigkJFskMC0yXSwkJFskMF0sJ29iamVjdCcpO1xuYnJlYWs7XG5jYXNlIDE0ODpcbnNlbGYuJCA9IG5ldyB5eS5PYmpBdHRyKCQkWyQwLTRdLCQkWyQwLTFdLmluZGVudGVkKCQkWyQwLTJdLCQkWyQwXSksJ29iamVjdCcpO1xuYnJlYWs7XG5jYXNlIDE1NzpcbnNlbGYuJCA9IG5ldyB5eS5Db21tZW50KCQkWyQwXSx0cnVlKTtcbmJyZWFrO1xuY2FzZSAxNTg6XG5zZWxmLiQgPSBuZXcgeXkuQ29tbWVudCgkJFskMF0sZmFsc2UpO1xuYnJlYWs7XG5jYXNlIDE2MjpcbnNlbGYuJCA9IG5ldyB5eS5CZWdpbigkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDE2MzpcbnNlbGYuJCA9IG5ldyB5eS5MYW1iZGEoW10sJCRbJDBdLG51bGwsbnVsbCx7Ym91bmQ6IHRydWUsa2V5d29yZDogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAxNjQ6XG5zZWxmLiQgPSBuZXcgeXkuTGFtYmRhKCQkWyQwLTJdLCQkWyQwXSxudWxsLG51bGwse2JvdW5kOiB0cnVlLGtleXdvcmQ6ICQkWyQwLTRdfSk7XG5icmVhaztcbmNhc2UgMTY1Olxuc2VsZi4kID0gbmV3IHl5LlByb3BlcnR5RGVjbGFyYXRpb24oJCRbJDAtMV0sJCRbJDBdLCQkWyQwLTJdKTtcbmJyZWFrO1xuY2FzZSAxNjY6XG5zZWxmLiQgPSBuZXcgeXkuUHJvcGVydHlEZWNsYXJhdGlvbigkJFskMC0zXSwkJFskMC0xXSwkJFskMC00XSk7XG5icmVhaztcbmNhc2UgMTY3Olxuc2VsZi4kID0gbmV3IHl5LlByb3BlcnR5RGVjbGFyYXRpb24oJCRbJDBdLG51bGwsJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDE3NDpcbnNlbGYuJCA9IG5ldyB5eS5NZXRob2REZWNsYXJhdGlvbigkJFskMC0yXSwkJFskMF0sJCRbJDAtNF0sJCRbJDAtNl0sJCRbJDAtNV0pLnNldCh7ZGVmOiAkJFskMC03XX0pO1xuYnJlYWs7XG5jYXNlIDE3NTpcbnNlbGYuJCA9IG5ldyB5eS5NZXRob2REZWNsYXJhdGlvbihbXSwkJFskMF0sJCRbJDAtMV0sJCRbJDAtM10sJCRbJDAtMl0pLnNldCh7ZGVmOiAkJFskMC00XX0pO1xuYnJlYWs7XG5jYXNlIDE3NjpcbnNlbGYuJCA9IG5ldyB5eS5NZXRob2REZWNsYXJhdGlvbigkJFskMC0yXSwkJFskMF0sJCRbJDAtNF0sbnVsbCkuc2V0KHtkZWY6ICQkWyQwLTVdfSk7XG5icmVhaztcbmNhc2UgMTc3Olxuc2VsZi4kID0gbmV3IHl5Lk1ldGhvZERlY2xhcmF0aW9uKFtdLCQkWyQwXSwkJFskMC0xXSxudWxsKS5zZXQoe2RlZjogJCRbJDAtMl19KTtcbmJyZWFrO1xuY2FzZSAxNzg6XG5zZWxmLiQgPSB7c3RhdGljOiB0cnVlfTtcbmJyZWFrO1xuY2FzZSAxNzk6XG5zZWxmLiQgPSB7fTtcbmJyZWFrO1xuY2FzZSAxODQ6XG5zZWxmLiQgPSAkJFskMF0uYm9keSgpO1xuYnJlYWs7XG5jYXNlIDE4NTogY2FzZSAxOTI6XG5zZWxmLiQgPSBbXTtcbmJyZWFrO1xuY2FzZSAxOTU6XG5zZWxmLiQgPSBuZXcgeXkuTmFtZWRQYXJhbXMoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxOTY6XG5zZWxmLiQgPSBuZXcgeXkuQXJyYXlQYXJhbXMoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAxOTc6XG5zZWxmLiQgPSBuZXcgeXkuUmVxdWlyZWRQYXJhbSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDE5ODpcbnNlbGYuJCA9IG5ldyB5eS5TcGxhdFBhcmFtKCQkWyQwXSxudWxsLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAxOTk6IGNhc2UgMjAwOlxuc2VsZi4kID0gbmV3IHl5LkJsb2NrUGFyYW0oJCRbJDBdLG51bGwsJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDIwMTpcbnNlbGYuJCA9IG5ldyB5eS5PcHRpb25hbFBhcmFtKCQkWyQwLTJdLCQkWyQwXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMjAzOlxuc2VsZi4kID0geXkuU1BMQVQoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyMDQ6IGNhc2UgMjA3Olxuc2VsZi4kID0geXkuU1BMQVQobmV3IHl5LlZhclJlZmVyZW5jZSgkJFskMF0sJCRbJDAtMl0pLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAyMDU6IGNhc2UgMjA2Olxuc2VsZi4kID0gbmV3IHl5LlZhclJlZmVyZW5jZSgkJFskMF0sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDIxMzpcbnNlbGYuJCA9IG5ldyB5eS5FbnZGbGFnKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjE1Olxuc2VsZi4kID0gbmV3IHl5Lkl2YXJBY2Nlc3MoJy4nLG51bGwsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyMjA6XG5zZWxmLiQgPSBuZXcgeXkuVmFyT3JBY2Nlc3MoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyMjE6XG5zZWxmLiQgPSBuZXcgeXkuTmV3KCQkWyQwLTJdKTtcbmJyZWFrO1xuY2FzZSAyMjI6XG5zZWxmLiQgPSBuZXcgeXkuU3VwZXJBY2Nlc3MoJy4nLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjIzOlxuc2VsZi4kID0gbmV3IHl5LlByb3BlcnR5QWNjZXNzKCQkWyQwLTFdLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjI0OiBjYXNlIDIyNTogY2FzZSAyMjY6IGNhc2UgMjI4Olxuc2VsZi4kID0gbmV3IHl5LkFjY2VzcygkJFskMC0xXSwkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDIyNzpcbnNlbGYuJCA9IG5ldyB5eS5BY2Nlc3MoJy4nLCQkWyQwLTJdLG5ldyB5eS5JZGVudGlmaWVyKCQkWyQwXS52YWx1ZSgpKSk7XG5icmVhaztcbmNhc2UgMjI5Olxuc2VsZi4kID0gbmV3IHl5LkluZGV4QWNjZXNzKCcuJywkJFskMC0zXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMjMyOlxuc2VsZi4kID0geXkuU1VQRVI7XG5icmVhaztcbmNhc2UgMjM2Olxuc2VsZi4kID0gbmV3IHl5LkF3YWl0KCQkWyQwXSkuc2V0KHtrZXl3b3JkOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDI0MjpcbnNlbGYuJCA9IHl5LkFSR1VNRU5UUztcbmJyZWFrO1xuY2FzZSAyNDg6XG5zZWxmLiQgPSBuZXcgeXkuSW5kZXgoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNDk6XG5zZWxmLiQgPSBuZXcgeXkuU2xpY2UoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNTA6XG5zZWxmLiQgPSBuZXcgeXkuT2JqKCQkWyQwLTJdLCQkWyQwLTNdLmdlbmVyYXRlZCk7XG5icmVhaztcbmNhc2UgMjUxOlxuc2VsZi4kID0gbmV3IHl5LkFzc2lnbkxpc3QoW10pO1xuYnJlYWs7XG5jYXNlIDI1MjpcbnNlbGYuJCA9IG5ldyB5eS5Bc3NpZ25MaXN0KFskJFskMF1dKTtcbmJyZWFrO1xuY2FzZSAyNTM6IGNhc2UgMjgzOlxuc2VsZi4kID0gJCRbJDAtMl0uYWRkKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjU0OiBjYXNlIDI4NDpcbnNlbGYuJCA9ICQkWyQwLTNdLmFkZCgkJFskMC0xXSkuYWRkKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjU1Olxuc2VsZi4kID0gJCRbJDAtNV0uY29uY2F0KCQkWyQwLTJdLmluZGVudGVkKCQkWyQwLTNdLCQkWyQwXSkpO1xuYnJlYWs7XG5jYXNlIDI1NzpcbnNlbGYuJCA9ICQkWyQwXS5zZXQoe2V4dGVuc2lvbjogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAyNTg6XG5zZWxmLiQgPSAkJFskMF0uc2V0KHtsb2NhbDogJCRbJDAtMV19KTtcbmJyZWFrO1xuY2FzZSAyNjA6XG5zZWxmLiQgPSBuZXcgeXkuQ2xhc3NEZWNsYXJhdGlvbigkJFskMF0sbnVsbCxbXSkuc2V0KHtrZXl3b3JkOiAkJFskMC0xXX0pO1xuYnJlYWs7XG5jYXNlIDI2MTpcbnNlbGYuJCA9IG5ldyB5eS5DbGFzc0RlY2xhcmF0aW9uKCQkWyQwLTFdLG51bGwsJCRbJDBdKS5zZXQoe2tleXdvcmQ6ICQkWyQwLTJdfSk7XG5icmVhaztcbmNhc2UgMjYyOlxuc2VsZi4kID0gbmV3IHl5LkNsYXNzRGVjbGFyYXRpb24oJCRbJDAtMl0sJCRbJDBdLFtdKS5zZXQoe2tleXdvcmQ6ICQkWyQwLTNdfSk7XG5icmVhaztcbmNhc2UgMjYzOlxuc2VsZi4kID0gbmV3IHl5LkNsYXNzRGVjbGFyYXRpb24oJCRbJDAtM10sJCRbJDAtMV0sJCRbJDBdKS5zZXQoe2tleXdvcmQ6ICQkWyQwLTRdfSk7XG5icmVhaztcbmNhc2UgMjY0Olxuc2VsZi4kID0gbmV3IHl5Lk1vZHVsZSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI2NTpcbnNlbGYuJCA9IG5ldyB5eS5Nb2R1bGUoJCRbJDAtMV0sbnVsbCwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI2NjpcbnNlbGYuJCA9IG5ldyB5eS5DYWxsKCQkWyQwLTJdLCQkWyQwXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMjY3Olxuc2VsZi4kID0gJCRbJDAtMV0uYWRkQmxvY2soJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNjg6XG5zZWxmLiQgPSBmYWxzZTtcbmJyZWFrO1xuY2FzZSAyNjk6XG5zZWxmLiQgPSB0cnVlO1xuYnJlYWs7XG5jYXNlIDI3MDpcbnNlbGYuJCA9IG5ldyB5eS5BcmdMaXN0KFtdKTtcbmJyZWFrO1xuY2FzZSAyNzE6XG5zZWxmLiQgPSAkJFskMC0yXTtcbmJyZWFrO1xuY2FzZSAyNzI6XG5zZWxmLiQgPSBuZXcgeXkuVGhpcygkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI3MzpcbnNlbGYuJCA9IG5ldyB5eS5TZWxmKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjc0Olxuc2VsZi4kID0gbmV3IHl5LkFycihuZXcgeXkuQXJnTGlzdChbXSkpO1xuYnJlYWs7XG5jYXNlIDI3NTpcbnNlbGYuJCA9IG5ldyB5eS5BcnIoJCRbJDAtMl0pO1xuYnJlYWs7XG5jYXNlIDI3NjpcbnNlbGYuJCA9ICcuLic7XG5icmVhaztcbmNhc2UgMjc3Olxuc2VsZi4kID0gJy4uLic7XG5icmVhaztcbmNhc2UgMjc4Olxuc2VsZi4kID0geXkuT1AoJCRbJDAtMl0sJCRbJDAtM10sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDI3OTpcbnNlbGYuJCA9IG5ldyB5eS5SYW5nZSgkJFskMC0yXSwkJFskMF0sJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDI4MDpcbnNlbGYuJCA9IG5ldyB5eS5SYW5nZSgkJFskMC0xXSxudWxsLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjgxOlxuc2VsZi4kID0gbmV3IHl5LlJhbmdlKG51bGwsJCRbJDBdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAyODU6XG5zZWxmLiQgPSAkJFskMC0yXS5pbmRlbnRlZCgkJFskMC0zXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI4NjpcbnNlbGYuJCA9ICQkWyQwLTVdLmNvbmNhdCgkJFskMC0yXSk7XG5icmVhaztcbmNhc2UgMjk0Olxuc2VsZi4kID0gW10uY29uY2F0KCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjk1Olxuc2VsZi4kID0gbmV3IHl5LlRyeSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDI5NjpcbnNlbGYuJCA9IG5ldyB5eS5UcnkoJCRbJDAtMV0sJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyOTc6XG5zZWxmLiQgPSBuZXcgeXkuVHJ5KCQkWyQwLTFdLG51bGwsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyOTg6XG5zZWxmLiQgPSBuZXcgeXkuVHJ5KCQkWyQwLTJdLCQkWyQwLTFdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMjk5Olxuc2VsZi4kID0gbmV3IHl5LkZpbmFsbHkoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzMDA6XG5zZWxmLiQgPSBuZXcgeXkuQ2F0Y2goJCRbJDBdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAzMDE6XG5zZWxmLiQgPSBuZXcgeXkuVGhyb3coJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzMDI6XG5zZWxmLiQgPSBuZXcgeXkuUGFyZW5zKCQkWyQwLTFdLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzAzOlxuc2VsZi4kID0gbmV3IHl5LlBhcmVucygkJFskMC0yXSwkJFskMC00XSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDMwNDpcbnNlbGYuJCA9IG5ldyB5eS5XaGlsZSgkJFskMF0se2tleXdvcmQ6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMzA1Olxuc2VsZi4kID0gbmV3IHl5LldoaWxlKCQkWyQwLTJdLHtndWFyZDogJCRbJDBdLGtleXdvcmQ6ICQkWyQwLTNdfSk7XG5icmVhaztcbmNhc2UgMzA2Olxuc2VsZi4kID0gbmV3IHl5LldoaWxlKCQkWyQwXSx7aW52ZXJ0OiB0cnVlLGtleXdvcmQ6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMzA3Olxuc2VsZi4kID0gbmV3IHl5LldoaWxlKCQkWyQwLTJdLHtpbnZlcnQ6IHRydWUsZ3VhcmQ6ICQkWyQwXSxrZXl3b3JkOiAkJFskMC0zXX0pO1xuYnJlYWs7XG5jYXNlIDMwODogY2FzZSAzMTY6IGNhc2UgMzE5Olxuc2VsZi4kID0gJCRbJDAtMV0uYWRkQm9keSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDMwOTogY2FzZSAzMTA6XG5zZWxmLiQgPSAkJFskMF0uYWRkQm9keSh5eS5CbG9jay53cmFwKFskJFskMC0xXV0pKTtcbmJyZWFrO1xuY2FzZSAzMTI6XG5zZWxmLiQgPSBuZXcgeXkuV2hpbGUobmV3IHl5LkxpdGVyYWwoJ3RydWUnLHtrZXl3b3JkOiAkJFskMC0xXX0pKS5hZGRCb2R5KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzEzOlxuc2VsZi4kID0gbmV3IHl5LldoaWxlKG5ldyB5eS5MaXRlcmFsKCd0cnVlJyx7a2V5d29yZDogJCRbJDAtMV19KSkuYWRkQm9keSh5eS5CbG9jay53cmFwKFskJFskMF1dKSk7XG5icmVhaztcbmNhc2UgMzE0OiBjYXNlIDMxNTpcbnNlbGYuJCA9ICQkWyQwXS5hZGRCb2R5KFskJFskMC0xXV0pO1xuYnJlYWs7XG5jYXNlIDMyMDpcbnNlbGYuJCA9IHtzb3VyY2U6IG5ldyB5eS5WYWx1ZU5vZGUoJCRbJDBdKX07XG5icmVhaztcbmNhc2UgMzIxOlxuc2VsZi4kID0gJCRbJDBdLmNvbmZpZ3VyZSh7b3duOiAkJFskMC0xXS5vd24sbmFtZTogJCRbJDAtMV1bMF0saW5kZXg6ICQkWyQwLTFdWzFdLGtleXdvcmQ6ICQkWyQwLTFdLmtleXdvcmR9KTtcbmJyZWFrO1xuY2FzZSAzMjI6XG5zZWxmLiQgPSAoJCRbJDBdLmtleXdvcmQgPSAkJFskMC0xXSkgJiYgJCRbJDBdO1xuYnJlYWs7XG5jYXNlIDMyMzpcbnNlbGYuJCA9ICgkJFskMF0ub3duID0gdHJ1ZSkgJiYgKCQkWyQwXS5rZXl3b3JkID0gJCRbJDAtMl0pICYmICQkWyQwXTtcbmJyZWFrO1xuY2FzZSAzMjU6IGNhc2UgMzI2Olxuc2VsZi4kID0gbmV3IHl5LlZhbHVlTm9kZSgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDMyODpcbnNlbGYuJCA9IFskJFskMC0yXSwkJFskMF1dO1xuYnJlYWs7XG5jYXNlIDMyOTpcbnNlbGYuJCA9IG5ldyB5eS5Gb3JJbih7c291cmNlOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAzMzA6XG5zZWxmLiQgPSBuZXcgeXkuRm9yT2Yoe3NvdXJjZTogJCRbJDBdLG9iamVjdDogdHJ1ZX0pO1xuYnJlYWs7XG5jYXNlIDMzMTpcbnNlbGYuJCA9IG5ldyB5eS5Gb3JJbih7c291cmNlOiAkJFskMC0yXSxndWFyZDogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgMzMyOlxuc2VsZi4kID0gbmV3IHl5LkZvck9mKHtzb3VyY2U6ICQkWyQwLTJdLGd1YXJkOiAkJFskMF0sb2JqZWN0OiB0cnVlfSk7XG5icmVhaztcbmNhc2UgMzMzOlxuc2VsZi4kID0gbmV3IHl5LkZvckluKHtzb3VyY2U6ICQkWyQwLTJdLHN0ZXA6ICQkWyQwXX0pO1xuYnJlYWs7XG5jYXNlIDMzNDpcbnNlbGYuJCA9IG5ldyB5eS5Gb3JJbih7c291cmNlOiAkJFskMC00XSxndWFyZDogJCRbJDAtMl0sc3RlcDogJCRbJDBdfSk7XG5icmVhaztcbmNhc2UgMzM1Olxuc2VsZi4kID0gbmV3IHl5LkZvckluKHtzb3VyY2U6ICQkWyQwLTRdLHN0ZXA6ICQkWyQwLTJdLGd1YXJkOiAkJFskMF19KTtcbmJyZWFrO1xuY2FzZSAzMzY6XG5zZWxmLiQgPSBuZXcgeXkuU3dpdGNoKCQkWyQwLTNdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAzMzc6XG5zZWxmLiQgPSBuZXcgeXkuU3dpdGNoKCQkWyQwLTVdLCQkWyQwLTNdLCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAzMzg6XG5zZWxmLiQgPSBuZXcgeXkuU3dpdGNoKG51bGwsJCRbJDAtMV0pO1xuYnJlYWs7XG5jYXNlIDMzOTpcbnNlbGYuJCA9IG5ldyB5eS5Td2l0Y2gobnVsbCwkJFskMC0zXSwkJFskMC0xXSk7XG5icmVhaztcbmNhc2UgMzQxOlxuc2VsZi4kID0gJCRbJDAtMV0uY29uY2F0KCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzQyOlxuc2VsZi4kID0gW25ldyB5eS5Td2l0Y2hDYXNlKCQkWyQwLTFdLCQkWyQwXSldO1xuYnJlYWs7XG5jYXNlIDM0MzpcbnNlbGYuJCA9IFtuZXcgeXkuU3dpdGNoQ2FzZSgkJFskMC0yXSwkJFskMC0xXSldO1xuYnJlYWs7XG5jYXNlIDM0NDpcbnNlbGYuJCA9IG5ldyB5eS5JZigkJFskMC0xXSwkJFskMF0se3R5cGU6ICQkWyQwLTJdfSk7XG5icmVhaztcbmNhc2UgMzQ1Olxuc2VsZi4kID0gJCRbJDAtNF0uYWRkRWxzZShuZXcgeXkuSWYoJCRbJDAtMV0sJCRbJDBdLHt0eXBlOiAkJFskMC0yXX0pKTtcbmJyZWFrO1xuY2FzZSAzNDY6XG5zZWxmLiQgPSAkJFskMC0zXS5hZGRFbHNlKG5ldyB5eS5JZigkJFskMC0xXSwkJFskMF0se3R5cGU6ICQkWyQwLTJdfSkpO1xuYnJlYWs7XG5jYXNlIDM0NzpcbnNlbGYuJCA9ICQkWyQwLTJdLmFkZEVsc2UoJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzNDk6XG5zZWxmLiQgPSBuZXcgeXkuSWYoJCRbJDBdLG5ldyB5eS5CbG9jayhbJCRbJDAtMl1dKSx7dHlwZTogJCRbJDAtMV0sc3RhdGVtZW50OiB0cnVlfSk7XG5icmVhaztcbmNhc2UgMzUwOlxuc2VsZi4kID0gbmV3IHl5LklmKCQkWyQwXSxuZXcgeXkuQmxvY2soWyQkWyQwLTJdXSkse3R5cGU6ICQkWyQwLTFdfSk7XG5icmVhaztcbmNhc2UgMzUxOlxuc2VsZi4kID0geXkuSWYudGVybmFyeSgkJFskMC00XSwkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDM1MjogY2FzZSAzNTM6XG5zZWxmLiQgPSB5eS5PUCgkJFskMC0xXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDM1NDpcbnNlbGYuJCA9IG5ldyB5eS5PcCgnLScsJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzNTU6XG5zZWxmLiQgPSBuZXcgeXkuT3AoJysnLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzU2Olxuc2VsZi4kID0gbmV3IHl5LlVuYXJ5T3AoJy0tJyxudWxsLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzU3Olxuc2VsZi4kID0gbmV3IHl5LlVuYXJ5T3AoJysrJyxudWxsLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzU4Olxuc2VsZi4kID0gbmV3IHl5LlVuYXJ5T3AoJy0tJywkJFskMC0xXSxudWxsLHRydWUpO1xuYnJlYWs7XG5jYXNlIDM1OTpcbnNlbGYuJCA9IG5ldyB5eS5VbmFyeU9wKCcrKycsJCRbJDAtMV0sbnVsbCx0cnVlKTtcbmJyZWFrO1xuY2FzZSAzNjA6IGNhc2UgMzYxOlxuc2VsZi4kID0gbmV3IHl5Lk9wKCQkWyQwLTFdLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzYyOiBjYXNlIDM2MzogY2FzZSAzNjQ6IGNhc2UgMzY1OiBjYXNlIDM2NzpcbnNlbGYuJCA9IHl5Lk9QKCQkWyQwLTFdLCQkWyQwLTJdLCQkWyQwXSk7XG5icmVhaztcbmNhc2UgMzY2Olxuc2VsZi4kID0geXkuT1AoJCRbJDAtMV0sJCRbJDAtM10sJCRbJDBdKS5pbnZlcnQoJCRbJDAtMl0pO1xuYnJlYWs7XG5jYXNlIDM2ODpcbnNlbGYuJCA9IHl5Lk9QX0NPTVBPVU5EKCQkWyQwLTFdLl92YWx1ZSwkJFskMC0xXSwkJFskMC0yXSwkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDM2OTpcbnNlbGYuJCA9IHl5Lk9QX0NPTVBPVU5EKCQkWyQwLTNdLl92YWx1ZSwkJFskMC00XSwkJFskMC0xXS5pbmRlbnRlZCgkJFskMC0yXSwkJFskMF0pKTtcbmJyZWFrO1xufVxufSxcbnRhYmxlOiBbezE6WzIsMV0sMzoxLDQ6Miw1OjMsNzokVjAsODo1LDEwOiRWMSwxMjo3LDEzOjgsMTU6OSwxNjoxMCwxNzoxMSwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTI4OiRWdSwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE0OTokVkMsMTUwOiRWRCwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxNzc6JFZKLDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSx7MTpbM119LHsxOlsyLDJdLDY6JFY3MSw5OjEzN30sezY6WzEsMTM5XX0sbygkVjgxLFsyLDRdKSxvKCRWODEsWzIsNV0sezE0OiRWOTF9KSx7NDoxNDIsNjpbMSwxNDNdLDc6JFYwLDg6NSwxMTpbMSwxNDFdLDEyOjcsMTM6OCwxNTo5LDE2OjEwLDE3OjExLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMjg6JFZ1LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTQ5OiRWQywxNTA6JFZELDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE3NzokVkosMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LG8oJFZhMSxbMiwxMl0pLG8oJFZhMSxbMiwxM10sezIyNjoxMTEsMjMwOjExMiwyMTk6MTU0LDIyNToxNTUsMTM2OiRWYjEsMTc4OiRWYzEsMjIwOiRWVywyMjI6JFZYLDIyNzokVlosMjI4OiRWXywyNDY6JFZkMSwyNDc6JFZlMSwyNTA6JFZmMSwyNTE6JFZnMSwyNTQ6JFZoMSwyNTU6JFZpMSwyNTY6JFZqMSwyNTc6JFZrMX0pLG8oJFZhMSxbMiwxNl0pLG8oJFZhMSxbMiwxN10sezIyNjoxMTEsMjMwOjExMiwyMTk6MTU3LDIyNToxNTgsMjIwOiRWVywyMjI6JFZYLDIyNzokVlosMjI4OiRWXywyNDY6JFZsMX0pLG8oJFZhMSxbMiwxOF0pLHsxMzoxNTksMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSxvKCRWbTEsWzIsMzldKSxvKCRWbTEsWzIsNDBdLHsyMDM6MTYxLDE1MjoxNjIsMTg4OjE2NCwyMjokVm4xLDk1OiRWbzEsMTE3OiRWcDEsMTU1OiRWRiwxODk6JFZxMSwxOTA6JFZyMSwxOTI6JFZzMSwyMDQ6JFZ0MX0pLG8oJFZtMSxbMiw0MV0pLG8oJFZtMSxbMiw0Ml0pLG8oJFZtMSxbMiw0M10pLG8oJFZtMSxbMiw0NF0pLG8oJFZtMSxbMiw0NV0pLG8oJFZtMSxbMiw0Nl0pLG8oJFZtMSxbMiw0N10pLG8oJFZtMSxbMiw0OF0pLG8oJFZtMSxbMiw0OV0pLG8oJFZtMSxbMiw1MF0pLG8oJFZtMSxbMiw1MV0pLG8oJFZtMSxbMiw1Ml0pLG8oJFZtMSxbMiw1M10pLG8oJFZtMSxbMiw1NF0pLG8oJFZ1MSxbMiwxNTddKSxvKCRWdTEsWzIsMTU4XSksbygkVnYxLFsyLDE5XSksbygkVnYxLFsyLDIwXSksbygkVnYxLFsyLDIxXSksbygkVnYxLFsyLDIyXSx7MjI6WzEsMTcwXX0pLG8oJFZ2MSxbMiwyNF0sezIyOlsxLDE3MV19KSxvKCRWdjEsWzIsMjZdKSxvKCRWdjEsWzIsMjddKSx7MTM6MTczLDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTI5OlsxLDE3Ml0sMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sezEzOjE3NCwxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LG8oJFZ3MSwkVngxLHsxMjI6WzEsMTc1XX0pLG8oJFZ3MSxbMiwyMzhdKSxvKCRWdzEsWzIsMjM5XSksbygkVncxLFsyLDI0MF0pLG8oJFZ3MSxbMiwyNDFdKSxvKCRWdzEsWzIsMjQyXSksbygkVncxLFsyLDI0M10pLG8oJFZ3MSxbMiwyNDRdKSxvKCRWdzEsWzIsMjQ1XSksbygkVncxLFsyLDI0Nl0pLG8oJFZ3MSxbMiwyNDddKSxvKCRWbTEsWzIsMTU5XSksbygkVm0xLFsyLDE2MF0pLG8oJFZtMSxbMiwxNjFdKSx7MTM6MTc2LDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sezEzOjE3NywxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LHsxMzoxNzgsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSx7MTM6MTc5LDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sezMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDE6MTgxLDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTU6MTA0LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjE4MiwxNDc6JFZCLDE2MTo3OSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDoxODAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjA1OiRWUywyMDY6JFZUfSx7MzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MToxODEsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExNToxMDQsMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6MTgyLDE0NzokVkIsMTYxOjc5LDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjE4MywxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDU6JFZTLDIwNjokVlR9LG8oJFZ5MSwkVnoxLHsyNTI6WzEsMTg0XSwyNTM6WzEsMTg1XSwyNTg6WzEsMTg2XX0pLG8oJFZtMSxbMiwzNDhdLHsyNDA6WzEsMTg3XSwyNDU6WzEsMTg4XX0pLHs1OjE4OSwxMDokVjF9LHs1OjE5MCwxMDokVjF9LG8oJFZtMSxbMiwzMTFdKSx7NToxOTEsMTA6JFYxfSx7MTA6WzEsMTkzXSwxMzoxOTIsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSxvKCRWbTEsWzIsMjU2XSksezEzMDoxOTUsMTM0OiRWeSwyMDA6MTk0LDIwMTokVlF9LHsxMzA6MTk3LDEzNDokVnksMjAwOjE5NiwyMDE6JFZRfSx7MTMwOjE5OSwxMzQ6JFZ5LDE2NDoyMDAsMTY1OiRWSSwyMDA6MTk4LDIwMTokVlF9LHszMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQxOjE4MSw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTE1OjEwNCwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0MjoxODIsMTQ3OiRWQiwxNjE6NzksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6MjAxLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwNTokVlMsMjA2OiRWVH0sbygkVm0xLFsyLDEzMF0pLG8oJFZBMSxbMiwxMDhdLHsxMTE6MjAyLDExNDoyMDQsMTE1OjIwNSw1NzpbMSwyMDZdLDk2OlsxLDIwM10sMTE2OlsxLDIwN10sMjA2OiRWVH0pLHs1NjoyMDksNTc6JFY5LDk2OlsxLDIxMF0sMTYwOjIwOH0sbygkVnYxLFsyLDgzXSx7NDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsMTg6MzEsMTk6MzIsMjY6MzcsMTQyOjQwLDE4Nzo0MSwzODo0MiwzOTo0MywxOTU6NDQsMTcyOjQ2LDEzOTo0NywxMDg6NDgsMTk3OjQ5LDM1OjUwLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE4NDo2MCwyNDM6NjEsMjE5OjYzLDIyMzo2NCwyMjU6NjUsMjAwOjY3LDEzMDo3MiwxNTk6NzQsMTc1Ojc4LDE2MTo3OSw3MTo4MSw4OTo5NCwxNjQ6OTYsNjU6MTAwLDYwOjEwMSw2MzoxMDIsNjc6MTAzLDExNToxMDQsMTgwOjEwNSw1NjoxMDYsMjI2OjExMSwyMzA6MTEyLDY5OjEyMCw3MzoxMjEsMTY6MTYwLDEzOjIxMSw4ODoyMTIsMjA6JFYyLDIxOiRWMywyMjokVkIxLDI0OiRWNCwyNTokVjUsMjc6JFY2LDMzOiRWNywzNjokVjgsNTc6JFY5LDYxOiRWYSw2MjokVmIsNjQ6JFZjLDY2OiRWZCw2ODokVmUsNzA6JFZmLDcyOiRWZyw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTEwOiRWdCwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDE0MDokVnosMTQxOiRWQSwxNDc6JFZCLDE1NDokVkUsMTU1OiRWRiwxNjI6JFZHLDE2MzokVkgsMTY1OiRWSSwxODE6JFZLLDE4MzokVkwsMTg1OiRWTSwxOTM6JFZOLDE5NDokVk8sMTk2OiRWUCwyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMjQ6JFZZLDIzODokViQsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9KSx7MTM6MjE0LDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sezI4OjIxNSwzMDoyMTYsMzI6MjE3LDMzOiRWQzEsMzQ6MjE5LDU2OjIyMSw1NzokVjksNjU6MjIwLDY2OiRWZH0sbygkVnkxLFsyLDIzNF0pLG8oJFZ5MSxbMiwyMzVdKSxvKCRWRDEsWzIsMjMyXSksbygkVncxLFsyLDczXSksbygkVncxLFsyLDc0XSksbygkVncxLFsyLDc1XSksbygkVncxLFsyLDc2XSksbygkVncxLFsyLDc3XSksbygkVncxLFsyLDc4XSksbygkVncxLFsyLDc5XSksbygkVncxLFsyLDgwXSksezQ6MjIyLDc6JFYwLDg6NSwxMDpbMSwyMjNdLDEyOjcsMTM6OCwxNTo5LDE2OjEwLDE3OjExLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMjg6JFZ1LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTQ5OiRWQywxNTA6JFZELDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE3NzokVkosMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LHsxMDokVkUxLDEyOjIyOSwxMzoyMjQsMTU6MjMxLDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwNDokVkYxLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTI2OjIyNiwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE0OTokVkMsMTUwOiRWRCwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxNzc6JFZKLDE3ODokVkcxLDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMDoyMjcsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LG8oWzEsNiwxMCwxMSwxNCwyMiwyMyw3OSw5NSw5Nyw5OCwxMDQsMTE3LDExOCwxMjUsMTM2LDE0NiwxNDgsMTU1LDE1OCwxNzgsMTg5LDE5MCwxOTIsMjA0LDIwOCwyMDksMjIwLDIyMSwyMjIsMjI3LDIyOCwyMzcsMjQ2LDI0NywyNTAsMjUxLDI1NCwyNTUsMjU2LDI1N10sWzIsMjcyXSksbygkVncxLFsyLDE0Ml0pLG8oJFZ3MSxbMiwxNDNdKSx7OTE6MjMzLDkyOlsxLDIzNF0sOTM6WzEsMjM1XSw5NDpbMSwyMzZdLDk1OlsxLDIzN10sOTg6WzEsMjM4XSw5OTpbMSwyMzldLDEwMDpbMSwyNDBdLDEwMTpbMSwyNDFdLDEwMjpbMSwyNDJdLDEwMzpbMSwyNDNdLDEwNzpbMSwyNDRdLDEwOTpbMSwyMzJdfSxvKCRWdzEsWzIsMzhdLHs3MTo4MSw2OToxMjAsNzM6MTIxLDM3OjI0NSwzODoyNDYsMzk6MjQ3LDMzOiRWNyw3MDokVmYsNzI6JFZnLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sMTQ3OiRWQn0pLG8oJFZtMSxbMiwxNzJdKSx7NToyNDgsMTA6JFYxLDE1NjpbMSwyNDldfSx7NToyNTAsMTA6JFYxfSxvKCRWRDEsWzIsMjEzXSksbygkVkQxLFsyLDIxNF0pLG8oJFZEMSxbMiwyMTVdKSxvKCRWRDEsWzIsMjE2XSksbygkVkQxLFsyLDIxN10pLG8oJFZEMSxbMiwyMThdKSxvKCRWRDEsWzIsMjE5XSksbygkVkQxLFsyLDIyMF0pLHsxMzoyNTEsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSx7MTM6MjUyLDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sezEzOjI1MywxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LHs1OjI1NCwxMDokVjEsMTM6MjU1LDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sezU2OjI2MCw1NzokVjksOTY6JFZyLDEwMzokVnMsMTYxOjI2MiwxNzU6MjYxLDE5NToyNTYsMjMyOjI1NywyMzM6WzEsMjU4XSwyMzQ6MjU5fSx7MjMxOjI2MywyMzU6WzEsMjY0XSwyMzY6WzEsMjY1XX0sezMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDE6MTgxLDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTU6MTA0LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjE4MiwxNDc6JFZCLDE2MTo3OSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDoyNjYsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjA1OiRWUywyMDY6JFZUfSx7MTE2OiRWSDEsMTM1OjI2NywxMzg6JFZJMX0sbygkVkoxLFsyLDE2OF0pLG8oJFZKMSxbMiwxNjldKSxvKFs2LDEwLDE0LDk3XSwkVksxLHs2OToxMjAsNzM6MTIxLDE5OToyNzAsMTQ0OjI3MSwxNDU6MjcyLDE1OjI3Myw1NjoyNzQsNjU6Mjc1LDU4OjI3Niw3MToyNzcsNjA6Mjc4LDYzOjI3OSwzMzokVjcsNTc6JFY5LDU5OiRWTDEsNjE6JFZhLDYyOiRWYiw2NDokVmMsNjY6JFZkLDcwOiRWZiw3MjokVmcsNzQ6JFZoLDE0NzokVk0xLDE0OTokVkMsMTUwOiRWRH0pLG8oJFZ3MSxbMiw2M10pLG8oJFZ3MSxbMiw2NF0pLG8oJFZ3MSxbMiw2NV0pLG8oJFZ3MSxbMiw2Nl0sezc2OjI4Myw3NTpbMSwyODJdLDc3OlsxLDI4NF0sNzg6WzEsMjg1XX0pLG8oJFZOMSxbMiw4NF0pLHs1NjoyOTEsNTc6JFY5LDYzOjI5MCw2NDokVmMsNjU6MjkyLDY2OiRWZCw5NjokVk8xLDExNToyODksMTY2OjI4NiwxNjg6Mjg3LDE3MjoyODgsMjA1OiRWUywyMDY6JFZUfSxvKFsxLDYsMTAsMTEsMTQsMjIsMjMsMjksNzksOTUsOTcsOTgsMTA0LDExNywxMTgsMTIyLDEyNSwxMzYsMTQ2LDE0OCwxNTUsMTU4LDE3MCwxNzEsMTc4LDE4OSwxOTAsMTkyLDIwNCwyMDgsMjA5LDIyMCwyMjEsMjIyLDIyNywyMjgsMjM3LDI0NiwyNDcsMjUwLDI1MSwyNTIsMjUzLDI1NCwyNTUsMjU2LDI1NywyNThdLFsyLDYwXSksbygkVlAxLFsyLDU3XSksbygkVlAxLFsyLDU4XSksbyhbMSw2LDEwLDExLDE0LDIyLDIzLDc5LDk1LDk3LDk4LDEwNCwxMTcsMTE4LDEyMiwxMjUsMTM2LDE0NiwxNDgsMTU1LDE1OCwxNzgsMTg5LDE5MCwxOTIsMjA0LDIwOCwyMDksMjIwLDIyMSwyMjIsMjI3LDIyOCwyMzcsMjQ2LDI0NywyNTAsMjUxLDI1MiwyNTMsMjU0LDI1NSwyNTYsMjU3LDI1OF0sWzIsNTldKSxvKCRWRDEsWzIsNjFdKSxvKCRWUDEsWzIsMjczXSksezU2OjI5Nyw1NzokVjksNjU6Mjk2LDY2OiRWZCwxMDM6JFZRMSwxNzU6Mjk4LDE3NzpbMSwyOTRdLDE4MjoyOTV9LHs1NjoyOTcsNTc6JFY5LDY1OjI5Niw2NjokVmQsMTAzOiRWUTEsMTc1OjI5OCwxNzc6WzEsMzAxXSwxODI6MzAwfSxvKFsxLDYsMTAsMTEsMTQsMjIsMjMsMjksNzksOTUsOTYsOTcsOTgsMTA0LDEwNSwxMTcsMTE4LDEyMiwxMjUsMTM2LDE0NiwxNDgsMTU1LDE1OCwxNzAsMTcxLDE3OCwxODksMTkwLDE5MiwyMDQsMjA4LDIwOSwyMjAsMjIxLDIyMiwyMjcsMjI4LDIzNSwyMzYsMjM3LDI0NiwyNDcsMjUwLDI1MSwyNTIsMjUzLDI1NCwyNTUsMjU2LDI1NywyNThdLFsyLDU1XSksbygkVlIxLFsyLDMxN10pLG8oJFZSMSxbMiwzMThdKSxvKCRWRDEsWzIsNjJdKSxvKCRWUzEsWzIsNjddKSxvKCRWODEsWzIsN10sezEyOjcsMTM6OCwxNTo5LDE2OjEwLDE3OjExLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDE4OjMxLDE5OjMyLDI2OjM3LDE0Mjo0MCwxODc6NDEsMzg6NDIsMzk6NDMsMTk1OjQ0LDE3Mjo0NiwxMzk6NDcsMTA4OjQ4LDE5Nzo0OSwzNTo1MCwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxODQ6NjAsMjQzOjYxLDIxOTo2MywyMjM6NjQsMjI1OjY1LDIwMDo2NywxMzA6NzIsMTU5Ojc0LDE3NTo3OCwxNjE6NzksNzE6ODEsODk6OTQsMTY0Ojk2LDY1OjEwMCw2MDoxMDEsNjM6MTAyLDY3OjEwMywxMTU6MTA0LDE4MDoxMDUsNTY6MTA2LDIyNjoxMTEsMjMwOjExMiw2OToxMjAsNzM6MTIxLDg6MzAyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNzokVjYsMzM6JFY3LDM2OiRWOCw1NzokVjksNjE6JFZhLDYyOiRWYiw2NDokVmMsNjY6JFZkLDY4OiRWZSw3MDokVmYsNzI6JFZnLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMTA6JFZ0LDEyODokVnUsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxNDA6JFZ6LDE0MTokVkEsMTQ3OiRWQiwxNDk6JFZDLDE1MDokVkQsMTU0OiRWRSwxNTU6JFZGLDE2MjokVkcsMTYzOiRWSCwxNjU6JFZJLDE3NzokVkosMTgxOiRWSywxODM6JFZMLDE4NTokVk0sMTkzOiRWTiwxOTQ6JFZPLDE5NjokVlAsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjIwOiRWVywyMjI6JFZYLDIyNDokVlksMjI3OiRWWiwyMjg6JFZfLDIzODokViQsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9KSxvKFsxLDYsMTEsMjAsMjEsMjQsMjUsMjcsMzMsMzYsNTcsNTksNjEsNjIsNjQsNjYsNjgsNzAsNzIsNzQsODAsODEsODIsODMsODQsODUsODYsODcsOTAsOTYsMTAzLDExMCwxMjgsMTMxLDEzMiwxMzMsMTM0LDE0MCwxNDEsMTQ3LDE0OCwxNDksMTUwLDE1NCwxNTUsMTYyLDE2MywxNjUsMTc3LDE3OCwxODEsMTgzLDE4NSwxOTMsMTk0LDE5NiwyMDEsMjAyLDIwNSwyMDYsMjEyLDIxOCwyMjAsMjIyLDIyNCwyMjcsMjI4LDIzOCwyNDQsMjQ4LDI0OSwyNTAsMjUxLDI1MiwyNTNdLFsyLDhdKSx7MTpbMiwzXX0sezEyOjMwNCwxMzozMDMsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE3NzokVkosMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LG8oJFZUMSxbMiw5XSksezY6JFY3MSw5OjEzNywxMTpbMSwzMDVdfSx7NDozMDYsNzokVjAsODo1LDEyOjcsMTM6OCwxNTo5LDE2OjEwLDE3OjExLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMjg6JFZ1LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTQ5OiRWQywxNTA6JFZELDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE3NzokVkosMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LHsxMzozMDcsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSx7MTM6MzA4LDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sezEzOjMwOSwxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LHsxMzozMTAsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSx7MTM6MzExLDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sezEzOjMxMiwxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LHsyNTc6WzEsMzEzXX0sezEzOjMxNCwxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LHsxMzozMTUsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSx7MTM6MzE2LDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sbygkVm0xLFsyLDMxMF0pLG8oJFZtMSxbMiwzMTVdKSx7MTM6MzE3LDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sbygkVm0xLFsyLDMwOV0pLG8oJFZtMSxbMiwzMTRdKSxvKFsxLDYsMTAsMTEsMTQsMjMsMTA0LDE0OF0sWzIsMjAzXSx7MjI2OjExMSwyMzA6MTEyLDIxOToxNTQsMjI1OjE1NSwxMzY6JFZiMSwxNzg6JFZjMSwyMjA6JFZXLDIyMjokVlgsMjI3OiRWWiwyMjg6JFZfLDI0NjokVmQxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSksezIxOToxNTcsMjIwOiRWVywyMjI6JFZYLDIyNToxNTgsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyNDY6JFZsMX0sezIyOiRWQjEsODg6MzE4fSxvKCRWdzEsWzIsMjY3XSksbygkVlUxLFsyLDIzMF0sezE4NzozMjAsNjk6MzIxLDcwOiRWZiwxODY6WzEsMzE5XSwxOTM6JFZOfSksezU2OjMyMiw1NzokVjksNjA6MzIzLDYxOiRWYSw2MjokVmIsNjU6MzI0LDY2OiRWZH0sezU2OjMyNSw1NzokVjl9LHs1NjozMjYsNTc6JFY5fSx7MTM6MzI4LDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkxOjMyNywxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDE5ODozMjksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjA3OjMzMCwyMDg6JFZWMSwyMDk6JFZXMSwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sezIyOlsyLDI2OV19LG8oJFZVMSxbMiwyMzFdKSx7MTM6MzMzLDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sezEzOjMzNCwxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LHsxMzozMzUsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSxvKCRWYTEsWzIsMTI5XSx7MjI2OjExMSwyMzA6MTEyLDIxOToxNTQsMjI1OjE1NSwxMzY6JFZiMSwxNzg6JFZjMSwyMjA6JFZXLDIyMjokVlgsMjI3OiRWWiwyMjg6JFZfLDI0NjokVmQxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSksbygkVlgxLFsyLDIzNl0sezIyNjoxMTEsMjMwOjExMiwyMTk6MTU0LDIyNToxNTUsMTM2OiRWYjEsMTc4OiRWYzEsMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9KSx7MTA6WzEsMzM3XSwxMzozMzYsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSxvKCRWWTEsWzIsMzUyXSx7MjI2OjExMSwyMzA6MTEyLDIxOToxNTQsMjI1OjE1NSwyNTY6JFZqMX0pLG8oJFZZMSxbMiwzNTNdLHsyMjY6MTExLDIzMDoxMTIsMjE5OjE1NCwyMjU6MTU1LDI1NjokVmoxfSksbygkVlkxLFsyLDM1NF0sezIyNjoxMTEsMjMwOjExMiwyMTk6MTU0LDIyNToxNTUsMjU2OiRWajF9KSxvKCRWWTEsWzIsMzU1XSx7MjI2OjExMSwyMzA6MTEyLDIxOToxNTQsMjI1OjE1NSwyNTY6JFZqMX0pLG8oJFZtMSxbMiwzNTZdLHsyMjokVnoxLDk1OiRWejEsMTE3OiRWejEsMTU1OiRWejEsMTg5OiRWejEsMTkwOiRWejEsMTkyOiRWejEsMjA0OiRWejF9KSx7MjI6JFZuMSw5NTokVm8xLDExNzokVnAxLDE1MjoxNjIsMTU1OiRWRiwxODg6MTY0LDE4OTokVnExLDE5MDokVnIxLDE5MjokVnMxLDIwMzoxNjEsMjA0OiRWdDF9LG8oWzIyLDk1LDExNywxNTUsMTg5LDE5MCwxOTIsMjA0XSwkVngxKSxvKCRWbTEsWzIsMzU3XSx7MjI6JFZ6MSw5NTokVnoxLDExNzokVnoxLDE1NTokVnoxLDE4OTokVnoxLDE5MDokVnoxLDE5MjokVnoxLDIwNDokVnoxfSksbygkVm0xLFsyLDM1OF0pLG8oJFZtMSxbMiwzNTldKSx7MTA6WzEsMzM5XSwxMzozMzgsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSx7NTozNDEsMTA6JFYxLDI0NDpbMSwzNDBdfSx7MTM6MzQyLDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sbygkVm0xLFsyLDI5NV0sezIxMzozNDMsMjE0OjM0NCwyMTU6JFZaMSwyMTY6WzEsMzQ1XX0pLG8oJFZtMSxbMiwzMDhdKSxvKCRWbTEsWzIsMzE2XSksezEwOlsxLDM0N10sMTM2OiRWYjEsMTc4OiRWYzEsMjE5OjE1NCwyMjA6JFZXLDIyMjokVlgsMjI1OjE1NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDI0NjokVmQxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSx7MjM5OjM0OCwyNDE6MzQ5LDI0MjokVl8xfSxvKCRWbTEsWzIsMjU3XSksbygkVm0xLFsyLDEzMV0pLG8oJFZtMSxbMiwyNThdKSxvKCRWbTEsWzIsMTMyXSksbygkVm0xLFsyLDI1OV0pLG8oJFZtMSxbMiwxMzNdKSxvKCRWbTEsWzIsMTczXSksbygkViQxLFsyLDI2NF0sezU6MzUxLDEwOiRWMSwyMjokVnoxLDk1OiRWejEsMTE3OiRWejEsMTU1OiRWejEsMTg5OiRWejEsMTkwOiRWejEsMTkyOiRWejEsMjA0OiRWejF9KSx7NjA6MzU3LDYxOiRWYSw2MjokVmIsOTU6WzEsMzUzXSw5ODpbMSwzNTZdLDExMjpbMSwzNTJdLDExNzpbMSwzNTRdLDExOTpbMSwzNTVdLDEyMDozNTgsMTIxOlsxLDM1OV19LHsxMzozNjAsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSxvKCRWQTEsWzIsMTA5XSksbygkVkExLFsyLDEwNV0pLG8oJFZBMSxbMiwxMDZdKSxvKCRWQTEsWzIsMTA3XSksbygkVm0xLFsyLDE2N10sezE2MTozNjEsMjI6WzEsMzYyXSw5NjokVnJ9KSxvKCRWMDIsWzIsMTcwXSksezEzOjM2MywxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LG8oJFZ2MSxbMiw4MV0sezIyNjoxMTEsMjMwOjExMiwyMTk6MTU0LDIyNToxNTUsMTM2OiRWYjEsMTc4OiRWYzEsMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9KSxvKCRWdjEsWzIsODJdKSx7MTA6JFZFMSwxMjoyMjksMTM6MzY2LDE1OjIzMSwxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyMzpbMSwzNjRdLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTI2OjM2NSwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE0OTokVkMsMTUwOiRWRCwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxNzc6JFZKLDE3ODokVkcxLDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMDoyMjcsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LG8oJFZ2MSxbMiwzMDFdLHsyMjY6MTExLDIzMDoxMTIsMjE5OjE1NCwyMjU6MTU1LDEzNjokVmIxLDE3ODokVmMxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSksezE0OlsxLDM2OF0sMjk6WzEsMzY3XX0sbygkVnYxLFsyLDMwXSx7MzE6WzEsMzY5XX0pLG8oJFYxMixbMiwzMl0pLG8oWzEsNiwxMSwxNCwzMSwxNDgsMjIwLDIyMiwyMjcsMjI4LDI0Nl0sWzIsMzFdKSxvKCRWMjIsWzIsMzRdKSxvKCRWMjIsWzIsMjA4XSksbygkVjIyLFsyLDIwOV0pLHs2OiRWNzEsOToxMzcsMTQ4OlsxLDM3MF19LHs0OjM3MSw3OiRWMCw4OjUsMTI6NywxMzo4LDE1OjksMTY6MTAsMTc6MTEsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEyODokVnUsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNDk6JFZDLDE1MDokVkQsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTc3OiRWSiwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sbyhbNiwxMCwxNCwxMDRdLCRWMzIsezIyNjoxMTEsMjMwOjExMiwyMTk6MTU0LDIyNToxNTUsMjA3OjM3MiwxMzY6JFZiMSwxNzg6JFZjMSwyMDg6JFZWMSwyMDk6JFZXMSwyMjA6JFZXLDIyMjokVlgsMjI3OiRWWiwyMjg6JFZfLDI0NjokVmQxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSksbygkVjQyLFsyLDI3NF0pLG8oWzYsMTAsMTA0XSwkVjUyLHsxNzM6MzczLDE0OiRWNjJ9KSxvKCRWNzIsWzIsMjgyXSksezEwOiRWRTEsMTI6MjI5LDEzOjM2NiwxNToyMzEsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMjY6Mzc1LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTQ5OiRWQywxNTA6JFZELDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE3NzokVkosMTc4OiRWRzEsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEwOjIyNywyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sbygkVjcyLFsyLDI5MF0pLG8oJFY3MixbMiwyOTFdKSxvKCRWNzIsWzIsMjkyXSksbygkVncxLFsyLDk4XSksbygkVk4xLFsyLDg1XSksbygkVk4xLFsyLDg2XSksbygkVk4xLFsyLDg3XSksbygkVk4xLFsyLDg4XSksezk2OlsxLDM3Nl19LHs5NjpbMSwzNzddfSxvKCRWTjEsWzIsOTFdKSxvKCRWTjEsWzIsOTJdKSxvKCRWTjEsWzIsOTNdKSxvKCRWTjEsWzIsOTRdKSx7NTY6Mzc4LDU3OiRWOX0sbygkVk4xLFsyLDk3XSksbygkVncxLFsyLDM1XSksbygkVncxLFsyLDM2XSksbygkVncxLFsyLDM3XSksbygkVncxLFsyLDE2M10pLG8oWzE0LDE1OF0sJFY4Mix7MTU3OjM3OSwxNzQ6MzgwLDE2MTozODEsMTc1OjM4MiwxNzY6MzgzLDU2OjM4Nyw1NzokVjksOTY6JFZyLDEwMzokVlExLDE3NzokVjkyLDE3ODokVmEyLDE3OTokVmIyfSksbygkVm0xLFsyLDE2Ml0pLHs1OjM4OCwxMDokVjEsMTM2OiRWYjEsMTc4OiRWYzEsMjE5OjE1NCwyMjA6JFZXLDIyMjokVlgsMjI1OjE1NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDI0NjokVmQxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSxvKCRWYzIsWzIsMzA0XSx7MjI2OjExMSwyMzA6MTEyLDIxOToxNTQsMjI1OjE1NSwxMzY6JFZiMSwxNzg6JFZjMSwyMjA6JFZXLDIyMTpbMSwzODldLDIyMjokVlgsMjI3OiRWWiwyNDc6JFZlMSwyNTA6JFZmMSwyNTE6JFZnMSwyNTQ6JFZoMSwyNTU6JFZpMSwyNTY6JFZqMSwyNTc6JFZrMX0pLG8oJFZjMixbMiwzMDZdLHsyMjY6MTExLDIzMDoxMTIsMjE5OjE1NCwyMjU6MTU1LDEzNjokVmIxLDE3ODokVmMxLDIyMDokVlcsMjIxOlsxLDM5MF0sMjIyOiRWWCwyMjc6JFZaLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSksbygkVm0xLFsyLDMxMl0pLG8oJFZkMixbMiwzMTNdLHsyMjY6MTExLDIzMDoxMTIsMjE5OjE1NCwyMjU6MTU1LDEzNjokVmIxLDE3ODokVmMxLDIyMDokVlcsMjIyOiRWWCwyMjc6JFZaLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSksbygkVm0xLFsyLDMyMF0pLG8oJFZlMixbMiwzMjJdKSx7NTY6MjYwLDU3OiRWOSw5NjokVnIsMTAzOiRWUTEsMTYxOjI2MiwxNzU6MjYxLDIzMjozOTEsMjM0OjI1OX0sbygkVmUyLFsyLDMyN10sezE0OlsxLDM5Ml19KSxvKCRWZjIsWzIsMzI0XSksbygkVmYyLFsyLDMyNV0pLG8oJFZmMixbMiwzMjZdKSxvKCRWbTEsWzIsMzIxXSksezEzOjM5MywxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LHsxMzozOTQsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSxvKCRWZzIsWzIsMjYwXSx7NTozOTUsMTA6JFYxLDIyOiRWejEsOTU6JFZ6MSwxMTc6JFZ6MSwxNTU6JFZ6MSwxODk6JFZ6MSwxOTA6JFZ6MSwxOTI6JFZ6MSwyMDQ6JFZ6MSwxMzY6WzEsMzk2XX0pLG8oJFZnMixbMiwxMzRdLHs1OjM5NywxMDokVjEsMTM2OlsxLDM5OF19KSxvKCRWbTEsWzIsMTQwXSksbygkVm0xLFsyLDE0MV0pLG8oWzYsMTAsOTddLCRWNTIsezE3MzozOTksMTQ6JFZoMn0pLG8oJFZpMixbMiwyNTJdKSxvKCRWaTIsWzIsMTQ2XSx7MTQ2OlsxLDQwMV19KSxvKCRWaTIsWzIsMTQ5XSksbygkVmoyLFsyLDE1MF0pLG8oJFZqMixbMiwxNTFdKSxvKCRWajIsWzIsMTUyXSksbygkVmoyLFsyLDE1M10pLG8oJFZqMixbMiwxNTRdKSxvKCRWajIsWzIsMTU1XSksezEzOjQwMiwxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LG8oJFZqMixbMiw1Nl0pLG8oJFZTMSxbMiw2OF0pLG8oJFZTMSxbMiw2OV0pLG8oJFZTMSxbMiw3MF0pLHsxMzo0MDQsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsNzk6WzEsNDAzXSw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LHs5NTpbMSw0MDZdLDk4OlsxLDQwN10sMTY3OjQwNX0sbygkVmsyLFsyLDE4Nl0sezE2OTo0MDksMjI6WzEsNDA4XSwxNzA6JFZsMiwxNzE6JFZtMn0pLG8oJFZrMixbMiwxODddKSxvKCRWazIsWzIsMTg4XSksbygkVmsyLFsyLDE4OV0pLG8oJFZuMixbMiwxODBdKSxvKCRWbjIsWzIsMTgxXSksezEzOjQxMiwxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LHs1NjoyOTcsNTc6JFY5LDY1OjI5Niw2NjokVmQsMTAzOiRWUTEsMTc1OjI5OCwxODI6NDEzfSxvKCRWRDEsWzIsMjA1XSksbygkVkQxLFsyLDIxMF0pLG8oJFZEMSxbMiwyMTFdKSxvKCRWRDEsWzIsMjEyXSksezEwOiRWRTEsMTI6MjI5LDEzOjM2NiwxNToyMzEsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA0OiRWRjEsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMjY6MjI2LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTQ5OiRWQywxNTA6JFZELDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE3NzokVkosMTc4OiRWRzEsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEwOjIyNywyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sbygkVkQxLFsyLDIwNl0pLHs1NjoyOTcsNTc6JFY5LDY1OjI5Niw2NjokVmQsMTAzOiRWUTEsMTc1OjI5OCwxODI6NDE0fSxvKCRWODEsWzIsNl0sezE0OiRWOTF9KSxvKCRWYTEsWzIsMTRdLHsyMjY6MTExLDIzMDoxMTIsMjE5OjE1NCwyMjU6MTU1LDEzNjokVmIxLDE3ODokVmMxLDIyMDokVlcsMjIyOiRWWCwyMjc6JFZaLDIyODokVl8sMjQ2OiRWZDEsMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9KSxvKCRWYTEsWzIsMTVdKSxvKCRWVDEsWzIsMTBdKSx7NjokVjcxLDk6MTM3LDExOlsxLDQxNV19LG8oJFZvMixbMiwzNjBdLHsyMjY6MTExLDIzMDoxMTIsMjE5OjE1NCwyMjU6MTU1LDI1NDokVmgxLDI1NjokVmoxfSksbygkVm8yLFsyLDM2MV0sezIyNjoxMTEsMjMwOjExMiwyMTk6MTU0LDIyNToxNTUsMjU0OiRWaDEsMjU2OiRWajF9KSxvKCRWWTEsWzIsMzYyXSx7MjI2OjExMSwyMzA6MTEyLDIxOToxNTQsMjI1OjE1NSwyNTY6JFZqMX0pLG8oWzEsNiwxMCwxMSwxNCwyMyw3OSw5NywxMDQsMTE4LDEyNSwxMzYsMTQ2LDE0OCwxNTgsMTc4LDIwOCwyMDksMjIwLDIyMSwyMjIsMjI3LDIyOCwyMzcsMjQ2LDI0NywyNTUsMjU3XSxbMiwzNjNdLHsyMjY6MTExLDIzMDoxMTIsMjE5OjE1NCwyMjU6MTU1LDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NjokVmoxfSksbyhbMSw2LDEwLDExLDE0LDIzLDc5LDk3LDEwNCwxMTgsMTI1LDEzNiwxNDYsMTQ4LDE1OCwxNzgsMjA4LDIwOSwyMjAsMjIxLDIyMiwyMjcsMjI4LDIzNywyNDYsMjQ3XSxbMiwzNjRdLHsyMjY6MTExLDIzMDoxMTIsMjE5OjE1NCwyMjU6MTU1LDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSksbyhbMSw2LDEwLDExLDE0LDIzLDc5LDk3LDEwNCwxMTgsMTI1LDE0NiwxNDgsMTU4LDE3OCwyMDgsMjA5LDIyMCwyMjEsMjIyLDIyNywyMjgsMjM3LDI0NiwyNDddLFsyLDM2NV0sezIyNjoxMTEsMjMwOjExMiwyMTk6MTU0LDIyNToxNTUsMTM2OiRWYjEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9KSx7MTM6NDE2LDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sbyhbMSw2LDEwLDExLDE0LDIzLDc5LDk3LDEwNCwxMTgsMTI1LDEzNiwxNDYsMTQ4LDE1OCwxNzgsMjA4LDIwOSwyMjAsMjIxLDIyMiwyMjcsMjI4LDIzNywyNDYsMjQ3LDI1N10sWzIsMzY3XSx7MjI2OjExMSwyMzA6MTEyLDIxOToxNTQsMjI1OjE1NSwyNTA6JFZmMSwyNTE6JFZnMSwyNTQ6JFZoMSwyNTU6JFZpMSwyNTY6JFZqMX0pLG8oJFZwMixbMiwzNTBdLHsyMjY6MTExLDIzMDoxMTIsMjE5OjE1NCwyMjU6MTU1LDEzNjokVmIxLDE3ODokVmMxLDIyMDokVlcsMjIyOiRWWCwyMjc6JFZaLDIyODokVl8sMjQ2OiRWZDEsMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9KSx7MTM2OiRWYjEsMTQ2OlsxLDQxN10sMTc4OiRWYzEsMjE5OjE1NCwyMjA6JFZXLDIyMjokVlgsMjI1OjE1NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDI0NjokVmQxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSxvKCRWcDIsWzIsMzQ5XSx7MjI2OjExMSwyMzA6MTEyLDIxOToxNTQsMjI1OjE1NSwxMzY6JFZiMSwxNzg6JFZjMSwyMjA6JFZXLDIyMjokVlgsMjI3OiRWWiwyMjg6JFZfLDI0NjokVmQxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSksbygkVncxLFsyLDI2Nl0pLG8oJFZEMSxbMiwyMjFdKSxvKCRWRDEsWzIsMjIyXSksbygkVkQxLFsyLDIyN10pLG8oJFZEMSxbMiwyMjNdKSxvKCRWRDEsWzIsMjI2XSksbygkVkQxLFsyLDIyOF0pLG8oJFZEMSxbMiwyMjRdKSxvKCRWRDEsWzIsMjI1XSksezExODpbMSw0MThdfSx7MTE4OlsyLDI0OF0sMTM2OiRWYjEsMTc4OiRWYzEsMjA3OjQxOSwyMDg6JFZWMSwyMDk6JFZXMSwyMTk6MTU0LDIyMDokVlcsMjIyOiRWWCwyMjU6MTU1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjQ2OiRWZDEsMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9LHsxMTg6WzIsMjQ5XX0sezEzOjQyMCwxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LG8oJFZxMixbMiwyNzZdKSxvKCRWcTIsWzIsMjc3XSksezIzOlsxLDQyMV0sMTM2OiRWYjEsMTc4OiRWYzEsMjE5OjE1NCwyMjA6JFZXLDIyMjokVlgsMjI1OjE1NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDI0NjokVmQxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSx7MjM6WzEsNDIyXSwxMzY6JFZiMSwxNzg6JFZjMSwyMTk6MTU0LDIyMDokVlcsMjIyOiRWWCwyMjU6MTU1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjQ2OiRWZDEsMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9LG8oJFZhMSxbMiwxMjhdLHsyMjY6MTExLDIzMDoxMTIsMjE5OjE1NCwyMjU6MTU1LDEzNjokVmIxLDE3ODokVmMxLDIyMDokVlcsMjIyOiRWWCwyMjc6JFZaLDIyODokVl8sMjQ2OiRWZDEsMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9KSxvKCRWWDEsWzIsMTQ0XSx7MjI2OjExMSwyMzA6MTEyLDIxOToxNTQsMjI1OjE1NSwxMzY6JFZiMSwxNzg6JFZjMSwyNDc6JFZlMSwyNTA6JFZmMSwyNTE6JFZnMSwyNTQ6JFZoMSwyNTU6JFZpMSwyNTY6JFZqMSwyNTc6JFZrMX0pLHsxMzo0MjMsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSxvKCRWWDEsWzIsMzY4XSx7MjI2OjExMSwyMzA6MTEyLDIxOToxNTQsMjI1OjE1NSwxMzY6JFZiMSwxNzg6JFZjMSwyNDc6JFZlMSwyNTA6JFZmMSwyNTE6JFZnMSwyNTQ6JFZoMSwyNTU6JFZpMSwyNTY6JFZqMSwyNTc6JFZrMX0pLHsxMzo0MjQsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSx7MTM6NDI1LDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sbygkVnIyLFsyLDM0N10pLHs1OjQyNiwxMDokVjEsMTM2OiRWYjEsMTc4OiRWYzEsMjE5OjE1NCwyMjA6JFZXLDIyMjokVlgsMjI1OjE1NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDI0NjokVmQxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSxvKCRWbTEsWzIsMjk2XSx7MjE0OjQyNywyMTU6JFZaMX0pLG8oJFZtMSxbMiwyOTddKSx7MjE3OlsxLDQyOF19LHs1OjQyOSwxMDokVjF9LHsyMzk6NDMwLDI0MTozNDksMjQyOiRWXzF9LHsxMTpbMSw0MzFdLDI0MDpbMSw0MzJdLDI0MTo0MzMsMjQyOiRWXzF9LG8oJFZzMixbMiwzNDBdKSx7MTM6NDM1LDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTE6NDM0LDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSxvKCRWbTEsWzIsMjY1XSksbygkViQxLFsyLDEwMl0sezExMzo0MzYsNTQ6NDM5LDEwOlsxLDQzN10sMjI6WzEsNDM4XSwxMTA6JFZ0fSksezU3OlsxLDQ0MV0sNjY6WzEsNDQyXSw3MDpbMSw0NDBdLDk2OlsxLDQ0M119LHsxMzo0NDQsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSx7OTY6WzEsNDQ1XX0sezU3OlsxLDQ0Nl0sOTY6WzEsNDQ3XX0sbygkVkExLFsyLDExN10pLG8oJFZBMSxbMiwxMTldKSxvKCRWQTEsWzIsMTIwXSx7MTIyOlsxLDQ0OF19KSx7OTc6WzEsNDQ5XSwxMzY6JFZiMSwxNzg6JFZjMSwyMTk6MTU0LDIyMDokVlcsMjIyOiRWWCwyMjU6MTU1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjQ2OiRWZDEsMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9LG8oJFZtMSxbMiwxNjVdKSx7OTY6JFZyLDE2MTo0NTB9LHs5NzpbMSw0NTFdLDEzNjokVmIxLDE3ODokVmMxLDIxOToxNTQsMjIwOiRWVywyMjI6JFZYLDIyNToxNTUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyNDY6JFZkMSwyNDc6JFZlMSwyNTA6JFZmMSwyNTE6JFZnMSwyNTQ6JFZoMSwyNTU6JFZpMSwyNTY6JFZqMSwyNTc6JFZrMX0sbygkVncxLFsyLDI3MF0pLG8oWzYsMTAsMjNdLCRWNTIsezE3Mzo0NTIsMTQ6JFY2Mn0pLG8oJFY3MiwkVjMyLHsyMjY6MTExLDIzMDoxMTIsMjE5OjE1NCwyMjU6MTU1LDEzNjokVmIxLDE3ODokVmMxLDIyMDokVlcsMjIyOiRWWCwyMjc6JFZaLDIyODokVl8sMjQ2OiRWZDEsMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9KSx7MzA6NDUzLDMzOiRWQzF9LHszMjo0NTQsMzQ6MjE5LDU2OjIyMSw1NzokVjksNjU6MjIwLDY2OiRWZH0sezMyOjQ1NSwzNDoyMTksNTY6MjIxLDU3OiRWOSw2NToyMjAsNjY6JFZkfSxvKCRWdzEsWzIsMzAyXSksezY6JFY3MSw5OjEzNywxMTpbMSw0NTZdfSx7MTM6NDU3LDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sezY6JFY3MSw5OjQ1OSwxMDokVnQyLDEwNDpbMSw0NThdfSxvKFs2LDEwLDExLDIzLDEwNF0sJFZ1Mix7NDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsMTg6MzEsMTk6MzIsMjY6MzcsMTQyOjQwLDE4Nzo0MSwzODo0MiwzOTo0MywxOTU6NDQsMTcyOjQ2LDEzOTo0NywxMDg6NDgsMTk3OjQ5LDM1OjUwLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE4NDo2MCwyNDM6NjEsMjE5OjYzLDIyMzo2NCwyMjU6NjUsMjAwOjY3LDEzMDo3MiwxNTk6NzQsMTc1Ojc4LDE2MTo3OSw3MTo4MSw4OTo5NCwxNjQ6OTYsNjU6MTAwLDYwOjEwMSw2MzoxMDIsNjc6MTAzLDExNToxMDQsMTgwOjEwNSw1NjoxMDYsMjI2OjExMSwyMzA6MTEyLDY5OjEyMCw3MzoxMjEsMTY6MTYwLDEyOjIyOSwxNToyMzEsMTM6MzY2LDIxMDo0NjEsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI3OiRWNiwzMzokVjcsMzY6JFY4LDU3OiRWOSw2MTokVmEsNjI6JFZiLDY0OiRWYyw2NjokVmQsNjg6JFZlLDcwOiRWZiw3MjokVmcsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDExMDokVnQsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxNDA6JFZ6LDE0MTokVkEsMTQ3OiRWQiwxNDk6JFZDLDE1MDokVkQsMTU0OiRWRSwxNTU6JFZGLDE2MjokVkcsMTYzOiRWSCwxNjU6JFZJLDE3NzokVkosMTc4OiRWRzEsMTgxOiRWSywxODM6JFZMLDE4NTokVk0sMTkzOiRWTiwxOTQ6JFZPLDE5NjokVlAsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjIwOiRWVywyMjI6JFZYLDIyNDokVlksMjI3OiRWWiwyMjg6JFZfLDIzODokViQsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9KSxvKCRWdjIsJFY1Mix7MTczOjQ2MiwxNDokVjYyfSksezEzOjQ2MywxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LHsxMzo0NjQsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSx7MTA0OlsxLDQ2NV0sMTA1OlsxLDQ2Nl19LHsxNDokVncyLDE1ODpbMSw0NjddfSxvKCRWeDIsWzIsMTkzXSksbygkVngyLFsyLDE5NV0pLG8oJFZ4MixbMiwxOTZdKSxvKCRWeDIsWzIsMTk3XSx7MTIyOlsxLDQ2OV19KSx7NTY6Mzg3LDU3OiRWOSwxNzY6NDcwfSx7NTY6Mzg3LDU3OiRWOSwxNzY6NDcxfSx7NTY6Mzg3LDU3OiRWOSwxNzY6NDcyfSxvKFsxNCwyMywxMjIsMTU4XSxbMiwyMDJdKSxvKCRWcjIsWzIsMzQ0XSksezEzOjQ3MywxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LHsxMzo0NzQsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSxvKCRWZTIsWzIsMzIzXSksezU2OjI2MCw1NzokVjksOTY6JFZyLDEwMzokVlExLDE2MToyNjIsMTc1OjI2MSwyMzQ6NDc1fSxvKFsxLDYsMTAsMTEsMTQsMjMsNzksOTcsMTA0LDExOCwxMjUsMTQ2LDE0OCwxNTgsMjA4LDIwOSwyMjAsMjIyLDIyNywyMjgsMjQ2XSxbMiwzMjldLHsyMjY6MTExLDIzMDoxMTIsMjE5OjE1NCwyMjU6MTU1LDEzNjokVmIxLDE3ODokVmMxLDIyMTpbMSw0NzZdLDIzNzpbMSw0NzddLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSksbygkVnkyLFsyLDMzMF0sezIyNjoxMTEsMjMwOjExMiwyMTk6MTU0LDIyNToxNTUsMTM2OiRWYjEsMTc4OiRWYzEsMjIxOlsxLDQ3OF0sMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9KSxvKCRWbTEsWzIsMjYxXSksezEzOjQ3OSwxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LG8oJFZtMSxbMiwxMzVdKSx7MTE2OiRWSDEsMTM1OjQ4MCwxMzg6JFZJMX0sezY6JFY3MSw5OjQ4MiwxMDokVnoyLDk3OlsxLDQ4MV19LG8oWzYsMTAsMTEsOTddLCRWdTIsezY5OjEyMCw3MzoxMjEsMTQ1OjI3MiwxNToyNzMsNTY6Mjc0LDY1OjI3NSw1ODoyNzYsNzE6Mjc3LDYwOjI3OCw2MzoyNzksMTQ0OjQ4NCwzMzokVjcsNTc6JFY5LDU5OiRWTDEsNjE6JFZhLDYyOiRWYiw2NDokVmMsNjY6JFZkLDcwOiRWZiw3MjokVmcsNzQ6JFZoLDE0NzokVk0xLDE0OTokVkMsMTUwOiRWRH0pLHsxMDpbMSw0ODZdLDEzOjQ4NSwxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LHsxMzY6JFZiMSwxNDg6WzEsNDg3XSwxNzg6JFZjMSwyMTk6MTU0LDIyMDokVlcsMjIyOiRWWCwyMjU6MTU1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjQ2OiRWZDEsMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9LG8oJFZTMSxbMiw3MV0pLHs3OTpbMSw0ODhdLDEzNjokVmIxLDE3ODokVmMxLDIxOToxNTQsMjIwOiRWVywyMjI6JFZYLDIyNToxNTUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyNDY6JFZkMSwyNDc6JFZlMSwyNTA6JFZmMSwyNTE6JFZnMSwyNTQ6JFZoMSwyNTU6JFZpMSwyNTY6JFZqMSwyNTc6JFZrMX0sezU2OjI5MSw1NzokVjksNjU6MjkyLDY2OiRWZCw5NjokVk8xLDE2ODo0ODl9LG8oJFZBMixbMiwxNzhdKSxvKCRWQTIsWzIsMTc5XSksbygkVkIyLCRWODIsezE3NDozODAsMTYxOjM4MSwxNzU6MzgyLDE3NjozODMsNTY6Mzg3LDE1Nzo0OTAsNTc6JFY5LDk2OiRWciwxMDM6JFZRMSwxNzc6JFY5MiwxNzg6JFZhMiwxNzk6JFZiMn0pLG8oJFZtMSxbMiwxNzddKSx7NTo0OTEsMTA6JFYxLDE1Mjo0OTIsMTU1OiRWRn0sbygkVm0xLFsyLDE4NV0pLHs5NzpbMSw0OTNdLDEzNjokVmIxLDE3ODokVmMxLDIxOToxNTQsMjIwOiRWVywyMjI6JFZYLDIyNToxNTUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyNDY6JFZkMSwyNDc6JFZlMSwyNTA6JFZmMSwyNTE6JFZnMSwyNTQ6JFZoMSwyNTU6JFZpMSwyNTY6JFZqMSwyNTc6JFZrMX0sbygkVkQxLFsyLDIwNF0pLG8oJFZEMSxbMiwyMDddKSxvKCRWVDEsWzIsMTFdKSxvKCRWWTEsWzIsMzY2XSx7MjI2OjExMSwyMzA6MTEyLDIxOToxNTQsMjI1OjE1NSwyNTY6JFZqMX0pLHsxMzo0OTQsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSxvKCRWRDEsWzIsMjI5XSksezEzOjQ5NSwxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDExODpbMiwyODBdLDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LHsxMTg6WzIsMjgxXSwxMzY6JFZiMSwxNzg6JFZjMSwyMTk6MTU0LDIyMDokVlcsMjIyOiRWWCwyMjU6MTU1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjQ2OiRWZDEsMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9LG8oJFZ2MSxbMiwyM10pLG8oJFZ2MSxbMiwyNV0pLHs2OiRWNzEsOTo0OTcsMTE6JFZDMiwxMzY6JFZiMSwxNDM6NDk2LDE3ODokVmMxLDIxOToxNTQsMjIwOiRWVywyMjI6JFZYLDIyNToxNTUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyNDY6JFZkMSwyNDc6JFZlMSwyNTA6JFZmMSwyNTE6JFZnMSwyNTQ6JFZoMSwyNTU6JFZpMSwyNTY6JFZqMSwyNTc6JFZrMX0sezY6JFY3MSw5OjQ5NywxMTokVkMyLDEzNjokVmIxLDE0Mzo0OTksMTc4OiRWYzEsMjE5OjE1NCwyMjA6JFZXLDIyMjokVlgsMjI1OjE1NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDI0NjokVmQxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSx7NTo1MDAsMTA6JFYxLDEzNjokVmIxLDE3ODokVmMxLDIxOToxNTQsMjIwOiRWVywyMjI6JFZYLDIyNToxNTUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyNDY6JFZkMSwyNDc6JFZlMSwyNTA6JFZmMSwyNTE6JFZnMSwyNTQ6JFZoMSwyNTU6JFZpMSwyNTY6JFZqMSwyNTc6JFZrMX0sbygkVnIyLFsyLDM0Nl0pLG8oJFZtMSxbMiwyOThdKSx7NTo1MDEsMTA6JFYxfSxvKCRWbTEsWzIsMjk5XSksezExOlsxLDUwMl0sMjQwOlsxLDUwM10sMjQxOjQzMywyNDI6JFZfMX0sbygkVm0xLFsyLDMzOF0pLHs1OjUwNCwxMDokVjF9LG8oJFZzMixbMiwzNDFdKSx7NTo1MDUsMTA6JFYxLDE0OlsxLDUwNl19LG8oJFZEMixbMiwyOTNdLHsyMjY6MTExLDIzMDoxMTIsMjE5OjE1NCwyMjU6MTU1LDEzNjokVmIxLDE3ODokVmMxLDIyMDokVlcsMjIyOiRWWCwyMjc6JFZaLDIyODokVl8sMjQ2OiRWZDEsMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9KSxvKCRWbTEsWzIsMTAzXSksezEwOiRWRTEsMTI6MjI5LDEzOjM2NiwxNToyMzEsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMjY6NTA3LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTQ5OiRWQywxNTA6JFZELDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE3NzokVkosMTc4OiRWRzEsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEwOjIyNywyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sezEwOiRWRTEsMTI6MjI5LDEzOjM2NiwxNToyMzEsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMjY6NTA4LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTQ5OiRWQywxNTA6JFZELDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE3NzokVkosMTc4OiRWRzEsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEwOjIyNywyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sbygkVm0xLFsyLDEyNV0pLG8oJFZBMSxbMiwxMTBdKSxvKCRWQTEsWzIsMTEyXSksbygkVkExLFsyLDExM10pLHsxMzo1MDksMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSx7MTE4OlsxLDUxMF0sMTM2OiRWYjEsMTc4OiRWYzEsMjE5OjE1NCwyMjA6JFZXLDIyMjokVlgsMjI1OjE1NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDI0NjokVmQxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSx7MTM6NTExLDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sbygkVkExLFsyLDExNl0pLHsxMzo1MTIsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSx7MTIzOjUxMywxMjQ6WzEsNTE0XX0sezExMjpbMSw1MTVdfSx7MjM6WzEsNTE2XX0sbygkVjAyLFsyLDE3MV0pLHs2OiRWNzEsOTo0NTksMTA6JFZ0MiwyMzpbMSw1MTddfSxvKCRWdjEsWzIsMjhdKSxvKCRWMTIsWzIsMzNdKSxvKCRWdjEsWzIsMjldKSx7MTQ4OlsxLDUxOF19LHsxMDQ6WzEsNTE5XSwxMzY6JFZiMSwxNzg6JFZjMSwyMTk6MTU0LDIyMDokVlcsMjIyOiRWWCwyMjU6MTU1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjQ2OiRWZDEsMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9LG8oJFY0MixbMiwyNzVdKSx7MTI6MjI5LDEzOjM2NiwxNToyMzEsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE0OTokVkMsMTUwOiRWRCwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxNzc6JFZKLDE3ODokVkcxLDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMDo1MjAsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LHsxMDokVkUxLDEyOjIyOSwxMzozNjYsMTU6MjMxLDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTI2OjUyMSwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE0OTokVkMsMTUwOiRWRCwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxNzc6JFZKLDE3ODokVkcxLDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMDoyMjcsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LG8oJFY3MixbMiwyODNdKSx7NjokVjcxLDk6NTIzLDEwOiRWdDIsMTE6JFZDMiwxNDM6NTIyfSx7OTc6WzEsNTI0XSwxMzY6JFZiMSwxNzg6JFZjMSwyMTk6MTU0LDIyMDokVlcsMjIyOiRWWCwyMjU6MTU1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjQ2OiRWZDEsMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9LHs5NzpbMSw1MjVdLDEzNjokVmIxLDE3ODokVmMxLDIxOToxNTQsMjIwOiRWVywyMjI6JFZYLDIyNToxNTUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyNDY6JFZkMSwyNDc6JFZlMSwyNTA6JFZmMSwyNTE6JFZnMSwyNTQ6JFZoMSwyNTU6JFZpMSwyNTY6JFZqMSwyNTc6JFZrMX0sbygkVk4xLFsyLDk1XSksezMzOiRWNyw1NzpbMSw1MjddLDY5OjEyMCw3MDokVmYsNzE6NTI4LDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDk2OlsxLDUyOV0sMTA2OjUyNn0sezU6NTMwLDEwOiRWMX0sezU2OjM4Nyw1NzokVjksOTY6JFZyLDEwMzokVlExLDE2MTozODEsMTc0OjUzMSwxNzU6MzgyLDE3NjozODMsMTc3OiRWOTIsMTc4OiRWYTIsMTc5OiRWYjJ9LHsxMzo1MzIsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSxvKCRWeDIsWzIsMTk4XSksbygkVngyLFsyLDE5OV0pLG8oJFZ4MixbMiwyMDBdKSxvKCRWZDIsWzIsMzA1XSx7MjI2OjExMSwyMzA6MTEyLDIxOToxNTQsMjI1OjE1NSwxMzY6JFZiMSwxNzg6JFZjMSwyMjA6JFZXLDIyMjokVlgsMjI3OiRWWiwyNDc6JFZlMSwyNTA6JFZmMSwyNTE6JFZnMSwyNTQ6JFZoMSwyNTU6JFZpMSwyNTY6JFZqMSwyNTc6JFZrMX0pLG8oJFZkMixbMiwzMDddLHsyMjY6MTExLDIzMDoxMTIsMjE5OjE1NCwyMjU6MTU1LDEzNjokVmIxLDE3ODokVmMxLDIyMDokVlcsMjIyOiRWWCwyMjc6JFZaLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSksbygkVmUyLFsyLDMyOF0pLHsxMzo1MzMsMTY6MTYwLDE4OjMxLDE5OjMyLDIwOiRWMiwyMTokVjMsMjQ6JFY0LDI1OiRWNSwyNjozNywyNzokVjYsMzM6JFY3LDM1OjUwLDM2OiRWOCwzODo0MiwzOTo0Myw0MDoxMyw0MToxNCw0MjoxNSw0MzoxNiw0NDoxNyw0NToxOCw0NjoxOSw0NzoyMCw0ODoyMSw0OToyMiw1MDoyMyw1MToyNCw1MjoyNSw1MzoyNiw1NDoyNyw1NToyOCw1NjoxMDYsNTc6JFY5LDYwOjEwMSw2MTokVmEsNjI6JFZiLDYzOjEwMiw2NDokVmMsNjU6MTAwLDY2OiRWZCw2NzoxMDMsNjg6JFZlLDY5OjEyMCw3MDokVmYsNzE6ODEsNzI6JFZnLDczOjEyMSw3NDokVmgsODA6JFZpLDgxOiRWaiw4MjokVmssODM6JFZsLDg0OiRWbSw4NTokVm4sODY6JFZvLDg3OiRWcCw4OTo5NCw5MDokVnEsOTY6JFZyLDEwMzokVnMsMTA4OjQ4LDExMDokVnQsMTE1OjEwNCwxMzA6NzIsMTMxOiRWdiwxMzI6JFZ3LDEzMzokVngsMTM0OiRWeSwxMzk6NDcsMTQwOiRWeiwxNDE6JFZBLDE0Mjo0MCwxNDc6JFZCLDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE4MDoxMDUsMTgxOiRWSywxODM6JFZMLDE4NDo2MCwxODU6JFZNLDE4Nzo0MSwxOTM6JFZOLDE5NDokVk8sMTk1OjQ0LDE5NjokVlAsMTk3OjQ5LDIwMDo2NywyMDE6JFZRLDIwMjokVlIsMjA1OiRWUywyMDY6JFZULDIxMjokVlUsMjE4OiRWViwyMTk6NjMsMjIwOiRWVywyMjI6JFZYLDIyMzo2NCwyMjQ6JFZZLDIyNTo2NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDIzODokViQsMjQzOjYxLDI0NDokVjAxLDI0ODokVjExLDI0OTokVjIxLDI1MDokVjMxLDI1MTokVjQxLDI1MjokVjUxLDI1MzokVjYxfSx7MTM6NTM0LDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sezEzOjUzNSwxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LG8oWzEsNiwxMSwxNCwyMyw3OSw5NywxMDQsMTE4LDEyNSwxNDYsMTQ4LDE1OCwyMDgsMjA5LDIyMSwyMjgsMjM3LDI0Nl0sWzIsMjYyXSx7MjI2OjExMSwyMzA6MTEyLDIxOToxNTQsMjI1OjE1NSw1OjUzNiwxMDokVjEsMTM2OiRWYjEsMTc4OiRWYzEsMjIwOiRWVywyMjI6JFZYLDIyNzokVlosMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9KSxvKCRWJDEsWzIsMTM2XSx7NTo1MzcsMTA6JFYxfSksbyhbMSw2LDEwLDExLDE0LDIyLDIzLDc5LDk1LDk3LDEwNCwxMTcsMTE4LDEyMiwxMjUsMTM2LDE0NiwxNDgsMTU1LDE1OCwxNzgsMTg5LDE5MCwxOTIsMjA0LDIwOCwyMDksMjIwLDIyMSwyMjIsMjI3LDIyOCwyMzUsMjM2LDIzNywyNDYsMjQ3LDI1MCwyNTEsMjU0LDI1NSwyNTYsMjU3XSxbMiwyNTBdKSx7MTU6MjczLDMzOiRWNyw1NjoyNzQsNTc6JFY5LDU4OjI3Niw1OTokVkwxLDYwOjI3OCw2MTokVmEsNjI6JFZiLDYzOjI3OSw2NDokVmMsNjU6Mjc1LDY2OiRWZCw2OToxMjAsNzA6JFZmLDcxOjI3Nyw3MjokVmcsNzM6MTIxLDc0OiRWaCwxNDQ6NTM4LDE0NToyNzIsMTQ3OiRWTTEsMTQ5OiRWQywxNTA6JFZEfSxvKFs2LDEwLDExLDE0XSwkVksxLHs2OToxMjAsNzM6MTIxLDE0NDoyNzEsMTQ1OjI3MiwxNToyNzMsNTY6Mjc0LDY1OjI3NSw1ODoyNzYsNzE6Mjc3LDYwOjI3OCw2MzoyNzksMTk5OjUzOSwzMzokVjcsNTc6JFY5LDU5OiRWTDEsNjE6JFZhLDYyOiRWYiw2NDokVmMsNjY6JFZkLDcwOiRWZiw3MjokVmcsNzQ6JFZoLDE0NzokVk0xLDE0OTokVkMsMTUwOiRWRH0pLG8oJFZpMixbMiwyNTNdKSxvKCRWaTIsWzIsMTQ3XSx7MjI2OjExMSwyMzA6MTEyLDIxOToxNTQsMjI1OjE1NSwxMzY6JFZiMSwxNzg6JFZjMSwyMjA6JFZXLDIyMjokVlgsMjI3OiRWWiwyMjg6JFZfLDI0NjokVmQxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSksezEzOjU0MCwxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LG8oJFZqMixbMiwxNTZdKSxvKCRWUzEsWzIsNzJdKSx7MjI6WzEsNTQxXSwxNjk6NTQyLDE3MDokVmwyLDE3MTokVm0yfSx7MTQ6JFZ3MiwyMzpbMSw1NDNdfSxvKCRWbTEsWzIsMTgzXSksbygkVm0xLFsyLDE4NF0pLG8oJFZuMixbMiwxODJdKSxvKFsxLDYsMTAsMTEsMTQsMjMsNzksOTcsMTA0LDExOCwxMjUsMTQ2LDE0OCwxNTgsMjA4LDIwOSwyMjAsMjIxLDIyMiwyMjcsMjI4LDIzNywyNDYsMjQ3XSxbMiwzNTFdLHsyMjY6MTExLDIzMDoxMTIsMjE5OjE1NCwyMjU6MTU1LDEzNjokVmIxLDE3ODokVmMxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSksezExODpbMiwyNzldLDEzNjokVmIxLDE3ODokVmMxLDIxOToxNTQsMjIwOiRWVywyMjI6JFZYLDIyNToxNTUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyNDY6JFZkMSwyNDc6JFZlMSwyNTA6JFZmMSwyNTE6JFZnMSwyNTQ6JFZoMSwyNTU6JFZpMSwyNTY6JFZqMSwyNTc6JFZrMX0sbygkVm0xLFsyLDE0NV0pLHsxMTokVkUyfSxvKCRWbTEsWzIsMjg4XSksbygkVm0xLFsyLDM2OV0pLG8oJFZyMixbMiwzNDVdKSxvKFsxLDYsMTAsMTEsMTQsMjMsNzksOTcsMTA0LDExOCwxMjUsMTM2LDE0NiwxNDgsMTU4LDE3OCwyMDgsMjA5LDIxNSwyMjAsMjIxLDIyMiwyMjcsMjI4LDIzNywyNDYsMjQ3LDI1MCwyNTEsMjU0LDI1NSwyNTYsMjU3XSxbMiwzMDBdKSxvKCRWbTEsWzIsMzM2XSksezU6NTQ1LDEwOiRWMX0sezExOlsxLDU0Nl19LG8oJFZzMixbMiwzNDJdLHs2OlsxLDU0N119KSx7MTM6NTQ4LDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sbygkVkYyLCRWNTIsezE3Mzo1NTAsMTE6WzEsNTQ5XSwxNDokVjYyfSksbygkVkYyLCRWNTIsezE3Mzo1NTAsMTQ6JFY2MiwyMzpbMSw1NTFdfSksezk3OlsxLDU1Ml0sMTM2OiRWYjEsMTc4OiRWYzEsMjE5OjE1NCwyMjA6JFZXLDIyMjokVlgsMjI1OjE1NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDI0NjokVmQxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSxvKCRWQTEsWzIsMTExXSksezk3OlsxLDU1M10sMTM2OiRWYjEsMTc4OiRWYzEsMjE5OjE1NCwyMjA6JFZXLDIyMjokVlgsMjI1OjE1NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDI0NjokVmQxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSx7OTc6WzEsNTU0XSwxMzY6JFZiMSwxNzg6JFZjMSwyMTk6MTU0LDIyMDokVlcsMjIyOiRWWCwyMjU6MTU1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjQ2OiRWZDEsMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9LG8oJFZBMSxbMiwxMjFdKSx7MTM6NTU1LDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sbygkVm0xLFsyLDEwNF0pLG8oJFZtMSxbMiwxNjZdKSxvKCRWdzEsWzIsMjcxXSksbygkVncxLFsyLDMwM10pLG8oJFZ3MSxbMiwyNzhdKSxvKCRWNzIsWzIsMjg0XSksbygkVnYyLCRWNTIsezE3Mzo1NTYsMTQ6JFY2Mn0pLG8oJFY3MixbMiwyODVdKSx7MTE6JFZFMiwxMjoyMjksMTM6MzY2LDE1OjIzMSwxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTQ5OiRWQywxNTA6JFZELDE1MTo1MSwxNTI6NTIsMTUzOjUzLDE1NDokVkUsMTU1OiRWRiwxNTk6NzQsMTYxOjc5LDE2MjokVkcsMTYzOiRWSCwxNjQ6OTYsMTY1OiRWSSwxNzI6NDYsMTc1Ojc4LDE3NzokVkosMTc4OiRWRzEsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEwOjUyMCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sbygkVk4xLFsyLDg5XSksbygkVk4xLFsyLDkwXSksezEwNDpbMSw1NTddfSx7MTA0OlsyLDk5XX0sezEwNDpbMiwxMDBdfSx7MTM6NTU4LDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sbygkVncxLFsyLDE2NF0pLG8oJFZ4MixbMiwxOTRdKSxvKCRWeDIsWzIsMjAxXSx7MjI2OjExMSwyMzA6MTEyLDIxOToxNTQsMjI1OjE1NSwxMzY6JFZiMSwxNzg6JFZjMSwyMjA6JFZXLDIyMjokVlgsMjI3OiRWWiwyMjg6JFZfLDI0NjokVmQxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSksbyhbMSw2LDEwLDExLDE0LDIzLDc5LDk3LDEwNCwxMTgsMTI1LDE0NiwxNDgsMTU4LDIwOCwyMDksMjIwLDIyMSwyMjIsMjI3LDIyOCwyNDZdLFsyLDMzMV0sezIyNjoxMTEsMjMwOjExMiwyMTk6MTU0LDIyNToxNTUsMTM2OiRWYjEsMTc4OiRWYzEsMjM3OlsxLDU1OV0sMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9KSxvKCRWeTIsWzIsMzMzXSx7MjI2OjExMSwyMzA6MTEyLDIxOToxNTQsMjI1OjE1NSwxMzY6JFZiMSwxNzg6JFZjMSwyMjE6WzEsNTYwXSwyNDc6JFZlMSwyNTA6JFZmMSwyNTE6JFZnMSwyNTQ6JFZoMSwyNTU6JFZpMSwyNTY6JFZqMSwyNTc6JFZrMX0pLG8oJFZYMSxbMiwzMzJdLHsyMjY6MTExLDIzMDoxMTIsMjE5OjE1NCwyMjU6MTU1LDEzNjokVmIxLDE3ODokVmMxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSksbygkVm0xLFsyLDI2M10pLG8oJFZtMSxbMiwxMzddKSxvKCRWaTIsWzIsMjU0XSksbygkVnYyLCRWNTIsezE3Mzo1NjEsMTQ6JFZoMn0pLHs2OiRWNzEsOTo0OTcsMTE6JFZDMiwxMzY6JFZiMSwxNDM6NTYyLDE3ODokVmMxLDIxOToxNTQsMjIwOiRWVywyMjI6JFZYLDIyNToxNTUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyNDY6JFZkMSwyNDc6JFZlMSwyNTA6JFZmMSwyNTE6JFZnMSwyNTQ6JFZoMSwyNTU6JFZpMSwyNTY6JFZqMSwyNTc6JFZrMX0sbygkVkIyLCRWODIsezE3NDozODAsMTYxOjM4MSwxNzU6MzgyLDE3NjozODMsNTY6Mzg3LDE1Nzo1NjMsNTc6JFY5LDk2OiRWciwxMDM6JFZRMSwxNzc6JFY5MiwxNzg6JFZhMiwxNzk6JFZiMn0pLG8oJFZtMSxbMiwxNzVdKSx7MTY5OjU2NCwxNzA6JFZsMiwxNzE6JFZtMn0sbygkVm0xLFsyLDI4N10pLHs2OiRWNzEsOTo0OTcsMTE6JFZDMiwxNDM6NTY1fSxvKCRWbTEsWzIsMzM5XSksbygkVnMyLFsyLDM0M10pLG8oJFZEMixbMiwyOTRdLHsyMjY6MTExLDIzMDoxMTIsMjE5OjE1NCwyMjU6MTU1LDEzNjokVmIxLDE3ODokVmMxLDIyMDokVlcsMjIyOiRWWCwyMjc6JFZaLDIyODokVl8sMjQ2OiRWZDEsMjQ3OiRWZTEsMjUwOiRWZjEsMjUxOiRWZzEsMjU0OiRWaDEsMjU1OiRWaTEsMjU2OiRWajEsMjU3OiRWazF9KSxvKCRWbTEsWzIsMTIzXSksezY6JFY3MSw5OjQ1OSwxMDokVnQyfSxvKCRWbTEsWzIsMTI0XSksbygkVkExLFsyLDExNF0pLG8oJFZBMSxbMiwxMTVdKSxvKCRWQTEsWzIsMTE4XSksezEyNTpbMSw1NjZdLDEzNjokVmIxLDE3ODokVmMxLDIxOToxNTQsMjIwOiRWVywyMjI6JFZYLDIyNToxNTUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyNDY6JFZkMSwyNDc6JFZlMSwyNTA6JFZmMSwyNTE6JFZnMSwyNTQ6JFZoMSwyNTU6JFZpMSwyNTY6JFZqMSwyNTc6JFZrMX0sezY6JFY3MSw5OjUyMywxMDokVnQyLDExOiRWQzIsMTQzOjU2N30sbygkVk4xLFsyLDk2XSksezk3OlsxLDU2OF0sMTM2OiRWYjEsMTc4OiRWYzEsMjE5OjE1NCwyMjA6JFZXLDIyMjokVlgsMjI1OjE1NSwyMjY6MTExLDIyNzokVlosMjI4OiRWXywyMzA6MTEyLDI0NjokVmQxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSx7MTM6NTY5LDE2OjE2MCwxODozMSwxOTozMiwyMDokVjIsMjE6JFYzLDI0OiRWNCwyNTokVjUsMjY6MzcsMjc6JFY2LDMzOiRWNywzNTo1MCwzNjokVjgsMzg6NDIsMzk6NDMsNDA6MTMsNDE6MTQsNDI6MTUsNDM6MTYsNDQ6MTcsNDU6MTgsNDY6MTksNDc6MjAsNDg6MjEsNDk6MjIsNTA6MjMsNTE6MjQsNTI6MjUsNTM6MjYsNTQ6MjcsNTU6MjgsNTY6MTA2LDU3OiRWOSw2MDoxMDEsNjE6JFZhLDYyOiRWYiw2MzoxMDIsNjQ6JFZjLDY1OjEwMCw2NjokVmQsNjc6MTAzLDY4OiRWZSw2OToxMjAsNzA6JFZmLDcxOjgxLDcyOiRWZyw3MzoxMjEsNzQ6JFZoLDgwOiRWaSw4MTokVmosODI6JFZrLDgzOiRWbCw4NDokVm0sODU6JFZuLDg2OiRWbyw4NzokVnAsODk6OTQsOTA6JFZxLDk2OiRWciwxMDM6JFZzLDEwODo0OCwxMTA6JFZ0LDExNToxMDQsMTMwOjcyLDEzMTokVnYsMTMyOiRWdywxMzM6JFZ4LDEzNDokVnksMTM5OjQ3LDE0MDokVnosMTQxOiRWQSwxNDI6NDAsMTQ3OiRWQiwxNTE6NTEsMTUyOjUyLDE1Mzo1MywxNTQ6JFZFLDE1NTokVkYsMTU5Ojc0LDE2MTo3OSwxNjI6JFZHLDE2MzokVkgsMTY0Ojk2LDE2NTokVkksMTcyOjQ2LDE3NTo3OCwxODA6MTA1LDE4MTokVkssMTgzOiRWTCwxODQ6NjAsMTg1OiRWTSwxODc6NDEsMTkzOiRWTiwxOTQ6JFZPLDE5NTo0NCwxOTY6JFZQLDE5Nzo0OSwyMDA6NjcsMjAxOiRWUSwyMDI6JFZSLDIwNTokVlMsMjA2OiRWVCwyMTI6JFZVLDIxODokVlYsMjE5OjYzLDIyMDokVlcsMjIyOiRWWCwyMjM6NjQsMjI0OiRWWSwyMjU6NjUsMjI2OjExMSwyMjc6JFZaLDIyODokVl8sMjMwOjExMiwyMzg6JFYkLDI0Mzo2MSwyNDQ6JFYwMSwyNDg6JFYxMSwyNDk6JFYyMSwyNTA6JFYzMSwyNTE6JFY0MSwyNTI6JFY1MSwyNTM6JFY2MX0sezEzOjU3MCwxNjoxNjAsMTg6MzEsMTk6MzIsMjA6JFYyLDIxOiRWMywyNDokVjQsMjU6JFY1LDI2OjM3LDI3OiRWNiwzMzokVjcsMzU6NTAsMzY6JFY4LDM4OjQyLDM5OjQzLDQwOjEzLDQxOjE0LDQyOjE1LDQzOjE2LDQ0OjE3LDQ1OjE4LDQ2OjE5LDQ3OjIwLDQ4OjIxLDQ5OjIyLDUwOjIzLDUxOjI0LDUyOjI1LDUzOjI2LDU0OjI3LDU1OjI4LDU2OjEwNiw1NzokVjksNjA6MTAxLDYxOiRWYSw2MjokVmIsNjM6MTAyLDY0OiRWYyw2NToxMDAsNjY6JFZkLDY3OjEwMyw2ODokVmUsNjk6MTIwLDcwOiRWZiw3MTo4MSw3MjokVmcsNzM6MTIxLDc0OiRWaCw4MDokVmksODE6JFZqLDgyOiRWayw4MzokVmwsODQ6JFZtLDg1OiRWbiw4NjokVm8sODc6JFZwLDg5Ojk0LDkwOiRWcSw5NjokVnIsMTAzOiRWcywxMDg6NDgsMTEwOiRWdCwxMTU6MTA0LDEzMDo3MiwxMzE6JFZ2LDEzMjokVncsMTMzOiRWeCwxMzQ6JFZ5LDEzOTo0NywxNDA6JFZ6LDE0MTokVkEsMTQyOjQwLDE0NzokVkIsMTUxOjUxLDE1Mjo1MiwxNTM6NTMsMTU0OiRWRSwxNTU6JFZGLDE1OTo3NCwxNjE6NzksMTYyOiRWRywxNjM6JFZILDE2NDo5NiwxNjU6JFZJLDE3Mjo0NiwxNzU6NzgsMTgwOjEwNSwxODE6JFZLLDE4MzokVkwsMTg0OjYwLDE4NTokVk0sMTg3OjQxLDE5MzokVk4sMTk0OiRWTywxOTU6NDQsMTk2OiRWUCwxOTc6NDksMjAwOjY3LDIwMTokVlEsMjAyOiRWUiwyMDU6JFZTLDIwNjokVlQsMjEyOiRWVSwyMTg6JFZWLDIxOTo2MywyMjA6JFZXLDIyMjokVlgsMjIzOjY0LDIyNDokVlksMjI1OjY1LDIyNjoxMTEsMjI3OiRWWiwyMjg6JFZfLDIzMDoxMTIsMjM4OiRWJCwyNDM6NjEsMjQ0OiRWMDEsMjQ4OiRWMTEsMjQ5OiRWMjEsMjUwOiRWMzEsMjUxOiRWNDEsMjUyOiRWNTEsMjUzOiRWNjF9LHs2OiRWNzEsOTo1NzIsMTA6JFZ6MiwxMTokVkMyLDE0Mzo1NzF9LG8oJFZpMixbMiwxNDhdKSx7MTQ6JFZ3MiwyMzpbMSw1NzNdfSxvKCRWbTEsWzIsMTc2XSksbygkVm0xLFsyLDMzN10pLG8oJFZBMSxbMiwxMjJdKSxvKCRWNzIsWzIsMjg2XSksezEwNDpbMiwxMDFdfSxvKCRWWDEsWzIsMzM0XSx7MjI2OjExMSwyMzA6MTEyLDIxOToxNTQsMjI1OjE1NSwxMzY6JFZiMSwxNzg6JFZjMSwyNDc6JFZlMSwyNTA6JFZmMSwyNTE6JFZnMSwyNTQ6JFZoMSwyNTU6JFZpMSwyNTY6JFZqMSwyNTc6JFZrMX0pLG8oJFZYMSxbMiwzMzVdLHsyMjY6MTExLDIzMDoxMTIsMjE5OjE1NCwyMjU6MTU1LDEzNjokVmIxLDE3ODokVmMxLDI0NzokVmUxLDI1MDokVmYxLDI1MTokVmcxLDI1NDokVmgxLDI1NTokVmkxLDI1NjokVmoxLDI1NzokVmsxfSksbygkVmkyLFsyLDI1NV0pLHsxMTokVkUyLDE1OjI3MywzMzokVjcsNTY6Mjc0LDU3OiRWOSw1ODoyNzYsNTk6JFZMMSw2MDoyNzgsNjE6JFZhLDYyOiRWYiw2MzoyNzksNjQ6JFZjLDY1OjI3NSw2NjokVmQsNjk6MTIwLDcwOiRWZiw3MToyNzcsNzI6JFZnLDczOjEyMSw3NDokVmgsMTQ0OjUzOCwxNDU6MjcyLDE0NzokVk0xLDE0OTokVkMsMTUwOiRWRH0sezE2OTo1NzQsMTcwOiRWbDIsMTcxOiRWbTJ9LG8oJFZtMSxbMiwxNzRdKV0sXG5kZWZhdWx0QWN0aW9uczogezEzOTpbMiwzXSwxNjg6WzIsMjY5XSwzMjk6WzIsMjQ5XSw1Mjc6WzIsOTldLDUyODpbMiwxMDBdLDU2ODpbMiwxMDFdfSxcbnBhcnNlRXJyb3I6IGZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XG4gICAgaWYgKGhhc2gucmVjb3ZlcmFibGUpIHtcbiAgICAgICAgdGhpcy50cmFjZShzdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xuICAgIH1cbn0sXG5wYXJzZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcblxuICAgIC8vIEZvciBJbWJhIHdlIGFyZSBnb2luZyB0byBkcm9wIG1vc3Qgb2YgdGhlIGZlYXR1cmVzIHRoYXQgYXJlIG5vdCB1c2VkXG4gICAgLy8gTG9jYXRpb25zIGFyZSBwcm92aWRlZCBieSB0aGUgdG9rZW5zIGZyb20gdGhlIGxleGVyIGRpcmVjdGx5IC0gc28gZHJvcCB5eWxsb2NcbiAgICAvLyBXZSBkb250IHJlYWxseSBuZWVkIHRoZSBzaGFyZWQgc3RhdGUgKGl0IHNlZW1zKVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBzdGFjayA9IFswXSxcbiAgICAgICAgdHN0YWNrID0gW10sIC8vIHRva2VuIHN0YWNrXG4gICAgICAgIHZzdGFjayA9IFtudWxsXSwgLy8gc2VtYW50aWMgdmFsdWUgc3RhY2tcbiAgICAgICAgdGFibGUgPSB0aGlzLnRhYmxlLFxuICAgICAgICB5eXRleHQgPSAnJyxcbiAgICAgICAgeXlsaW5lbm8gPSAwLFxuICAgICAgICB5eWxlbmcgPSAwLFxuICAgICAgICByZWNvdmVyaW5nID0gMCxcbiAgICAgICAgVEVSUk9SID0gMixcbiAgICAgICAgRU9GID0gMTtcblxuICAgIC8vIHZhciBhcmdzID0gbHN0YWNrLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAvL3RoaXMucmVkdWN0aW9uQ291bnQgPSB0aGlzLnNoaWZ0Q291bnQgPSAwO1xuXG4gICAgdmFyIGxleGVyID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmxleGVyKTtcbiAgICB2YXIgeXkgPSB0aGlzLnl5O1xuXG4gICAgbGV4ZXIuc2V0SW5wdXQoaW5wdXQseXkpO1xuXG4gICAgaWYgKHR5cGVvZiB5eS5wYXJzZUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHl5LnBhcnNlRXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLnBhcnNlRXJyb3I7IC8vIHdoYXQ/XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9wU3RhY2sgKG4pIHtcbiAgICAgICAgc3RhY2subGVuZ3RoID0gc3RhY2subGVuZ3RoIC0gMiAqIG47XG4gICAgICAgIHZzdGFjay5sZW5ndGggPSB2c3RhY2subGVuZ3RoIC0gbjtcbiAgICB9XG5cbiAgICB2YXIgc3ltYm9sLCBwcmVFcnJvclN5bWJvbCwgc3RhdGUsIGFjdGlvbiwgYSwgciwgeXl2YWwgPSB7fSwgcCwgbGVuLCBuZXdTdGF0ZSwgZXhwZWN0ZWQ7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvcigpe1xuICAgICAgICB2YXIgZXJyb3JfcnVsZV9kZXB0aDtcbiAgICAgICAgdmFyIGVyclN0ciA9ICcnO1xuXG4gICAgICAgIC8vIFJldHVybiB0aGUgcnVsZSBzdGFjayBkZXB0aCB3aGVyZSB0aGUgbmVhcmVzdCBlcnJvciBydWxlIGNhbiBiZSBmb3VuZC5cbiAgICAgICAgLy8gUmV0dXJuIEZBTFNFIHdoZW4gbm8gZXJyb3IgcmVjb3ZlcnkgcnVsZSB3YXMgZm91bmQuXG4gICAgICAgIC8vIHdlIGhhdmUgbm8gcnVsZXMgbm93XG4gICAgICAgIGZ1bmN0aW9uIGxvY2F0ZU5lYXJlc3RFcnJvclJlY292ZXJ5UnVsZShzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIHN0YWNrX3Byb2JlID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IDA7XG5cbiAgICAgICAgICAgIC8vIHRyeSB0byByZWNvdmVyIGZyb20gZXJyb3JcbiAgICAgICAgICAgIGZvcig7Oykge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBlcnJvciByZWNvdmVyeSBydWxlIGluIHRoaXMgc3RhdGVcbiAgICAgICAgICAgICAgICBpZiAoKFRFUlJPUi50b1N0cmluZygpKSBpbiB0YWJsZVtzdGF0ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IDAgfHwgc3RhY2tfcHJvYmUgPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gc3VpdGFibGUgZXJyb3IgcmVjb3ZlcnkgcnVsZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YWNrX3Byb2JlIC09IDI7IC8vIHBvcFN0YWNrKDEpOiBbc3ltYm9sLCBhY3Rpb25dXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFja19wcm9iZV07XG4gICAgICAgICAgICAgICAgKytkZXB0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVjb3ZlcmluZykge1xuICAgICAgICAgICAgLy8gZmlyc3Qgc2VlIGlmIHRoZXJlJ3MgYW55IGNoYW5jZSBhdCBoaXR0aW5nIGFuIGVycm9yIHJlY292ZXJ5IHJ1bGU6XG4gICAgICAgICAgICBlcnJvcl9ydWxlX2RlcHRoID0gbG9jYXRlTmVhcmVzdEVycm9yUmVjb3ZlcnlSdWxlKHN0YXRlKTtcblxuICAgICAgICAgICAgLy8gUmVwb3J0IGVycm9yXG4gICAgICAgICAgICBleHBlY3RlZCA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgdHN5bSA9IGxleGVyLnl5dGV4dDtcbiAgICAgICAgICAgIHZhciB0b2sgPSBzZWxmLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2w7XG4gICAgICAgICAgICB2YXIgdGxvYyA9IHRzeW0gPyB0c3ltLl9sb2MgOiAtMTtcbiAgICAgICAgICAgIHZhciB0cG9zID0gdGxvYyAhPSAtMSA/IFwiW1wiICsgdHN5bS5fbG9jICsgXCI6XCIgKyB0c3ltLl9sZW4gKyBcIl1cIiA6ICdbMDowXSc7XG5cbiAgICAgICAgICAgIGlmIChsZXhlci5zaG93UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3IgYXQgJysodHBvcykrXCI6XFxuXCIrbGV4ZXIuc2hvd1Bvc2l0aW9uKCkrXCJcXG5FeHBlY3RpbmcgXCIrZXhwZWN0ZWQuam9pbignLCAnKSArIFwiLCBnb3QgJ1wiICsgKHNlbGYudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkrIFwiJ1wiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3IgYXQgJysodHBvcykrXCI6IFVuZXhwZWN0ZWQgXCIgKyAoc3ltYm9sID09IEVPRiA/IFwiZW5kIG9mIGlucHV0XCIgOiAoXCInXCIrKHRvaykrXCInXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5wYXJzZUVycm9yKGVyclN0ciwge1xuICAgICAgICAgICAgICAgIGxleGVyOiBsZXhlcixcbiAgICAgICAgICAgICAgICB0ZXh0OiBsZXhlci5tYXRjaCxcbiAgICAgICAgICAgICAgICB0b2tlbjogdG9rLFxuICAgICAgICAgICAgICAgIGxpbmU6IGxleGVyLnl5bGluZW5vLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgICAgICAgICAgICByZWNvdmVyYWJsZTogKGVycm9yX3J1bGVfZGVwdGggIT09IGZhbHNlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJlRXJyb3JTeW1ib2wgIT09IEVPRikge1xuICAgICAgICAgICAgZXJyb3JfcnVsZV9kZXB0aCA9IGxvY2F0ZU5lYXJlc3RFcnJvclJlY292ZXJ5UnVsZShzdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBqdXN0IHJlY292ZXJlZCBmcm9tIGFub3RoZXIgZXJyb3JcbiAgICAgICAgaWYgKHJlY292ZXJpbmcgPT0gMykge1xuICAgICAgICAgICAgaWYgKHN5bWJvbCA9PT0gRU9GIHx8IHByZUVycm9yU3ltYm9sID09PSBFT0YpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyU3RyIHx8ICdQYXJzaW5nIGhhbHRlZCB3aGlsZSBzdGFydGluZyB0byByZWNvdmVyIGZyb20gYW5vdGhlciBlcnJvci4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGlzY2FyZCBjdXJyZW50IGxvb2thaGVhZCBhbmQgZ3JhYiBhbm90aGVyXG4gICAgICAgICAgICB5eXRleHQgPSBsZXhlci55eXRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cnkgdG8gcmVjb3ZlciBmcm9tIGVycm9yXG4gICAgICAgIGlmIChlcnJvcl9ydWxlX2RlcHRoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyclN0ciB8fCAnUGFyc2luZyBoYWx0ZWQuIE5vIHN1aXRhYmxlIGVycm9yIHJlY292ZXJ5IHJ1bGUgYXZhaWxhYmxlLicpO1xuICAgICAgICB9XG4gICAgICAgIHBvcFN0YWNrKGVycm9yX3J1bGVfZGVwdGgpO1xuICAgICAgICBwcmVFcnJvclN5bWJvbCA9IChzeW1ib2wgPT0gVEVSUk9SID8gbnVsbCA6IHN5bWJvbCk7IC8vIHNhdmUgdGhlIGxvb2thaGVhZCB0b2tlblxuICAgICAgICBzeW1ib2wgPSBURVJST1I7ICAgICAgICAgLy8gaW5zZXJ0IGdlbmVyaWMgZXJyb3Igc3ltYm9sIGFzIG5ldyBsb29rYWhlYWRcbiAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGgtMV07XG4gICAgICAgIGFjdGlvbiA9IHRhYmxlW3N0YXRlXSAmJiB0YWJsZVtzdGF0ZV1bVEVSUk9SXTtcbiAgICAgICAgcmVjb3ZlcmluZyA9IDM7IC8vIGFsbG93IDMgcmVhbCBzeW1ib2xzIHRvIGJlIHNoaWZ0ZWQgYmVmb3JlIHJlcG9ydGluZyBhIG5ldyBlcnJvclxuICAgIH1cblxuXG4gICAgdmFyIF9fc3ltID0gdGhpcy5zeW1ib2xzXztcbiAgICB2YXIgX19wcm9kID0gdGhpcy5wcm9kdWN0aW9uc187XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAvLyByZXRyZWl2ZSBzdGF0ZSBudW1iZXIgZnJvbSB0b3Agb2Ygc3RhY2tcbiAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoc3ltYm9sID09PSBudWxsIHx8IHR5cGVvZiBzeW1ib2wgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHN5bWJvbCA9IF9fc3ltW2xleGVyLmxleCgpXSB8fCBFT0Y7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aW9uID0gdGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtzeW1ib2xdO1xuXG5faGFuZGxlX2Vycm9yOlxuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3VuZGVmaW5lZCcgfHwgIWFjdGlvbi5sZW5ndGggfHwgIWFjdGlvblswXSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uWzBdKSB7XG4gICAgICAgICAgICBjYXNlIDE6IC8vIHNoaWZ0XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goYWN0aW9uWzFdKTsgLy8gcHVzaCBzdGF0ZVxuICAgICAgICAgICAgICAgIHZzdGFjay5wdXNoKGxleGVyLnl5dGV4dCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIXByZUVycm9yU3ltYm9sKSB7IC8vIG5vcm1hbCBleGVjdXRpb24vbm8gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgeXl0ZXh0ID0gbGV4ZXIueXl0ZXh0O1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3ZlcmluZyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY292ZXJpbmctLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVycm9yIGp1c3Qgb2NjdXJyZWQsIHJlc3VtZSBvbGQgbG9va2FoZWFkIGYvIGJlZm9yZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBwcmVFcnJvclN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgcHJlRXJyb3JTeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGxlbiA9IF9fcHJvZFthY3Rpb25bMV1dWzFdO1xuICAgICAgICAgICAgICAgIC8vIHBlcmZvcm0gc2VtYW50aWMgYWN0aW9uXG4gICAgICAgICAgICAgICAgeXl2YWwuJCA9IHZzdGFja1t2c3RhY2subGVuZ3RoLWxlbl07XG4gICAgICAgICAgICAgICAgciA9IHRoaXMucGVyZm9ybUFjdGlvbih5eXZhbCwgeXl0ZXh0LCB5eSwgYWN0aW9uWzFdLCB2c3RhY2spO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUobGVuID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHZzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChfX3Byb2RbYWN0aW9uWzFdXVswXSk7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0YWJsZVtzdGFja1tzdGFjay5sZW5ndGgtMl1dW3N0YWNrW3N0YWNrLmxlbmd0aC0xXV07XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgdnN0YWNrLnB1c2goeXl2YWwuJCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufX07XG5cbmZ1bmN0aW9uIFBhcnNlciAoKSB7XG4gIHRoaXMueXkgPSB7fTtcbn1cblBhcnNlci5wcm90b3R5cGUgPSBwYXJzZXI7cGFyc2VyLlBhcnNlciA9IFBhcnNlcjtcbnJldHVybiBuZXcgUGFyc2VyO1xufSkoKTtcblxuXG5pZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuZXhwb3J0cy5wYXJzZXIgPSBwYXJzZXI7XG5leHBvcnRzLlBhcnNlciA9IHBhcnNlci5QYXJzZXI7XG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyc2VyLnBhcnNlLmFwcGx5KHBhcnNlciwgYXJndW1lbnRzKTsgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9pbWJhL2xpYi9jb21waWxlci9wYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIiMgaW1iYSRpbmxpbmVIZWxwZXJzPTFcbiMgVE9ETyBDcmVhdGUgRXhwcmVzc2lvbiAtIG1ha2UgYWxsIGV4cHJlc3Npb25zIGluaGVyaXQgZnJvbSB0aGVzZT9cblxudmFyIGhlbHBlcnMgPSByZXF1aXJlICcuL2hlbHBlcnMnXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSAnLi9jb25zdGFudHMnXG5cbmltcG9ydCBJbWJhUGFyc2VFcnJvciBmcm9tICcuL2Vycm9ycydcbmltcG9ydCBUb2tlbiBmcm9tICcuL3Rva2VuJ1xuaW1wb3J0IFNvdXJjZU1hcCBmcm9tICcuL3NvdXJjZW1hcCdcblxuZXhwb3J0IHZhciBBU1QgPSB7fVxuXG4jIEhlbHBlcnMgZm9yIG9wZXJhdG9yc1xuZXhwb3J0IHZhciBPUCA9IGRvIHxvcCwgbCwgcnxcblx0dmFyIG8gPSBTdHJpbmcob3ApXG5cdHN3aXRjaCBvXG5cdFx0d2hlbiAnLidcblx0XHRcdHIgPSBJZGVudGlmaWVyLm5ldyhyKSBpZiByIGlzYSBTdHJpbmdcblx0XHRcdCMgciA9IHIudmFsdWUgaWYgciBpc2EgVmFyT3JBY2Nlc3Ncblx0XHRcdEFjY2Vzcy5uZXcob3AsbCxyKVxuXHRcdHdoZW4gJz0nXG5cdFx0XHRyZXR1cm4gVHVwbGVBc3NpZ24ubmV3KG9wLGwscikgaWYgbCBpc2EgVHVwbGVcblx0XHRcdEFzc2lnbi5uZXcob3AsbCxyKVxuXG5cdFx0d2hlbiAnPz0nLCd8fD0nLCcmJj0nXG5cdFx0XHRDb25kaXRpb25hbEFzc2lnbi5uZXcob3AsbCxyKVxuXHRcdHdoZW4gJys9JywnLT0nLCcqPScsJy89JywnXj0nLCclPSdcblx0XHRcdENvbXBvdW5kQXNzaWduLm5ldyhvcCxsLHIpXG5cblx0XHR3aGVuICc/Lidcblx0XHRcdGlmIHIgaXNhIFZhck9yQWNjZXNzXG5cdFx0XHRcdHIgPSByLnZhbHVlXG5cblx0XHRcdCMgZGVwZW5kcyBvbiB0aGUgcmlnaHQgc2lkZSAtIHRoaXMgaXMgd3Jvbmdcblx0XHRcdFByb3BlcnR5QWNjZXNzLm5ldyhvcCxsLHIpXG5cblx0XHR3aGVuICdpbnN0YW5jZW9mJywnaXNhJ1xuXHRcdFx0SW5zdGFuY2VPZi5uZXcob3AsbCxyKVxuXHRcdHdoZW4gJ2luJ1xuXHRcdFx0SW4ubmV3KG9wLGwscilcblx0XHR3aGVuICd0eXBlb2YnXG5cdFx0XHRUeXBlT2YubmV3KG9wLGwscilcblx0XHR3aGVuICdkZWxldGUnXG5cdFx0XHREZWxldGUubmV3KG9wLGwscilcblx0XHR3aGVuICctLScsJysrJywnIScsJ+KImicsJ25vdCcgIyBhbGlhc1xuXHRcdFx0VW5hcnlPcC5uZXcob3AsbCxyKVxuXHRcdHdoZW4gJz4nLCc8JywnPj0nLCc8PScsJz09JywnPT09JywnIT0nLCchPT0nXG5cdFx0XHRDb21wYXJpc29uT3AubmV3KG9wLGwscilcblx0XHR3aGVuICfiiKknLCfiiKonXG5cdFx0XHRNYXRoT3AubmV3KG9wLGwscilcblx0XHR3aGVuICcuLicsJy4uLidcblx0XHRcdFJhbmdlLm5ldyhvcCxsLHIpXG5cdFx0ZWxzZVxuXHRcdFx0T3AubmV3KG9wLGwscilcblxuZXhwb3J0IHZhciBPUF9DT01QT1VORCA9IGRvIHxzeW0sb3AsbCxyfFxuXHQjIGNvbnNvbGUubG9nIFwiPy4gc29hayBvcGVyYXRvclwiLHN5bVxuXHRpZiBzeW0gPT0gJz8uJ1xuXHRcdGNvbnNvbGUubG9nIFwiPy4gc29hayBvcGVyYXRvclwiXG5cdFx0cmV0dXJuIG51bGxcblx0aWYgc3ltID09ICc/PScgb3Igc3ltID09ICd8fD0nIG9yIHN5bSA9PSAnJiY9J1xuXHRcdHJldHVybiBDb25kaXRpb25hbEFzc2lnbi5uZXcob3AsbCxyKVxuXHRlbHNlXG5cdFx0cmV0dXJuIENvbXBvdW5kQXNzaWduLm5ldyhvcCxsLHIpXG5cbnZhciBPUFRTID0ge31cbnZhciBST09UID0gbnVsbFxuXG5leHBvcnQgdmFyIE5PREVTID0gW11cblxudmFyIExJVCA9IGRvIHx2YWx8XG5cdExpdGVyYWwubmV3KHZhbClcblxudmFyIFNZTSA9IGRvIHx2YWx8XG5cdFN5bWJvbC5uZXcodmFsKVxuXG52YXIgSUYgPSBkbyB8Y29uZCxib2R5LGFsdHxcblx0dmFyIG5vZGUgPSBJZi5uZXcoY29uZCxib2R5KVxuXHRub2RlLmFkZEVsc2UoYWx0KSBpZiBhbHRcblx0bm9kZVxuXG52YXIgRk4gPSBkbyB8cGFycyxib2R5fFxuXHRGdW5jLm5ldyhwYXJzLGJvZHkpXG5cbnZhciBDQUxMID0gZG8gfGNhbGxlZSxwYXJzID0gW118XG5cdCMgcG9zc2libHkgcmV0dXJuIGluc3RlYWQoISlcblx0Q2FsbC5uZXcoY2FsbGVlLHBhcnMpXG5cbnZhciBDQUxMU0VMRiA9IGRvIHxuYW1lLHBhcnMgPSBbXXxcblx0dmFyIHJlZiA9IElkZW50aWZpZXIubmV3KG5hbWUpXG5cdENhbGwubmV3KE9QKCcuJyxTRUxGLHJlZikscGFycylcblxudmFyIEJMT0NLID0gZG9cblx0QmxvY2sud3JhcChbXTpzbGljZS5jYWxsKGFyZ3VtZW50cykpXG5cbnZhciBXSElMRSA9IGRvIHx0ZXN0LGNvZGV8XG5cdFdoaWxlLm5ldyh0ZXN0KS5hZGRCb2R5KGNvZGUpXG5cbmV4cG9ydCB2YXIgU1BMQVQgPSBkbyB8dmFsdWV8XG5cdGlmIHZhbHVlIGlzYSBBc3NpZ25cblx0XHR2YWx1ZS5sZWZ0ID0gU3BsYXQubmV3KHZhbHVlLmxlZnQpXG5cdFx0cmV0dXJuIHZhbHVlXG5cdGVsc2Vcblx0XHRTcGxhdC5uZXcodmFsdWUpXG5cbnZhciBTRU1JQ09MT05fVEVTVCA9IC87KFxccypcXC9cXC8uKik/W1xcblxcc1xcdF0qJC9cbnZhciBSRVNFUlZFRF9URVNUID0gL14oZGVmYXVsdHxjaGFyfGZvcikkL1xuXG4jIGNhcHR1cmVzIGVycm9yIGZyb20gcGFyc2VyXG5leHBvcnQgZGVmIHBhcnNlRXJyb3Igc3RyLCBvXG5cdCMgZmluZCBuZWFyZXN0IHRva2VuXG5cdHZhciBlcnJcblxuXHRpZiBvOmxleGVyXG5cdFx0dmFyIHRva2VuID0gbzpsZXhlcjp5eXRleHRcblx0XHQjIGNvbnNvbGUubG9nIG86bGV4ZXI6cG9zLHRva2VuLkBsb2Ncblx0XHRlcnIgPSBJbWJhUGFyc2VFcnJvci5uZXcoe21lc3NhZ2U6IHN0cn0se1xuXHRcdFx0cG9zOiBvOmxleGVyOnBvc1xuXHRcdFx0dG9rZW5zOiBvOmxleGVyOnRva2Vuc1xuXHRcdFx0dG9rZW46IG86bGV4ZXI6eXl0ZXh0XG5cdFx0XHRtZXRhOiBvXG5cdFx0fSlcblxuXHRcdHRocm93IGVyclxuXG5cdFx0IyBzaG91bGQgZmluZCB0aGUgY2xvc2VzdCB0b2tlbiB3aXRoIGFjdHVhbCBwb3NpdGlvblxuXHRcdCMgc3RyID0gXCJbe3Rva2VuLkBsb2N9Ont0b2tlbi5AbGVuIHx8IFN0cmluZyh0b2tlbik6bGVuZ3RofV0ge3N0cn1cIlxuXHR2YXIgZSA9IEVycm9yLm5ldyhzdHIpXG5cdGU6bGV4ZXIgPSBvOmxleGVyXG5cdGU6b3B0aW9ucyA9IG9cblx0dGhyb3cgZVxuXG5kZWYgY19fIG9ialxuXHR0eXBlb2Ygb2JqID09ICdzdHJpbmcnID8gb2JqIDogb2JqLmNcblxuZGVmIG1hcmtfXyB0b2tcblx0aWYgdG9rIGFuZCAoT1BUUzpzb3VyY2VNYXBJbmxpbmUgb3IgT1BUUzpzb3VyY2VNYXApIGFuZCB0b2s6c291cmNlTWFwTWFya2VyXG5cdFx0dG9rLnNvdXJjZU1hcE1hcmtlclxuXHRlbHNlXG5cdFx0JydcblxuZGVmIG51bV9fIG51bVxuXHROdW0ubmV3KG51bSlcblxuZGVmIHN0cl9fIHN0clxuXHQjIHNob3VsZCBwYWNrIGluIHRva2VuPyE/XG5cdFN0ci5uZXcoc3RyKVxuXG5kZWYgYmxrX18gb2JqXG5cdG9iaiBpc2EgQXJyYXkgPyBCbG9jay53cmFwKG9iaikgOiBvYmpcblxuZGVmIHN5bV9fIG9ialxuXHQjIGNvbnNvbGUubG9nIFwic3ltIHtvYmp9XCJcblx0aGVscGVycy5zeW1ib2xpemUoU3RyaW5nKG9iaikpXG5cbmRlZiBjYXJ5X18gYXJ5XG5cdGFyeS5tYXAofHZ8IHR5cGVvZiB2ID09ICdzdHJpbmcnID8gdiA6IHYuYyApXG5cbmRlZiBkdW1wX18gb2JqLCBrZXlcblx0aWYgb2JqIGlzYSBBcnJheVxuXHRcdG9iai5tYXAgZG8gfHZ8IHYgJiYgdjpkdW1wID8gdi5kdW1wKGtleSkgOiB2XG5cdGVsaWYgb2JqIGFuZCBvYmo6ZHVtcFxuXHRcdG9iai5kdW1wXG5cbmRlZiBjb21wYWN0X18gYXJ5XG5cdGlmIGFyeSBpc2EgTGlzdE5vZGVcblx0XHRyZXR1cm4gYXJ5LmNvbXBhY3RcblxuXHRhcnkuZmlsdGVyIGRvIHx2fCB2ICE9IHVuZGVmaW5lZCAmJiB2ICE9IG51bGxcblxuZGVmIHJlZHVjZV9fIHJlcyxhcnlcblx0Zm9yIHYgaW4gYXJ5XG5cdFx0diBpc2EgQXJyYXkgPyByZWR1Y2VfXyhyZXMsdikgOiByZXMucHVzaCh2KVxuXHRyZXR1cm5cblxuZGVmIGZsYXR0ZW5fXyBhcnksIGNvbXBhY3QgPSBub1xuXHR2YXIgb3V0ID0gW11cblx0Zm9yIHYgaW4gYXJ5XG5cdFx0diBpc2EgQXJyYXkgPyByZWR1Y2VfXyhvdXQsdikgOiBvdXQucHVzaCh2KVxuXHRyZXR1cm4gb3V0XG5cbmRlZiBBU1QucGFyc2Ugc3RyLCBvcHRzID0ge31cblx0dmFyIGluZGVudCA9IHN0ci5tYXRjaCgvXFx0Ky8pWzBdXG5cdCMgcmVhbGx5PyBSZXF1aXJlIHRoZSBjb21waWxlciwgbm90IHRoaXNcblx0SW1iYWMucGFyc2Uoc3RyLG9wdHMpXG5cbmRlZiBBU1QuaW5saW5lIHN0ciwgb3B0cyA9IHt9XG5cdHBhcnNlKHN0cixvcHRzKS5ib2R5XG5cbmRlZiBBU1Qubm9kZSB0eXAsIHBhcnNcblx0aWYgdHlwID09ICdjYWxsJ1xuXHRcdGlmIHBhcnNbMF0uYyA9PSAncmV0dXJuJ1xuXHRcdFx0cGFyc1swXSA9ICd0YXRhJ1xuXHRcdENhbGwubmV3KHBhcnNbMF0scGFyc1sxXSxwYXJzWzJdKVxuXG5cbmRlZiBBU1QuZXNjYXBlQ29tbWVudHMgc3RyXG5cdHJldHVybiAnJyB1bmxlc3Mgc3RyXG5cdHJldHVybiBzdHJcblxuXG52YXIgc2hvcnRSZWZDYWNoZSA9IFtdXG5cbmRlZiBjb3VudGVyVG9TaG9ydFJlZiBuclxuXHR2YXIgYmFzZSA9IFwiQVwiLmNoYXJDb2RlQXQoMClcblxuXHR3aGlsZSBzaG9ydFJlZkNhY2hlOmxlbmd0aCA8PSBuclxuXHRcdHZhciBudW0gPSBzaG9ydFJlZkNhY2hlOmxlbmd0aCArIDFcblx0XHR2YXIgc3RyID0gXCJcIlxuXG5cdFx0d2hpbGUgdHJ1ZVxuXHRcdFx0bnVtIC09IDFcblx0XHRcdHN0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYmFzZSArIChudW0gJSAyNikpICsgc3RyXG5cdFx0XHRudW0gPSBNYXRoLmZsb29yKG51bSAvIDI2KVxuXHRcdFx0YnJlYWsgdW5sZXNzIG51bSA+IDBcblxuXHRcdHNob3J0UmVmQ2FjaGUucHVzaChzdHIpXG5cdHJldHVybiBzaG9ydFJlZkNhY2hlW25yXVxuXG5kZWYgdHJ1dGh5X18gbm9kZVxuXG5cdGlmIG5vZGUgaXNhIFRydWVcblx0XHRyZXR1cm4gdHJ1ZVxuXG5cdGlmIG5vZGUgaXNhIEZhbHNlXG5cdFx0cmV0dXJuIGZhbHNlXG5cblx0aWYgbm9kZTppc1RydXRoeVxuXHRcdHJldHVybiBub2RlLmlzVHJ1dGh5XG5cblx0cmV0dXJuIHVuZGVmaW5lZFxuXG5leHBvcnQgY2xhc3MgSW5kZW50YXRpb25cblxuXHRwcm9wIG9wZW5cblx0cHJvcCBjbG9zZVxuXG5cdGRlZiBpbml0aWFsaXplIGEsYlxuXHRcdEBvcGVuID0gYVxuXHRcdEBjbG9zZSA9IGJcblx0XHRzZWxmXG5cblx0ZGVmIGlzR2VuZXJhdGVkXG5cdFx0QG9wZW4gYW5kIEBvcGVuOmdlbmVyYXRlZFxuXG5cdGRlZiBhbG9jXG5cdFx0QG9wZW4gYW5kIEBvcGVuLkBsb2Mgb3IgMFxuXG5cdGRlZiBibG9jXG5cdFx0QGNsb3NlIGFuZCBAY2xvc2UuQGxvYyBvciAwXG5cblx0ZGVmIHdyYXAgc3RyXG5cdFx0dmFyIG9tID0gQG9wZW4gYW5kIEBvcGVuLkBtZXRhXG5cdFx0dmFyIHByZSA9IG9tIGFuZCBvbTpwcmUgb3IgJydcblx0XHR2YXIgcG9zdCA9IG9tIGFuZCBvbTpwb3N0IG9yICcnXG5cdFx0dmFyIGVzYyA9IEFTVDplc2NhcGVDb21tZW50c1xuXHRcdHZhciBvdXQgPSBAY2xvc2VcblxuXHRcdCMgdGhlIGZpcnN0IG5ld2xpbmUgc2hvdWxkIG5vdCBiZSBpbmRlbnRlZD9cblx0XHRzdHIgPSBwb3N0LnJlcGxhY2UoL15cXG4vLCcnKSArIHN0clxuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKC9eL2csXCJcXHRcIikucmVwbGFjZSgvXFxuL2csXCJcXG5cXHRcIikucmVwbGFjZSgvXFxuXFx0JC9nLFwiXFxuXCIpXG5cblx0XHRzdHIgPSBwcmUgKyAnXFxuJyArIHN0clxuXHRcdHN0ciArPSBvdXQuYyBpZiBvdXQgaXNhIFRlcm1pbmF0b3Jcblx0XHRzdHIgPSBzdHIgKyAnXFxuJyB1bmxlc3Mgc3RyW3N0cjpsZW5ndGggLSAxXSA9PSAnXFxuJ1xuXHRcdHJldHVybiBzdHJcblxudmFyIElOREVOVCA9IEluZGVudGF0aW9uLm5ldyh7fSx7fSlcblxuY2xhc3MgU3Rhc2hcblxuXHRkZWYgaW5pdGlhbGl6ZVxuXHRcdEBlbnRpdGllcyA9IFtdXG5cblx0ZGVmIGFkZCBpdGVtXG5cdFx0QGVudGl0aWVzLnVuc2hpZnQoaXRlbSlcblx0XHRzZWxmXG5cblx0ZGVmIHBsdWNrIGl0ZW1cblx0XHR2YXIgbWF0Y2ggPSBudWxsXG5cdFx0Zm9yIGVudGl0eSxpIGluIEBlbnRpdGllc1xuXHRcdFx0aWYgZW50aXR5ID09IGl0ZW0gb3IgZW50aXR5IGlzYSBpdGVtXG5cdFx0XHRcdG1hdGNoID0gZW50aXR5XG5cdFx0XHRcdEBlbnRpdGllcy5zcGxpY2UoaSwxKVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hcblx0XHRyZXR1cm4gbnVsbFxuXG5cbmV4cG9ydCBjbGFzcyBTdGFja1xuXG5cdHByb3AgbG9nbGV2ZWxcblx0cHJvcCBub2Rlc1xuXHRwcm9wIHNjb3Blc1xuXG5cdGRlZiBpbml0aWFsaXplXG5cdFx0cmVzZXRcblxuXHRkZWYgcmVzZXRcblx0XHRAbm9kZXMgICAgPSBbXVxuXHRcdEBzY29waW5nICA9IFtdXG5cdFx0QHNjb3BlcyAgID0gW11cblx0XHRAc3Rhc2ggICAgPSBTdGFzaC5uZXcoc2VsZilcblx0XHRAbG9nbGV2ZWwgPSAzXG5cdFx0QGNvdW50ZXIgID0gMFxuXHRcdEBjb3VudGVycyA9IHt9XG5cdFx0c2VsZlxuXG5cdGRlZiBpbmNyIG5hbWVcblx0XHRAY291bnRlcnNbbmFtZV0gfHw9IDBcblx0XHRAY291bnRlcnNbbmFtZV0gKz0gMVxuXG5cdGRlZiBzdGFzaFxuXHRcdEBzdGFzaFxuXG5cdGRlZiBvcHRpb24ga2V5XG5cdFx0QG9wdGlvbnMgYW5kIEBvcHRpb25zW2tleV1cblxuXHRkZWYgcGxhdGZvcm1cblx0XHRAb3B0aW9uczp0YXJnZXRcblxuXHRkZWYgZW52IGtleVxuXHRcdHZhciB2YWwgPSBAb3B0aW9uc1tcIkVOVl97a2V5fVwiXVxuXHRcdHJldHVybiB2YWwgaWYgdmFsICE9IHVuZGVmaW5lZFxuXG5cdFx0aWYgcGxhdGZvcm0gYW5kIGtleSBpbiBbJ1dFQicsJ05PREUnLCdXRUJXT1JLRVInXVxuXHRcdFx0cmV0dXJuIHBsYXRmb3JtLnRvVXBwZXJDYXNlID09IGtleVxuXG5cdFx0IyBjb25zb2xlLmxvZyAnbG9va3VwIGVudiB2YXInLGtleSxAb3B0aW9uczplbnZcblxuXHRcdGlmIHZhciBlID0gQG9wdGlvbnM6ZW52XG5cdFx0XHRpZiBlLmhhc093blByb3BlcnR5KGtleSlcblx0XHRcdFx0cmV0dXJuIGVba2V5XVxuXHRcdFx0ZWxpZiBlLmhhc093blByb3BlcnR5KGtleS50b0xvd2VyQ2FzZSlcblx0XHRcdFx0cmV0dXJuIGVba2V5LnRvTG93ZXJDYXNlXVxuXG5cdFx0aWYgcHJvY2VzczplbnZcblx0XHRcdHZhbCA9IHByb2Nlc3M6ZW52W2tleS50b1VwcGVyQ2FzZV1cblx0XHRcdGlmIHZhbCAhPSB1bmRlZmluZWRcblx0XHRcdFx0cmV0dXJuIHZhbFxuXHRcdFx0cmV0dXJuIG51bGxcblxuXHRcdHJldHVybiB1bmRlZmluZWRcblxuXG5cdGRlZiBhZGRTY29wZSBzY29wZVxuXHRcdEBzY29wZXMucHVzaChzY29wZSlcblx0XHRzZWxmXG5cblx0ZGVmIHRyYXZlcnNlIG5vZGVcblx0XHRzZWxmXG5cblx0ZGVmIHB1c2ggbm9kZVxuXHRcdEBub2Rlcy5wdXNoKG5vZGUpXG5cdFx0IyBub3Qgc3VyZSBpZiB3ZSBoYXZlIGFscmVhZHkgZGVmaW5lZCBhIHNjb3BlP1xuXHRcdHNlbGZcblxuXHRkZWYgcG9wIG5vZGVcblx0XHRAbm9kZXMucG9wICMgKG5vZGUpXG5cdFx0c2VsZlxuXG5cdGRlZiBwYXJlbnRcblx0XHRAbm9kZXNbQG5vZGVzOmxlbmd0aCAtIDJdXG5cblx0ZGVmIGN1cnJlbnRcblx0XHRAbm9kZXNbQG5vZGVzOmxlbmd0aCAtIDFdXG5cblx0ZGVmIHVwIHRlc3Rcblx0XHR0ZXN0IHx8PSBkbyB8dnwgISh2IGlzYSBWYXJPckFjY2VzcylcblxuXHRcdGlmIHRlc3Q6cHJvdG90eXBlIGlzYSBOb2RlXG5cdFx0XHR2YXIgdHlwID0gdGVzdFxuXHRcdFx0dGVzdCA9IGRvIHx2fCB2IGlzYSB0eXBcblxuXHRcdHZhciBpID0gQG5vZGVzOmxlbmd0aCAtIDIgIyBrZXlcblx0XHR3aGlsZSBpID49IDBcblx0XHRcdHZhciBub2RlID0gQG5vZGVzW2ldXG5cdFx0XHRyZXR1cm4gbm9kZSBpZiB0ZXN0KG5vZGUpXG5cdFx0XHRpIC09IDFcblx0XHRyZXR1cm4gbnVsbFxuXG5cdGRlZiByZWxhdGl2ZSBub2RlLCBvZmZzZXQgPSAwXG5cdFx0dmFyIGlkeCA9IEBub2Rlcy5pbmRleE9mKG5vZGUpXG5cdFx0aWR4ID49IDAgPyBAbm9kZXNbaWR4ICsgb2Zmc2V0XSA6IG51bGxcblxuXHRkZWYgc2NvcGUgbHZsID0gMFxuXHRcdHZhciBpID0gQG5vZGVzOmxlbmd0aCAtIDEgLSBsdmxcblx0XHR3aGlsZSBpID49IDBcblx0XHRcdHZhciBub2RlID0gQG5vZGVzW2ldXG5cdFx0XHRyZXR1cm4gbm9kZS5Ac2NvcGUgaWYgbm9kZS5Ac2NvcGVcblx0XHRcdGkgLT0gMVxuXHRcdHJldHVybiBudWxsXG5cblx0ZGVmIHNjb3Blc1xuXHRcdCMgaW5jbHVkZSBkZWVwZXIgc2NvcGVzIGFzIHdlbGw/XG5cdFx0dmFyIHNjb3BlcyA9IFtdXG5cdFx0dmFyIGkgPSBAbm9kZXM6bGVuZ3RoIC0gMVxuXHRcdHdoaWxlIGkgPj0gMFxuXHRcdFx0dmFyIG5vZGUgPSBAbm9kZXNbaV1cblx0XHRcdHNjb3Blcy5wdXNoKG5vZGUuQHNjb3BlKSBpZiBub2RlLkBzY29wZVxuXHRcdFx0aSAtPSAxXG5cdFx0cmV0dXJuIHNjb3Blc1xuXG5cdGRlZiBtZXRob2Rcblx0XHR1cChNZXRob2REZWNsYXJhdGlvbilcblxuXHRkZWYgYmxvY2tcblx0XHR1cChCbG9jaylcblxuXHRkZWYgaXNFeHByZXNzaW9uXG5cdFx0dmFyIGkgPSBAbm9kZXM6bGVuZ3RoIC0gMVxuXHRcdHdoaWxlIGkgPj0gMFxuXHRcdFx0dmFyIG5vZGUgPSBAbm9kZXNbaV1cblx0XHRcdCMgd2h5IGFyZSB3ZSBub3QgdXNpbmcgaXNFeHByZXNzaW9uIGhlcmUgYXMgd2VsbD9cblx0XHRcdGlmIG5vZGUgaXNhIENvZGUgb3Igbm9kZSBpc2EgTG9vcFxuXHRcdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRcdGlmIG5vZGUuaXNFeHByZXNzaW9uXG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHQjIHByb2JhYmx5IG5vdCB0aGUgcmlnaHQgdGVzdCAtIG5lZWQgdG8gYmUgbW9yZSBleHBsaWNpdFxuXHRcdFx0aSAtPSAxXG5cdFx0cmV0dXJuIGZhbHNlXG5cblx0ZGVmIHRvU3RyaW5nXG5cdFx0XCJTdGFjayh7QG5vZGVzLmpvaW4oXCIgLT4gXCIpfSlcIlxuXG5cdGRlZiBpc0FuYWx5emluZ1xuXHRcdEBhbmFseXppbmdcblxuXHRkZWYgc2NvcGluZ1xuXHRcdEBub2Rlcy5maWx0ZXIofG58IG4uQHNjb3BlICkubWFwKHxufCBuLkBzY29wZSApXG5cbiMgTG90cyBvZiBnbG9iYWxzIC0tIHJlYWxseSBuZWVkIHRvIGRlYWwgd2l0aCBvbmUgc3RhY2sgcGVyIGZpbGUgLyBjb250ZXh0XG5leHBvcnQgdmFyIFNUQUNLID0gU3RhY2submV3XG5cbiMgdXNlIGEgYml0bWFzayBmb3IgdGhlc2VcblxuZXhwb3J0IGNsYXNzIE5vZGVcblxuXHRwcm9wIG9cblx0cHJvcCBvcHRpb25zXG5cdHByb3AgdHJhdmVyc2VkXG5cblx0ZGVmIHNhZmVjaGFpblxuXHRcdG5vXG5cblx0ZGVmIHBcblx0XHQjIGFsbG93IGNvbnRyb2xsaW5nIHRoaXMgZnJvbSBDTElcblx0XHRpZiBTVEFDSy5sb2dsZXZlbCA+IDBcblx0XHRcdGNvbnNvbGUubG9nKCphcmd1bWVudHMpXG5cdFx0c2VsZlxuXG5cdGRlZiB0eXBlTmFtZVxuXHRcdHNlbGY6Y29uc3RydWN0b3I6bmFtZVxuXG5cdGRlZiBuYW1lcGF0aFxuXHRcdHR5cGVOYW1lXG5cblx0ZGVmIGluaXRpYWxpemVcblx0XHRzZXR1cFxuXHRcdHNlbGZcblxuXHRkZWYgc2V0dXBcblx0XHRAZXhwcmVzc2lvbiA9IG5vXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHBhcmVucyA9IG5vXG5cdFx0QGNhY2hlID0gbnVsbFxuXHRcdEB2YWx1ZSA9IG51bGxcblx0XHRzZWxmXG5cblx0ZGVmIHNldCBvYmpcblx0XHRAb3B0aW9ucyB8fD0ge31cblx0XHRmb3Igb3duIGssdiBvZiBvYmpcblx0XHRcdEBvcHRpb25zW2tdID0gdlxuXHRcdHNlbGZcblxuXHQjIGdldCBhbmQgc2V0XG5cdGRlZiBvcHRpb24ga2V5LCB2YWxcblx0XHRpZiB2YWwgIT0gdW5kZWZpbmVkXG5cdFx0XHRAb3B0aW9ucyB8fD0ge31cblx0XHRcdEBvcHRpb25zW2tleV0gPSB2YWxcblx0XHRcdHJldHVybiBzZWxmXG5cblx0XHRAb3B0aW9ucyAmJiBAb3B0aW9uc1trZXldXG5cblx0ZGVmIGNvbmZpZ3VyZSBvYmpcblx0XHRzZXQob2JqKVxuXG5cdGRlZiByZWdpb25cblx0XHRbMCwwXVxuXG5cdGRlZiBsb2Ncblx0XHRbMCwwXVxuXG5cdGRlZiB0b2tlblxuXHRcdG51bGxcblxuXHRkZWYgY29tcGlsZVxuXHRcdHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHRzZWxmXG5cblx0ZGVmIHN0YWNrXG5cdFx0U1RBQ0tcblxuXHRkZWYgaXNTdHJpbmdcblx0XHRub1xuXG5cdGRlZiBpc1ByaW1pdGl2ZSBkZWVwXG5cdFx0bm9cblxuXHRkZWYgaXNSZXNlcnZlZFxuXHRcdG5vXG5cblx0IyBzaG91bGQgcmF0aGVyIGRvIHRyYXZlcnNhbHNcblx0IyBvID0ge30sIHVwLCBrZXksIGluZGV4XG5cdGRlZiB0cmF2ZXJzZVxuXHRcdGlmIEB0cmF2ZXJzZWRcblx0XHRcdHJldHVybiBzZWxmXG5cdFx0IyBOT0RFUy5wdXNoKHNlbGYpXG5cdFx0QHRyYXZlcnNlZCA9IHllc1xuXHRcdFNUQUNLLnB1c2ggc2VsZlxuXHRcdHZpc2l0KFNUQUNLKVxuXHRcdFNUQUNLLnBvcCBzZWxmXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgaW5zcGVjdFxuXHRcdHt0eXBlOiBzZWxmOmNvbnN0cnVjdG9yLnRvU3RyaW5nfVxuXG5cdGRlZiBqcyBvXG5cdFx0XCJOT0RFXCJcblxuXHRkZWYgdG9TdHJpbmdcblx0XHRcIntzZWxmOmNvbnN0cnVjdG9yOm5hbWV9XCJcblxuXHQjIHN3YWxsb3cgbWlnaHQgYmUgYmV0dGVyIG5hbWVcblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdGlmIG5vZGUgaXNhIFB1c2hBc3NpZ25cblx0XHRcdHJldHVybiBQdXNoQXNzaWduLm5ldyhub2RlLm9wLG5vZGUubGVmdCxzZWxmKVxuXG5cdFx0aWYgbm9kZSBpc2EgQXNzaWduXG5cdFx0XHQjIG5vZGUucmlnaHQgPSBzZWxmXG5cdFx0XHRyZXR1cm4gT1Aobm9kZS5vcCxub2RlLmxlZnQsc2VsZilcblx0XHRlbGlmIG5vZGUgaXNhIE9wXG5cdFx0XHRyZXR1cm4gT1Aobm9kZS5vcCxub2RlLmxlZnQsc2VsZilcblx0XHRlbGlmIG5vZGUgaXNhIFJldHVyblxuXHRcdFx0cmV0dXJuIFJldHVybi5uZXcoc2VsZilcblx0XHRyZXR1cm4gc2VsZlxuXG5cdGRlZiB0b0V4cHJlc3Npb25cblx0XHRAZXhwcmVzc2lvbiA9IHRydWVcblx0XHRzZWxmXG5cblx0ZGVmIGZvcmNlRXhwcmVzc2lvblxuXHRcdEBleHByZXNzaW9uID0gdHJ1ZVxuXHRcdHNlbGZcblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdHRydWVcblxuXHRkZWYgaXNFeHByZXNzaW9uXG5cdFx0QGV4cHJlc3Npb24gfHwgZmFsc2VcblxuXHRkZWYgaGFzU2lkZUVmZmVjdHNcblx0XHR0cnVlXG5cblx0ZGVmIGlzVXNlZFxuXHRcdHRydWVcblxuXHRkZWYgc2hvdWxkUGFyZW50aGVzaXplXG5cdFx0ZmFsc2VcblxuXHRkZWYgc2hvdWxkUGFyZW50aGVzaXplSW5UZXJuYXJ5XG5cdFx0eWVzXG5cblx0ZGVmIGJsb2NrXG5cdFx0QmxvY2sud3JhcChbc2VsZl0pXG5cblx0ZGVmIG5vZGVcblx0XHRzZWxmXG5cblx0ZGVmIHNjb3BlX19cblx0XHRTVEFDSy5zY29wZVxuXG5cdGRlZiB1cFxuXHRcdFNUQUNLLnBhcmVudFxuXG5cdGRlZiB1dGlsXG5cdFx0VXRpbFxuXG5cdGRlZiByZWNlaXZlclxuXHRcdHNlbGZcblxuXHRkZWYgYWRkRXhwcmVzc2lvbiBleHByXG5cdFx0IyBtaWdodCBiZSBiZXR0ZXIgdG8gbmVzdCB0aGlzIHVwIGFmdGVyIHBhcnNpbmcgaXMgZG9uZT9cblx0XHR2YXIgbm9kZSA9IEV4cHJlc3Npb25CbG9jay5uZXcoW3NlbGZdKVxuXHRcdHJldHVybiBub2RlLmFkZEV4cHJlc3Npb24oZXhwcilcblxuXG5cdGRlZiBpbmRlbnRlZCBhLGJcblxuXHRcdGlmIGEgaXNhIEluZGVudGF0aW9uXG5cdFx0XHRAaW5kZW50YXRpb24gPSBhXG5cdFx0XHRyZXR1cm4gc2VsZlxuXG5cdFx0IyB0aGlzIGlzIGEgX0JJR18gaGFja1xuXHRcdGlmIGIgaXNhIEFycmF5XG5cdFx0XHRhZGQoYlswXSlcblx0XHRcdGIgPSBiWzFdXG5cblx0XHQjIGlmIGluZGVudCBhbmQgaW5kZW50Lm1hdGNoKC9cXDovKVxuXHRcdEBpbmRlbnRhdGlvbiB8fD0gYSBhbmQgYiA/IEluZGVudGF0aW9uLm5ldyhhLGIpIDogSU5ERU5UXG5cdFx0c2VsZlxuXG5cdGRlZiBwcmVicmVhayB0ZXJtID0gJ1xcbidcblx0XHRzZWxmXG5cblx0ZGVmIGludmVydFxuXHRcdHJldHVybiBPUCgnIScsc2VsZilcblxuXHRkZWYgY2FjaGUgbyA9IHt9XG5cdFx0QGNhY2hlID0gb1xuXHRcdG86dmFyID0gc2NvcGVfXy50ZW1wb3Jhcnkoc2VsZixvKVxuXHRcdG86bG9va3VwcyA9IDBcblx0XHRzZWxmXG5cblx0ZGVmIGNhY2hldmFyXG5cdFx0QGNhY2hlICYmIEBjYWNoZTp2YXJcblxuXHRkZWYgZGVjYWNoZVxuXHRcdGlmIEBjYWNoZVxuXHRcdFx0Y2FjaGV2YXIuZnJlZVxuXHRcdFx0QGNhY2hlID0gbnVsbFxuXHRcdHNlbGZcblxuXHQjIGlzIHRoaXMgd2l0aG91dCBzaWRlLWVmZmVjdHM/IGhtbSAtIHdoYXQgZG9lcyBpdCBldmVuIGRvP1xuXHRkZWYgcHJlZGVjbGFyZVxuXHRcdGlmIEBjYWNoZVxuXHRcdFx0c2NvcGVfXy52YXJzLnN3YXAoQGNhY2hlOnZhcixzZWxmKVxuXHRcdHNlbGZcblxuXHQjIHRoZSBcIm5hbWUtc3VnZ2VzdGlvblwiIGZvciBub2RlcyBpZiB0aGV5IG5lZWQgdG8gYmUgY2FjaGVkXG5cdGRlZiBhbGlhc1xuXHRcdG51bGxcblxuXHRkZWYgd2FybiB0ZXh0LCBvcHRzID0ge31cblx0XHRvcHRzOm1lc3NhZ2UgPSB0ZXh0XG5cdFx0b3B0czpsb2MgfHw9IGxvY1xuXHRcdHNjb3BlX18ucm9vdC53YXJuIG9wdHNcblx0XHRzZWxmXG5cblx0ZGVmIGMgb1xuXHRcdHZhciBzID0gU1RBQ0tcblx0XHR2YXIgY2ggPSBAY2FjaGVcblx0XHRyZXR1cm4gY19jYWNoZWQoY2gpIGlmIGNoIGFuZCBjaDpjYWNoZWRcblxuXHRcdHMucHVzaChzZWxmKVxuXHRcdGZvcmNlRXhwcmVzc2lvbiBpZiBvICYmIG86ZXhwcmVzc2lvblxuXG5cdFx0aWYgbyBhbmQgbzppbmRlbnRcblx0XHRcdEBpbmRlbnRhdGlvbiB8fD0gSU5ERU5UXG5cblx0XHR2YXIgb3V0ID0ganMocyxvKVxuXG5cdFx0IyByZWFsbHk/IHdoeSBub3QgY2FsbCB0aGlzIHNvbWV3aGVyZSBlbHNlP1xuXHRcdHZhciBwYXJlbiA9IHNob3VsZFBhcmVudGhlc2l6ZVxuXG5cdFx0aWYgdmFyIGluZGVudCA9IEBpbmRlbnRhdGlvblxuXHRcdFx0b3V0ID0gaW5kZW50LndyYXAob3V0LG8pXG5cblx0XHQjIHNob3VsZCBtb3ZlIHRoaXMgc29tZXdoZXJlIGVsc2UgcmVhbGx5XG5cdFx0b3V0ID0gXCIoe291dH0pXCIgaWYgcGFyZW5cblx0XHRpZiBvIGFuZCBvOmJyYWNlc1xuXHRcdFx0aWYgaW5kZW50XG5cdFx0XHRcdG91dCA9ICd7JyArIG91dCArICd9J1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRvdXQgPSAneyAnICsgb3V0ICsgJyB9J1xuXG5cdFx0cy5wb3Aoc2VsZilcblxuXHRcdGlmIGNoID0gQGNhY2hlXG5cdFx0XHRvdXQgPSBcIntjaDp2YXIuY30gPSB7b3V0fVwiIHVubGVzcyBjaDptYW51YWxcblx0XHRcdHZhciBwYXIgPSBzLmN1cnJlbnRcblx0XHRcdG91dCA9ICcoJyArIG91dCArICcpJyBpZiBwYXIgaXNhIEFjY2VzcyB8fCBwYXIgaXNhIE9wICMgb3RoZXJzPyAjXG5cdFx0XHRjaDpjYWNoZWQgPSB5ZXNcblx0XHRyZXR1cm4gb3V0XG5cblx0ZGVmIGNfY2FjaGVkIGNhY2hlXG5cdFx0Y2FjaGU6bG9va3VwcysrXG5cdFx0Y2FjaGU6dmFyLmZyZWUgaWYgY2FjaGU6dXNlcyA9PSBjYWNoZTpsb29rdXBzXG5cdFx0cmV0dXJuIGNhY2hlOnZhci5jICMgcmVjb21waWxlIGV2ZXJ5IHRpbWU/P1xuXG5leHBvcnQgY2xhc3MgVmFsdWVOb2RlIDwgTm9kZVxuXG5cdHByb3AgdmFsdWVcblxuXHRkZWYgaW5pdGlhbGl6ZSB2YWx1ZVxuXHRcdHNldHVwXG5cdFx0QHZhbHVlID0gbG9hZCh2YWx1ZSlcblxuXHRkZWYgbG9hZCB2YWx1ZVxuXHRcdHZhbHVlXG5cblx0ZGVmIGpzIG9cblx0XHR0eXBlb2YgQHZhbHVlID09ICdzdHJpbmcnID8gQHZhbHVlIDogQHZhbHVlLmNcblxuXHRkZWYgdmlzaXRcblxuXHRcdEB2YWx1ZS50cmF2ZXJzZSBpZiBAdmFsdWUgaXNhIE5vZGUgIyAgJiYgQHZhbHVlOnRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cdGRlZiByZWdpb25cblx0XHRbQHZhbHVlLkBsb2MsQHZhbHVlLkBsb2MgKyBAdmFsdWUuQGxlbl1cblxuXG5leHBvcnQgY2xhc3MgU3RhdGVtZW50IDwgVmFsdWVOb2RlXG5cblx0ZGVmIGlzRXhwcmVzc2FibGVcblx0XHRyZXR1cm4gbm9cblxuXG5leHBvcnQgY2xhc3MgTWV0YSA8IFZhbHVlTm9kZVxuXG5cdGRlZiBpc1ByaW1pdGl2ZSBkZWVwXG5cdFx0eWVzXG5cbmV4cG9ydCBjbGFzcyBDb21tZW50IDwgTWV0YVxuXG5cdGRlZiB2aXNpdFxuXHRcdGlmIHZhciBibG9jayA9IHVwXG5cdFx0XHR2YXIgaWR4ID0gYmxvY2suaW5kZXhPZihzZWxmKSArIDFcblx0XHRcdGlkeCArPSAxIGlmIGJsb2NrLmluZGV4KGlkeCkgaXNhIFRlcm1pbmF0b3Jcblx0XHRcdGlmIHZhciBuZXh0ID0gYmxvY2suaW5kZXgoaWR4KVxuXHRcdFx0XHRuZXh0LkBkZXNjID0gc2VsZlxuXG5cdFx0c2VsZlxuXG5cdGRlZiB0b0RvY1xuXHRcdGhlbHBlcnMubm9ybWFsaXplSW5kZW50YXRpb24oXCJcIiArIEB2YWx1ZS5AdmFsdWUpXG5cblx0ZGVmIHRvSlNPTlxuXHRcdGhlbHBlcnMubm9ybWFsaXplSW5kZW50YXRpb24oXCJcIiArIEB2YWx1ZS5AdmFsdWUpXG5cblx0ZGVmIGMgb1xuXHRcdHZhciB2ID0gQHZhbHVlLkB2YWx1ZVxuXHRcdGlmIG8gYW5kIG86ZXhwcmVzc2lvbiBvciB2Lm1hdGNoKC9cXG4vKSBvciBAdmFsdWUudHlwZSA9PSAnSEVSRUNPTU1FTlQnICMgbXVsdGlsaW5lP1xuXHRcdFx0XCIvKnt2fSovXCJcblx0XHRlbHNlXG5cdFx0XHRcIi8vIHt2fVwiXG5cbmV4cG9ydCBjbGFzcyBUZXJtaW5hdG9yIDwgTWV0YVxuXG5cdGRlZiBpbml0aWFsaXplIHZcblx0XHRAdmFsdWUgPSB2XG5cdFx0c2VsZlxuXG5cdGRlZiB0cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHRkZWYgbG9jXG5cdFx0W0B2YWx1ZS5AbG9jLEB2YWx1ZS5AbG9jICsgQHZhbHVlLkB2YWx1ZTpsZW5ndGhdXG5cblx0ZGVmIGNcblx0XHRyZXR1cm4gQHZhbHVlLmNcblxuZXhwb3J0IGNsYXNzIE5ld2xpbmUgPCBUZXJtaW5hdG9yXG5cblx0ZGVmIGluaXRpYWxpemUgdlxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEB2YWx1ZSA9IHYgb3IgJ1xcbidcblxuXHRkZWYgY1xuXHRcdGNfXyhAdmFsdWUpXG5cblxuIyB3ZWlyZCBwbGFjZT9cbmV4cG9ydCBjbGFzcyBJbmRleCA8IFZhbHVlTm9kZVxuXG5cdGRlZiBjYWNoZSBvID0ge31cblx0XHRAdmFsdWUuY2FjaGUobylcblxuXHRkZWYganMgb1xuXHRcdEB2YWx1ZS5jXG5cbmV4cG9ydCBjbGFzcyBMaXN0Tm9kZSA8IE5vZGVcblxuXHRwcm9wIG5vZGVzXG5cblx0ZGVmIGluaXRpYWxpemUgbGlzdFxuXHRcdHNldHVwXG5cdFx0QG5vZGVzID0gbG9hZChsaXN0IG9yIFtdKVxuXHRcdEBpbmRlbnRhdGlvbiA9IG51bGxcblxuXHQjIFBFUkYgYWNjZXMgQG5vZGVzIGRpcmVjdGx5P1xuXHRkZWYgbGlzdFxuXHRcdEBub2Rlc1xuXG5cdGRlZiBjb21wYWN0XG5cdFx0QG5vZGVzID0gY29tcGFjdF9fKEBub2Rlcylcblx0XHRzZWxmXG5cblx0ZGVmIGxvYWQgbGlzdFxuXHRcdGxpc3RcblxuXHRkZWYgY29uY2F0IG90aGVyXG5cdFx0IyBuZWVkIHRvIHN0b3JlIGluZGVudGVkIGNvbnRlbnQgYXMgd2VsbD9cblx0XHRAbm9kZXMgPSBub2Rlcy5jb25jYXQob3RoZXIgaXNhIEFycmF5ID8gb3RoZXIgOiBvdGhlci5ub2Rlcylcblx0XHRzZWxmXG5cblx0ZGVmIHN3YXAgaXRlbSwgb3RoZXJcblx0XHR2YXIgaWR4ID0gaW5kZXhPZihpdGVtKVxuXHRcdG5vZGVzW2lkeF0gPSBvdGhlciBpZiBpZHggPj0gMFxuXHRcdHNlbGZcblxuXHRkZWYgcHVzaCBpdGVtXG5cdFx0QG5vZGVzLnB1c2goaXRlbSlcblx0XHRzZWxmXG5cblx0ZGVmIHBvcFxuXHRcdHZhciBlbmQgPSBAbm9kZXMucG9wXG5cdFx0cmV0dXJuIGVuZFxuXG5cdGRlZiBhZGQgaXRlbVxuXHRcdEBub2Rlcy5wdXNoKGl0ZW0pXG5cdFx0c2VsZlxuXG5cdGRlZiB1bnNoaWZ0IGl0ZW0sIGJyXG5cdFx0QG5vZGVzLnVuc2hpZnQoQlIpIGlmIGJyXG5cdFx0QG5vZGVzLnVuc2hpZnQoaXRlbSlcblx0XHRzZWxmXG5cblx0IyB0ZXN0XG5cdGRlZiBzbGljZSBhLCBiXG5cdFx0c2VsZjpjb25zdHJ1Y3Rvci5uZXcoQG5vZGVzLnNsaWNlKGEsYikpXG5cblx0ZGVmIGJyZWFrIGJyLCBwcmUgPSBub1xuXHRcdGJyID0gVGVybWluYXRvci5uZXcoYnIpIGlmIHR5cGVvZiBiciA9PSAnc3RyaW5nJ1xuXHRcdHByZSA/IHVuc2hpZnQoYnIpIDogcHVzaChicilcblx0XHRzZWxmXG5cblx0ZGVmIHNvbWUgY2Jcblx0XHRmb3Igbm9kZSBpbiBAbm9kZXNcblx0XHRcdHJldHVybiB5ZXMgaWYgY2Iobm9kZSlcblx0XHRyZXR1cm4gbm9cblxuXHRkZWYgZXZlcnkgY2Jcblx0XHRmb3Igbm9kZSBpbiBAbm9kZXNcblx0XHRcdHJldHVybiBubyB1bmxlc3MgY2Iobm9kZSlcblx0XHRyZXR1cm4geWVzXG5cblx0ZGVmIGZpbHRlciBjYlxuXHRcdEBub2Rlcy5maWx0ZXIoY2IpXG5cblx0ZGVmIHBsdWNrIGNiXG5cdFx0dmFyIGl0ZW0gPSBmaWx0ZXIoY2IpWzBdXG5cdFx0cmVtb3ZlKGl0ZW0pIGlmIGl0ZW1cblx0XHRyZXR1cm4gaXRlbVxuXG5cdGRlZiBpbmRleE9mIGl0ZW1cblx0XHRAbm9kZXMuaW5kZXhPZihpdGVtKVxuXG5cdGRlZiBpbmRleCBpXG5cdFx0QG5vZGVzW2ldXG5cblx0ZGVmIHJlbW92ZSBpdGVtXG5cdFx0dmFyIGlkeCA9IEBub2Rlcy5pbmRleE9mKGl0ZW0pXG5cdFx0QG5vZGVzLnNwbGljZShpZHgsIDEpIGlmIGlkeCA+PSAwXG5cdFx0c2VsZlxuXG5cdGRlZiByZW1vdmVBdCBpZHhcblx0XHR2YXIgaXRlbSA9IEBub2Rlc1tpZHhdXG5cdFx0QG5vZGVzLnNwbGljZShpZHgsIDEpIGlmIGlkeCA+PSAwXG5cdFx0cmV0dXJuIGl0ZW1cblxuXG5cdGRlZiByZXBsYWNlIG9yaWdpbmFsLCByZXBsYWNlbWVudFxuXHRcdHZhciBpZHggPSBAbm9kZXMuaW5kZXhPZihvcmlnaW5hbClcblx0XHRpZiBpZHggPj0gMFxuXHRcdFx0aWYgcmVwbGFjZW1lbnQgaXNhIEFycmF5XG5cdFx0XHRcdEBub2Rlcy5zcGxpY2UoaWR4LDEsKnJlcGxhY2VtZW50KVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRAbm9kZXNbaWR4XSA9IHJlcGxhY2VtZW50XG5cdFx0c2VsZlxuXG5cdGRlZiBmaXJzdFxuXHRcdEBub2Rlc1swXVxuXG5cdGRlZiBsYXN0XG5cdFx0dmFyIGkgPSBAbm9kZXM6bGVuZ3RoXG5cdFx0d2hpbGUgaVxuXHRcdFx0aSA9IGkgLSAxXG5cdFx0XHR2YXIgdiA9IEBub2Rlc1tpXVxuXHRcdFx0cmV0dXJuIHYgdW5sZXNzIHYgaXNhIE1ldGFcblx0XHRyZXR1cm4gbnVsbFxuXG5cdGRlZiBtYXAgZm5cblx0XHRAbm9kZXMubWFwKGZuKVxuXG5cdGRlZiBmb3JFYWNoIGZuXG5cdFx0QG5vZGVzLmZvckVhY2goZm4pXG5cblx0ZGVmIHJlbWFwIGZuXG5cdFx0QG5vZGVzID0gbWFwKGZuKVxuXHRcdHNlbGZcblxuXHRkZWYgY291bnRcblx0XHRAbm9kZXM6bGVuZ3RoXG5cblx0ZGVmIHJlYWxDb3VudFxuXHRcdHZhciBrID0gMFxuXHRcdGZvciBub2RlIGluIEBub2Rlc1xuXHRcdFx0aysrIGlmIG5vZGUgYW5kICEobm9kZSBpc2EgTWV0YSlcblx0XHRyZXR1cm4ga1xuXG5cdGRlZiB2aXNpdFxuXHRcdGZvciBub2RlIGluIEBub2Rlc1xuXHRcdFx0bm9kZSBhbmQgbm9kZS50cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdGZvciBub2RlIGluIG5vZGVzXG5cdFx0XHRyZXR1cm4gbm8gaWYgbm9kZSBhbmQgIW5vZGUuaXNFeHByZXNzYWJsZVxuXG5cdFx0cmV0dXJuIHllc1xuXG5cdGRlZiB0b0FycmF5XG5cdFx0QG5vZGVzXG5cblx0ZGVmIGRlbGltaXRlclxuXHRcdEBkZWxpbWl0ZXIgb3IgXCIsXCJcblxuXHRkZWYganMgbywgbm9kZXM6IEBub2Rlc1xuXHRcdHZhciBkZWxpbSA9ICcsJ1xuXHRcdHZhciBleHByZXNzID0gZGVsaW0gIT0gJzsnXG5cdFx0dmFyIGxhc3QgPSBsYXN0XG5cblx0XHR2YXIgaSA9IDBcblx0XHR2YXIgbCA9IG5vZGVzOmxlbmd0aFxuXHRcdHZhciBzdHIgPSBcIlwiXG5cblx0XHRmb3IgYXJnIGluIG5vZGVzXG5cdFx0XHR2YXIgcGFydCA9IHR5cGVvZiBhcmcgPT0gJ3N0cmluZycgPyBhcmcgOiAoYXJnID8gYXJnLmMoZXhwcmVzc2lvbjogZXhwcmVzcykgOiAnJylcblx0XHRcdHN0ciArPSBwYXJ0XG5cdFx0XHRzdHIgKz0gZGVsaW0gaWYgcGFydCBhbmQgKCFleHByZXNzIG9yIGFyZyAhPSBsYXN0KSBhbmQgIShhcmcgaXNhIE1ldGEpXG5cblx0XHRyZXR1cm4gc3RyXG5cblx0ZGVmIGluZGVudGVkIGEsYlxuXHRcdGlmIGEgaXNhIEluZGVudGF0aW9uXG5cdFx0XHRAaW5kZW50YXRpb24gPSBhXG5cdFx0XHRyZXR1cm4gc2VsZlxuXG5cdFx0QGluZGVudGF0aW9uIHx8PSBhIGFuZCBiID8gSW5kZW50YXRpb24ubmV3KGEsYikgOiBJTkRFTlRcblx0XHRzZWxmXG5cblxuZXhwb3J0IGNsYXNzIEFyZ0xpc3QgPCBMaXN0Tm9kZVxuXG5leHBvcnQgY2xhc3MgQXNzaWduTGlzdCA8IEFyZ0xpc3RcblxuXHRkZWYgY29uY2F0IG90aGVyXG5cdFx0aWYgQG5vZGVzOmxlbmd0aCA9PSAwIGFuZCBvdGhlciBpc2EgQXNzaWduTGlzdFxuXHRcdFx0cmV0dXJuIG90aGVyXG5cdFx0ZWxzZVxuXHRcdFx0c3VwZXIob3RoZXIpXG5cdFx0IyBuZWVkIHRvIHN0b3JlIGluZGVudGVkIGNvbnRlbnQgYXMgd2VsbD9cblx0XHQjIEBub2RlcyA9IG5vZGVzLmNvbmNhdChvdGhlciBpc2EgQXJyYXkgPyBvdGhlciA6IG90aGVyLm5vZGVzKVxuXHRcdHNlbGZcblxuXG5leHBvcnQgY2xhc3MgQmxvY2sgPCBMaXN0Tm9kZVxuXG5cdHByb3AgaGVhZFxuXG5cdGRlZiBpbml0aWFsaXplIGxpc3Rcblx0XHRzZXR1cFxuXHRcdEBub2RlcyA9IGxpc3Qgb3IgW11cblx0XHRAaGVhZCA9IG51bGxcblx0XHRAaW5kZW50YXRpb24gPSBudWxsXG5cblx0ZGVmIHNlbGYud3JhcCBhcnlcblx0XHR1bmxlc3MgYXJ5IGlzYSBBcnJheVxuXHRcdFx0dGhyb3cgU3ludGF4RXJyb3IubmV3KFwid2hhdFwiKVxuXHRcdGFyeTpsZW5ndGggPT0gMSAmJiBhcnlbMF0gaXNhIEJsb2NrID8gYXJ5WzBdIDogQmxvY2submV3KGFyeSlcblxuXHRkZWYgdmlzaXRcblx0XHRAc2NvcGUudmlzaXQgaWYgQHNjb3BlXG5cblx0XHRmb3Igbm9kZSxpIGluIEBub2Rlc1xuXHRcdFx0bm9kZSBhbmQgbm9kZS50cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHRkZWYgYmxvY2tcblx0XHRzZWxmXG5cblx0ZGVmIGxvY1xuXHRcdCMgcmF0aGVyIGluZGVudHMsIG5vP1xuXHRcdGlmIHZhciBvcHQgPSBvcHRpb24oOmVuZHMpXG5cdFx0XHR2YXIgYSA9IG9wdFswXS5sb2Ncblx0XHRcdHZhciBiID0gb3B0WzFdLmxvY1xuXG5cdFx0XHRwIFwibm8gbG9jIGZvciB7b3B0WzBdfVwiIHVubGVzcyBhXG5cdFx0XHRwIFwibm8gbG9jIGZvciB7b3B0WzFdfVwiIHVubGVzcyBiXG5cblx0XHRcdFthWzBdLGJbMV1dXG5cdFx0ZWxpZiB2YXIgaW5kID0gQGluZGVudGF0aW9uXG5cdFx0XHRbaW5kLmFsb2MsaW5kLmJsb2NdXG5cdFx0ZWxzZVxuXHRcdFx0IyBmaXJzdCBub2RlXG5cdFx0XHRsZXQgYSA9IEBub2Rlc1swXVxuXHRcdFx0bGV0IGIgPSBAbm9kZXNbQG5vZGVzOmxlbmd0aCAtIDFdXG5cdFx0XHRbYSBhbmQgYS5sb2NbMF0gb3IgMCxiIGFuZCBiLmxvY1sxXSBvciAwXVxuXG5cdCMgZ28gdGhyb3VnaCBjaGlsZHJlbiBhbmQgdW53cmFwIGlubmVyIG5vZGVzXG5cdGRlZiB1bndyYXBcblx0XHR2YXIgYXJ5ID0gW11cblx0XHRmb3Igbm9kZSxpIGluIG5vZGVzXG5cdFx0XHRpZiBub2RlIGlzYSBCbG9ja1xuXHRcdFx0XHRhcnk6cHVzaC5hcHBseShhcnksbm9kZS51bndyYXApXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGFyeS5wdXNoKG5vZGUpXG5cdFx0cmV0dXJuIGFyeVxuXG5cdGRlZiBwdXNoIGl0ZW1cblx0XHRAbm9kZXMucHVzaChpdGVtKVxuXHRcdHNlbGZcblxuXHRkZWYgYWRkIGl0ZW1cblx0XHRAbm9kZXMucHVzaChpdGVtKVxuXHRcdHNlbGZcblxuXHQjIFRoaXMgaXMganVzdCB0byB3b3JrIGFzIGFuIGlucGxhY2UgcmVwbGFjZW1lbnQgb2Ygbm9kZXMuY29mZmVlXG5cdCMgQWZ0ZXIgdGhpbmdzIGFyZSB3b3JraW5nIG9rYXkgd2UnbGwgZG8gYmlnZ2VyIHJlZmFjdG9yaW5nc1xuXHRkZWYgY29tcGlsZSBvID0ge31cblx0XHR2YXIgcm9vdCA9IFJvb3QubmV3KHNlbGYsbylcblx0XHRyb290LmNvbXBpbGUobylcblxuXG5cdCMgTm90IHN1cmUgaWYgd2Ugc2hvdWxkIGNyZWF0ZSBhIHNlcGFyYXRlIGJsb2NrP1xuXHRkZWYgYW5hbHl6ZSBvID0ge31cblx0XHRzZWxmXG5cblx0ZGVmIGNwYXJ0IG5vZGVcblx0XHR2YXIgb3V0ID0gdHlwZW9mIG5vZGUgPT0gJ3N0cmluZycgPyBub2RlIDogKG5vZGUgPyBub2RlLmMgOiBcIlwiKVxuXHRcdHJldHVybiBcIlwiIGlmIG91dCA9PSBudWxsIG9yIG91dCA9PSB1bmRlZmluZWQgb3Igb3V0ID09IFwiXCJcblxuXHRcdGlmIG91dCBpc2EgQXJyYXlcblx0XHRcdHZhciBzdHIgPSBcIlwiXG5cdFx0XHR2YXIgbCA9IG91dDpsZW5ndGhcblx0XHRcdHZhciBpID0gMFxuXHRcdFx0d2hpbGUgaSA8IGxcblx0XHRcdFx0c3RyICs9IGNwYXJ0KG91dFtpKytdKVxuXHRcdFx0cmV0dXJuIHN0clxuXG5cdFx0dmFyIGhhc1NlbWlDb2xvbiA9IFNFTUlDT0xPTl9URVNULnRlc3Qob3V0KVxuXHRcdG91dCArPSBcIjtcIiB1bmxlc3MgaGFzU2VtaUNvbG9uIG9yIG5vZGUgaXNhIE1ldGFcblx0XHRyZXR1cm4gb3V0XG5cblx0ZGVmIGpzIG8sIG9wdHNcblx0XHR2YXIgYXN0ID0gQG5vZGVzXG5cdFx0dmFyIGwgPSBhc3Q6bGVuZ3RoXG5cdFx0IyByZWFsbHk/XG5cdFx0dmFyIGV4cHJlc3MgPSBpc0V4cHJlc3Npb24gb3Igby5pc0V4cHJlc3Npb24gb3IgKG9wdGlvbig6ZXhwcmVzcykgYW5kIGlzRXhwcmVzc2FibGUpXG5cdFx0cmV0dXJuICcnIGlmIGFzdDpsZW5ndGggPT0gMFxuXG5cdFx0aWYgZXhwcmVzc1xuXHRcdFx0cmV0dXJuIHN1cGVyKG8sbm9kZXM6IGFzdClcblxuXHRcdHZhciBzdHIgPSBcIlwiXG5cdFx0Zm9yIHYgaW4gYXN0XG5cdFx0XHRzdHIgKz0gY3BhcnQodilcblxuXHRcdCMgbm93IGFkZCB0aGUgaGVhZCBpdGVtcyBhcyB3ZWxsXG5cdFx0aWYgQGhlYWQgYW5kIEBoZWFkOmxlbmd0aCA+IDBcblx0XHRcdHZhciBwcmVmaXggPSBcIlwiXG5cdFx0XHRmb3IgdiBpbiBAaGVhZFxuXHRcdFx0XHR2YXIgaHYgPSBjcGFydCh2KVxuXHRcdFx0XHRwcmVmaXggKz0gaHYgKyAnXFxuJyBpZiBodlxuXHRcdFx0c3RyID0gcHJlZml4ICsgc3RyXG5cdFx0cmV0dXJuIHN0clxuXG5cblx0IyBTaG91bGQgdGhpcyBjcmVhdGUgdGhlIGZ1bmN0aW9uIGFzIHdlbGw/XG5cdGRlZiBkZWZlcnMgb3JpZ2luYWwsIHJlcGxhY2VtZW50XG5cdFx0dmFyIGlkeCA9IEBub2Rlcy5pbmRleE9mKG9yaWdpbmFsKVxuXHRcdEBub2Rlc1tpZHhdID0gcmVwbGFjZW1lbnQgaWYgaWR4ID49IDBcblx0XHR2YXIgcmVzdCA9IEBub2Rlcy5zcGxpY2UoaWR4ICsgMSlcblx0XHRyZXR1cm4gcmVzdFxuXG5cdGRlZiBleHByZXNzaW9uc1xuXHRcdHZhciBleHByZXNzaW9ucyA9IFtdXG5cdFx0Zm9yIG5vZGUgaW4gbm9kZXNcblx0XHRcdGV4cHJlc3Npb25zLnB1c2gobm9kZSkgdW5sZXNzIG5vZGUgaXNhIFRlcm1pbmF0b3Jcblx0XHRyZXR1cm4gZXhwcmVzc2lvbnNcblxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRpZiBub2RlIGlzYSBUYWdUcmVlICMgc3BlY2lhbCBjYXNlPyE/XG5cdFx0XHRAbm9kZXMgPSBAbm9kZXMubWFwIGRvIHxjaGlsZHxcblx0XHRcdFx0Y2hpbGQuY29uc3VtZShub2RlKVxuXG5cdFx0XHRsZXQgcmVhbCA9IGV4cHJlc3Npb25zXG5cdFx0XHQjIGNvbnNvbGUubG9nICdCbG9jay5jb25zdW1lIFRhZ1RyZWUnLG5vZGUuQGxvb3Bcblx0XHRcdCMgRklYTUUgc2hvdWxkIG5vdCBpbmNsdWRlIHRlcm1pbmF0b3JzIGFuZCBjb21tZW50cyB3aGVuIGNvdW50aW5nXG5cdFx0XHQjIHNob3VsZCBvbmx5IHdyYXAgdGhlIGNvbnRlbnQgaW4gYXJyYXkgKHJldHVybmluZyBhbGwgcGFydHMpXG5cdFx0XHQjIGZvciBpZi9lbHNlIGJsb2NrcyAtLSBub3QgbG9vcHNcblxuXHRcdFx0IyB3ZSBuZWVkIHRvIGNvbXBhcmUgdGhlIHJlYWwgbGVuZ3RoXG5cdFx0XHRpZiAhbm9kZS5AbG9vcCAmJiByZWFsOmxlbmd0aCA+IDFcblx0XHRcdFx0bGV0IG5yID0gbm9kZS5ibG9ja3MucHVzaChzZWxmKVxuXHRcdFx0XHR2YXIgYXJyID0gQXJyLm5ldyhBcmdMaXN0Lm5ldyggQG5vZGVzICkpXG5cdFx0XHRcdGFyci5pbmRlbnRlZChAaW5kZW50YXRpb24pXG5cdFx0XHRcdEBpbmRlbnRhdGlvbiA9IG51bGxcblxuXHRcdFx0XHRpZiBub2RlLnJlYWN0aXZlXG5cdFx0XHRcdFx0QG5vZGVzID0gW1V0aWwuY2FsbEltYmEoc2NvcGVfXywgXCJzdGF0aWNcIixbYXJyLE51bS5uZXcobnIpXSldXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRAbm9kZXMgPSBbYXJyXVxuXG5cblxuXHRcdFx0cmV0dXJuIHNlbGZcblxuXHRcdGVsaWYgbm9kZSBpc2EgVGFnUHVzaEFzc2lnblxuXHRcdFx0IyBjb25zb2xlLmxvZyAnVGFnUHVzaEFzc2lnbidcblx0XHRcdGxldCByZWFsID0gZXhwcmVzc2lvbnNcblxuXHRcdFx0QG5vZGVzID0gQG5vZGVzLm1hcCBkbyB8Y2hpbGR8XG5cdFx0XHRcdGlmIGNoaWxkIGluIHJlYWwgYW5kICEoY2hpbGQgaXNhIEFzc2lnbilcblx0XHRcdFx0XHQjIGNvbnNvbGUubG9nIFwie2NoaWxkfVwiXG5cdFx0XHRcdFx0Y2hpbGQuY29uc3VtZShub2RlKVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0Y2hpbGRcblxuXHRcdFx0cmV0dXJuIHNlbGZcblxuXHRcdCMgY2FuIGFsc28gcmV0dXJuIHN1cGVyIGlmIGl0IGlzIGV4cHJlc3NhYmxlLCBidXQgc2hvdWxkIHdlIHJlYWxseT9cblx0XHRpZiB2YXIgYmVmb3JlID0gbGFzdFxuXHRcdFx0dmFyIGFmdGVyID0gYmVmb3JlLmNvbnN1bWUobm9kZSlcblx0XHRcdGlmIGFmdGVyICE9IGJlZm9yZVxuXHRcdFx0XHRpZiBhZnRlciBpc2EgQmxvY2tcblx0XHRcdFx0XHRhZnRlciA9IGFmdGVyLm5vZGVzXG5cblx0XHRcdFx0cmVwbGFjZShiZWZvcmUsYWZ0ZXIpXG5cblx0XHRyZXR1cm4gc2VsZlxuXG5cblx0ZGVmIGlzRXhwcmVzc2FibGVcblx0XHRyZXR1cm4gbm8gdW5sZXNzIEBub2Rlcy5ldmVyeSh8dnwgdi5pc0V4cHJlc3NhYmxlIClcblx0XHRyZXR1cm4geWVzXG5cblx0ZGVmIGlzRXhwcmVzc2lvblxuXG5cdFx0b3B0aW9uKDpleHByZXNzKSB8fCBAZXhwcmVzc2lvblxuXG5cdGRlZiBzaG91bGRQYXJlbnRoZXNpemVJblRlcm5hcnlcblx0XHRpZiBjb3VudCA9PSAxXG5cdFx0XHRyZXR1cm4gZmlyc3Quc2hvdWxkUGFyZW50aGVzaXplSW5UZXJuYXJ5XG5cblx0XHR5ZXNcblxuXG4jIHRoaXMgaXMgYWxtb3N0IGxpa2UgdGhlIG9sZCBWYXJEZWNsYXJhdGlvbnMgYnV0IHdpdGhvdXQgdGhlIHZhbHVlc1xuZXhwb3J0IGNsYXNzIFZhckJsb2NrIDwgTGlzdE5vZGVcblxuXG5cdGRlZiBsb2FkIGxpc3Rcblx0XHR2YXIgZmlyc3QgPSBsaXN0WzBdXG5cblx0XHRpZiBmaXJzdCBpc2EgQXNzaWduXG5cdFx0XHRAdHlwZSA9IGZpcnN0LmxlZnQuQHR5cGVcblx0XHRlbGlmIGZpcnN0IGlzYSBWYXJSZWZlcmVuY2Vcblx0XHRcdEB0eXBlID0gZmlyc3QuQHR5cGVcblx0XHQjIEB0eXBlID0gbGlzdFswXSBhbmQgbGlzdFswXS50eXBlXG5cdFx0bGlzdFxuXG5cdCMgVE9ETyBBbGwgdGhlc2UgaW5uZXIgaXRlbXMgc2hvdWxkIHJhdGhlciBiZSBzdHJhaWdodCB1cCBsaXRlcmFsc1xuXHQjIG9yIGJhc2ljIGxvY2FsdmFycyAtIHdpdGhvdXQgYW55IGNhcmUgd2hhdHNvZXZlciBhYm91dCBhZGRpbmcgdmFyIHRvIHRoZVxuXHQjIGJlZ2lubmluZyBldGMuXG5cdGRlZiBhZGRFeHByZXNzaW9uIGV4cHJcblxuXHRcdGlmIGV4cHIgaXNhIEFzc2lnblxuXHRcdFx0IyBtYWtlIHN1cmUgdGhlIGxlZnQtc2lkZSBpcyBhIHZhci1yZWZlcmVuY2Vcblx0XHRcdCMgdGhpcyBzaG91bGQgYmUgYSBkaWZmZXJlbnQgdHlwZSBvZiBhc3NpZ24sIG5vP1xuXHRcdFx0aWYgZXhwci5sZWZ0IGlzYSBWYXJPckFjY2Vzc1xuXHRcdFx0XHRleHByLmxlZnQgPSBWYXJSZWZlcmVuY2UubmV3KGV4cHIubGVmdC52YWx1ZSxAdHlwZSlcblxuXHRcdFx0cHVzaChleHByKVxuXG5cdFx0ZWxpZiBleHByIGlzYSBBc3NpZ25cblx0XHRcdGFkZEV4cHJlc3Npb24oZXhwci5sZWZ0KSAjIG1ha2Ugc3VyZSB0aGlzIGlzIGEgdmFsaWQgdGhpbmc/XG5cdFx0XHQjIG1ha2UgdGhpcyBpbnRvIGEgdHVwbGUgaW5zdGVhZFxuXHRcdFx0IyBkb2VzIG5vdCBuZWVkIHRvIGJlIGEgdHVwbGU/XG5cdFx0XHRyZXR1cm4gVHVwbGVBc3NpZ24ubmV3KCc9JyxUdXBsZS5uZXcobm9kZXMpLGV4cHIucmlnaHQpXG5cblx0XHRlbGlmIGV4cHIgaXNhIFZhck9yQWNjZXNzXG5cdFx0XHQjIHRoaXMgaXMgcmVhbGx5IGEgVmFyUmVmZXJlbmNlXG5cdFx0XHRwdXNoKFZhclJlZmVyZW5jZS5uZXcoZXhwci52YWx1ZSxAdHlwZSkpXG5cblx0XHRlbGlmIGV4cHIgaXNhIFNwbGF0ICYmIGV4cHIubm9kZSBpc2EgVmFyT3JBY2Nlc3Ncblx0XHRcdGV4cHIudmFsdWUgPSBWYXJSZWZlcmVuY2UubmV3KGV4cHIubm9kZS52YWx1ZSxAdHlwZSlcblx0XHRcdHB1c2goZXhwcilcblx0XHRlbHNlXG5cdFx0XHRwIFwiVmFyQmxvY2suYWRkRXhwcmVzc2lvbiB7c2VsZn0gPC0ge2V4cHJ9XCJcblx0XHRcdHRocm93IFwiVmFyQmxvY2sgZG9lcyBub3QgYWxsb3cgbm9uLXZhcmlhYmxlIGV4cHJlc3Npb25zXCJcblx0XHRzZWxmXG5cblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdCMgd2Ugd291bGQgbmVlZCB0byBmb3JjZS1kcm9wIHRoZSB2YXJpYWJsZXMsIG1ha2VzIGxpdHRsZSBzZW5zZVxuXHRcdCMgYnV0LCBpdCBjb3VsZCBiZSwgY291bGQganVzdCBwdXNoIHRoZSB2YXJpYWJsZXMgb3V0P1xuXHRcdG5vXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgY29kZSA9IGNvbXBhY3RfXyhmbGF0dGVuX18oY2FyeV9fKG5vZGVzKSkpXG5cdFx0Y29kZSA9IGNvZGUuZmlsdGVyKHxufCBuICE9IG51bGwgJiYgbiAhPSB1bmRlZmluZWQgJiYgbiAhPSBFTVBUWSlcblx0XHR2YXIgb3V0ID0gY29kZS5qb2luKFwiLFwiKVxuXHRcdCMgd2UganVzdCBuZWVkIHRvIHRydXN0IHRoYXQgdGhlIHZhcmlhYmxlcyBoYXZlIGJlZW4gYXV0b2RlY2xhcmVkIGJlZm9yZWhhbmRcblx0XHQjIGlmIHdlIGFyZSBpbnNpZGUgYW4gZXhwcmVzc2lvblxuXHRcdG91dCA9IFwidmFyIFwiICsgb3V0IHVubGVzcyBvLmlzRXhwcmVzc2lvblxuXHRcdHJldHVybiBvdXRcblxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHQjIEl0IGRvZXNudCBtYWtlIG11Y2ggc2Vuc2UgZm9yIGEgVmFyQmxvY2sgdG8gY29uc3VtZSBhbnl0aGluZ1xuXHRcdCMgaXQgc2hvdWxkIHByb2JhYmx5IHJldHVybiB2b2lkIGZvciBtZXRob2RzXG5cdFx0cmV0dXJuIHNlbGZcblxuXG4jIENvdWxkIGluaGVyaXQgZnJvbSB2YWx1ZU5vZGVcbmV4cG9ydCBjbGFzcyBQYXJlbnMgPCBWYWx1ZU5vZGVcblxuXHRkZWYgaW5pdGlhbGl6ZSB2YWx1ZSwgb3BlbiwgY2xvc2Vcblx0XHRzZXR1cFxuXHRcdEBvcGVuID0gb3BlblxuXHRcdEBjbG9zZSA9IGNsb3NlXG5cdFx0QHZhbHVlID0gbG9hZCh2YWx1ZSlcblxuXHRkZWYgbG9hZCB2YWx1ZVxuXHRcdEBub3BhcmVuID0gbm9cblx0XHR2YWx1ZSBpc2EgQmxvY2sgYW5kIHZhbHVlLmNvdW50ID09IDEgPyB2YWx1ZS5maXJzdCA6IHZhbHVlXG5cblx0ZGVmIGlzU3RyaW5nXG5cdFx0IyBjaGVja2luZyBpZiB0aGlzIGlzIGFuIGludGVycG9sYXRlZCBzdHJpbmdcblx0XHRAb3BlbiBhbmQgU3RyaW5nKEBvcGVuKSA9PSAnKFwiJyBvciB2YWx1ZS5pc1N0cmluZ1xuXG5cdGRlZiBqcyBvXG5cblx0XHR2YXIgcGFyID0gdXBcblx0XHR2YXIgdiA9IEB2YWx1ZVxuXHRcdHZhciBzdHIgPSBudWxsXG5cblx0XHRAbm9wYXJlbiA9IHllcyBpZiB2IGlzYSBGdW5jXG5cblx0XHRpZiBwYXIgaXNhIEJsb2NrXG5cdFx0XHQjIGlzIGl0IHdvcnRoIGl0P1xuXHRcdFx0QG5vcGFyZW4gPSB5ZXMgdW5sZXNzIG8uaXNFeHByZXNzaW9uXG5cdFx0XHRzdHIgPSB2IGlzYSBBcnJheSA/IGNhcnlfXyh2KSA6IHYuYyhleHByZXNzaW9uOiBvLmlzRXhwcmVzc2lvbilcblx0XHRlbHNlXG5cdFx0XHRzdHIgPSB2IGlzYSBBcnJheSA/IGNhcnlfXyh2KSA6IHYuYyhleHByZXNzaW9uOiB5ZXMpXG5cblx0XHQjIGNoZWNrIGlmIHdlIHJlYWxseSBuZWVkIHBhcmVucyBoZXJlP1xuXHRcdHJldHVybiBzdHJcblxuXHRkZWYgc2V0IG9ialxuXHRcdGNvbnNvbGUubG9nIFwiUGFyZW5zIHNldCB7SlNPTi5zdHJpbmdpZnkob2JqKX1cIlxuXHRcdHN1cGVyKG9iailcblxuXG5cdGRlZiBzaG91bGRQYXJlbnRoZXNpemVcblx0XHQjIG5vIG5lZWQgdG8gcGFyZW50aGVzaXplIGlmIHRoaXMgaXMgYSBsaW5lIGluIGEgYmxvY2tcblx0XHRyZXR1cm4gbm8gaWYgQG5vcGFyZW4gIyAgb3IgcGFyIGlzYSBBcmdMaXN0XG5cdFx0cmV0dXJuIHllc1xuXG5cblx0ZGVmIHByZWJyZWFrIGJyXG5cdFx0c3VwZXIoYnIpXG5cdFx0Y29uc29sZS5sb2cgXCJQUkVCUkVBS1wiXG5cdFx0QHZhbHVlLnByZWJyZWFrKGJyKSBpZiBAdmFsdWVcblx0XHRzZWxmXG5cblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdEB2YWx1ZS5pc0V4cHJlc3NhYmxlXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdEB2YWx1ZS5jb25zdW1lKG5vZGUpXG5cblxuIyBDb3VsZCBpbmhlcml0IGZyb20gdmFsdWVOb2RlXG4jIGFuIGV4cGxpY2l0IGV4cHJlc3Npb24tYmxvY2sgKHdpdGggcGFyZW5zKSBpcyBzb21ld2hhdCBkaWZmZXJlbnRcbiMgY2FuIGJlIHVzZWQgdG8gcmV0dXJuIGFmdGVyIGFuIGV4cHJlc3Npb25cbmV4cG9ydCBjbGFzcyBFeHByZXNzaW9uQmxvY2sgPCBMaXN0Tm9kZVxuXG5cblx0ZGVmIGMgb1xuXHRcdG1hcCh8aXRlbXwgaXRlbS5jKG8pICkuam9pbihcIixcIilcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0dmFsdWUuY29uc3VtZShub2RlKVxuXG5cdGRlZiBhZGRFeHByZXNzaW9uIGV4cHJcblx0XHQjIE5lZWQgdG8gdGFrZSBjYXJlIG9mIHRoZSBzcGxhdCBoZXJlIHRvLi4gaGF6emxlXG5cdFx0aWYgZXhwci5ub2RlIGlzYSBBc3NpZ25cblx0XHRcdHB1c2goZXhwci5sZWZ0KVxuXHRcdFx0IyBtYWtlIHRoaXMgaW50byBhIHR1cGxlIGluc3RlYWRcblx0XHRcdCMgcG9zc2libHkgZml4IHRoaXMgYXMgd2VsbD8hP1xuXHRcdFx0cmV0dXJuIFR1cGxlQXNzaWduLm5ldygnPScsVHVwbGUubmV3KG5vZGVzKSxleHByLnJpZ2h0KVxuXHRcdGVsc2Vcblx0XHRcdHB1c2goZXhwcilcblx0XHRzZWxmXG5cblxuXG4jIFNUQVRFTUVOVFNcblxuZXhwb3J0IGNsYXNzIFJldHVybiA8IFN0YXRlbWVudFxuXG5cdHByb3AgdmFsdWVcblxuXHRkZWYgaW5pdGlhbGl6ZSB2XG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHZhbHVlID0gdiBpc2EgQXJnTGlzdCBhbmQgdi5jb3VudCA9PSAxID8gdi5sYXN0IDogdlxuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIHZpc2l0XG5cdFx0QHZhbHVlLnRyYXZlcnNlIGlmIEB2YWx1ZSAmJiBAdmFsdWU6dHJhdmVyc2VcblxuXHRkZWYganMgb1xuXHRcdHZhciB2ID0gQHZhbHVlXG5cblx0XHRpZiB2IGlzYSBBcmdMaXN0XG5cdFx0XHRyZXR1cm4gXCJyZXR1cm4gW3t2LmMoZXhwcmVzc2lvbjogeWVzKX1dXCJcblx0XHRlbGlmIHZcblx0XHRcdHJldHVybiBcInJldHVybiB7di5jKGV4cHJlc3Npb246IHllcyl9XCJcblx0XHRlbHNlXG5cdFx0XHRcInJldHVyblwiXG5cblx0ZGVmIGNcblx0XHRyZXR1cm4gc3VwZXIgaWYgIXZhbHVlIG9yIHZhbHVlLmlzRXhwcmVzc2FibGVcblx0XHR2YWx1ZS5jb25zdW1lKHNlbGYpLmNcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0cmV0dXJuIHNlbGZcblxuZXhwb3J0IGNsYXNzIEltcGxpY2l0UmV0dXJuIDwgUmV0dXJuXG5cbmV4cG9ydCBjbGFzcyBHcmVlZHlSZXR1cm4gPCBJbXBsaWNpdFJldHVyblxuXG4jIGNhbm5vdCBsaXZlIGluc2lkZSBhbiBleHByZXNzaW9uKCEpXG5leHBvcnQgY2xhc3MgVGhyb3cgPCBTdGF0ZW1lbnRcblxuXHRkZWYganMgb1xuXHRcdFwidGhyb3cge3ZhbHVlLmN9XCJcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0IyBST0FETUFQIHNob3VsZCBwb3NzaWJseSBjb25zdW1lIHRvIHRoZSB2YWx1ZSBvZiB0aHJvdyBhbmQgdGhlbiB0aHJvdz9cblx0XHRyZXR1cm4gc2VsZlxuXG5cbmV4cG9ydCBjbGFzcyBMb29wRmxvd1N0YXRlbWVudCA8IFN0YXRlbWVudFxuXG5cdHByb3AgbGl0ZXJhbFxuXHRwcm9wIGV4cHJlc3Npb25cblxuXHRkZWYgaW5pdGlhbGl6ZSBsaXQsIGV4cHJcblx0XHRzZWxmLmxpdGVyYWwgPSBsaXRcblx0XHRzZWxmLmV4cHJlc3Npb24gPSBleHByXG5cblx0ZGVmIHZpc2l0XG5cdFx0ZXhwcmVzc2lvbi50cmF2ZXJzZSBpZiBleHByZXNzaW9uXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdHNlbGZcblxuXHRkZWYgY1xuXHRcdHJldHVybiBzdXBlciB1bmxlc3MgZXhwcmVzc2lvblxuXHRcdCMgZ2V0IHVwIHRvIHRoZSBvdXRlciBsb29wXG5cdFx0dmFyIF9sb29wID0gU1RBQ0sudXAoTG9vcClcblxuXHRcdCMgbmVlZCB0byBmaXggdGhlIGdyYW1tYXIgZm9yIHRoaXMuIFJpZ2h0IG5vdyBpdFxuXHRcdCMgaXMgbGlrZSBhIGZha2UgY2FsbCwgYnV0IHNob3VsZCBvbmx5IGNhcmUgYWJvdXQgdGhlIGZpcnN0IGFyZ3VtZW50XG5cdFx0dmFyIGV4cHIgPSBzZWxmLmV4cHJlc3Npb25cblxuXHRcdGlmIF9sb29wLmNhdGNoZXJcblx0XHRcdGV4cHIgPSBleHByLmNvbnN1bWUoX2xvb3AuY2F0Y2hlcilcblx0XHRcdHZhciBjb3B5ID0gc2VsZjpjb25zdHJ1Y3Rvci5uZXcobGl0ZXJhbClcblx0XHRcdEJsb2NrLm5ldyhbZXhwcixjb3B5XSkuY1xuXHRcdGVsaWYgZXhwclxuXHRcdFx0dmFyIGNvcHkgPSBzZWxmOmNvbnN0cnVjdG9yLm5ldyhsaXRlcmFsKVxuXHRcdFx0QmxvY2submV3KFtleHByLGNvcHldKS5jXG5cdFx0ZWxzZVxuXHRcdFx0c3VwZXJcblx0XHQjIHJldHVybiBcImxvb3BmbG93XCJcblxuXG5leHBvcnQgY2xhc3MgQnJlYWtTdGF0ZW1lbnQgPCBMb29wRmxvd1N0YXRlbWVudFxuXHRkZWYganMgbyBkbyBcImJyZWFrXCJcblxuZXhwb3J0IGNsYXNzIENvbnRpbnVlU3RhdGVtZW50IDwgTG9vcEZsb3dTdGF0ZW1lbnRcblx0ZGVmIGpzIG8gZG8gXCJjb250aW51ZVwiXG5cbmV4cG9ydCBjbGFzcyBEZWJ1Z2dlclN0YXRlbWVudCA8IFN0YXRlbWVudFxuXG5cbiMgUEFSQU1TXG5cbmV4cG9ydCBjbGFzcyBQYXJhbSA8IE5vZGVcblxuXHRwcm9wIG5hbWVcblx0cHJvcCBpbmRleFxuXHRwcm9wIGRlZmF1bHRzXG5cdHByb3Agc3BsYXRcblx0cHJvcCB2YXJpYWJsZVxuXG5cdGRlZiBpbml0aWFsaXplIG5hbWUsIGRlZmF1bHRzLCB0eXBcblx0XHQjIGNvdWxkIGhhdmUgaW50cm9kdWNlZCBidWdzIGJ5IG1vdmluZyBiYWNrIHRvIGlkZW50aWZpZXIgaGVyZVxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBuYW1lID0gbmFtZVxuXHRcdEBkZWZhdWx0cyA9IGRlZmF1bHRzXG5cdFx0QHR5cCA9IHR5cFxuXHRcdEB2YXJpYWJsZSA9IG51bGxcblxuXHRkZWYgdmFybmFtZVxuXHRcdEB2YXJpYWJsZSA/IEB2YXJpYWJsZS5jIDogbmFtZVxuXG5cdGRlZiBqcyBvXG5cdFx0cmV0dXJuIEB2YXJpYWJsZS5jIGlmIEB2YXJpYWJsZVxuXG5cdFx0aWYgZGVmYXVsdHNcblx0XHRcdCMgc2hvdWxkIG5vdCBpbmNsdWRlIGFueSBzb3VyY2UtbWFwcGluZyBoZXJlP1xuXHRcdFx0XCJpZih7bmFtZS5jfSA9PSBudWxsKSB7bmFtZS5jfSA9IHtkZWZhdWx0cy5jfVwiXG5cdFx0IyBzZWUgaWYgdGhpcyBpcyB0aGUgaW5pdGlhbCBkZWNsYXJhdG9yP1xuXG5cdGRlZiB2aXNpdFxuXHRcdEBkZWZhdWx0cy50cmF2ZXJzZSBpZiBAZGVmYXVsdHNcblx0XHRzZWxmLnZhcmlhYmxlIHx8PSBzY29wZV9fLnJlZ2lzdGVyKG5hbWUsc2VsZilcblxuXHRcdGlmIEBuYW1lIGlzYSBJZGVudGlmaWVyXG5cdFx0XHQjIGNoYW5nZSB0eXBlIGhlcmU/XG5cdFx0XHRAbmFtZS5AdmFsdWUuQHR5cGUgPSBcIlBBUkFNVkFSXCIgaWYgQG5hbWUuQHZhbHVlXG5cdFx0XHRAbmFtZS5yZWZlcmVuY2VzKEB2YXJpYWJsZSlcblx0XHRcdEB2YXJpYWJsZS5hZGRSZWZlcmVuY2UoQG5hbWUpXG5cdFx0XHQjIGNvbnNvbGUubG9nIEBuYW1lLmMsIFwiZ290IGhlcmUhISB7QG5hbWU6Y29uc3RydWN0b3J9XCJcblx0XHRcdCMgQG5hbWUuQHRva2VuLkB2YXJpYWJsZSA9IEB2YXJpYWJsZSBpZiBAbmFtZS5AdG9rZW5cblxuXHRcdHNlbGZcblxuXHRkZWYgYXNzaWdubWVudFxuXHRcdE9QKCc9Jyx2YXJpYWJsZS5hY2Nlc3NvcixkZWZhdWx0cylcblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdCFkZWZhdWx0cyB8fCBkZWZhdWx0cy5pc0V4cHJlc3NhYmxlXG5cblx0ZGVmIGR1bXBcblx0XHR7bG9jOiBsb2N9XG5cblx0ZGVmIGxvY1xuXHRcdEBuYW1lICYmIEBuYW1lLnJlZ2lvblxuXG5cdGRlZiB0b0pTT05cblx0XHR7XG5cdFx0XHR0eXBlOiB0eXBlTmFtZVxuXHRcdFx0bmFtZTogbmFtZVxuXHRcdFx0ZGVmYXVsdHM6IGRlZmF1bHRzXG5cdFx0fVxuXG5cbmV4cG9ydCBjbGFzcyBTcGxhdFBhcmFtIDwgUGFyYW1cblxuXHRkZWYgbG9jXG5cdFx0IyBoYWNreS4uIGNhbm5vdCBrbm93IGZvciBzdXJlIHRoYXQgdGhpcyBpcyByaWdodD9cblx0XHR2YXIgciA9IG5hbWUucmVnaW9uXG5cdFx0W3JbMF0gLSAxLHJbMV1dXG5cbmV4cG9ydCBjbGFzcyBCbG9ja1BhcmFtIDwgUGFyYW1cblxuXHRkZWYgY1xuXHRcdFwiYmxvY2twYXJhbVwiXG5cblx0ZGVmIGxvY1xuXHRcdCMgaGFja3kuLiBjYW5ub3Qga25vdyBmb3Igc3VyZSB0aGF0IHRoaXMgaXMgcmlnaHQ/XG5cdFx0dmFyIHIgPSBuYW1lLnJlZ2lvblxuXHRcdFtyWzBdIC0gMSxyWzFdXVxuXG5cbmV4cG9ydCBjbGFzcyBPcHRpb25hbFBhcmFtIDwgUGFyYW1cblxuZXhwb3J0IGNsYXNzIE5hbWVkUGFyYW0gPCBQYXJhbVxuXG5leHBvcnQgY2xhc3MgUmVxdWlyZWRQYXJhbSA8IFBhcmFtXG5cbmV4cG9ydCBjbGFzcyBOYW1lZFBhcmFtcyA8IExpc3ROb2RlXG5cblx0cHJvcCBpbmRleFxuXHRwcm9wIHZhcmlhYmxlXG5cblx0ZGVmIGxvYWQgbGlzdFxuXHRcdHZhciBsb2FkID0gKHxrfCBOYW1lZFBhcmFtLm5ldyhrLmtleSxrLnZhbHVlKSApXG5cdFx0bGlzdCBpc2EgT2JqID8gbGlzdC52YWx1ZS5tYXAobG9hZCkgOiBsaXN0XG5cblx0ZGVmIHZpc2l0XG5cdFx0dmFyIHMgPSBzY29wZV9fXG5cdFx0QHZhcmlhYmxlIHx8PSBzLnRlbXBvcmFyeShzZWxmLCBwb29sOiAna2V5cGFycycpXG5cdFx0QHZhcmlhYmxlLnByZWRlY2xhcmVkXG5cblx0XHQjIHRoaXMgaXMgYSBsaXN0bm9kZSwgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IHRyYXZlcnNlXG5cdFx0IyBhbmQgdmlzaXQgYWxsIGNoaWxkcmVuXG5cdFx0c3VwZXJcblx0XHQjIHJlZ2lzdGVyIHRoZSBpbm5lciB2YXJpYWJsZXMgYXMgd2VsbCghKVxuXHRcdHNlbGZcblxuXG5cdGRlZiB2YXJuYW1lXG5cdFx0dmFyaWFibGUuY1xuXG5cdGRlZiBuYW1lXG5cdFx0dmFybmFtZVxuXG5cdGRlZiBqcyBvXG5cdFx0XCJuYW1lZHBhclwiXG5cblx0ZGVmIHRvSlNPTlxuXHRcdHtcblx0XHRcdHR5cGU6IHR5cGVOYW1lXG5cdFx0XHRub2RlczogZmlsdGVyKHx2fCB2IGlzYSBOYW1lZFBhcmFtKVxuXHRcdH1cblxuXG5leHBvcnQgY2xhc3MgSW5kZXhlZFBhcmFtIDwgUGFyYW1cblxuXHRwcm9wIHBhcmVudFxuXHRwcm9wIHN1YmluZGV4XG5cblx0ZGVmIHZpc2l0XG5cdFx0IyBCVUcgVGhlIGRlZmF1bHRzIHNob3VsZCBwcm9iYWJseSBiZSBsb29rZWQgdXAgbGlrZSB2YXJzXG5cdFx0c2VsZi52YXJpYWJsZSB8fD0gc2NvcGVfXy5yZWdpc3RlcihuYW1lLHNlbGYpXG5cdFx0c2VsZi52YXJpYWJsZS5wcm94eShwYXJlbnQudmFyaWFibGUsc3ViaW5kZXgpXG5cdFx0c2VsZlxuXG5cbmV4cG9ydCBjbGFzcyBBcnJheVBhcmFtcyA8IExpc3ROb2RlXG5cblx0cHJvcCBpbmRleFxuXHRwcm9wIHZhcmlhYmxlXG5cblx0ZGVmIHZpc2l0XG5cdFx0dmFyIHMgPSBzY29wZV9fXG5cdFx0QHZhcmlhYmxlIHx8PSBzLnRlbXBvcmFyeShzZWxmLCBwb29sOiAna2V5cGFycycpXG5cdFx0QHZhcmlhYmxlLnByZWRlY2xhcmVkXG5cblx0XHQjIG5vdyB3aGVuIHdlIGxvb3AgdGhyb3VnaCB0aGVzZSBpbm5lciBwYXJhbXMgLSB3ZSBjcmVhdGUgdGhlIHBhcnNcblx0XHQjIHdpdGggdGhlIGNvcnJlY3QgbmFtZSwgYnV0IGJpbmQgdGhlbSB0byB0aGUgcGFyZW50XG5cdFx0c3VwZXJcblxuXHRkZWYgbmFtZVxuXHRcdHZhcmlhYmxlLmNcblxuXHRkZWYgbG9hZCBsaXN0XG5cdFx0cmV0dXJuIG51bGwgdW5sZXNzIGxpc3QgaXNhIEFyclxuXHRcdCMgdHJ5IHRoZSBiYXNpYyBmaXJzdFxuXHRcdHVubGVzcyBsaXN0LnNwbGF0XG5cdFx0XHRsaXN0LnZhbHVlLm1hcCBkbyB8dixpfFxuXHRcdFx0XHQjIG11c3QgbWFrZSBzdXJlIHRoZSBwYXJhbXMgYXJlIHN1cHBvcnRlZCBoZXJlXG5cdFx0XHRcdCMgc2hvdWxkIHJlYWxseSBub3QgcGFyc2UgYW55IGFycmF5IGF0IGFsbCghKVxuXHRcdFx0XHR2YXIgbmFtZSA9IHZcblx0XHRcdFx0aWYgdiBpc2EgVmFyT3JBY2Nlc3Ncblx0XHRcdFx0XHQjIEZJWD9cblx0XHRcdFx0XHRuYW1lID0gdi52YWx1ZS52YWx1ZVxuXHRcdFx0XHRcdCMgdGhpcyBpcyBhY2NlcHRlZFxuXHRcdFx0XHRwYXJzZShuYW1lLHYsaSlcblxuXHRkZWYgcGFyc2UgbmFtZSxjaGlsZCxpXG5cdFx0dmFyIHBhcmFtID0gSW5kZXhlZFBhcmFtLm5ldyhuYW1lLG51bGwpXG5cblx0XHRwYXJhbS5wYXJlbnQgPSBzZWxmXG5cdFx0cGFyYW0uc3ViaW5kZXggPSBpXG5cdFx0cGFyYW1cblxuXHRkZWYgaGVhZCBhc3Rcblx0XHRzZWxmXG5cbmV4cG9ydCBjbGFzcyBQYXJhbUxpc3QgPCBMaXN0Tm9kZVxuXG5cdHByb3Agc3BsYXRcblx0cHJvcCBibG9ja1xuXG5cdGRlZiBhdCBpbmRleCwgZm9yY2UgPSBubywgbmFtZSA9IG51bGxcblx0XHRpZiBmb3JjZVxuXHRcdFx0YWRkKFBhcmFtLm5ldyhjb3VudCA9PSBpbmRleCAmJiBuYW1lIHx8IFwiX3tjb3VudH1cIikpIHVudGlsIGNvdW50ID4gaW5kZXhcblx0XHRcdCMgbmVlZCB0byB2aXNpdCBhdCB0aGUgc2FtZSB0aW1lLCBubz9cblx0XHRsaXN0W2luZGV4XVxuXG5cdGRlZiBtZXRhZGF0YVxuXHRcdGZpbHRlcih8cGFyfCAhKHBhciBpc2EgTWV0YSkpXG5cblx0ZGVmIHRvSlNPTlxuXHRcdG1ldGFkYXRhXG5cblx0ZGVmIHZpc2l0XG5cdFx0QHNwbGF0ID0gZmlsdGVyKHxwYXJ8IHBhciBpc2EgU3BsYXRQYXJhbSlbMF1cblx0XHR2YXIgYmxrID0gZmlsdGVyKHxwYXJ8IHBhciBpc2EgQmxvY2tQYXJhbSlcblxuXHRcdGlmIGJsazpsZW5ndGggPiAxXG5cdFx0XHRibGtbMV0ud2FybiBcImEgbWV0aG9kIGNhbiBvbmx5IGhhdmUgb25lICZibG9jayBwYXJhbWV0ZXJcIlxuXG5cdFx0ZWxpZiBibGtbMF0gJiYgYmxrWzBdICE9IGxhc3Rcblx0XHRcdGJsa1swXS53YXJuIFwiJmJsb2NrIG11c3QgYmUgdGhlIGxhc3QgcGFyYW1ldGVyIG9mIGEgbWV0aG9kXCJcblx0XHRcdCMgd2FybiBcIiZibG9jayBtdXN0IGJlIHRoZSBsYXN0IHBhcmFtZXRlciBvZiBhIG1ldGhvZFwiLCBibGtbMF1cblxuXHRcdCMgYWRkIG1vcmUgd2FybmluZ3MgbGF0ZXIoISlcblx0XHQjIHNob3VsZCBwcm9iYWJseSB0aHJvdyBlcnJvciBhcyB3ZWxsIHRvIHN0b3AgY29tcGlsYXRpb25cblxuXHRcdCMgbmVlZCB0byByZWdpc3RlciB0aGUgcmVxdWlyZWQtcGFycyBhcyB2YXJpYWJsZXNcblx0XHRzdXBlclxuXG5cdGRlZiBqcyBvXG5cdFx0cmV0dXJuIEVNUFRZIGlmIGNvdW50ID09IDBcblx0XHRyZXR1cm4gaGVhZChvKSBpZiBvLnBhcmVudCBpc2EgQmxvY2tcblxuXHRcdCMgaXRlbXMgPSBtYXAofGFyZ3wgYXJnLm5hbWUuYyApLmNvbXBhY3Rcblx0XHQjIHJldHVybiBudWxsIHVubGVzcyBpdGVtc1swXVxuXG5cdFx0aWYgby5wYXJlbnQgaXNhIENvZGVcblx0XHRcdCMgcmVtb3ZlIHRoZSBzcGxhdCwgZm9yIHN1cmUuLiBuZWVkIHRvIGhhbmRsZSB0aGUgb3RoZXIgaXRlbXMgYXMgd2VsbFxuXHRcdFx0IyB0aGlzIGlzIG1lc3N5IHdpdGggcmVmZXJlbmNlcyB0byBhcmd2YXJzIGV0YyBldGMuIEZpeFxuXHRcdFx0dmFyIHBhcnMgPSBub2Rlc1xuXHRcdFx0IyBwYXJzID0gZmlsdGVyKHxhcmd8IGFyZyAhPSBAc3BsYXQgJiYgIShhcmcgaXNhIEJsb2NrUGFyYW0pKSBpZiBAc3BsYXRcblx0XHRcdHBhcnMgPSBmaWx0ZXIofGFyZ3wgYXJnIGlzYSBSZXF1aXJlZFBhcmFtIG9yIGFyZyBpc2EgT3B0aW9uYWxQYXJhbSkgaWYgQHNwbGF0XG5cdFx0XHRjb21wYWN0X18ocGFycy5tYXAofGFyZ3wgY19fKGFyZy52YXJuYW1lKSApKS5qb2luKFwiLFwiKVxuXHRcdGVsc2Vcblx0XHRcdHRocm93IFwibm90IGltcGxlbWVudGVkIHBhcmFtbGlzdCBqc1wiXG5cdFx0XHRcInRhXCIgKyBjb21wYWN0X18obWFwKHxhcmd8IGFyZy5jICkpLmpvaW4oXCIsXCIpXG5cblx0ZGVmIGhlYWQgb1xuXHRcdHZhciByZWcgPSBbXVxuXHRcdHZhciBvcHQgPSBbXVxuXHRcdHZhciBibGsgPSBudWxsXG5cdFx0dmFyIHNwbGF0ID0gbnVsbFxuXHRcdHZhciBuYW1lZCA9IG51bGxcblx0XHR2YXIgYXJ5cyA9IFtdXG5cdFx0dmFyIHNpZ25hdHVyZSA9IFtdXG5cdFx0dmFyIGlkeCA9IDBcblxuXHRcdG5vZGVzLmZvckVhY2ggZG8gfHBhcixpfFxuXHRcdFx0cGFyLmluZGV4ID0gaWR4XG5cdFx0XHRpZiBwYXIgaXNhIE5hbWVkUGFyYW1zXG5cdFx0XHRcdHNpZ25hdHVyZS5wdXNoKCduYW1lZCcpXG5cdFx0XHRcdG5hbWVkID0gcGFyXG5cdFx0XHRlbGlmIHBhciBpc2EgT3B0aW9uYWxQYXJhbVxuXHRcdFx0XHRzaWduYXR1cmUucHVzaCgnb3B0Jylcblx0XHRcdFx0b3B0LnB1c2gocGFyKVxuXHRcdFx0ZWxpZiBwYXIgaXNhIEJsb2NrUGFyYW1cblx0XHRcdFx0c2lnbmF0dXJlLnB1c2goJ2JsaycpXG5cdFx0XHRcdGJsayA9IHBhclxuXHRcdFx0ZWxpZiBwYXIgaXNhIFNwbGF0UGFyYW1cblx0XHRcdFx0c2lnbmF0dXJlLnB1c2goJ3NwbGF0Jylcblx0XHRcdFx0c3BsYXQgPSBwYXJcblx0XHRcdFx0aWR4IC09IDEgIyB0aGlzIHNob3VsZCByZWFsbHkgYmUgcmVtb3ZlZCBmcm9tIHRoZSBsaXN0LCBubz9cblx0XHRcdGVsaWYgcGFyIGlzYSBBcnJheVBhcmFtc1xuXHRcdFx0XHRhcnlzLnB1c2gocGFyKVxuXHRcdFx0XHRzaWduYXR1cmUucHVzaCgnYXJ5Jylcblx0XHRcdGVsc2Vcblx0XHRcdFx0c2lnbmF0dXJlLnB1c2goJ3JlZycpXG5cdFx0XHRcdHJlZy5wdXNoKHBhcilcblx0XHRcdGlkeCsrXG5cblx0XHRpZiBuYW1lZFxuXHRcdFx0dmFyIG5hbWVkdmFyID0gbmFtZWQudmFyaWFibGVcblxuXHRcdCMgdmFyIG9wdCA9IG5vZGVzLmZpbHRlcih8bnwgbiBpc2EgT3B0aW9uYWxQYXJhbSlcblx0XHQjIHZhciBibGsgPSBub2Rlcy5maWx0ZXIofG58IG4gaXNhIEJsb2NrUGFyYW0pWzBdXG5cdFx0IyB2YXIgc3BsYXQgPSBub2Rlcy5maWx0ZXIofG58IG4gaXNhIFNwbGF0UGFyYW0pWzBdXG5cblx0XHQjIHNpbXBsZSBzaXR1YXRpb24gd2hlcmUgd2Ugc2ltcGx5IHN3aXRjaFxuXHRcdCMgY2FuIHByb2JhYmx5IG9wdGltaXplIGJ5IG5vdCBsb29raW5nIGF0IGFyZ3VtZW50cyBhdCBhbGxcblx0XHR2YXIgYXN0ID0gW11cblx0XHR2YXIgaXNGdW5jID0gZG8gfGpzfCBcInR5cGVvZiB7anN9ID09ICdmdW5jdGlvbidcIlxuXG5cdFx0IyBUaGlzIGlzIGJyb2tlbiB3aGVuIGRlYWxpbmcgd2l0aCBpZnJhbWVzIGFuYyBYU1Mgc2NyaXB0aW5nXG5cdFx0IyBidXQgZm9yIG5vdyBpdCBpcyB0aGUgYmVzdCB0ZXN0IGZvciBhY3R1YWwgYXJndW1lbnRzXG5cdFx0IyBjYW4gYWxzbyBkbyBjb25zdHJ1Y3Rvci5uYW1lID09ICdPYmplY3QnXG5cdFx0dmFyIGlzT2JqID0gZG8gfGpzfCBcIntqc30uY29uc3RydWN0b3IgPT09IE9iamVjdFwiXG5cdFx0dmFyIGlzbnRPYmogPSBkbyB8anN8IFwie2pzfS5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0XCJcblx0XHQjIHNob3VsZCBoYW5kbGUgc29tZSBjb21tb24gY2FzZXMgaW4gYSBjbGVhbmVyIChsZXNzIHZlcmJvc2UpIG1hbm5lclxuXHRcdCMgZG9lcyB0aGlzIHdvcmsgd2l0aCBkZWZhdWx0IHBhcmFtcyBhZnRlciBvcHRpb25hbCBvbmVzPyBJcyB0aGF0IGV2ZW4gd29ydGggYW55dGhpbmc/XG5cdFx0IyB0aGlzIG9ubHkgd29ya3MgaW4gb25lIGRpcmVjdGlvbiBub3csIHVubGlrZSBUdXBsZUFzc2lnblxuXG5cdFx0IyB3ZSBkb250IHJlYWxseSBjaGVjayB0aGUgbGVuZ3RoIGV0YyBub3cgLS0gc28gaXQgaXMgYnVnZ3kgZm9yIGxvdHMgb2YgYXJndW1lbnRzXG5cblx0XHQjIGlmIHdlIGhhdmUgb3B0aW9uYWwgcGFyYW1zIGluIHRoZSByZWd1bGFyIG9yZGVyIGV0YyB3ZSBjYW4gZ28gdGhlIGVhc3kgcm91dGVcblx0XHQjIHNsaWdodGx5IGhhY2t5IG5vdy4gU2hvdWxkIHJlZmFjdG9yIGFsbCBvZiB0aGVzZSB0byB1c2UgdGhlIHNpZ25hdHVyZT9cblx0XHRpZiAhbmFtZWQgJiYgIXNwbGF0ICYmICFibGsgJiYgb3B0Omxlbmd0aCA+IDAgJiYgc2lnbmF0dXJlLmpvaW4oXCIgXCIpLm1hdGNoKC9vcHQkLylcblx0XHRcdGZvciBwYXIsaSBpbiBvcHRcblx0XHRcdFx0YXN0LnB1c2ggXCJpZih7cGFyLm5hbWUuY30gPT09IHVuZGVmaW5lZCkge3Bhci5uYW1lLmN9ID0ge3Bhci5kZWZhdWx0cy5jfVwiXG5cblxuXHRcdGVsaWYgbmFtZWQgJiYgIXNwbGF0ICYmICFibGsgJiYgb3B0Omxlbmd0aCA9PSAwICMgYW5kIG5vIGJsb2NrPyFcblx0XHRcdCMgZGlmZmVyZW50IHNob3J0aGFuZHNcblx0XHRcdCMgaWYgbmFtZWRcblx0XHRcdGFzdC5wdXNoIFwiaWYoIXtuYW1lZHZhci5jfXx8e2lzbnRPYmoobmFtZWR2YXIuYyl9KSB7bmFtZWR2YXIuY30gPSBcXHtcXH1cIlxuXG5cdFx0ZWxpZiBibGsgJiYgb3B0Omxlbmd0aCA9PSAxICYmICFzcGxhdCAmJiAhbmFtZWRcblx0XHRcdHZhciBvcCA9IG9wdFswXVxuXHRcdFx0dmFyIG9wbiA9IG9wLm5hbWUuY1xuXHRcdFx0dmFyIGJuID0gYmxrLm5hbWUuY1xuXHRcdFx0YXN0LnB1c2ggXCJpZih7Ym59PT11bmRlZmluZWQgJiYge2lzRnVuYyhvcG4pfSkge2JufSA9IHtvcG59LHtvcG59ID0ge29wLmRlZmF1bHRzLmN9XCJcblx0XHRcdGFzdC5wdXNoIFwiaWYoe29wbn09PXVuZGVmaW5lZCkge29wbn0gPSB7b3AuZGVmYXVsdHMuY31cIlxuXG5cdFx0ZWxpZiBibGsgJiYgbmFtZWQgJiYgb3B0Omxlbmd0aCA9PSAwICYmICFzcGxhdFxuXHRcdFx0dmFyIGJuID0gYmxrLm5hbWUuY1xuXHRcdFx0YXN0LnB1c2ggXCJpZih7Ym59PT11bmRlZmluZWQgJiYge2lzRnVuYyhuYW1lZHZhci5jKX0pIHtibn0gPSB7bmFtZWR2YXIuY30se25hbWVkdmFyLmN9ID0gXFx7XFx9XCJcblx0XHRcdGFzdC5wdXNoIFwiZWxzZSBpZighe25hbWVkdmFyLmN9fHx7aXNudE9iaihuYW1lZHZhci5jKX0pIHtuYW1lZHZhci5jfSA9IFxce1xcfVwiXG5cblx0XHRlbGlmIG9wdDpsZW5ndGggPiAwIHx8IHNwbGF0ICMgJiYgYmxrICAjICYmICFzcGxhdFxuXG5cdFx0XHR2YXIgYXJndmFyID0gc2NvcGVfXy50ZW1wb3Jhcnkoc2VsZiwgcG9vbDogJ2FyZ3VtZW50cycpLnByZWRlY2xhcmVkLmNcblx0XHRcdHZhciBsZW4gPSBzY29wZV9fLnRlbXBvcmFyeShzZWxmLCBwb29sOiAnY291bnRlcicpLnByZWRlY2xhcmVkLmNcblxuXHRcdFx0dmFyIGxhc3QgPSBcInthcmd2YXJ9W3tsZW59LTFdXCJcblx0XHRcdHZhciBwb3AgPSBcInthcmd2YXJ9Wy0te2xlbn1dXCJcblx0XHRcdGFzdC5wdXNoIFwidmFyIHthcmd2YXJ9ID0gYXJndW1lbnRzLCB7bGVufSA9IHthcmd2YXJ9Lmxlbmd0aFwiXG5cblx0XHRcdGlmIGJsa1xuXHRcdFx0XHR2YXIgYm4gPSBibGsubmFtZS5jXG5cdFx0XHRcdGlmIHNwbGF0XG5cdFx0XHRcdFx0YXN0LnB1c2ggXCJ2YXIge2JufSA9IHtpc0Z1bmMobGFzdCl9ID8ge3BvcH0gOiBudWxsXCJcblx0XHRcdFx0ZWxpZiByZWc6bGVuZ3RoID4gMFxuXHRcdFx0XHRcdCMgYXN0LnB1c2ggXCIvLyBzZXZlcmFsIHJlZ3MgcmVhbGx5P1wiXG5cdFx0XHRcdFx0YXN0LnB1c2ggXCJ2YXIge2JufSA9IHtsZW59ID4ge3JlZzpsZW5ndGh9ICYmIHtpc0Z1bmMobGFzdCl9ID8ge3BvcH0gOiBudWxsXCJcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGFzdC5wdXNoIFwidmFyIHtibn0gPSB7aXNGdW5jKGxhc3QpfSA/IHtwb3B9IDogbnVsbFwiXG5cblx0XHRcdCMgaWYgd2UgaGF2ZSBuYW1lZCBwYXJhbXMgLSBsb29rIGZvciB0aGVtIGJlZm9yZSBzcGxhdFxuXHRcdFx0IyBzaG91bGQgcHJvYmFibHkgbG9vcCB0aHJvdWdoIHBhcnMgaW4gdGhlIHNhbWUgb3JkZXIgdGhleSB3ZXJlIGFkZGVkXG5cdFx0XHQjIHNob3VsZCBpdCBiZSBwcmlvcml0aXplZCBhYm92ZSBvcHRpb25hbCBvYmplY3RzPz9cblx0XHRcdGlmIG5hbWVkXG5cdFx0XHRcdCMgc2hvdWxkIG5vdCBpbmNsdWRlIGl0IHdoZW4gdGhlcmUgaXMgYSBzcGxhdD9cblx0XHRcdFx0YXN0LnB1c2ggXCJ2YXIge25hbWVkdmFyLmN9ID0ge2xhc3R9JiZ7aXNPYmoobGFzdCl9ID8ge3BvcH0gOiBcXHtcXH1cIlxuXG5cdFx0XHRmb3IgcGFyLGkgaW4gb3B0XG5cdFx0XHRcdGFzdC5wdXNoIFwiaWYoe2xlbn0gPCB7cGFyLmluZGV4ICsgMX0pIHtwYXIubmFtZS5jfSA9IHtwYXIuZGVmYXVsdHMuY31cIlxuXG5cdFx0XHQjIGFkZCB0aGUgc3BsYXRcblx0XHRcdGlmIHNwbGF0XG5cdFx0XHRcdHZhciBzbiA9IHNwbGF0Lm5hbWUuY1xuXHRcdFx0XHR2YXIgc2kgPSBzcGxhdC5pbmRleFxuXG5cdFx0XHRcdGlmIHNpID09IDBcblx0XHRcdFx0XHRhc3QucHVzaCBcInZhciB7c259ID0gbmV3IEFycmF5KHtsZW59PntzaX0gPyB7bGVufSA6IDApXCJcblx0XHRcdFx0XHRhc3QucHVzaCBcIndoaWxlKHtsZW59PntzaX0pIHtzbn1be2xlbn0tMV0gPSB7cG9wfVwiXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRhc3QucHVzaCBcInZhciB7c259ID0gbmV3IEFycmF5KHtsZW59PntzaX0gPyB7bGVufS17c2l9IDogMClcIlxuXHRcdFx0XHRcdGFzdC5wdXNoIFwid2hpbGUoe2xlbn0+e3NpfSkge3NufVstLXtsZW59IC0ge3NpfV0gPSB7YXJndmFyfVt7bGVufV1cIlxuXG5cdFx0XHQjIGlmIG5hbWVkXG5cdFx0XHQjIFx0Zm9yIGssaSBpbiBuYW1lZC5ub2Rlc1xuXHRcdFx0IyBcdFx0IyBPUCgnLicsbmFtZWR2YXIpIDwtIHRoaXMgaXMgdGhlIHJpZ2h0IHdheSwgd2l0aCBpbnZhbGlkIG5hbWVzIGV0Y1xuXHRcdFx0IyBcdFx0dmFyIG9wID0gT1AoJy4nLG5hbWVkdmFyLGsua2V5KS5jXG5cdFx0XHQjIFx0XHRhc3QucHVzaCBcInZhciB7ay5rZXkuY30gPSB7b3B9ICE9PSB1bmRlZmluZWQgPyB7b3B9IDoge2sudmFsdWUuY31cIlxuXG5cdFx0XHQjIGlmIG5hbWVkXG5cblx0XHRcdCMgcmV0dXJuIGFzdC5qb2luKFwiO1xcblwiKSArIFwiO1wiXG5cdFx0XHQjIHJldHVybiBcImlmKHtvcHRbMF0ubmFtZS5jfSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7YmxrLmN9ID0ge29wdFswXS5jfTtcIlxuXG5cblx0XHRlbGlmIG9wdDpsZW5ndGggPiAwXG5cdFx0XHRmb3IgcGFyLGkgaW4gb3B0XG5cdFx0XHRcdGFzdC5wdXNoIFwiaWYoe3Bhci5uYW1lLmN9ID09PSB1bmRlZmluZWQpIHtwYXIubmFtZS5jfSA9IHtwYXIuZGVmYXVsdHMuY31cIlxuXG5cdFx0IyBub3cgc2V0IHN0dWZmIGlmIG5hbWVkIHBhcmFtcyghKVxuXG5cdFx0aWYgbmFtZWRcblx0XHRcdGZvciBrLGkgaW4gbmFtZWQubm9kZXNcblx0XHRcdFx0IyBjb25zb2xlLmxvZyBcIm5hbWVkIHZhciB7ay5jfVwiXG5cdFx0XHRcdHZhciBvcCA9IE9QKCcuJyxuYW1lZHZhcixrLmMpLmNcblx0XHRcdFx0YXN0LnB1c2ggXCJ2YXIge2suY30gPSB7b3B9ICE9PSB1bmRlZmluZWQgPyB7b3B9IDoge2suZGVmYXVsdHMuY31cIlxuXG5cdFx0aWYgYXJ5czpsZW5ndGhcblx0XHRcdGZvciB2LGkgaW4gYXJ5c1xuXHRcdFx0XHQjIGNyZWF0ZSB0dXBsZXNcblx0XHRcdFx0di5oZWFkKG8sYXN0LHNlbGYpXG5cdFx0XHRcdCMgYXN0LnB1c2ggdi5jXG5cblxuXG5cdFx0IyBpZiBvcHQ6bGVuZ3RoID09IDBcblx0XHRyZXR1cm4gYXN0Omxlbmd0aCA+IDAgPyAoYXN0LmpvaW4oXCI7XFxuXCIpICsgXCI7XCIpIDogRU1QVFlcblxuXG4jIExlZ2FjeS4gU2hvdWxkIG1vdmUgYXdheSBmcm9tIHRoaXM/XG5leHBvcnQgY2xhc3MgVmFyaWFibGVEZWNsYXJhdGlvbiA8IExpc3ROb2RlXG5cblx0IyBmb3IgbGF0ZXIsIG1vei1hc3Qgc3R5bGVcblx0cHJvcCBraW5kXG5cblx0IyB3ZSB3YW50IHRvIHJlZ2lzdGVyIHRoZXNlIHZhcmlhYmxlcyBpblxuXHRkZWYgYWRkIG5hbWUsIGluaXQsIHBvcyA9IC0xXG5cdFx0dmFyIHZhcmRlYyA9IFZhcmlhYmxlRGVjbGFyYXRvci5uZXcobmFtZSxpbml0KVxuXHRcdHZhcmRlYy52YXJpYWJsZSA9IG5hbWUgaWYgbmFtZSBpc2EgVmFyaWFibGVcblx0XHRwb3MgPT0gMCA/IHVuc2hpZnQodmFyZGVjKSA6IHB1c2godmFyZGVjKVxuXHRcdHZhcmRlY1xuXG5cdGRlZiBsb2FkIGxpc3Rcblx0XHQjIHRlbXBvcmFyeSBzb2x1dGlvbiEhIVxuXHRcdGxpc3QubWFwIGRvIHxwYXJ8IFZhcmlhYmxlRGVjbGFyYXRvci5uZXcocGFyLm5hbWUscGFyLmRlZmF1bHRzLHBhci5zcGxhdClcblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdG5vZGVzLmV2ZXJ5KHxpdGVtfCBpdGVtLmlzRXhwcmVzc2FibGUpXG5cblx0ZGVmIGpzIG9cblx0XHRyZXR1cm4gRU1QVFkgaWYgY291bnQgPT0gMFxuXG5cdFx0aWYgY291bnQgPT0gMSAmJiAhaXNFeHByZXNzYWJsZVxuXHRcdFx0Zmlyc3QudmFyaWFibGUuYXV0b2RlY2xhcmVcblx0XHRcdHZhciBub2RlID0gZmlyc3QuYXNzaWdubWVudFxuXHRcdFx0cmV0dXJuIG5vZGUuY1xuXG5cdFx0IyBGSVggUEVSRk9STUFOQ0Vcblx0XHR2YXIgb3V0ID0gY29tcGFjdF9fKGNhcnlfXyhub2RlcykpLmpvaW4oXCIsIFwiKVxuXHRcdG91dCA/IFwidmFyIHtvdXR9XCIgOiBcIlwiXG5cbmV4cG9ydCBjbGFzcyBWYXJpYWJsZURlY2xhcmF0b3IgPCBQYXJhbVxuXG5cdCMgY2FuIHBvc3NpYmx5IGNyZWF0ZSB0aGUgdmFyaWFibGUgaW1tZWRpYXRlbHkgYnV0IHdhaXQgd2l0aCBzY29wZS1kZWNsYXJpbmdcblx0IyBXaGF0IGlmIHRoaXMgaXMgbWVyZWx5IHRoZSBkZWNsYXJhdGlvbiBvZiBhIHN5c3RlbS90ZW1wb3JhcnkgdmFyaWFibGU/XG5cdGRlZiB2aXNpdFxuXHRcdCMgZXZlbiBpZiB3ZSBzaG91bGQgdHJhdmVyc2UgdGhlIGRlZmF1bHRzIGFzIGlmIHRoaXMgdmFyaWFibGUgZG9lcyBub3QgZXhpc3Rcblx0XHQjIHdlIG5lZWQgdG8gcHJlcmVnaXN0ZXIgaXQgYW5kIHRoZW4gYWN0aXZhdGUgaXQgbGF0ZXJcblx0XHRzZWxmLnZhcmlhYmxlIHx8PSBzY29wZV9fLnJlZ2lzdGVyKG5hbWUsbnVsbClcblx0XHRkZWZhdWx0cy50cmF2ZXJzZSBpZiBkZWZhdWx0c1xuXHRcdCMgV0FSTiB3aGF0IGlmIGl0IGlzIGFscmVhZHkgZGVjbGFyZWQ/XG5cdFx0c2VsZi52YXJpYWJsZS5kZWNsYXJhdG9yID0gc2VsZlxuXHRcdHNlbGYudmFyaWFibGUuYWRkUmVmZXJlbmNlKG5hbWUpXG5cdFx0c2VsZlxuXG5cdCMgbmVlZHMgdG8gYmUgbGlua2VkIHVwIHRvIHRoZSBhY3R1YWwgc2NvcGVkIHZhcmlhYmxlcywgbm8/XG5cdGRlZiBqcyBvXG5cdFx0cmV0dXJuIG51bGwgaWYgdmFyaWFibGUuQHByb3h5XG5cblx0XHR2YXIgZGVmcyA9IGRlZmF1bHRzXG5cdFx0IyBGSVhNRSBuZWVkIHRvIGRlYWwgd2l0aCB2YXItZGVmaW5lcyB3aXRoaW4gb3RoZXIgc3RhdGVtZW50cyBldGNcblx0XHQjIEZJWE1FIG5lZWQgYmV0dGVyIHN5bnRheCBmb3IgdGhpc1xuXHRcdGlmIGRlZnMgIT0gbnVsbCAmJiBkZWZzICE9IHVuZGVmaW5lZFxuXHRcdFx0IyBjb25zb2xlLmxvZyBcImRlZmF1bHRzIGlzIHtkZWZhdWx0c31cIlxuXHRcdFx0ZGVmcyA9IGRlZnMuYyhleHByZXNzaW9uOiB5ZXMpIGlmIGRlZnMgaXNhIE5vZGVcblxuXHRcdFx0XCJ7dmFyaWFibGUuY30gPSB7ZGVmc31cIlxuXHRcdGVsc2Vcblx0XHRcdFwie3ZhcmlhYmxlLmN9XCJcblxuXHRkZWYgYWNjZXNzb3Jcblx0XHRzZWxmXG5cblxuIyBUT0RPIGNsZWFuIHVwIGFuZCByZWZhY3RvciBhbGwgdGhlIGRpZmZlcmVudCByZXByZXNlbnRhdGlvbnMgb2YgdmFyc1xuIyBWYXJOYW1lLCBWYXJSZWZlcmVuY2UsIExvY2FsVmFyQWNjZXNzP1xuZXhwb3J0IGNsYXNzIFZhck5hbWUgPCBWYWx1ZU5vZGVcblxuXHRwcm9wIHZhcmlhYmxlXG5cdHByb3Agc3BsYXRcblxuXHRkZWYgaW5pdGlhbGl6ZSBhLGJcblx0XHRzdXBlclxuXHRcdEBzcGxhdCA9IGJcblxuXHRkZWYgdmlzaXRcblx0XHQjIHNob3VsZCB3ZSBub3QgbG9va3VwIGluc3RlYWQ/XG5cdFx0IyBGSVhNRSBwIFwicmVnaXN0ZXIgdmFsdWUge3ZhbHVlLmN9XCJcblx0XHRzZWxmLnZhcmlhYmxlIHx8PSBzY29wZV9fLnJlZ2lzdGVyKHZhbHVlLmMsbnVsbClcblx0XHRzZWxmLnZhcmlhYmxlLmRlY2xhcmF0b3IgPSBzZWxmXG5cdFx0c2VsZi52YXJpYWJsZS5hZGRSZWZlcmVuY2UodmFsdWUpXG5cdFx0c2VsZlxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyaWFibGUuY1xuXG5cdGRlZiBjXG5cdFx0dmFyaWFibGUuY1xuXG5cbmV4cG9ydCBjbGFzcyBWYXJMaXN0IDwgTm9kZVxuXG5cdHByb3AgdHlwZSAjIGxldCAvIHZhciAvIGNvbnN0XG5cdHByb3AgbGVmdFxuXHRwcm9wIHJpZ2h0XG5cblx0IyBmb3JtYXQgOnR5cGUsIDpsZWZ0LCA6cmlnaHRcblxuXHQjIHNob3VsZCB0aHJvdyBlcnJvciBpZiB0aGVyZSBhcmUgbW9yZSB2YWx1ZXMgb24gcmlnaHQgdGhhbiBsZWZ0XG5cblx0ZGVmIGluaXRpYWxpemUgdCxsLHJcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAdHlwZSA9IHR5cGVcblx0XHRAbGVmdCA9IGxcblx0XHRAcmlnaHQgPSByXG5cblx0ZGVmIHZpc2l0XG5cblx0XHQjIHdlIG5lZWQgdG8gY2FyZWZ1bGx5IHRyYXZlcnNlIGNoaWxkcmVuIGluIHRoZSByaWdodCBvcmRlclxuXHRcdCMgc2luY2Ugd2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVmZXJlbmNlXG5cdFx0Zm9yIGwsaSBpbiBsZWZ0XG5cdFx0XHRsLnRyYXZlcnNlICMgdGhpcyBzaG91bGQgcmVhbGx5IGJlIGEgdmFyLWRlY2xhcmF0aW9uXG5cdFx0XHRyLnRyYXZlcnNlIGlmIHZhciByID0gcmlnaHRbaV1cblx0XHRzZWxmXG5cblx0ZGVmIGpzIG9cblx0XHQjIGZvciB0aGUgcmVndWxhciBpdGVtc1xuXHRcdHZhciBwYWlycyA9IFtdXG5cdFx0dmFyIGxsID0gbGVmdDpsZW5ndGhcblx0XHR2YXIgcmwgPSByaWdodDpsZW5ndGhcblx0XHR2YXIgdiA9IG51bGxcblxuXHRcdCMgc3BsYXR0aW5nIGhlcmUgd2UgY29tZVxuXHRcdGlmIGxsID4gMSAmJiBybCA9PSAxXG5cdFx0XHRwIFwibXVsdGlhc3NpZ24hXCJcblx0XHRcdHZhciByID0gcmlnaHRbMF1cblx0XHRcdHIuY2FjaGVcblx0XHRcdGZvciBsLGkgaW4gbGVmdFxuXHRcdFx0XHRpZiBsLnNwbGF0XG5cdFx0XHRcdFx0dGhyb3cgXCJub3Qgc3VwcG9ydGVkP1wiXG5cdFx0XHRcdFx0cCBcInNwbGF0XCIgIyBGSVggcmVpbXBsZW1lbnQgc2xpY2U/XG5cdFx0XHRcdFx0aWYgaSA9PSBsbCAtIDFcblx0XHRcdFx0XHRcdHYgPSB1dGlsLnNsaWNlKHIsaSlcblx0XHRcdFx0XHRcdHAgXCJsYXN0XCJcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHR2ID0gdXRpbC5zbGljZShyLGksLShsbCAtIGkpICsgMSlcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHYgPSBPUCgnLicscixudW1fXyhpKSlcblxuXHRcdFx0XHRwYWlycy5wdXNoKE9QKCc9JyxsLHYpKVxuXG5cdFx0ZWxzZVxuXHRcdFx0Zm9yIGwsaSBpbiBsZWZ0XG5cdFx0XHRcdHZhciByID0gcmlnaHRbaV1cblx0XHRcdFx0cGFpcnMucHVzaChyID8gT1AoJz0nLGwudmFyaWFibGUuYWNjZXNzb3IscikgOiBsKVxuXG5cdFx0cmV0dXJuIFwidmFyIHtwYWlycy5jfVwiXG5cblxuIyBDT0RFXG5cbmV4cG9ydCBjbGFzcyBDb2RlIDwgTm9kZVxuXG5cdHByb3AgaGVhZFxuXHRwcm9wIGJvZHlcblx0cHJvcCBzY29wZVxuXHRwcm9wIHBhcmFtc1xuXG5cdGRlZiBzY29wZXR5cGVcblx0XHRTY29wZVxuXG5cdGRlZiB2aXNpdFxuXHRcdEBzY29wZS52aXNpdCBpZiBAc2NvcGVcblx0XHQjIEBzY29wZS5wYXJlbnQgPSBTVEFDSy5zY29wZSgxKSBpZiBAc2NvcGVcblx0XHRzZWxmXG5cblxuIyBSZW5hbWUgdG8gUHJvZ3JhbT9cbmV4cG9ydCBjbGFzcyBSb290IDwgQ29kZVxuXG5cdGRlZiBpbml0aWFsaXplIGJvZHksIG9wdHNcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAYm9keSA9IGJsa19fKGJvZHkpXG5cdFx0QHNjb3BlID0gUm9vdFNjb3BlLm5ldyhzZWxmLG51bGwpXG5cdFx0QG9wdGlvbnMgPSB7fVxuXG5cdGRlZiBsb2Ncblx0XHRAYm9keS5sb2NcblxuXHRkZWYgdmlzaXRcblx0XHRST09UID0gU1RBQ0suUk9PVCA9IEBzY29wZVxuXHRcdHNjb3BlLnZpc2l0XG5cdFx0Ym9keS50cmF2ZXJzZVxuXG5cdGRlZiBjb21waWxlIG9cblx0XHRTVEFDSy5yZXNldCAjIC0tIG5lc3RlZCBjb21waWxhdGlvbiBkb2VzIG5vdCB3b3JrIG5vd1xuXHRcdE9QVFMgPSBTVEFDSy5Ab3B0aW9ucyA9IEBvcHRpb25zID0gbyBvciB7fVxuXG5cdFx0dHJhdmVyc2VcblxuXHRcdHZhciBvdXQgPSBjXG5cdFx0dmFyIHJlc3VsdCA9IHtcblx0XHRcdGpzOiBvdXQsXG5cdFx0XHRhc3Q6IHNlbGYsXG5cdFx0XHR3YXJuaW5nczogc2NvcGUud2FybmluZ3MsXG5cdFx0XHRvcHRpb25zOiBvLFxuXHRcdFx0dG9TdHJpbmc6IChkbyB0aGlzOmpzKVxuXHRcdH1cblx0XHRpZiBvOnNvdXJjZU1hcElubGluZSBvciBvOnNvdXJjZU1hcFxuXHRcdFx0cmVzdWx0OnNvdXJjZW1hcCA9IFNvdXJjZU1hcC5uZXcocmVzdWx0KS5nZW5lcmF0ZVxuXG5cdFx0cmV0dXJuIHJlc3VsdFxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIG91dFxuXHRcdHVubGVzcyBAb3B0aW9uczp3cmFwXG5cdFx0XHRvdXQgPSBzY29wZS5jXG5cdFx0ZWxzZVxuXHRcdFx0Ym9keS5jb25zdW1lKEltcGxpY2l0UmV0dXJuLm5ldylcblx0XHRcdG91dCA9IHNjb3BlLmMoaW5kZW50OiB5ZXMpXG5cdFx0XHRvdXQgPSBvdXQucmVwbGFjZSgvXlxcbj8vLCdcXG4nKVxuXHRcdFx0b3V0ID0gb3V0LnJlcGxhY2UoL1xcbj8kLywnXFxuXFxuJylcblx0XHRcdG91dCA9ICcoZnVuY3Rpb24oKXsnICsgb3V0ICsgJ30pKCk7J1xuXG5cdFx0IyBmaW5kIGFuZCByZXBsYWNlIHNoZWJhbmdzXG5cdFx0dmFyIHNoZWJhbmdzID0gW11cblx0XHRvdXQgPSBvdXQucmVwbGFjZSgvXlsgXFx0XSpcXC9cXC8oXFwhLispJC9tZykgZG8gfG0sc2hlYmFuZ3xcblx0XHRcdHNoZWJhbmcgPSBzaGViYW5nLnJlcGxhY2UoL1xcYmltYmFcXGIvZywnbm9kZScpXG5cdFx0XHRzaGViYW5ncy5wdXNoKFwiI3tzaGViYW5nfVxcblwiKVxuXHRcdFx0cmV0dXJuIFwiXCJcblxuXHRcdG91dCA9IHNoZWJhbmdzLmpvaW4oJycpICsgb3V0XG5cblx0XHRyZXR1cm4gb3V0XG5cblxuXHRkZWYgYW5hbHl6ZSBvID0ge31cblx0XHQjIGxvZ2xldmVsOiAwLCBlbnRpdGllczogbm8sIHNjb3BlczogeWVzXG5cdFx0U1RBQ0subG9nbGV2ZWwgPSBvOmxvZ2xldmVsIG9yIDBcblx0XHRTVEFDSy5AYW5hbHl6aW5nID0gdHJ1ZVxuXHRcdFJPT1QgPSBTVEFDSy5ST09UID0gQHNjb3BlXG5cdFx0T1BUUyA9IFNUQUNLLkBvcHRpb25zID0ge1xuXHRcdFx0dGFyZ2V0OiBvOnRhcmdldFxuXHRcdFx0bG9nbGV2ZWw6IG86bG9nbGV2ZWwgb3IgMFxuXHRcdFx0YW5hbHlzaXM6IHtcblx0XHRcdFx0ZW50aXRpZXM6IChvOmVudGl0aWVzIG9yIG5vKSxcblx0XHRcdFx0c2NvcGVzOiAobzpzY29wZXMgPz0geWVzKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRyYXZlcnNlXG5cdFx0U1RBQ0suQGFuYWx5emluZyA9IGZhbHNlXG5cblx0XHRyZXR1cm4gc2NvcGUuZHVtcFxuXG5cdGRlZiBpbnNwZWN0XG5cdFx0dHJ1ZVxuXG5leHBvcnQgY2xhc3MgQ2xhc3NEZWNsYXJhdGlvbiA8IENvZGVcblxuXHRwcm9wIG5hbWVcblx0cHJvcCBzdXBlcmNsYXNzXG5cdHByb3AgaW5pdG9yXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdGlmIG5vZGUgaXNhIFJldHVyblxuXHRcdFx0b3B0aW9uKCdyZXR1cm4nLHllcylcblx0XHRcdHJldHVybiBzZWxmXG5cdFx0c3VwZXJcblxuXHRkZWYgbmFtZXBhdGhcblx0XHRAbmFtZXBhdGggfHw9IFwie25hbWUuY31cIlxuXG5cdGRlZiBtZXRhZGF0YVxuXHRcdHtcblx0XHRcdHR5cGU6ICdjbGFzcydcblx0XHRcdG5hbWVwYXRoOiBuYW1lcGF0aFxuXHRcdFx0aW5oZXJpdHM6IHN1cGVyY2xhc3M/Lm5hbWVwYXRoXG5cdFx0XHRwYXRoOiBuYW1lLmMudG9TdHJpbmdcblx0XHRcdGRlc2M6IEBkZXNjXG5cdFx0XHRsb2M6IGxvY1xuXHRcdH1cblxuXHRkZWYgdG9KU09OXG5cdFx0bWV0YWRhdGFcblxuXHRkZWYgaW5pdGlhbGl6ZSBuYW1lLCBzdXBlcmNsYXNzLCBib2R5XG5cdFx0IyB3aGF0IGFib3V0IHRoZSBuYW1lc3BhY2U/XG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QG5hbWUgPSBuYW1lXG5cdFx0QHN1cGVyY2xhc3MgPSBzdXBlcmNsYXNzXG5cdFx0QHNjb3BlID0gQ2xhc3NTY29wZS5uZXcoc2VsZilcblx0XHRAYm9keSA9IGJsa19fKGJvZHkpXG5cdFx0c2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcdCMgcmVwbGFjZSB3aXRoIHNvbWUgYWR2YW5jZWQgbG9va3VwP1xuXHRcdFJPT1QuZW50aXRpZXMuYWRkKG5hbWVwYXRoLHNlbGYpXG5cdFx0c2NvcGUudmlzaXRcblx0XHRib2R5LnRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cdGRlZiBqcyBvXG5cdFx0c2NvcGUudmlydHVhbGl6ZSAjIGlzIHRoaXMgYWx3YXlzIG5lZWRlZD9cblx0XHRzY29wZS5jb250ZXh0LnZhbHVlID0gbmFtZVxuXHRcdHNjb3BlLmNvbnRleHQucmVmZXJlbmNlID0gbmFtZVxuXHRcdCMgc2hvdWxkIHByb2JhYmx5IGFsc28gd2FybiBhYm91dCBzdHVmZiBldGNcblx0XHRpZiBvcHRpb24oOmV4dGVuc2lvbilcblx0XHRcdHJldHVybiBib2R5LmNcblxuXHRcdHZhciBoZWFkID0gW11cblx0XHR2YXIgbyA9IEBvcHRpb25zIG9yIHt9XG5cdFx0dmFyIGNuYW1lID0gbmFtZSBpc2EgQWNjZXNzID8gbmFtZS5yaWdodCA6IG5hbWVcblx0XHR2YXIgbmFtZXNwYWNlZCA9IG5hbWUgIT0gY25hbWVcblx0XHR2YXIgaW5pdG9yID0gbnVsbFxuXHRcdHZhciBzdXAgPSBzdXBlcmNsYXNzXG5cblx0XHR2YXIgYm9keWluZGV4ID0gLTFcblx0XHR2YXIgc3BhY2VzID0gYm9keS5maWx0ZXIgZG8gfGl0ZW18IGl0ZW0gaXNhIFRlcm1pbmF0b3Jcblx0XHR2YXIgbWFyayA9IG1hcmtfXyhvcHRpb24oJ2tleXdvcmQnKSlcblxuXHRcdGJvZHkubWFwIGRvIHxjLGl8XG5cdFx0XHRpZiBjIGlzYSBNZXRob2REZWNsYXJhdGlvbiAmJiBjLnR5cGUgPT0gOmNvbnN0cnVjdG9yXG5cdFx0XHRcdGJvZHlpbmRleCA9IGlcblxuXHRcdGlmIGJvZHlpbmRleCA+PSAwXG5cdFx0XHRpbml0b3IgPSBib2R5LnJlbW92ZUF0KGJvZHlpbmRleClcblxuXHRcdCMgdmFyIGluaXRvciA9IGJvZHkucGx1Y2sgZG8gfGN8IGMgaXNhIE1ldGhvZERlY2xhcmF0aW9uICYmIGMudHlwZSA9PSA6Y29uc3RydWN0b3Jcblx0XHQjIGNvbXBpbGUgdGhlIGNuYW1lXG5cdFx0Y25hbWUgPSBjbmFtZS5jIHVubGVzcyB0eXBlb2YgY25hbWUgPT0gJ3N0cmluZydcblxuXHRcdHZhciBjcGF0aCA9IHR5cGVvZiBuYW1lICA9PSAnc3RyaW5nJyA/IG5hbWUgOiBuYW1lLmNcblxuXHRcdEBjbmFtZSA9IGNuYW1lXG5cdFx0QGNwYXRoID0gY3BhdGhcblxuXHRcdGlmICFpbml0b3Jcblx0XHRcdGlmIHN1cFxuXHRcdFx0XHRpbml0b3IgPSBcInttYXJrfWZ1bmN0aW9uIHtjbmFtZX0oKVxceyByZXR1cm4ge3N1cC5jfS5hcHBseSh0aGlzLGFyZ3VtZW50cykgXFx9O1xcblxcblwiXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGluaXRvciA9IFwie21hcmt9ZnVuY3Rpb24ge2NuYW1lfSgpXCIgKyAneyB9O1xcblxcbidcblxuXHRcdGVsc2Vcblx0XHRcdGluaXRvci5uYW1lID0gY25hbWVcblx0XHRcdGluaXRvciA9IGluaXRvci5jICsgJzsnXG5cblx0XHQjIGlmIHdlIGFyZSBkZWZpbmluZyBhIGNsYXNzIGluc2lkZSBhIG5hbWVzcGFjZSBldGMgLS0gaG93IHNob3VsZCB3ZSBzZXQgdXAgdGhlIGNsYXNzP1xuXG5cdFx0aWYgbmFtZXNwYWNlZFxuXHRcdFx0IyBzaG91bGQgdXNlIE5vZGVzIHRvIGJ1aWxkIHRoaXMgaW5zdGVhZFxuXHRcdFx0aW5pdG9yID0gXCJ7Y3BhdGh9ID0ge2luaXRvcn1cIiAjIE9QKCc9JyxuYW1lLGluaXRvcilcblxuXHRcdGhlYWQucHVzaChpbml0b3IpICMgLy8gQGNsYXNzIHtjbmFtZX1cXG5cblxuXHRcdGlmIGJvZHlpbmRleCA+PSAwXG5cdFx0XHQjIGFkZCB0aGUgc3BhY2UgYWZ0ZXIgaW5pdG9yP1xuXHRcdFx0aWYgYm9keS5pbmRleChib2R5aW5kZXgpIGlzYSBUZXJtaW5hdG9yXG5cdFx0XHRcdGhlYWQucHVzaChib2R5LnJlbW92ZUF0KGJvZHlpbmRleCkpXG5cdFx0ZWxzZVxuXHRcdFx0IyBoZWFkLnB1c2goVGVybWluYXRvci5uZXcoJ1xcblxcbicpKVxuXHRcdFx0dHJ1ZVxuXG5cdFx0aWYgc3VwXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwiZGVhbCB3aXRoIHN1cGVyY2xhc3MhXCJcblx0XHRcdCMgaGVhZC5wdXNoKFwiLy8gZXh0ZW5kaW5nIHRoZSBzdXBlcmNsYXNzXFxuaW1iYSRjbGFzcyh7bmFtZS5jfSx7c3VwLmN9KTtcXG5cXG5cIilcblx0XHRcdGhlYWQucHVzaChVdGlsLlN1YmNsYXNzLm5ldyhbbmFtZSxzdXBdKSlcblxuXHRcdCMgb25seSBpZiBpdCBpcyBub3QgbmFtZXNwYWNlZFxuXHRcdGlmIG86Z2xvYmFsIGFuZCAhbmFtZXNwYWNlZCAjIG9wdGlvbig6Z2xvYmFsKVxuXHRcdFx0bGV0IGdsb2JhbE5hbWUgPSBTVEFDSy5wbGF0Zm9ybSA9PSAnd2ViJyA/IFwid2luZG93XCIgOiBcImdsb2JhbFwiXG5cdFx0XHRoZWFkLnB1c2goXCJ7Z2xvYmFsTmFtZX0ue2NuYW1lfSA9IHtjcGF0aH07IC8vIGdsb2JhbCBjbGFzcyBcXG5cIilcblxuXHRcdGlmIG86ZXhwb3J0IGFuZCAhbmFtZXNwYWNlZFxuXHRcdFx0aGVhZC5wdXNoKFwiZXhwb3J0cy57bzpkZWZhdWx0ID8gJ2RlZmF1bHQnIDogY25hbWV9ID0ge2NwYXRofTsgLy8gZXhwb3J0IGNsYXNzIFxcblwiKVxuXG5cdFx0IyBGSVhNRVxuXHRcdCMgaWYgbmFtZXNwYWNlZCBhbmQgKG86bG9jYWwgb3IgbzpleHBvcnQpXG5cdFx0IyBcdGNvbnNvbGUubG9nIFwibmFtZXNwYWNlZCBjbGFzc2VzIGFyZSBpbXBsaWNpdGx5IGxvY2FsL2dsb2JhbCBkZXBlbmRpbmcgb24gdGhlIG5hbWVzcGFjZVwiXG5cblx0XHRpZiBvcHRpb24oJ3JldHVybicpXG5cdFx0XHRib2R5LnB1c2goXCJyZXR1cm4ge2NwYXRofTtcIilcblxuXHRcdGJvZHkudW5zaGlmdChwYXJ0KSBmb3IgcGFydCBpbiBoZWFkLnJldmVyc2Vcblx0XHRib2R5LkBpbmRlbnRhdGlvbiA9IG51bGxcblx0XHR2YXIgZW5kID0gYm9keS5pbmRleChib2R5LmNvdW50IC0gMSlcblx0XHRib2R5LnBvcCBpZiBlbmQgaXNhIFRlcm1pbmF0b3IgYW5kIGVuZC5jOmxlbmd0aCA9PSAxXG5cblx0XHR2YXIgb3V0ID0gYm9keS5jXG5cblx0XHRyZXR1cm4gb3V0XG5cblxuZXhwb3J0IGNsYXNzIFRhZ0RlY2xhcmF0aW9uIDwgQ29kZVxuXG5cdHByb3AgbmFtZVxuXHRwcm9wIHN1cGVyY2xhc3Ncblx0cHJvcCBpbml0b3JcblxuXHRkZWYgbmFtZXBhdGhcblx0XHRcIjx7bmFtZX0+XCJcblxuXHRkZWYgdG9KU09OXG5cdFx0e1xuXHRcdFx0dHlwZTogJ3RhZydcblx0XHRcdG5hbWVwYXRoOiBuYW1lcGF0aFxuXHRcdFx0aW5oZXJpdHM6IHN1cGVyY2xhc3MgPyBcIjx7c3VwZXJjbGFzcy5uYW1lfT5cIiA6IG51bGxcblx0XHRcdGxvYzogbG9jXG5cdFx0XHRkZXNjOiBAZGVzY1xuXHRcdH1cblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0aWYgbm9kZSBpc2EgUmV0dXJuXG5cdFx0XHRvcHRpb24oJ3JldHVybicseWVzKVxuXHRcdFx0cmV0dXJuIHNlbGZcblx0XHRzdXBlclxuXG5cdGRlZiBpbml0aWFsaXplIG5hbWUsIHN1cGVyY2xhc3MsIGJvZHlcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAbmFtZSA9IG5hbWVcblx0XHRAc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3Ncblx0XHRAc2NvcGUgPSBUYWdTY29wZS5uZXcoc2VsZilcblx0XHRAYm9keSA9IGJsa19fKGJvZHkgfHwgW10pXG5cblx0ZGVmIHZpc2l0XG5cdFx0aWYgU3RyaW5nKG5hbWUpLm1hdGNoKC9eW0EtWl0vKVxuXHRcdFx0c2V0KGlzQ2xhc3M6IHllcylcblxuXHRcdFJPT1QuZW50aXRpZXMucmVnaXN0ZXIoc2VsZikgIyB3aGF0IGlmIHRoaXMgaXMgbm90IGxvY2FsP1xuXG5cdFx0IyByZXBsYWNlIHdpdGggc29tZSBhZHZhbmNlZCBsb29rdXA/XG5cdFx0c2NvcGUudmlzaXRcblx0XHRib2R5LnRyYXZlcnNlXG5cblx0ZGVmIGlkXG5cdFx0bmFtZS5pZFxuXG5cdGRlZiB0YWdzcGFjZVxuXHRcdHZhciBjdHggPSBzY29wZS5jbG9zdXJlLnRhZ0NvbnRleHRQYXRoXG5cdFx0bmFtZS5ucyA/IFwie2N0eH0ubnMoe2hlbHBlcnMuc2luZ2xlcXVvdGUgbmFtZS5uc30pXCIgOiBjdHhcblxuXHRkZWYganMgb1xuXHRcdHNjb3BlLmNvbnRleHQudmFsdWUgPSBAY3R4ID0gc2NvcGUuZGVjbGFyZSgndGFnJyxudWxsLHN5c3RlbTogeWVzKVxuXG5cdFx0dmFyIG5zID0gbmFtZS5uc1xuXHRcdHZhciBtYXJrID0gbWFya19fKG9wdGlvbigna2V5d29yZCcpKVxuXHRcdHZhciBwYXJhbXMgPSBbXVxuXG5cdFx0cGFyYW1zLnB1c2goaGVscGVycy5zaW5nbGVxdW90ZShuYW1lLm5hbWUpKVxuXHRcdHZhciBjYm9keSA9IGJvZHkuY1xuXG5cdFx0aWYgc3VwZXJjbGFzc1xuXHRcdFx0IyBXQVJOIHdoYXQgaWYgdGhlIHN1cGVyY2xhc3MgaGFzIGEgbmFtZXNwYWNlP1xuXHRcdFx0IyB3aGF0IGlmIGl0IGlzIGEgcmVndWxhciBjbGFzcz9cblx0XHRcdGxldCBzdXBuYW1lID0gc3VwZXJjbGFzcy5uYW1lXG5cdFx0XHRpZiAhc3VwbmFtZVswXS5tYXRjaCgvW0EtWl0vKVxuXHRcdFx0XHRzdXBuYW1lID0gaGVscGVycy5zaW5nbGVxdW90ZShzdXBuYW1lKVxuXHRcdFx0cGFyYW1zLnB1c2goc3VwbmFtZSlcblxuXHRcdGlmIGJvZHkuY291bnRcblx0XHRcdHBhcmFtcy5wdXNoKFwiZnVuY3Rpb24oe0BjdHguY30pXFx7e2Nib2R5fVxcfVwiKVxuXG5cdFx0dmFyIG1ldGggPSBvcHRpb24oOmV4dGVuc2lvbikgPyAnZXh0ZW5kVGFnJyA6ICdkZWZpbmVUYWcnXG5cblx0XHR2YXIganMgPSBcInttYXJrfXt0YWdzcGFjZX0ue21ldGh9KHtwYXJhbXMuam9pbignLCAnKX0pXCJcblxuXG5cdFx0aWYgb3B0aW9uKDppc0NsYXNzKVxuXHRcdFx0bGV0IGNuYW1lID0gbmFtZS5uYW1lXG5cdFx0XHQjIGRlY2xhcmUgdmFyaWFibGVcblx0XHRcdGpzID0gXCJ2YXIge2NuYW1lfSA9IHtqc31cIlxuXHRcdFx0IyBvbmx5IGlmIGl0IGlzIG5vdCBuYW1lc3BhY2VkXG5cdFx0XHQjIGlmIG86Z2xvYmFsIGFuZCAhbmFtZXNwYWNlZCAjIG9wdGlvbig6Z2xvYmFsKVxuXHRcdFx0I1x0anMucHVzaChcImdsb2JhbC57Y25hbWV9ID0ge2NwYXRofTsgLy8gZ2xvYmFsIGNsYXNzIFxcblwiKVxuXHRcdFx0aWYgb3B0aW9uKDpleHBvcnQpXG5cdFx0XHRcdGpzID0gXCJ7anN9XFxuZXhwb3J0cy57b3B0aW9uKDpkZWZhdWx0KSA/ICdkZWZhdWx0JyA6IGNuYW1lfSA9IHtjbmFtZX07XCJcblxuXHRcdFx0aWYgb3B0aW9uKDpyZXR1cm4pXG5cdFx0XHRcdGpzICs9IFwiXFxucmV0dXJuIHtjbmFtZX07XCJcblxuXHRcdGVsc2Vcblx0XHRcdGlmIG9wdGlvbig6cmV0dXJuKVxuXHRcdFx0XHRqcyA9IFwicmV0dXJuIFwiICsganNcblxuXG5cdFx0cmV0dXJuIGpzXG5cblx0XHQjIHJldHVybiBvdXRcblxuZXhwb3J0IGNsYXNzIEZ1bmMgPCBDb2RlXG5cblx0cHJvcCBuYW1lXG5cdHByb3AgcGFyYW1zXG5cdHByb3AgdGFyZ2V0XG5cdHByb3Agb3B0aW9uc1xuXHRwcm9wIHR5cGVcblx0cHJvcCBjb250ZXh0XG5cblx0ZGVmIHNjb3BldHlwZSBkbyBGdW5jdGlvblNjb3BlXG5cblx0ZGVmIGluaXRpYWxpemUgcGFyYW1zLCBib2R5LCBuYW1lLCB0YXJnZXQsIG9cblx0XHRAb3B0aW9ucyA9IG9cblx0XHR2YXIgdHlwID0gc2NvcGV0eXBlXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QGJvZHkgPSBibGtfXyhib2R5KVxuXHRcdEBzY29wZSB8fD0gKG8gYW5kIG86c2NvcGUpIHx8IHR5cC5uZXcoc2VsZilcblx0XHRAc2NvcGUucGFyYW1zID0gQHBhcmFtcyA9IFBhcmFtTGlzdC5uZXcocGFyYW1zKVxuXHRcdEBuYW1lID0gbmFtZSB8fCAnJ1xuXHRcdEB0YXJnZXQgPSB0YXJnZXRcblx0XHRAdHlwZSA9IDpmdW5jdGlvblxuXHRcdEB2YXJpYWJsZSA9IG51bGxcblx0XHRzZWxmXG5cblx0ZGVmIG5vbmxvY2Fsc1xuXHRcdEBzY29wZS5Abm9ubG9jYWxzXG5cblx0ZGVmIHZpc2l0XG5cdFx0c2NvcGUudmlzaXRcblx0XHRAY29udGV4dCA9IHNjb3BlLnBhcmVudFxuXHRcdEBwYXJhbXMudHJhdmVyc2Vcblx0XHRAYm9keS50cmF2ZXJzZSAjIHNvIHNvb24/XG5cblxuXHRkZWYganMgb1xuXHRcdGJvZHkuY29uc3VtZShJbXBsaWNpdFJldHVybi5uZXcpIHVubGVzcyBvcHRpb24oOm5vcmV0dXJuKVxuXHRcdHZhciBpbmQgPSBib2R5LkBpbmRlbnRhdGlvblxuXHRcdCMgdmFyIHMgPSBpbmQgYW5kIGluZC5Ab3BlblxuXHRcdGJvZHkuQGluZGVudGF0aW9uID0gbnVsbCBpZiBpbmQgYW5kIGluZC5pc0dlbmVyYXRlZFxuXHRcdHZhciBjb2RlID0gc2NvcGUuYyhpbmRlbnQ6ICghaW5kIG9yICFpbmQuaXNHZW5lcmF0ZWQpLCBicmFjZXM6IHllcylcblxuXHRcdCMgYXJncyA9IHBhcmFtcy5tYXAgZG8gfHBhcnwgcGFyLm5hbWVcblx0XHQjIGhlYWQgPSBwYXJhbXMubWFwIGRvIHxwYXJ8IHBhci5jXG5cdFx0IyBjb2RlID0gW2hlYWQsYm9keS5jKGV4cHJlc3Npb246IG5vKV0uZmxhdHRlbl9fLmNvbXBhY3Quam9pbihcIlxcblwiKS53cmFwXG5cdFx0IyBGSVhNRSBjcmVhdGluZyB0aGUgZnVuY3Rpb24tbmFtZSB0aGlzIHdheSBpcyBwcm9uZSB0byBjcmVhdGUgbmFtaW5nLWNvbGxpc2lvbnNcblx0XHQjIHdpbGwgbmVlZCB0byB3cmFwIHRoZSB2YWx1ZSBpbiBhIEZ1bmN0aW9uTmFtZSB3aGljaCB0YWtlcyBjYXJlIG9mIGxvb2tpbmcgdXAgc2NvcGVcblx0XHQjIGFuZCBwb3NzaWJseSBkZWFsaW5nIHdpdGggaXRcblx0XHR2YXIgbmFtZSA9IHR5cGVvZiBAbmFtZSA9PSAnc3RyaW5nJyA/IEBuYW1lIDogQG5hbWUuY1xuXHRcdHZhciBuYW1lID0gbmFtZSA/ICcgJyArIG5hbWUucmVwbGFjZSgvXFwuL2csJ18nKSA6ICcnXG5cdFx0dmFyIG91dCA9IFwiZnVuY3Rpb257bmFtZX0oe3BhcmFtcy5jfSkgXCIgKyBjb2RlXG5cdFx0b3V0ID0gXCIoe291dH0pKClcIiBpZiBvcHRpb24oOmV2YWwpXG5cdFx0cmV0dXJuIG91dFxuXG5cdGRlZiBzaG91bGRQYXJlbnRoZXNpemUgcGFyID0gdXBcblx0XHRwYXIgaXNhIENhbGwgJiYgcGFyLmNhbGxlZSA9PSBzZWxmXG5cdFx0IyBpZiB1cCBhcyBhIGNhbGw/IE9ubHkgaWYgd2UgYXJlXG5cblxuZXhwb3J0IGNsYXNzIExhbWJkYSA8IEZ1bmNcblx0ZGVmIHNjb3BldHlwZVxuXHRcdHZhciBrID0gb3B0aW9uKDprZXl3b3JkKVxuXHRcdChrIGFuZCBrLkB2YWx1ZSA9PSAnxpInKSA/IChNZXRob2RTY29wZSkgOiAoTGFtYmRhU2NvcGUpXG5cblxuZXhwb3J0IGNsYXNzIFRhZ0ZyYWdtZW50RnVuYyA8IEZ1bmNcblxuXHRkZWYgc2NvcGV0eXBlXG5cdFx0IyBjYWNoaW5nIHN0aWxsIG5lZWRzIHRvIGJlIGxvY2FsIG5vIG1hdHRlciB3aGF0P1xuXHRcdG9wdGlvbig6Y2xvc2VkKSA/IChNZXRob2RTY29wZSkgOiAoTGFtYmRhU2NvcGUpXG5cbmV4cG9ydCBjbGFzcyBNZXRob2REZWNsYXJhdGlvbiA8IEZ1bmNcblxuXHRwcm9wIHZhcmlhYmxlXG5cblx0ZGVmIHNjb3BldHlwZSBkbyBNZXRob2RTY29wZVxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRpZiBub2RlIGlzYSBSZXR1cm5cblx0XHRcdG9wdGlvbigncmV0dXJuJyx5ZXMpXG5cdFx0XHRyZXR1cm4gc2VsZlxuXHRcdHN1cGVyXG5cblx0ZGVmIG1ldGFkYXRhXG5cdFx0e1xuXHRcdFx0dHlwZTogXCJtZXRob2RcIlxuXHRcdFx0bmFtZTogXCJcIiArIG5hbWVcblx0XHRcdG5hbWVwYXRoOiBuYW1lcGF0aFxuXHRcdFx0cGFyYW1zOiBAcGFyYW1zLm1ldGFkYXRhXG5cdFx0XHRkZXNjOiBAZGVzY1xuXHRcdFx0c2NvcGVucjogc2NvcGUuQG5yXG5cdFx0XHRsb2M6IGxvY1xuXHRcdH1cblxuXHRkZWYgbG9jXG5cdFx0aWYgbGV0IGQgPSBvcHRpb24oOmRlZilcblx0XHRcdFtkLkBsb2MsYm9keS5sb2NbMV1dXG5cdFx0ZWxzZVxuXHRcdFx0WzAsMF1cblxuXG5cdGRlZiB0b0pTT05cblx0XHRtZXRhZGF0YVxuXG5cdGRlZiBuYW1lcGF0aFxuXHRcdHJldHVybiBAbmFtZXBhdGggaWYgQG5hbWVwYXRoXG5cblx0XHR2YXIgbmFtZSA9IFN0cmluZyhuYW1lKVxuXHRcdHZhciBzZXAgPSAob3B0aW9uKCdzdGF0aWMnKSA/ICcuJyA6ICcjJylcblx0XHRpZiB0YXJnZXRcblx0XHRcdEBuYW1lcGF0aCA9IEB0YXJnZXQubmFtZXBhdGggKyBzZXAgKyBuYW1lXG5cdFx0ZWxzZVxuXHRcdFx0QG5hbWVwYXRoID0gJyYnICsgbmFtZVxuXG5cdGRlZiB2aXNpdFxuXHRcdCMgQGRlc2MgPSBzdGFjay5zdGFzaC5wbHVjayhDb21tZW50KVxuXHRcdCMgQGRlc2MgPSBzdGFjay5zdGFzaC5wbHVjayhDb21tZW50KVxuXHRcdCMgcHJlYnJlYWsgIyBtYWtlIHN1cmUgdGhpcyBoYXMgYSBicmVhaz9cblx0XHRzY29wZS52aXNpdFxuXG5cdFx0aWYgU3RyaW5nKG5hbWUpLm1hdGNoKC9cXD0kLylcblx0XHRcdHNldChjaGFpbmFibGU6IHllcylcblxuXHRcdGlmIG9wdGlvbig6Z3JlZWR5KVxuXHRcdFx0d2FybiBcImRlcHJlY2F0ZWRcIlxuXHRcdFx0IyBzZXQoZ3JlZWR5OiB0cnVlKVxuXHRcdFx0dmFyIHRyZWUgPSBUYWdUcmVlLm5ld1xuXHRcdFx0QGJvZHkgPSBib2R5LmNvbnN1bWUodHJlZSlcblx0XHRcdCMgYm9keS5ub2RlcyA9IFtBcnIubmV3KGJvZHkubm9kZXMpXVxuXG5cdFx0QGNvbnRleHQgPSBzY29wZS5wYXJlbnQuY2xvc3VyZVxuXHRcdEBwYXJhbXMudHJhdmVyc2VcblxuXHRcdGlmIFN0cmluZyhuYW1lKSA9PSAnaW5pdGlhbGl6ZSdcblx0XHRcdGlmIChjb250ZXh0IGlzYSBDbGFzc1Njb3BlKSBhbmQgIShjb250ZXh0IGlzYSBUYWdTY29wZSlcblx0XHRcdFx0c2VsZi50eXBlID0gOmNvbnN0cnVjdG9yXG5cblx0XHRpZiB0YXJnZXQgaXNhIFNlbGZcblx0XHRcdEB0YXJnZXQgPSBAY29udGV4dC5jb250ZXh0XG5cdFx0XHRzZXQoc3RhdGljOiB5ZXMpXG5cblx0XHRpZiBjb250ZXh0IGlzYSBDbGFzc1Njb3BlXG5cdFx0XHRjb250ZXh0LmFubm90YXRlKHNlbGYpXG5cdFx0XHRAdGFyZ2V0IHx8PSBjb250ZXh0LmNvbnRleHRcblx0XHRcdCMgcmVnaXN0ZXIgYXMgY2xhc3MtbWV0aG9kP1xuXHRcdFx0IyBzaG91bGQgcmVnaXN0ZXIgZm9yIHRoaXNcblx0XHRcdCMgY29uc29sZS5sb2cgXCJjb250ZXh0IGlzIGNsYXNzc2NvcGUge0BuYW1lfVwiXG5cblx0XHRpZiAhQHRhcmdldFxuXHRcdFx0IyBzaG91bGQgbm90IGJlIHJlZ2lzdGVyZWQgb24gdGhlIG91dGVybW9zdCBjbG9zdXJlP1xuXHRcdFx0QHZhcmlhYmxlID0gY29udGV4dC5yZWdpc3RlcihuYW1lLCBzZWxmLCB0eXBlOiAnbWV0aCcpXG5cblx0XHRpZiB0YXJnZXQgaXNhIElkZW50aWZpZXJcblx0XHRcdGlmIGxldCB2YXJpYWJsZSA9IHNjb3BlLmxvb2t1cCh0YXJnZXQudG9TdHJpbmcpXG5cdFx0XHRcdHRhcmdldCA9IHZhcmlhYmxlXG5cblx0XHRST09ULmVudGl0aWVzLmFkZChuYW1lcGF0aCxzZWxmKVxuXHRcdEBib2R5LnRyYXZlcnNlICMgc28gc29vbj9cblx0XHRzZWxmXG5cblx0ZGVmIHN1cGVybmFtZVxuXHRcdHR5cGUgPT0gOmNvbnN0cnVjdG9yID8gdHlwZSA6IG5hbWVcblxuXG5cdCMgRklYTUUgZXhwb3J0IGdsb2JhbCBldGMgYXJlIE5PVCB2YWxpZCBmb3IgbWV0aG9kcyBpbnNpZGUgYW55IG90aGVyIHNjb3BlIHRoYW5cblx0IyB0aGUgb3V0ZXJtb3N0IHNjb3BlIChyb290KVxuXG5cdGRlZiBqcyBvXG5cdFx0IyBGSVhNRSBEbyB0aGlzIGluIHRoZSBncmFtbWFyIC0gcmVtbmFudHMgb2Ygb2xkIGltcGxlbWVudGF0aW9uXG5cdFx0dW5sZXNzIHR5cGUgPT0gOmNvbnN0cnVjdG9yIG9yIG9wdGlvbig6bm9yZXR1cm4pXG5cdFx0XHRpZiBvcHRpb24oOmNoYWluYWJsZSlcblx0XHRcdFx0Ym9keS5hZGQoSW1wbGljaXRSZXR1cm4ubmV3KHNjb3BlLmNvbnRleHQpKVxuXHRcdFx0ZWxpZiBvcHRpb24oOmdyZWVkeSlcblx0XHRcdFx0IyBoYWFhY2tcblx0XHRcdFx0Ym9keS5jb25zdW1lKEdyZWVkeVJldHVybi5uZXcpXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGJvZHkuY29uc3VtZShJbXBsaWNpdFJldHVybi5uZXcpXG5cblx0XHR2YXIgY29kZSA9IHNjb3BlLmMoaW5kZW50OiB5ZXMsIGJyYWNlczogeWVzKVxuXG5cdFx0IyBzYW1lIGZvciBGdW5jIC0tIHNob3VsZCBnZW5lcmFsaXplXG5cdFx0dmFyIG5hbWUgPSB0eXBlb2YgQG5hbWUgPT0gJ3N0cmluZycgPyBAbmFtZSA6IEBuYW1lLmNcblx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKC9cXC4vZywnXycpXG5cblx0XHQjIHZhciBuYW1lID0gc2VsZi5uYW1lLmMucmVwbGFjZSgvXFwuL2csJ18nKSAjIFdIQVQ/XG5cdFx0dmFyIGZvb3QgPSBbXVxuXG5cdFx0dmFyIGxlZnQgPSBcIlwiXG5cdFx0dmFyIGZ1bmMgPSBcIih7cGFyYW1zLmN9KVwiICsgY29kZSAjIC53cmFwXG5cdFx0dmFyIHRhcmdldCA9IHNlbGYudGFyZ2V0XG5cdFx0dmFyIGRlY2wgPSAhb3B0aW9uKDpnbG9iYWwpIGFuZCAhb3B0aW9uKDpleHBvcnQpXG5cblx0XHRpZiB0YXJnZXQgaXNhIFNjb3BlQ29udGV4dFxuXHRcdFx0IyB0aGUgdGFyZ2V0IGlzIGEgc2NvcGUgY29udGV4dFxuXHRcdFx0dGFyZ2V0ID0gbnVsbFxuXG5cdFx0dmFyIGN0eCA9IGNvbnRleHRcblx0XHR2YXIgb3V0ID0gXCJcIlxuXHRcdHZhciBtYXJrID0gbWFya19fKG9wdGlvbignZGVmJykpXG5cdFx0IyBpZiBjdHhcblxuXHRcdHZhciBmbmFtZSA9IHN5bV9fKHNlbGYubmFtZSlcblx0XHQjIGNvbnNvbGUubG9nIFwic3ltYm9saXplIHtzZWxmLm5hbWV9IC0tIHtmbmFtZX1cIlxuXHRcdHZhciBmZGVjbCA9IGZuYW1lICMgZGVjbCA/IGZuYW1lIDogJydcblxuXHRcdGlmIGN0eCBpc2EgQ2xhc3NTY29wZSBhbmQgIXRhcmdldFxuXHRcdFx0aWYgdHlwZSA9PSA6Y29uc3RydWN0b3Jcblx0XHRcdFx0b3V0ID0gXCJ7bWFya31mdW5jdGlvbiB7Zm5hbWV9e2Z1bmN9XCJcblx0XHRcdGVsaWYgb3B0aW9uKDpzdGF0aWMpXG5cdFx0XHRcdG91dCA9IFwie21hcmt9e2N0eC5jb250ZXh0LmN9LntmbmFtZX0gPSBmdW5jdGlvbiB7ZnVuY31cIlxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRvdXQgPSBcInttYXJrfXtjdHguY29udGV4dC5jfS5wcm90b3R5cGUue2ZuYW1lfSA9IGZ1bmN0aW9uIHtmdW5jfVwiXG5cblx0XHRlbGlmIGN0eCBpc2EgUm9vdFNjb3BlIGFuZCAhdGFyZ2V0XG5cdFx0XHQjIHJlZ2lzdGVyIG1ldGhvZCBhcyBhIHJvb3QtZnVuY3Rpb24sIGJ1dCB3aXRoIGF1dG8tY2FsbD8gaG1tXG5cdFx0XHQjIHNob3VsZCBwcm9iYWJseSBzZXQgdXNpbmcgdmFyaWFibGUgZGlyZWN0bHkgaW5zdGVhZCwgbm8/XG5cdFx0XHRvdXQgPSBcInttYXJrfWZ1bmN0aW9uIHtmZGVjbH17ZnVuY31cIlxuXG5cdFx0ZWxpZiB0YXJnZXQgYW5kIG9wdGlvbig6c3RhdGljKVxuXHRcdFx0b3V0ID0gXCJ7bWFya317dGFyZ2V0LmN9LntmbmFtZX0gPSBmdW5jdGlvbiB7ZnVuY31cIlxuXG5cdFx0ZWxpZiB0YXJnZXRcblx0XHRcdG91dCA9IFwie21hcmt9e3RhcmdldC5jfS5wcm90b3R5cGUue2ZuYW1lfSA9IGZ1bmN0aW9uIHtmdW5jfVwiXG5cdFx0ZWxzZVxuXHRcdFx0b3V0ID0gXCJ7bWFya31mdW5jdGlvbiB7ZmRlY2x9e2Z1bmN9XCJcblxuXHRcdGlmIG9wdGlvbig6Z2xvYmFsKVxuXHRcdFx0b3V0ID0gXCJ7Zm5hbWV9ID0ge291dH1cIlxuXG5cdFx0aWYgb3B0aW9uKDpleHBvcnQpXG5cdFx0XHRvdXQgPSBcIntvdXR9OyBleHBvcnRzLntvcHRpb24oOmRlZmF1bHQpID8gJ2RlZmF1bHQnIDogZm5hbWV9ID0ge2ZuYW1lfTtcIlxuXHRcdFx0b3V0ID0gXCJ7b3V0fTsgcmV0dXJuIHtmbmFtZX07XCIgaWYgb3B0aW9uKDpyZXR1cm4pXG5cblx0XHRlbGlmIG9wdGlvbig6cmV0dXJuKVxuXHRcdFx0b3V0ID0gXCJyZXR1cm4ge291dH1cIlxuXG5cdFx0b3V0XG5cblxuZXhwb3J0IGNsYXNzIFRhZ0ZyYWdtZW50RGVjbGFyYXRpb24gPCBNZXRob2REZWNsYXJhdGlvblxuXG5cbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eURlY2xhcmF0aW9uIDwgTm9kZVxuXG5cdHZhciBwcm9wVGVtcGxhdGUgPSAnJydcblx0JHtoZWFkZXJzfVxuXHQke3BhdGh9JHtnZXR0ZXJLZXl9ID0gZnVuY3Rpb24odil7IHJldHVybiAke2dldH07IH1cblx0JHtwYXRofS4ke3NldHRlcn0gPSBmdW5jdGlvbih2KXsgJHtzZXR9OyByZXR1cm4gdGhpczsgfVxuXHQke2luaXR9XG5cdCcnJ1xuXG5cdHZhciBwcm9wV2F0Y2hUZW1wbGF0ZSA9ICcnJ1xuXHQke2hlYWRlcnN9XG5cdCR7cGF0aH0ke2dldHRlcktleX0gPSBmdW5jdGlvbih2KXsgcmV0dXJuICR7Z2V0fTsgfVxuXHQke3BhdGh9LiR7c2V0dGVyfSA9IGZ1bmN0aW9uKHYpe1xuXHRcdHZhciBhID0gdGhpcy4ke2dldHRlcn0oKTtcblx0XHRpZih2ICE9IGEpIHsgJHtzZXR9OyB9XG5cdFx0aWYodiAhPSBhKSB7ICR7b25kaXJ0eX0gfVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdCR7aW5pdH1cblx0JycnXG5cblx0cHJvcCBuYW1lXG5cdHByb3Agb3B0aW9uc1xuXG5cdGRlZiBpbml0aWFsaXplIG5hbWUsIG9wdGlvbnMsIHRva2VuXG5cdFx0QHRva2VuID0gdG9rZW5cblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAbmFtZSA9IG5hbWVcblx0XHRAb3B0aW9ucyA9IG9wdGlvbnMgfHwgT2JqLm5ldyhBc3NpZ25MaXN0Lm5ldylcblxuXHRkZWYgdmlzaXRcblx0XHRAb3B0aW9ucy50cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHQjIFRoaXMgd2lsbCBzb29uIHN1cHBvcnQgYmluZGluZ3MgLyBsaXN0ZW5lcnMgZXRjLCBtdWNoIG1vcmVcblx0IyBhZHZhbmNlZCBnZW5lcmF0ZWQgY29kZSBiYXNlZCBvbiBvcHRpb25zIHBhc3NlZCBpbi5cblx0ZGVmIGNcblx0XHR2YXIgbyA9IG9wdGlvbnNcblx0XHR2YXIgYXN0ID0gXCJcIlxuXHRcdHZhciBrZXkgPSBuYW1lLmpzXG5cdFx0dmFyIHNjb3BlID0gU1RBQ0suc2NvcGVcblxuXHRcdHZhciBhZGREZXNjID0gby5rZXlzOmxlbmd0aFxuXG5cdFx0dmFyIHBhcnMgPSBvLmhhc2hcblxuXHRcdHZhciBpc0F0dHIgPSAoQHRva2VuIGFuZCBTdHJpbmcoQHRva2VuKSA9PSAnYXR0cicpIG9yIG8ua2V5KDphdHRyKVxuXG5cdFx0dmFyIGpzID1cblx0XHRcdGtleToga2V5XG5cdFx0XHRnZXR0ZXI6IGtleVxuXHRcdFx0Z2V0dGVyS2V5OiBSRVNFUlZFRF9URVNULnRlc3Qoa2V5KSA/IFwiWyd7a2V5fSddXCIgOiBcIi57a2V5fVwiXG5cdFx0XHRzZXR0ZXI6IHN5bV9fKFwic2V0LXtrZXl9XCIpXG5cdFx0XHRzY29wZTogXCJ7c2NvcGUuY29udGV4dC5jfVwiXG5cdFx0XHRwYXRoOiAnJHtzY29wZX0ucHJvdG90eXBlJ1xuXHRcdFx0c2V0OiBcInRoaXMuX3trZXl9ID0gdlwiXG5cdFx0XHRnZXQ6IFwidGhpcy5fe2tleX1cIlxuXHRcdFx0aW5pdDogXCJcIlxuXHRcdFx0aGVhZGVyczogXCJcIlxuXHRcdFx0b25kaXJ0eTogXCJcIlxuXG5cblx0XHRpZiBwYXJzOmlubGluZVxuXHRcdFx0aWYgcGFyczppbmxpbmUgaXNhIEJvb2wgYW5kICFwYXJzOmlubGluZS5pc1RydXRoeVxuXHRcdFx0XHRvLnJlbW92ZSgnaW5saW5lJylcblx0XHRcdFx0cmV0dXJuIFwie3Njb3BlX18uaW1iYS5jfS57QHRva2VufSh7anM6c2NvcGV9LCd7bmFtZS52YWx1ZX0nLHtvLmN9KVwiLnJlcGxhY2UoJyx7fSknLCcpJylcblxuXHRcdHZhciB0cGwgPSBwcm9wVGVtcGxhdGVcblxuXHRcdG8uYWRkKCduYW1lJyxTeW1ib2wubmV3KGtleSkpXG5cblx0XHRpZiBwYXJzOndhdGNoXG5cdFx0XHR0cGwgPSBwcm9wV2F0Y2hUZW1wbGF0ZSB1bmxlc3MgcGFyczp3YXRjaCBpc2EgQm9vbCBhbmQgIXBhcnM6d2F0Y2guaXNUcnV0aHlcblx0XHRcdHZhciB3Zm4gPSBcIntrZXl9RGlkU2V0XCJcblxuXHRcdFx0aWYgcGFyczp3YXRjaCBpc2EgU3ltYm9sXG5cdFx0XHRcdHdmbiA9IHBhcnM6d2F0Y2hcblx0XHRcdGVsaWYgcGFyczp3YXRjaCBpc2EgU3RyXG5cdFx0XHRcdHdmbiA9IHBhcnM6d2F0Y2hcblx0XHRcdGVsaWYgcGFyczp3YXRjaCBpc2EgQm9vbFxuXHRcdFx0XHRvLmtleSg6d2F0Y2gpLnZhbHVlID0gU3ltYm9sLm5ldyhcIntrZXl9RGlkU2V0XCIpXG5cdFx0XHRlbHNlXG5cdFx0XHRcdHdmbiA9IG51bGxcblxuXHRcdFx0aWYgd2ZuXG5cdFx0XHRcdGxldCBmbiA9IE9QKCcuJyxUaGlzLm5ldyx3Zm4pXG5cdFx0XHRcdGpzOm9uZGlydHkgPSBPUCgnJiYnLGZuLENBTEwoZm4sWyd2JywnYScsXCJ0aGlzLl9fe2tleX1cIl0pKS5jXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGpzOm9uZGlydHkgPSBcIntzY29wZV9fLmltYmEuY30ucHJvcERpZFNldCh0aGlzLHRoaXMuX197a2V5fSx2LGEpXCJcblxuXG5cdFx0aWYgcGFyczpvYnNlcnZlXG5cdFx0XHRpZiBwYXJzOm9ic2VydmUgaXNhIEJvb2xcblx0XHRcdFx0by5rZXkoOm9ic2VydmUpLnZhbHVlID0gU3ltYm9sLm5ldyhcIntrZXl9RGlkRW1pdFwiKVxuXG5cdFx0XHR0cGwgPSBwcm9wV2F0Y2hUZW1wbGF0ZVxuXHRcdFx0anM6b25kaXJ0eSA9IFwie3Njb3BlX18uaW1iYS5jfS5vYnNlcnZlUHJvcGVydHkodGhpcywne2tleX0nLHtvLmtleSg6b2JzZXJ2ZSkudmFsdWUuY30sdixhKTtcIiArwqAoanM6b25kaXJ0eSBvciAnJylcblx0XHRcdCMgT1AoJyYmJyxmbixDQUxMKGZuLFsndicsJ2EnLFwidGhpcy5fX3trZXl9XCJdKSkuY1xuXG5cdFx0aWYgIWlzQXR0ciBhbmQgby5rZXkoOmRvbSlcblx0XHRcdGpzOnNldCA9IFwiaWYgKHYgIT0gdGhpcy5kb20oKS57bmFtZS52YWx1ZX0pIFxceyB0aGlzLmRvbSgpLntuYW1lLnZhbHVlfSA9IHYgXFx9XCJcblx0XHRcdGpzOmdldCA9IFwidGhpcy5kb20oKS57bmFtZS52YWx1ZX1cIlxuXG5cdFx0aWYgaXNBdHRyICMgKEB0b2tlbiBhbmQgU3RyaW5nKEB0b2tlbikgPT0gJ2F0dHInKSBvciBvLmtleSg6ZG9tKSBvciBvLmtleSg6YXR0cilcblx0XHRcdGxldCBhdHRyS2V5ID0gby5rZXkoOmRvbSkgaXNhIFN0ciA/IG8ua2V5KDpkb20pIDogbmFtZS52YWx1ZVxuXHRcdFx0IyBuZWVkIHRvIG1ha2Ugc3VyZSBvIGhhcyBhIGtleSBmb3IgYXR0ciB0aGVuIC0gc28gdGhhdCB0aGUgZGVsZWdhdGUgY2FuIGtub3c/XG5cdFx0XHRqczpzZXQgPSBcInRoaXMuc2V0QXR0cmlidXRlKCd7YXR0cktleX0nLHYpXCJcblx0XHRcdGpzOmdldCA9IFwidGhpcy5nZXRBdHRyaWJ1dGUoJ3thdHRyS2V5fScpXCJcblxuXHRcdGVsaWYgby5rZXkoOmRlbGVnYXRlKVxuXHRcdFx0IyBpZiB3ZSBoYXZlIGEgZGVsZWdhdGVcblx0XHRcdGpzOnNldCA9IFwidiA9IHRoaXMuX197a2V5fS5kZWxlZ2F0ZS5zZXQodGhpcywne2tleX0nLHYsdGhpcy5fX3trZXl9KVwiXG5cdFx0XHRqczpnZXQgPSBcInRoaXMuX197a2V5fS5kZWxlZ2F0ZS5nZXQodGhpcywne2tleX0nLHRoaXMuX197a2V5fSlcIlxuXG5cblxuXHRcdGlmIHBhcnM6ZGVmYXVsdFxuXHRcdFx0aWYgby5rZXkoOmRvbSlcblx0XHRcdFx0IyBGSVhNRSBnbyB0aHJvdWdoIGNsYXNzLW1ldGhvZCBzZXRBdHRyaWJ1dGUgaW5zdGVhZFxuXHRcdFx0XHRqczppbml0ID0gXCJ7anM6c2NvcGV9LmRvbSgpLnNldEF0dHJpYnV0ZSgne2tleX0nLHtwYXJzOmRlZmF1bHQuY30pO1wiXG5cdFx0XHRlbHNlXG5cdFx0XHRcdCMgaWYgdGhpcyBpcyBub3QgYSBwcmltaXRpdmUgLSBpdCBNVVNUIGJlIGluY2x1ZGVkIGluIHRoZVxuXHRcdFx0XHQjIGdldHRlciAvIHNldHRlciBpbnN0ZWFkXG5cdFx0XHRcdCMgRklYTUUgdGhyb3cgd2FybmluZyBpZiB0aGUgZGVmYXVsdCBpcyBub3QgYSBwcmltaXRpdmUgb2JqZWN0XG5cdFx0XHRcdGpzOmluaXQgPSBcIntqczpzY29wZX0ucHJvdG90eXBlLl97a2V5fSA9IHtwYXJzOmRlZmF1bHQuY307XCJcblxuXHRcdGlmIG8ua2V5KDpjaGFpbmFibGUpXG5cdFx0XHRqczpnZXQgPSBcInYgIT09IHVuZGVmaW5lZCA/ICh0aGlzLntqczpzZXR0ZXJ9KHYpLHRoaXMpIDoge2pzOmdldH1cIlxuXG5cblx0XHRqczpvcHRpb25zID0gby5jXG5cblx0XHRpZiBhZGREZXNjXG5cdFx0XHRqczpoZWFkZXJzID0gXCJ7anM6cGF0aH0uX197anM6Z2V0dGVyfSA9IHtqczpvcHRpb25zfTtcIlxuXG5cdFx0dmFyIHJlZyA9IC9cXCRcXHsoXFx3KylcXH0vZ21cblx0XHQjIHZhciB0cGwgPSBvLmtleSg6d2F0Y2gpID8gcHJvcFdhdGNoVGVtcGxhdGUgOiBwcm9wVGVtcGxhdGVcblx0XHR2YXIgb3V0ID0gdHBsLnJlcGxhY2UocmVnKSBkbyB8bSxhfCBqc1thXVxuXHRcdCMgcnVuIGFub3RoZXIgdGltZSBmb3IgbmVzdGluZy4gaGFja3lcblx0XHRvdXQgPSBvdXQucmVwbGFjZShyZWcpIGRvIHxtLGF8IGpzW2FdXG5cdFx0IyBvdXQgPSBvdXQucmVwbGFjZSgvXFxuXFxzKiQvLCcnKVxuXHRcdG91dCA9IG91dC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcblxuXHRcdCMgaWYgby5rZXkoOnYpXG5cdFx0cmV0dXJuIG91dFxuXG5cblxuIyBMaXRlcmFscyBzaG91bGQgcHJvYmFibHkgbm90IGluaGVyaXQgZnJvbSB0aGUgc2FtZSBwYXJlbnRcbiMgYXMgYXJyYXlzLCB0dXBsZXMsIG9iamVjdHMgd291bGQgYmUgYmV0dGVyIG9mZiBpbmhlcml0aW5nXG4jIGZyb20gbGlzdG5vZGUuXG5cbmV4cG9ydCBjbGFzcyBMaXRlcmFsIDwgVmFsdWVOb2RlXG5cblx0ZGVmIGluaXRpYWxpemUgdlxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBleHByZXNzaW9uID0geWVzXG5cdFx0QGNhY2hlID0gbnVsbFxuXHRcdEByYXcgPSBudWxsXG5cdFx0QHZhbHVlID0gdlxuXG5cdGRlZiB0b1N0cmluZ1xuXHRcdFwiXCIgKyB2YWx1ZVxuXG5cdGRlZiBoYXNTaWRlRWZmZWN0c1xuXHRcdGZhbHNlXG5cblx0ZGVmIHNob3VsZFBhcmVudGhlc2l6ZUluVGVybmFyeVxuXHRcdG5vXG5cblxuZXhwb3J0IGNsYXNzIEJvb2wgPCBMaXRlcmFsXG5cblx0IyBTaG91bGQga2VlcCB0aGUgcmVhbCB2YWx1ZSAoeWVzL25vL3RydWUvZmFsc2UpP1xuXHRkZWYgaW5pdGlhbGl6ZSB2XG5cdFx0QHZhbHVlID0gdlxuXHRcdEByYXcgPSBTdHJpbmcodikgPT0gXCJ0cnVlXCIgPyB0cnVlIDogZmFsc2VcblxuXHRkZWYgY2FjaGVcblx0XHRzZWxmXG5cblx0ZGVmIGlzUHJpbWl0aXZlXG5cdFx0eWVzXG5cblx0ZGVmIHRydXRoeVxuXHRcdFN0cmluZyh2YWx1ZSkgPT0gXCJ0cnVlXCJcblx0XHQjIHllc1xuXG5cdGRlZiBqcyBvXG5cdFx0U3RyaW5nKEB2YWx1ZSlcblxuXHRkZWYgY1xuXHRcdFNUQUNLLkBjb3VudGVyICs9IDFcblx0XHQjIHVuZGVmaW5lZCBzaG91bGQgbm90IGJlIGEgYm9vbFxuXHRcdFN0cmluZyhAdmFsdWUpXG5cdFx0IyBAcmF3ID8gXCJ0cnVlXCIgOiBcImZhbHNlXCJcblxuXHRkZWYgdG9KU09OXG5cdFx0e3R5cGU6ICdCb29sJywgdmFsdWU6IEB2YWx1ZX1cblxuXHRkZWYgbG9jXG5cdFx0QHZhbHVlOnJlZ2lvbiA/IEB2YWx1ZS5yZWdpb24gOiBbMCwwXVxuXG5leHBvcnQgY2xhc3MgVW5kZWZpbmVkIDwgTGl0ZXJhbFxuXG5cdGRlZiBpc1ByaW1pdGl2ZVxuXHRcdHllc1xuXG5cdGRlZiBpc1RydXRoeVxuXHRcdG5vXG5cblx0ZGVmIGNcblx0XHRtYXJrX18oQHZhbHVlKSArIFwidW5kZWZpbmVkXCJcblxuZXhwb3J0IGNsYXNzIE5pbCA8IExpdGVyYWxcblxuXHRkZWYgaXNQcmltaXRpdmVcblx0XHR5ZXNcblxuXHRkZWYgaXNUcnV0aHlcblx0XHRub1xuXG5cdGRlZiBjXG5cdFx0bWFya19fKEB2YWx1ZSkgKyBcIm51bGxcIlxuXG5leHBvcnQgY2xhc3MgVHJ1ZSA8IEJvb2xcblxuXHRkZWYgcmF3XG5cdFx0dHJ1ZVxuXG5cdGRlZiBpc1RydXRoeVxuXHRcdHllc1xuXG5cdGRlZiBjXG5cdFx0bWFya19fKEB2YWx1ZSkgKyBcInRydWVcIlxuXG5leHBvcnQgY2xhc3MgRmFsc2UgPCBCb29sXG5cblx0ZGVmIHJhd1xuXHRcdGZhbHNlXG5cblx0ZGVmIGlzVHJ1dGh5XG5cdFx0bm9cblxuXHRkZWYgY1xuXHRcdG1hcmtfXyhAdmFsdWUpICsgXCJmYWxzZVwiXG5cbmV4cG9ydCBjbGFzcyBOdW0gPCBMaXRlcmFsXG5cblx0IyB2YWx1ZSBpcyB0b2tlbiAtIHNob3VsZCBub3QgYmVcblx0ZGVmIGluaXRpYWxpemUgdlxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEB2YWx1ZSA9IHZcblxuXHRkZWYgdG9TdHJpbmdcblx0XHRTdHJpbmcoQHZhbHVlKVxuXG5cdGRlZiBpc1ByaW1pdGl2ZSBkZWVwXG5cdFx0eWVzXG5cblx0ZGVmIGlzVHJ1dGh5XG5cdFx0U3RyaW5nKEB2YWx1ZSkgIT0gXCIwXCJcblxuXHRkZWYgc2hvdWxkUGFyZW50aGVzaXplIHBhciA9IHVwXG5cdFx0cGFyIGlzYSBBY2Nlc3MgYW5kIHBhci5sZWZ0ID09IHNlbGZcblxuXHRkZWYganMgb1xuXHRcdHZhciBudW0gPSBTdHJpbmcoQHZhbHVlKVxuXHRcdHJldHVybiBudW1cblxuXHRkZWYgYyBvXG5cdFx0cmV0dXJuIHN1cGVyKG8pIGlmIEBjYWNoZVxuXHRcdHZhciBqcyA9IFN0cmluZyhAdmFsdWUpXG5cdFx0dmFyIHBhciA9IFNUQUNLLmN1cnJlbnRcblx0XHR2YXIgcGFyZW4gPSBwYXIgaXNhIEFjY2VzcyBhbmQgcGFyLmxlZnQgPT0gc2VsZlxuXHRcdCMgb25seSBpZiB0aGlzIGlzIHRoZSByaWdodCBwYXJ0IG9mIHRlaCBhY2Nlc1xuXHRcdHBhcmVuID8gXCIoe21hcmtfXyhAdmFsdWUpfVwiICsganMgKyBcIilcIiA6IChtYXJrX18oQHZhbHVlKSArIGpzKVxuXHRcdCMgQGNhY2hlID8gc3VwZXIobykgOiBTdHJpbmcoQHZhbHVlKVxuXG5cdGRlZiBjYWNoZSBvXG5cdFx0cmV0dXJuIHNlbGYgdW5sZXNzIG8gYW5kIChvOmNhY2hlIG9yIG86cG9vbClcblx0XHRzdXBlcihvKVxuXG5cdGRlZiByYXdcblx0XHQjIHJlYWxseT9cblx0XHRKU09OLnBhcnNlKFN0cmluZyh2YWx1ZSkpXG5cblx0ZGVmIHRvSlNPTlxuXHRcdHt0eXBlOiB0eXBlTmFtZSwgdmFsdWU6IHJhd31cblxuIyBzaG91bGQgYmUgcXVvdGVkIG5vP1xuIyB3aGF0IGFib3V0IHN0cmluZ3MgaW4gb2JqZWN0LWxpdGVyYWxzP1xuIyB3ZSB3YW50IHRvIGJlIGFibGUgdG8gc2VlIGlmIHRoZSB2YWx1ZXMgYXJlIGFsbG93ZWRcbmV4cG9ydCBjbGFzcyBTdHIgPCBMaXRlcmFsXG5cblx0ZGVmIGluaXRpYWxpemUgdlxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBleHByZXNzaW9uID0geWVzXG5cdFx0QGNhY2hlID0gbnVsbFxuXHRcdEB2YWx1ZSA9IHZcblx0XHQjIHNob3VsZCBncmFiIHRoZSBhY3R1YWwgdmFsdWUgaW1tZWRpYXRlbHk/XG5cblx0ZGVmIGlzU3RyaW5nXG5cdFx0eWVzXG5cblx0ZGVmIGlzUHJpbWl0aXZlIGRlZXBcblx0XHR5ZXNcblxuXHRkZWYgcmF3XG5cdFx0IyBKU09OLnBhcnNlIHJlcXVpcmVzIGRvdWJsZS1xdW90ZWQgc3RyaW5ncyxcblx0XHQjIHdoaWxlIGV2YWwgYWxzbyBhbGxvd3Mgc2luZ2xlIHF1b3Rlcy5cblx0XHQjIE5FWFQgZXZhbCBpcyBub3QgYWNjZXNzaWJsZSBsaWtlIHRoaXNcblx0XHQjIFdBUk5JTkcgVE9ETyBiZSBjYXJlZnVsISAtIHNob3VsZCBjbGVhbiB1cFxuXG5cdFx0QHJhdyB8fD0gU3RyaW5nKHZhbHVlKS5zbGljZSgxLC0xKSAjIGluY3JlZGlibHkgc3R1cGlkIHNvbHV0aW9uXG5cblx0ZGVmIGlzVmFsaWRJZGVudGlmaWVyXG5cdFx0IyB0aGVyZSBhcmUgYWxzbyBzb21lIHZhbHVlcyB3ZSBjYW5ub3QgdXNlXG5cdFx0cmF3Lm1hdGNoKC9eW2EtekEtWlxcJFxcX10rW1xcZFxcd1xcJFxcX10qJC8pID8gdHJ1ZSA6IGZhbHNlXG5cblx0ZGVmIGpzIG9cblx0XHRTdHJpbmcoQHZhbHVlKVxuXG5cdGRlZiBjIG9cblx0XHRAY2FjaGUgPyBzdXBlcihvKSA6IFN0cmluZyhAdmFsdWUpXG5cblxuZXhwb3J0IGNsYXNzIEludGVycG9sYXRpb24gPCBWYWx1ZU5vZGVcblxuIyBDdXJyZW50bHkgbm90IHVzZWQgLSBpdCB3b3VsZCBiZSBiZXR0ZXIgdG8gdXNlIHRoaXNcbiMgZm9yIHJlYWwgaW50ZXJwb2xhdGVkIHN0cmluZ3MgdGhvdWdoLCB0aGFuIHRvIGJyZWFrXG4jIHRoZW0gdXAgaW50byB0aGVpciBwYXJ0cyBiZWZvcmUgcGFyc2luZ1xuZXhwb3J0IGNsYXNzIEludGVycG9sYXRlZFN0cmluZyA8IE5vZGVcblxuXHRkZWYgaW5pdGlhbGl6ZSBub2RlcywgbyA9IHt9XG5cdFx0QG5vZGVzID0gbm9kZXNcblx0XHRAb3B0aW9ucyA9IG9cblx0XHRzZWxmXG5cblx0ZGVmIGFkZCBwYXJ0XG5cdFx0QG5vZGVzLnB1c2gocGFydCkgaWYgcGFydFxuXHRcdHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHRmb3Igbm9kZSBpbiBAbm9kZXNcblx0XHRcdG5vZGUudHJhdmVyc2Vcblx0XHRzZWxmXG5cblx0ZGVmIGVzY2FwZVN0cmluZyBzdHJcblx0XHQjIHZhciBpZHggPSAwXG5cdFx0IyB2YXIgbGVuID0gc3RyOmxlbmd0aFxuXHRcdCMgdmFyIGNoclxuXHRcdCMgd2hpbGUgY2hyID0gc3RyW2lkeCsrXVxuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKC9cXG4vZywgJ1xcXFxcXG4nKVxuXG5cdGRlZiBqcyBvXG5cdFx0IyBjcmVhdGluZyB0aGUgc3RyaW5nXG5cdFx0dmFyIHBhcnRzID0gW11cblx0XHR2YXIgc3RyID0gJygnXG5cblx0XHRAbm9kZXMubWFwIGRvIHxwYXJ0LGl8XG5cdFx0XHRpZiBwYXJ0IGlzYSBUb2tlbiBhbmQgcGFydC5AdHlwZSA9PSAnTkVPU1RSSU5HJ1xuXHRcdFx0XHQjIGVzY2Fcblx0XHRcdFx0cGFydHMucHVzaCgnXCInICsgZXNjYXBlU3RyaW5nKHBhcnQuQHZhbHVlKSArICdcIicpXG5cdFx0XHRlbGlmIHBhcnRcblx0XHRcdFx0aWYgaSA9PSAwXG5cdFx0XHRcdFx0IyBmb3JjZSBmaXJzdCBwYXJ0IHRvIGJlIHN0cmluZ1xuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ1wiXCInKVxuXHRcdFx0XHRwYXJ0LkBwYXJlbnMgPSB5ZXNcblx0XHRcdFx0cGFydHMucHVzaChwYXJ0LmMoZXhwcmVzc2lvbjogeWVzKSlcblxuXHRcdHN0ciArPSBwYXJ0cy5qb2luKFwiICsgXCIpXG5cdFx0c3RyICs9ICcpJ1xuXHRcdHJldHVybiBzdHJcblxuXG5leHBvcnQgY2xhc3MgVHVwbGUgPCBMaXN0Tm9kZVxuXG5cdGRlZiBjXG5cdFx0IyBjb21waWxlcyBhcyBhbiBhcnJheVxuXHRcdEFyci5uZXcobm9kZXMpLmNcblxuXHRkZWYgaGFzU3BsYXRcblx0XHRmaWx0ZXIofHZ8IHYgaXNhIFNwbGF0IClbMF1cblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0aWYgY291bnQgPT0gMVxuXHRcdFx0cmV0dXJuIGZpcnN0LmNvbnN1bWUobm9kZSlcblx0XHRlbHNlXG5cdFx0XHR0aHJvdyBcIm11bHRpdHVwbGUgY2Fubm90IGNvbnN1bWVcIlxuXG5cbiMgQmVjYXVzZSB3ZSd2ZSBkcm9wcGVkIHRoZSBTdHItd3JhcHBlciBpdCBpcyBraW5kYSBkaWZmaWN1bHRcbmV4cG9ydCBjbGFzcyBTeW1ib2wgPCBMaXRlcmFsXG5cblx0ZGVmIGlzVmFsaWRJZGVudGlmaWVyXG5cdFx0cmF3Lm1hdGNoKC9eW2EtekEtWlxcJFxcX10rW1xcZFxcd1xcJFxcX10qJC8pID8gdHJ1ZSA6IGZhbHNlXG5cblx0ZGVmIGlzUHJpbWl0aXZlIGRlZXBcblx0XHR5ZXNcblxuXHRkZWYgcmF3XG5cdFx0QHJhdyB8fD0gc3ltX18odmFsdWUudG9TdHJpbmcucmVwbGFjZSgvXlxcOi8sJycpKVxuXG5cdGRlZiBqcyBvXG5cdFx0XCIne3N5bV9fKHJhdyl9J1wiXG5cbmV4cG9ydCBjbGFzcyBSZWdFeHAgPCBMaXRlcmFsXG5cblx0ZGVmIGlzUHJpbWl0aXZlXG5cdFx0eWVzXG5cblx0ZGVmIGpzXG5cdFx0dmFyIHYgPSBzdXBlclxuXHRcdFxuXHRcdCMgc3BlY2lhbCBjYXNpbmcgaGVyZWdleFxuXHRcdGlmIHZhciBtID0gY29uc3RhbnRzLkhFUkVHRVguZXhlYyh2KVxuXHRcdFx0IyBjb25zb2xlLmxvZyAnbWF0eGhlZCBoZXJlZ2V4JyxtXG5cdFx0XHR2YXIgcmUgPSBtWzFdLnJlcGxhY2UoY29uc3RhbnRzLkhFUkVHRVhfT01JVCwgJycpLnJlcGxhY2UoL1xcLy9nLCAnXFxcXC8nKVxuXHRcdFx0cmV0dXJuICcvJyArIChyZSBvciAnKD86KScpICsgJy8nICsgbVsyXVxuXHRcdFxuXHRcdHYgPT0gJy8vJyA/ICcvKD86KS8nIDogdlxuXG4jIFNob3VsZCBpbmhlcml0IGZyb20gTGlzdE5vZGUgLSB3b3VsZCBzaW1wbGlmeVxuZXhwb3J0IGNsYXNzIEFyciA8IExpdGVyYWxcblxuXHRkZWYgbG9hZCB2YWx1ZVxuXHRcdHZhbHVlIGlzYSBBcnJheSA/IEFyZ0xpc3QubmV3KHZhbHVlKSA6IHZhbHVlXG5cblx0ZGVmIHB1c2ggaXRlbVxuXHRcdHZhbHVlLnB1c2goaXRlbSlcblx0XHRzZWxmXG5cblx0ZGVmIGNvdW50XG5cdFx0dmFsdWU6bGVuZ3RoXG5cblx0ZGVmIG5vZGVzXG5cdFx0dmFyIHZhbCA9IHZhbHVlXG5cdFx0dmFsIGlzYSBBcnJheSA/IHZhbCA6IHZhbC5ub2Rlc1xuXG5cdGRlZiBzcGxhdFxuXHRcdHZhbHVlLnNvbWUofHZ8IHYgaXNhIFNwbGF0KVxuXG5cdGRlZiB2aXNpdFxuXHRcdEB2YWx1ZS50cmF2ZXJzZSBpZiBAdmFsdWUgYW5kIEB2YWx1ZTp0cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHRkZWYgaXNQcmltaXRpdmUgZGVlcFxuXHRcdCF2YWx1ZS5zb21lKHx2fCAhdi5pc1ByaW1pdGl2ZSh5ZXMpIClcblxuXHRkZWYganMgb1xuXG5cdFx0dmFyIHZhbCA9IEB2YWx1ZVxuXHRcdHJldHVybiBcIltdXCIgdW5sZXNzIHZhbFxuXG5cdFx0dmFyIHNwbGF0ID0gc3BsYXRcblx0XHR2YXIgbm9kZXMgPSB2YWwgaXNhIEFycmF5ID8gdmFsIDogdmFsLm5vZGVzXG5cblx0XHQjIGZvciB2IGluIEB2YWx1ZVxuXHRcdCMgXHRicmVhayBzcGxhdCA9IHllcyBpZiB2IGlzYSBTcGxhdFxuXHRcdCMgdmFyIHNwbGF0ID0gdmFsdWUuc29tZSh8dnwgdiBpc2EgU3BsYXQpXG5cblx0XHRpZiBzcGxhdFxuXHRcdFx0IyBcIlNQTEFUVEVEIEFSUkFZIVwiXG5cdFx0XHQjIGlmIHdlIGtub3cgZm9yIGNlcnRhaW4gdGhhdCB0aGUgc3BsYXRzIGFyZSBhcnJheXMgd2UgY2FuIGRyb3AgdGhlIHNsaWNlP1xuXHRcdFx0dmFyIHNsaWNlcyA9IFtdXG5cdFx0XHR2YXIgZ3JvdXAgPSBudWxsXG5cblx0XHRcdGZvciB2IGluIG5vZGVzXG5cdFx0XHRcdGlmIHYgaXNhIFNwbGF0XG5cdFx0XHRcdFx0c2xpY2VzLnB1c2godilcblx0XHRcdFx0XHRncm91cCA9IG51bGxcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHNsaWNlcy5wdXNoKGdyb3VwID0gQXJyLm5ldyhbXSkpIHVubGVzcyBncm91cFxuXHRcdFx0XHRcdGdyb3VwLnB1c2godilcblxuXHRcdFx0XCJbXS5jb25jYXQoe2NhcnlfXyhzbGljZXMpLmpvaW4oXCIsIFwiKX0pXCJcblx0XHRlbHNlXG5cdFx0XHQjIHZlcnkgdGVtcG9yYXJ5LiBuZWVkIGEgbW9yZSBnZW5lcmljIHdheSB0byBwcmV0dGlmeSBjb2RlXG5cdFx0XHQjIHNob3VsZCBkZXBlbmQgb24gdGhlIGxlbmd0aCBvZiB0aGUgaW5uZXIgaXRlbXMgZXRjXG5cdFx0XHQjIGlmIEBpbmRlbnRlZCBvciBvcHRpb24oOmluZGVudCkgb3IgdmFsdWUuQGluZGVudGVkXG5cdFx0XHQjXHRcIltcXG57dmFsdWUuYy5qb2luKFwiLFxcblwiKS5pbmRlbnR9XFxuXVwiXG5cdFx0XHR2YXIgb3V0ID0gdmFsIGlzYSBBcnJheSA/IGNhcnlfXyh2YWwpIDogdmFsLmNcblx0XHRcdFwiW3tvdXR9XVwiXG5cblx0ZGVmIGhhc1NpZGVFZmZlY3RzXG5cdFx0dmFsdWUuc29tZSh8dnwgdi5oYXNTaWRlRWZmZWN0cyApXG5cblx0ZGVmIHRvU3RyaW5nXG5cdFx0XCJBcnJcIlxuXG5cdGRlZiBpbmRlbnRlZCBhLGJcblx0XHRAdmFsdWUuaW5kZW50ZWQoYSxiKVxuXHRcdHNlbGZcblxuXHRkZWYgc2VsZi53cmFwIHZhbFxuXHRcdEFyci5uZXcodmFsKVxuXG4jIHNob3VsZCBub3QgYmUgY2tsYXNzaWZpZWQgYXMgYSBsaXRlcmFsP1xuZXhwb3J0IGNsYXNzIE9iaiA8IExpdGVyYWxcblxuXHRkZWYgbG9hZCB2YWx1ZVxuXHRcdHZhbHVlIGlzYSBBcnJheSA/IEFzc2lnbkxpc3QubmV3KHZhbHVlKSA6IHZhbHVlXG5cblx0ZGVmIHZpc2l0XG5cdFx0QHZhbHVlLnRyYXZlcnNlIGlmIEB2YWx1ZVxuXHRcdCMgZm9yIHYgaW4gdmFsdWVcblx0XHQjIFx0di50cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHRkZWYganMgb1xuXHRcdHZhciBkeW4gPSB2YWx1ZS5maWx0ZXIofHZ8IHYgaXNhIE9iakF0dHIgYW5kICh2LmtleSBpc2EgT3Agb3Igdi5rZXkgaXNhIEludGVycG9sYXRlZFN0cmluZykgIClcblxuXHRcdGlmIGR5bjpsZW5ndGggPiAwXG5cdFx0XHR2YXIgaWR4ID0gdmFsdWUuaW5kZXhPZihkeW5bMF0pXG5cdFx0XHQjIGNyZWF0ZSBhIHRlbXAgdmFyaWFibGVcblxuXHRcdFx0dmFyIHRtcCA9IHNjb3BlX18udGVtcG9yYXJ5KHNlbGYpXG5cdFx0XHQjIHNldCB0aGUgdGVtcG9yYXJ5IG9iamVjdCB0byB0aGUgc2FtZVxuXHRcdFx0dmFyIGZpcnN0ID0gdmFsdWUuc2xpY2UoMCxpZHgpXG5cdFx0XHR2YXIgb2JqID0gT2JqLm5ldyhmaXJzdClcblx0XHRcdHZhciBhc3QgPSBbT1AoJz0nLHRtcCxvYmopXVxuXG5cdFx0XHR2YWx1ZS5zbGljZShpZHgpLmZvckVhY2ggZG8gfGF0cnxcblx0XHRcdFx0YXN0LnB1c2goT1AoJz0nLE9QKCcuJyx0bXAsYXRyLmtleSksYXRyLnZhbHVlKSlcblx0XHRcdGFzdC5wdXNoKHRtcCkgIyBhY2Nlc3MgdGhlIHRtcCBhdCBpbiB0aGUgbGFzdCBwYXJ0XG5cdFx0XHRyZXR1cm4gUGFyZW5zLm5ldyhhc3QpLmNcblxuXHRcdCMgZm9yIG9iamVjdHMgd2l0aCBleHByZXNzaW9uLWtleXMgd2UgbmVlZCB0byB0aGluayBkaWZmZXJlbnRseVxuXHRcdCd7JyArIHZhbHVlLmMgKyAnfSdcblxuXHRkZWYgYWRkIGssIHZcblx0XHRrID0gSWRlbnRpZmllci5uZXcoaykgaWYgayBpc2EgU3RyaW5nXG5cdFx0dmFyIGt2ID0gT2JqQXR0ci5uZXcoayx2KVxuXHRcdHZhbHVlLnB1c2goa3YpXG5cdFx0cmV0dXJuIGt2XG5cblx0ZGVmIHJlbW92ZSBrZXlcblx0XHRmb3IgayBpbiB2YWx1ZVxuXHRcdFx0dmFsdWUucmVtb3ZlKGspIGlmIGsua2V5LnN5bWJvbCA9PSBrZXlcblx0XHRzZWxmXG5cblx0ZGVmIGtleXNcblx0XHRPYmplY3Qua2V5cyhoYXNoKVxuXG5cdGRlZiBoYXNoXG5cdFx0dmFyIGhhc2ggPSB7fVxuXHRcdGZvciBrIGluIHZhbHVlXG5cdFx0XHRoYXNoW2sua2V5LnN5bWJvbF0gPSBrLnZhbHVlIGlmIGsgaXNhIE9iakF0dHJcblx0XHRyZXR1cm4gaGFzaFxuXHRcdCMgcmV0dXJuIGsgaWYgay5rZXkuc3ltYm9sID09IGtleVxuXG5cdCMgYWRkIG1ldGhvZCBmb3IgZmluZGluZyBwcm9wZXJ0aWVzIGV0Yz9cblx0ZGVmIGtleSBrZXlcblx0XHRmb3IgayBpbiB2YWx1ZVxuXHRcdFx0cmV0dXJuIGsgaWYgayBpc2EgT2JqQXR0ciBhbmQgay5rZXkuc3ltYm9sID09IGtleVxuXHRcdG51bGxcblxuXHRkZWYgaW5kZW50ZWQgYSxiXG5cdFx0QHZhbHVlLmluZGVudGVkKGEsYilcblx0XHRzZWxmXG5cblx0ZGVmIGhhc1NpZGVFZmZlY3RzXG5cdFx0dmFsdWUuc29tZSh8dnwgdi5oYXNTaWRlRWZmZWN0cyApXG5cblx0IyBmb3IgY29udmVydGluZyBhIHJlYWwgb2JqZWN0IGludG8gYW4gYXN0LXJlcHJlc2VudGF0aW9uXG5cdGRlZiBzZWxmLndyYXAgb2JqXG5cdFx0dmFyIGF0dHJzID0gW11cblx0XHRmb3Igb3duIGssdiBvZiBvYmpcblx0XHRcdGlmIHYgaXNhIEFycmF5XG5cdFx0XHRcdHYgPSBBcnIud3JhcCh2KVxuXHRcdFx0ZWxpZiB2OmNvbnN0cnVjdG9yID09IE9iamVjdFxuXHRcdFx0XHR2ID0gT2JqLndyYXAodilcblx0XHRcdGF0dHJzLnB1c2goT2JqQXR0ci5uZXcoayx2KSlcblx0XHRyZXR1cm4gT2JqLm5ldyhhdHRycylcblxuXHRkZWYgdG9TdHJpbmdcblx0XHRcIk9ialwiXG5cbmV4cG9ydCBjbGFzcyBPYmpBdHRyIDwgTm9kZVxuXG5cdHByb3Aga2V5XG5cdHByb3AgdmFsdWVcblx0cHJvcCBvcHRpb25zXG5cblx0ZGVmIGluaXRpYWxpemUga2V5LCB2YWx1ZVxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBrZXkgPSBrZXlcblx0XHRAdmFsdWUgPSB2YWx1ZVxuXHRcdEBkeW5hbWljID0ga2V5IGlzYSBPcFxuXHRcdHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHQjIHNob3VsZCBwcm9iYWJseSB0cmF2ZXJzZSBrZXkgYXMgd2VsbCwgdW5sZXNzIGl0IGlzIGEgZGVhZCBzaW1wbGUgaWRlbnRpZmllclxuXHRcdGtleS50cmF2ZXJzZVxuXHRcdHZhbHVlLnRyYXZlcnNlXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgayA9IGtleS5pc1Jlc2VydmVkID8gXCIne2tleS5jfSdcIiA6IGtleS5jXG5cdFx0XCJ7a306IHt2YWx1ZS5jfVwiXG5cblx0ZGVmIGhhc1NpZGVFZmZlY3RzXG5cdFx0dHJ1ZVxuXG5cblxuZXhwb3J0IGNsYXNzIEFyZ3NSZWZlcmVuY2UgPCBOb2RlXG5cblx0IyBzaG91bGQgcmVnaXN0ZXIgaW4gdGhpcyBzY29wZSAtLVxuXHRkZWYgY1xuXHRcdFwiYXJndW1lbnRzXCJcblxuIyBzaG91bGQgYmUgYSBzZXBhcmF0ZSBDb250ZXh0IG9yIHNvbWV0aGluZ1xuZXhwb3J0IGNsYXNzIFNlbGYgPCBMaXRlcmFsXG5cblx0ZGVmIGluaXRpYWxpemUgdmFsdWVcblx0XHRAdmFsdWUgPSB2YWx1ZVxuXG5cdGRlZiBjYWNoZVxuXHRcdHNlbGZcblxuXHRkZWYgcmVmZXJlbmNlXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHRzY29wZV9fLmNvbnRleHRcblx0XHRzZWxmXG5cblx0ZGVmIGNcblx0XHR2YXIgcyA9IHNjb3BlX19cblx0XHQocyA/IHMuY29udGV4dC5jIDogXCJ0aGlzXCIpXG5cbmV4cG9ydCBjbGFzcyBJbXBsaWNpdFNlbGYgPCBTZWxmXG5cbmV4cG9ydCBjbGFzcyBUaGlzIDwgU2VsZlxuXG5cdGRlZiBjYWNoZVxuXHRcdHNlbGZcblxuXHRkZWYgcmVmZXJlbmNlXG5cdFx0c2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcdHNlbGZcblxuXHRkZWYgY1xuXHRcdFwidGhpc1wiXG5cblxuXG5cbiMgT1BFUkFUT1JTXG5cbmV4cG9ydCBjbGFzcyBPcCA8IE5vZGVcblxuXHRwcm9wIG9wXG5cdHByb3AgbGVmdFxuXHRwcm9wIHJpZ2h0XG5cblx0ZGVmIGluaXRpYWxpemUgbywgbCwgclxuXHRcdCMgc2V0IGV4cHJlc3Npb24geWVzLCBubz9cblx0XHRAZXhwcmVzc2lvbiA9IG5vXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHBhcmVucyA9IG5vXG5cdFx0QGNhY2hlID0gbnVsbFxuXHRcdEBpbnZlcnQgPSBub1xuXHRcdEBvcFRva2VuID0gb1xuXHRcdEBvcCA9IG8gYW5kIG8uQHZhbHVlIG9yIG9cblx0XHRcblx0XHRpZiBAb3AgPT0gJ2FuZCdcblx0XHRcdEBvcCA9ICcmJidcblx0XHRlbGlmIEBvcCA9PSAnb3InXG5cdFx0XHRAb3AgPSAnfHwnXG5cdFx0ZWxpZiBAb3AgPT0gJ2lzJ1xuXHRcdFx0QG9wID0gJz09J1xuXHRcdGVsaWYgQG9wID09ICdpc250J1xuXHRcdFx0QG9wID0gJyE9J1xuXHRcdFxuXHRcdFx0XG5cdFx0QGxlZnQgPSBsXG5cdFx0QHJpZ2h0ID0gclxuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIHZpc2l0XG5cdFx0QHJpZ2h0LnRyYXZlcnNlIGlmIEByaWdodFxuXHRcdEBsZWZ0LnRyYXZlcnNlIGlmIEBsZWZ0XG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdCMgd2hhdCBpZiByaWdodCBpcyBhIHN0cmluZz8hP1xuXHRcdCFyaWdodCB8fCByaWdodC5pc0V4cHJlc3NhYmxlXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgb3V0ID0gbnVsbFxuXHRcdHZhciBvcCA9IEBvcFxuXG5cdFx0dmFyIGwgPSBAbGVmdFxuXHRcdHZhciByID0gQHJpZ2h0XG5cblx0XHRsID0gbC5jIGlmIGwgaXNhIE5vZGVcblx0XHRyID0gci5jIGlmIHIgaXNhIE5vZGVcblxuXHRcdGlmIGwgJiYgclxuXHRcdFx0b3V0ID0gXCJ7bH0ge21hcmtfXyhAb3BUb2tlbil9e29wfSB7cn1cIlxuXHRcdGVsaWYgbFxuXHRcdFx0b3V0ID0gXCJ7bWFya19fKEBvcFRva2VuKX17b3B9e2x9XCJcblx0XHQjIG91dCA9IG91dC5wYXJlbnRoZXNpemUgaWYgdXAgaXNhIE9wICMgcmVhbGx5P1xuXHRcdG91dFxuXG5cdGRlZiBzaG91bGRQYXJlbnRoZXNpemVcblx0XHRAcGFyZW5zXG5cdFx0IyBvcHRpb24oOnBhcmVucylcblxuXHRkZWYgcHJlY2VkZW5jZVxuXHRcdDEwXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdCMgaWYgaXQgaXMgcG9zc2libGUsIGNvbnZlcnQgaW50byBleHByZXNzaW9uXG5cdFx0aWYgbm9kZSBpc2EgVGFnVHJlZVxuXHRcdFx0QGxlZnQuY29uc3VtZShub2RlKSBpZiBAbGVmdFxuXHRcdFx0QHJpZ2h0LmNvbnN1bWUobm9kZSkgaWYgQHJpZ2h0XG5cdFx0XHQjIEBib2R5ID0gQGJvZHkuY29uc3VtZShub2RlKVxuXHRcdFx0IyBAYWx0ID0gQGFsdC5jb25zdW1lKG5vZGUpIGlmIEBhbHRcblx0XHRcdHJldHVybiBzZWxmXG5cdFx0cmV0dXJuIHN1cGVyIGlmIGlzRXhwcmVzc2FibGVcblxuXHRcdCMgVE9ETyBjYW4gcmF0aGVyIHVzZSBnbG9iYWwgY2FjaGluZz9cblx0XHR2YXIgdG1wdmFyID0gc2NvcGVfXy5kZWNsYXJlKDp0bXAsbnVsbCxzeXN0ZW06IHllcylcblx0XHR2YXIgY2xvbmUgPSBPUChvcCxsZWZ0LG51bGwpXG5cdFx0dmFyIGFzdCA9IHJpZ2h0LmNvbnN1bWUoY2xvbmUpXG5cdFx0YXN0LmNvbnN1bWUobm9kZSkgaWYgbm9kZVxuXHRcdHJldHVybiBhc3RcblxuZXhwb3J0IGNsYXNzIENvbXBhcmlzb25PcCA8IE9wXG5cblx0ZGVmIGludmVydFxuXHRcdCMgYXJlIHRoZXJlIG90aGVyIGNvbXBhcmlzb24gb3BzP1xuXHRcdCMgd2hhdCBhYm91dCBhIGNoYWluP1xuXHRcdHZhciBvcCA9IEBvcFxuXHRcdHZhciBwYWlycyA9IFsgXCI9PVwiLFwiIT1cIiAsIFwiPT09XCIsXCIhPT1cIiAsIFwiPlwiLFwiPD1cIiAsIFwiPFwiLFwiPj1cIiBdXG5cdFx0dmFyIGlkeCA9IHBhaXJzLmluZGV4T2Yob3ApXG5cdFx0aWR4ICs9IChpZHggJSAyID8gLTEgOiAxKVxuXHRcdHNlbGYub3AgPSBwYWlyc1tpZHhdXG5cdFx0QGludmVydCA9ICFAaW52ZXJ0XG5cdFx0c2VsZlxuXG5cdGRlZiBjXG5cdFx0aWYgbGVmdCBpc2EgQ29tcGFyaXNvbk9wXG5cdFx0XHRsZWZ0LnJpZ2h0LmNhY2hlXG5cdFx0XHRPUCgnJiYnLGxlZnQsT1Aob3AsbGVmdC5yaWdodCxyaWdodCkpLmNcblx0XHRlbHNlXG5cdFx0XHRzdXBlclxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIG9wID0gQG9wXG5cdFx0dmFyIGwgPSBAbGVmdFxuXHRcdHZhciByID0gQHJpZ2h0XG5cblx0XHRsID0gbC5jIGlmIGwgaXNhIE5vZGVcblx0XHRyID0gci5jIGlmIHIgaXNhIE5vZGVcblx0XHRyZXR1cm4gXCJ7bH0ge21hcmtfXyhAb3BUb2tlbil9e29wfSB7cn1cIlxuXG5cbmV4cG9ydCBjbGFzcyBNYXRoT3AgPCBPcFxuXHQjIEJVRyBpZiB3ZSBoYXZlIGEgc3RhdGVtZW50IGluIGxlZnQgb3IgcmlnaHQgd2UgbmVlZFxuXHQjIHRvIEZPUkNFIGl0IGludG8gYW4gZXhwcmVzc2lvbiwgYW5kIHJlZ2lzdGVyIHdhcm5pbmdcblx0IyBzaG91bGQgbm90IGF0IGFsbCBjb25zdW1lIGFueXRoaW5nIGxpa2UgYSByZWd1bGFyIE9wXG5cdGRlZiBjXG5cdFx0aWYgb3AgPT0gJ+KIqidcblx0XHRcdHJldHVybiB1dGlsLnVuaW9uKGxlZnQscmlnaHQpLmNcblx0XHRlbGlmIG9wID09ICfiiKknXG5cdFx0XHRyZXR1cm4gdXRpbC5pbnRlcnNlY3QobGVmdCxyaWdodCkuY1xuXG5cbmV4cG9ydCBjbGFzcyBVbmFyeU9wIDwgT3BcblxuXHRkZWYgaW52ZXJ0XG5cdFx0aWYgb3AgPT0gJyEnXG5cdFx0XHRyZXR1cm4gbGVmdFxuXHRcdGVsc2Vcblx0XHRcdHN1cGVyICMgcmVndWxhciBpbnZlcnRcblxuXHRkZWYgaXNUcnV0aHlcblx0XHR2YXIgdmFsID0gdHJ1dGh5X18obGVmdClcblx0XHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgPyAoIXZhbCkgOiAodW5kZWZpbmVkKVxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIGwgPSBAbGVmdFxuXHRcdHZhciByID0gQHJpZ2h0XG5cdFx0dmFyIG9wID0gb3BcblxuXHRcdGlmIG9wID09ICdub3QnXG5cdFx0XHRvcCA9ICchJ1xuXG5cdFx0aWYgb3AgPT0gJyEnXG5cdFx0XHQjIGwuQHBhcmVucyA9IHllc1xuXHRcdFx0dmFyIHN0ciA9IGwuY1xuXHRcdFx0dmFyIHBhcmVuID0gbC5zaG91bGRQYXJlbnRoZXNpemUoc2VsZilcblx0XHRcdCMgRklYTUUgdGhpcyBpcyBhIHZlcnkgaGFja3kgd29ya2Fyb3VuZC4gTmVlZCB0byBoYW5kbGUgYWxsIHRoaXNcblx0XHRcdCMgaW4gdGhlIGNoaWxkIGluc3RlYWQsIHByb2JsZW1zIGFyaXNlIGR1ZSB0byBhdXRvbWF0aWMgY2FjaGluZ1xuXHRcdFx0c3RyID0gJygnICsgc3RyICsgJyknIHVubGVzcyBzdHIubWF0Y2goL15cXCE/KFtcXHdcXC5dKykkLykgb3IgbCBpc2EgUGFyZW5zIG9yIHBhcmVuIG9yIGwgaXNhIEFjY2VzcyBvciBsIGlzYSBDYWxsXG5cdFx0XHQjIGwuc2V0KHBhcmVuczogeWVzKSAjIHN1cmU/XG5cdFx0XHRcIntvcH17c3RyfVwiXG5cblx0XHRlbGlmIG9wID09ICfiiJonXG5cdFx0XHRcIk1hdGguc3FydCh7bC5jfSlcIlxuXG5cdFx0ZWxpZiBsZWZ0XG5cdFx0XHRcIntsLmN9e29wfVwiXG5cblx0XHRlbHNlXG5cdFx0XHRcIntvcH17ci5jfVwiXG5cblx0ZGVmIG5vcm1hbGl6ZVxuXHRcdHJldHVybiBzZWxmIGlmIG9wID09ICchJyBvciBvcCA9PSAn4oiaJ1xuXHRcdHZhciBub2RlID0gKGxlZnQgfHwgcmlnaHQpLm5vZGVcblx0XHQjIGZvciBwcm9wZXJ0eS1hY2Nlc3NvcnMgd2UgbmVlZCB0byByZXdyaXRlIHRoZSBhc3Rcblx0XHRyZXR1cm4gc2VsZiB1bmxlc3Mgbm9kZSBpc2EgUHJvcGVydHlBY2Nlc3NcblxuXHRcdCMgYXNrIHRvIGNhY2hlIHRoZSBwYXRoXG5cdFx0bm9kZS5sZWZ0LmNhY2hlIGlmIG5vZGUgaXNhIEFjY2VzcyAmJiBub2RlLmxlZnRcblxuXHRcdHZhciBudW0gPSBOdW0ubmV3KDEpXG5cdFx0dmFyIGFzdCA9IE9QKCc9Jyxub2RlLE9QKG9wWzBdLG5vZGUsbnVtKSlcblx0XHRhc3QgPSBPUChvcFswXSA9PSAnLScgPyAnKycgOiAnLScsYXN0LG51bSkgaWYgbGVmdFxuXG5cdFx0cmV0dXJuIGFzdFxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHR2YXIgbm9ybSA9IG5vcm1hbGl6ZVxuXHRcdG5vcm0gPT0gc2VsZiA/IHN1cGVyIDogbm9ybS5jb25zdW1lKG5vZGUpXG5cblx0ZGVmIGNcblx0XHR2YXIgbm9ybSA9IG5vcm1hbGl6ZVxuXHRcdG5vcm0gPT0gc2VsZiA/IHN1cGVyIDogbm9ybS5jXG5cbmV4cG9ydCBjbGFzcyBJbnN0YW5jZU9mIDwgT3BcblxuXHRkZWYganMgb1xuXHRcdCMgZml4IGNoZWNrcyBmb3IgU3RyaW5nIGFuZCBOdW1iZXJcblxuXHRcdGlmIHJpZ2h0IGlzYSBDb25zdFxuXHRcdFx0IyBXQVJOIG90aGVyd2lzZSAtIHdoYXQgZG8gd2UgZG8/IGRvZXMgbm90IHdvcmsgd2l0aCBkeW5hbWljXG5cdFx0XHQjIGNsYXNzZXMgZXRjPyBTaG91bGQgcHJvYmFibHkgc2VuZCB0byB1dGlsaXR5IGZ1bmN0aW9uIGlzYSRcblx0XHRcdHZhciBuYW1lID0gY19fKHJpZ2h0LnZhbHVlKVxuXHRcdFx0dmFyIG9iaiA9IGxlZnQubm9kZVxuXHRcdFx0IyBUT0RPIGFsc28gY2hlY2sgZm9yIHByaW1pdGl2ZS1jb25zdHJ1Y3RvclxuXHRcdFx0aWYgbmFtZSBpbiBbJ1N0cmluZycsJ051bWJlcicsJ0Jvb2xlYW4nXVxuXHRcdFx0XHR1bmxlc3Mgb2JqIGlzYSBMb2NhbFZhckFjY2Vzc1xuXHRcdFx0XHRcdG9iai5jYWNoZVxuXHRcdFx0XHQjIG5lZWQgYSBkb3VibGUgY2hlY2sgZm9yIHRoZXNlIChjYWNoZSBsZWZ0KSAtIHBvc3NpYmx5XG5cdFx0XHRcdHJldHVybiBcIih0eXBlb2Yge29iai5jfT09J3tuYW1lLnRvTG93ZXJDYXNlfSd8fHtvYmouY30gaW5zdGFuY2VvZiB7bmFtZX0pXCJcblxuXHRcdFx0XHQjIGNvbnZlcnRcblx0XHR2YXIgb3V0ID0gXCJ7bGVmdC5jfSBpbnN0YW5jZW9mIHtyaWdodC5jfVwiXG5cblx0XHQjIHNob3VsZCB0aGlzIG5vdCBoYXBwZW4gaW4gI2M/XG5cdFx0b3V0ID0gaGVscGVycy5wYXJlbnRoZXNpemUob3V0KSBpZiBvLnBhcmVudCBpc2EgT3Bcblx0XHRvdXRcblxuZXhwb3J0IGNsYXNzIFR5cGVPZiA8IE9wXG5cblx0ZGVmIGpzIG9cblx0XHRcInR5cGVvZiB7bGVmdC5jfVwiXG5cbmV4cG9ydCBjbGFzcyBEZWxldGUgPCBPcFxuXG5cdGRlZiBqcyBvXG5cdFx0IyBUT0RPIHRoaXMgd2lsbCBleGVjdXRlIGNhbGxzIHNldmVyYWwgdGltZXMgaWYgdGhlIHBhdGggaXMgbm90IGRpcmVjdGx5IHRvIGFuIG9iamVjdFxuXHRcdCMgbmVlZCB0byBjYWNoZSB0aGUgcmVjZWl2ZXJcblx0XHR2YXIgbCA9IGxlZnRcblx0XHR2YXIgdG1wID0gc2NvcGVfXy50ZW1wb3Jhcnkoc2VsZiwgcG9vbDogJ3ZhbCcpXG5cdFx0dmFyIG8gPSBPUCgnPScsdG1wLGwpXG5cdFx0IyBGSVhNRVxuXHRcdHJldHVybiBcIih7by5jfSxkZWxldGUge2wuY30sIHt0bXAuY30pXCIgIyBvaCB3ZWxsXG5cdFx0IyB2YXIgYXN0ID0gW09QKCc9Jyx0bXAsbGVmdCksXCJkZWxldGUge2xlZnQuY31cIix0bXBdXG5cdFx0IyBzaG91bGQgcGFyZW50aGVzaXplIGRpcmVjdGx5IG5vP1xuXHRcdCMgYXN0LmNcblxuXHRkZWYgc2hvdWxkUGFyZW50aGVzaXplXG5cdFx0eWVzXG5cbmV4cG9ydCBjbGFzcyBJbiA8IE9wXG5cblx0ZGVmIGludmVydFxuXHRcdEBpbnZlcnQgPSAhQGludmVydFxuXHRcdHNlbGZcblxuXHRkZWYganMgb1xuXHRcdHZhciBjb25kID0gQGludmVydCA/IFwiPT0gLTFcIiA6IFwiPj0gMFwiXG5cdFx0dmFyIGlkeCA9IFV0aWwuaW5kZXhPZihsZWZ0LHJpZ2h0KVxuXHRcdFwie2lkeC5jfSB7Y29uZH1cIlxuXG5cblxuIyBBQ0NFU1NcblxuZXhwb3J0IGNsYXNzIEFjY2VzcyA8IE9wXG5cblx0ZGVmIGluaXRpYWxpemUgbywgbCwgclxuXHRcdCMgc2V0IGV4cHJlc3Npb24geWVzLCBubz9cblx0XHRAZXhwcmVzc2lvbiA9IG5vXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHBhcmVucyA9IG5vXG5cdFx0QGNhY2hlID0gbnVsbFxuXHRcdEBpbnZlcnQgPSBub1xuXHRcdEBvcCA9IG8gYW5kIG8uQHZhbHVlIG9yIG9cblx0XHRAbGVmdCA9IGxcblx0XHRAcmlnaHQgPSByXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgY2xvbmUgbGVmdCwgcmlnaHRcblx0XHR2YXIgY3RvciA9IHNlbGY6Y29uc3RydWN0b3Jcblx0XHRjdG9yLm5ldyhvcCxsZWZ0LHJpZ2h0KVxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIHJhdyA9IG51bGxcblx0XHR2YXIgcmd0ID0gcmlnaHRcblx0XHR2YXIgY3R4ID0gKGxlZnQgfHwgc2NvcGVfXy5jb250ZXh0KVxuXHRcdHZhciBwcmUgPSBcIlwiXG5cdFx0dmFyIG1hcmsgPSAnJ1xuXG5cdFx0IyBpZiBzYWZlY2hhaW5cblx0XHQjXHRwIFwiQWNjZXNzIGlzIHNhZmVjaGFpbmVkIHtyZ3QuY31cIlxuXG5cblx0XHRpZiByZ3QgaXNhIE51bVxuXHRcdFx0cmV0dXJuIGN0eC5jICsgXCJbXCIgKyByZ3QuYyArIFwiXVwiXG5cblx0XHQjIGlzIHRoaXMgcmlnaHQ/IFNob3VsZCBub3QgdGhlIGluZGV4IGNvbXBpbGUgdGhlIGJyYWNrZXRzXG5cdFx0IyBvciB2YWx1ZSBpcyBhIHN5bWJvbCAtLSBzaG91bGQgYmUgdGhlIHNhbWUsIG5vP1xuXHRcdGlmIHJndCBpc2EgSW5kZXggYW5kIChyZ3QudmFsdWUgaXNhIFN0ciBvciByZ3QudmFsdWUgaXNhIFN5bWJvbClcblx0XHRcdHJndCA9IHJndC52YWx1ZVxuXG5cdFx0IyBUT0RPIGRvIHRoZSBpZGVudGlmaWVyLXZhbGlkYXRpb24gaW4gYSBjZW50cmFsIHBsYWNlIGluc3RlYWRcblx0XHRpZiByZ3QgaXNhIFN0ciBhbmQgcmd0LmlzVmFsaWRJZGVudGlmaWVyXG5cdFx0XHRyYXcgPSByZ3QucmF3XG5cblx0XHRlbGlmIHJndCBpc2EgU3ltYm9sIGFuZCByZ3QuaXNWYWxpZElkZW50aWZpZXJcblx0XHRcdHJhdyA9IHJndC5yYXdcblxuXHRcdGVsaWYgcmd0IGlzYSBJZGVudGlmaWVyIGFuZCByZ3QuaXNWYWxpZElkZW50aWZpZXJcblx0XHRcdG1hcmsgPSBtYXJrX18ocmd0LkB2YWx1ZSlcblx0XHRcdHJhdyA9IHJndC5jXG5cblx0XHRpZiBzYWZlY2hhaW4gYW5kIGN0eFxuXHRcdFx0Y3R4LmNhY2hlKGZvcmNlOiB5ZXMpXG5cdFx0XHRwcmUgPSBjdHguYyArIFwiICYmIFwiXG5cblx0XHQjIHJlYWxseT9cblx0XHQjIHZhciBjdHggPSAobGVmdCB8fCBzY29wZV9fLmNvbnRleHQpXG5cdFx0dmFyIG91dCA9IGlmIHJhd1xuXHRcdFx0IyBzZWUgaWYgaXQgbmVlZHMgcXVvdGluZ1xuXHRcdFx0IyBuZWVkIHRvIGNoZWNrIHRvIHNlZSBpZiBpdCBpcyBsZWdhbFxuXHRcdFx0Y3R4ID8gXCJ7Y3R4LmN9LnttYXJrfXtyYXd9XCIgOiByYXdcblx0XHRlbHNlXG5cdFx0XHR2YXIgciA9IHJndCBpc2EgTm9kZSA/IHJndC5jKGV4cHJlc3Npb246IHllcykgOiByZ3Rcblx0XHRcdFwie2N0eC5jfVt7cn1dXCJcblxuXHRcdCMgaWYgc2FmZWNoYWluIGFuZCBjdHhcblx0XHQjIFx0b3V0ID0gXCJ7Y3R4LmN9ICYmIHtvdXR9XCJcblxuXHRcdHJldHVybiBwcmUgKyBvdXRcblxuXHRkZWYgdmlzaXRcblx0XHRsZWZ0LnRyYXZlcnNlIGlmIGxlZnRcblx0XHRyaWdodC50cmF2ZXJzZSBpZiByaWdodFxuXHRcdHJldHVyblxuXG5cdGRlZiBpc0V4cHJlc3NhYmxlXG5cdFx0dHJ1ZVxuXG5cdGRlZiBhbGlhc1xuXHRcdHJpZ2h0IGlzYSBJZGVudGlmaWVyID8gcmlnaHQuYWxpYXMgOiBzdXBlcigpXG5cblx0ZGVmIHNhZmVjaGFpblxuXHRcdCMgcmlnaHQuc2FmZWNoYWluXG5cdFx0U3RyaW5nKEBvcCkgPT0gJz8uJyBvciBTdHJpbmcoQG9wKSA9PSAnPzonXG5cblx0ZGVmIGNhY2hlIG9cblx0XHQocmlnaHQgaXNhIEl2YXIgJiYgIWxlZnQpID8gc2VsZiA6IHN1cGVyKG8pXG5cblx0ZGVmIHNob3VsZFBhcmVudGhlc2l6ZUluVGVybmFyeVxuXHRcdEBwYXJlbnMgb3IgQGNhY2hlXG5cblxuIyBTaG91bGQgY2hhbmdlIHRoaXMgdG8ganVzdCByZWZlciBkaXJlY3RseSB0byB0aGUgdmFyaWFibGU/IE9yIFZhclJlZmVyZW5jZVxuZXhwb3J0IGNsYXNzIExvY2FsVmFyQWNjZXNzIDwgQWNjZXNzXG5cblx0cHJvcCBzYWZlY2hhaW5cblxuXHRkZWYganMgb1xuXHRcdGlmIHJpZ2h0IGlzYSBWYXJpYWJsZSBhbmQgcmlnaHQudHlwZSA9PSAnbWV0aCdcblx0XHRcdHJldHVybiBcIntyaWdodC5jfSgpXCIgdW5sZXNzIHVwIGlzYSBDYWxsXG5cblx0XHRyaWdodC5jXG5cblx0ZGVmIHZhcmlhYmxlXG5cdFx0cmlnaHRcblxuXHRkZWYgY2FjaGUgbyA9IHt9XG5cdFx0c3VwZXIobykgaWYgbzpmb3JjZVxuXHRcdHNlbGZcblxuXHRkZWYgYWxpYXNcblx0XHR2YXJpYWJsZS5AYWxpYXMgb3Igc3VwZXIoKVxuXG5cbmV4cG9ydCBjbGFzcyBHbG9iYWxWYXJBY2Nlc3MgPCBWYWx1ZU5vZGVcblxuXHRkZWYganMgb1xuXHRcdHZhbHVlLmNcblxuXG5leHBvcnQgY2xhc3MgT2JqZWN0QWNjZXNzIDwgQWNjZXNzXG5cblxuZXhwb3J0IGNsYXNzIFByb3BlcnR5QWNjZXNzIDwgQWNjZXNzXG5cblx0ZGVmIGluaXRpYWxpemUgbywgbCwgclxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBpbnZlcnQgPSBub1xuXHRcdEBwYXJlbnMgPSBub1xuXHRcdEBleHByZXNzaW9uID0gbm8gIyB5ZXM/XG5cdFx0QGNhY2hlID0gbnVsbFxuXHRcdEBvcCA9IG9cblx0XHRAbGVmdCA9IGxcblx0XHRAcmlnaHQgPSByXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHRAcmlnaHQudHJhdmVyc2UgaWYgQHJpZ2h0XG5cdFx0QGxlZnQudHJhdmVyc2UgaWYgQGxlZnRcblx0XHRyZXR1cm4gc2VsZlxuXG5cdCMgcmlnaHQgaW4gYyB3ZSBzaG91bGQgcG9zc2libHkgb3ZlcnJpZGVcblx0IyB0byBjcmVhdGUgYSBjYWxsIGFuZCByZWd1bGFyIGFjY2VzcyBpbnN0ZWFkXG5cblx0ZGVmIGpzIG9cblxuXHRcdGlmIHZhciByZWMgPSByZWNlaXZlclxuXHRcdFx0dmFyIGFzdCA9IENBTEwoT1AoJy4nLGxlZnQscmlnaHQpLFtdKSAjIGNvbnZlcnQgdG8gQXJnTGlzdCBvciBudWxsXG5cdFx0XHRhc3QucmVjZWl2ZXIgPSByZWNcblx0XHRcdHJldHVybiBhc3QuY1xuXG5cdFx0dmFyIHVwID0gdXBcblxuXHRcdHVubGVzcyB1cCBpc2EgQ2FsbFxuXHRcdFx0dmFyIGFzdCA9IENBTEwoQWNjZXNzLm5ldyhvcCxsZWZ0LHJpZ2h0KSxbXSlcblx0XHRcdHJldHVybiBhc3QuY1xuXG5cdFx0IyByZWFsbHkgbmVlZCB0byBmaXggdGhpcyAtIGZvciBzdXJlXG5cdFx0IyBzaG91bGQgYmUgcG9zc2libGUgZm9yIHRoZSBmdW5jdGlvbiB0byByZW1vdmUgdGhpcyB0aGlzIGluc3RlYWQ/XG5cdFx0dmFyIGpzID0gXCJ7c3VwZXIobyl9XCJcblxuXHRcdHVubGVzcyAodXAgaXNhIENhbGwgb3IgdXAgaXNhIFV0aWwuSXNGdW5jdGlvbilcblx0XHRcdGpzICs9IFwiKClcIlxuXG5cdFx0cmV0dXJuIGpzXG5cblxuXHRkZWYgcmVjZWl2ZXJcblx0XHRpZiBsZWZ0IGlzYSBTdXBlckFjY2VzcyB8fCBsZWZ0IGlzYSBTdXBlclxuXHRcdFx0U0VMRlxuXHRcdGVsc2Vcblx0XHRcdG51bGxcblxuXG5leHBvcnQgY2xhc3MgSXZhckFjY2VzcyA8IEFjY2Vzc1xuXG5cdGRlZiB2aXNpdFxuXHRcdEByaWdodC50cmF2ZXJzZSBpZiBAcmlnaHRcblx0XHRAbGVmdCA/IEBsZWZ0LnRyYXZlcnNlIDogc2NvcGVfXy5jb250ZXh0XG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgY2FjaGVcblx0XHQjIFdBUk4gaG1tLCB0aGlzIGlzIG5vdCByaWdodC4uLiB3aGVuIGFjY2Vzc2luZyBvbiBhbm90aGVyIG9iamVjdCBpdCB3aWxsIG5lZWQgdG8gYmUgY2FjaGVkXG5cdFx0cmV0dXJuIHNlbGZcblxuXG5leHBvcnQgY2xhc3MgQ29uc3RBY2Nlc3MgPCBBY2Nlc3NcblxuXG5leHBvcnQgY2xhc3MgSW5kZXhBY2Nlc3MgPCBBY2Nlc3NcblxuXHRkZWYgY2FjaGUgbyA9IHt9XG5cdFx0cmV0dXJuIHN1cGVyIGlmIG86Zm9yY2Vcblx0XHRyaWdodC5jYWNoZVxuXHRcdHNlbGZcblxuXG5leHBvcnQgY2xhc3MgU3VwZXJBY2Nlc3MgPCBBY2Nlc3NcblxuXHRkZWYganMgb1xuXHRcdHZhciBtID0gby5tZXRob2Rcblx0XHR2YXIgdXAgPSBvLnBhcmVudFxuXHRcdHZhciBkZWVwID0gby5wYXJlbnQgaXNhIEFjY2Vzc1xuXG5cdFx0dmFyIG91dCA9IFwie2xlZnQuY30uX19zdXBlcl9fXCJcblxuXHRcdHVubGVzcyB1cCBpc2EgQWNjZXNzXG5cdFx0XHRvdXQgKz0gXCIue20uc3VwZXJuYW1lLmN9XCJcblx0XHRcdHVubGVzcyB1cCBpc2EgQ2FsbCAjIGF1dG9jYWxsP1xuXHRcdFx0XHRvdXQgKz0gXCIuYXBwbHkoe20uc2NvcGUuY29udGV4dC5jfSxhcmd1bWVudHMpXCJcblxuXHRcdHJldHVybiBvdXRcblxuXHRkZWYgcmVjZWl2ZXJcblx0XHRTRUxGXG5cblxuZXhwb3J0IGNsYXNzIFZhck9yQWNjZXNzIDwgVmFsdWVOb2RlXG5cblx0ZGVmIGluaXRpYWxpemUgdmFsdWVcblx0XHQjIHNob3VsZCByYXRoZXIgY2FsbCB1cCB0byB2YWx1ZW5vZGU/XG5cdFx0QHRyYXZlcnNlZCBcdD0gbm9cblx0XHRAcGFyZW5zIFx0PSBub1xuXHRcdEB2YWx1ZSBcdFx0PSB2YWx1ZVxuXHRcdEBpZGVudGlmaWVyID0gdmFsdWVcblx0XHRAdG9rZW4gXHRcdD0gdmFsdWUuQHZhbHVlXG5cdFx0QHZhcmlhYmxlID0gbnVsbFxuXHRcdHNlbGZcblxuXHQjIFNob3J0Y2lyY3VpdCB0cmF2ZXJzZSBzbyB0aGF0IGl0IGlzIG5vdCBhZGRlZCB0byB0aGUgc3RhY2s/IVxuXHRkZWYgdmlzaXRcblx0XHQjIEBpZGVudGlmaWVyID0gdmFsdWUgIyB0aGlzIGlzIG5vdCBhIHJlYWwgaWRlbnRpZmllcj9cblx0XHQjIGNvbnNvbGUubG9nIFwiVmFyT3JBY2Nlc3Mge0BpZGVudGlmaWVyfVwiXG5cblxuXHRcdHZhciBzY29wZSA9IHNjb3BlX19cblxuXHRcdHZhciB2YXJpYWJsZSA9IHNjb3BlLmxvb2t1cCh2YWx1ZSlcblxuXHRcdCMgZG9lcyBub3QgcmVhbGx5IG5lZWQgdG8gaGF2ZSBhIGRlY2xhcmF0b3IgYWxyZWFkeT8gLS0gdHJpY2t5XG5cdFx0aWYgdmFyaWFibGUgJiYgdmFyaWFibGUuZGVjbGFyYXRvclxuXHRcdFx0IyB2YXIgZGVjbCA9IHZhcmlhYmxlLmRlY2xhcmF0b3JcblxuXHRcdFx0IyBpZiB0aGUgdmFyaWFibGUgaXMgbm90IGluaXRpYWxpemVkIGp1c3QgeWV0IGFuZCB3ZSBhcmVcblx0XHRcdCMgaW4gdGhlIHNhbWUgc2NvcGUgLSB3ZSBzaG91bGQgbm90IHRyZWF0IHRoaXMgYXMgYSB2YXItbG9va3VwXG5cdFx0XHQjIGllLiAgdmFyIHggPSB4IHdvdWxkIHJlc29sdmUgdG8gdmFyIHggPSB0aGlzLngoKSBpZiB4XG5cdFx0XHQjIHdhcyBub3QgcHJldmlvdXNseSBkZWZpbmVkXG5cblx0XHRcdCMgc2hvdWxkIGRvIHRoaXMgZXZlbiBpZiB3ZSBhcmUgbm90IGluIHRoZSBzYW1lIHNjb3BlP1xuXHRcdFx0IyB3ZSBvbmx5IG5lZWQgdG8gYmUgaW4gdGhlIHNhbWUgY2xvc3VyZSghKVxuXG5cdFx0XHRpZiB2YXJpYWJsZS5AaW5pdGlhbGl6ZWQgb3IgKHNjb3BlLmNsb3N1cmUgIT0gdmFyaWFibGUuc2NvcGUuY2xvc3VyZSlcblx0XHRcdFx0QHZhcmlhYmxlID0gdmFyaWFibGVcblx0XHRcdFx0dmFyaWFibGUuYWRkUmVmZXJlbmNlKHNlbGYpXG5cdFx0XHRcdEB2YWx1ZSA9IHZhcmlhYmxlICMgdmFyaWFibGUuYWNjZXNzb3Ioc2VsZilcblx0XHRcdFx0QHRva2VuLkB2YXJpYWJsZSA9IHZhcmlhYmxlXG5cdFx0XHRcdHJldHVybiBzZWxmXG5cdFx0XHQjIEZJWFxuXHRcdFx0IyBAdmFsdWUuc2FmZWNoYWluID0gc2FmZWNoYWluXG5cblx0XHQjIFRPRE8gZGVwcmVjYXRlIGFuZCByZW1vdmVcblx0XHRpZiB2YWx1ZS5zeW1ib2wuaW5kZXhPZignJCcpID49IDBcblx0XHRcdCMgYmlnIGhhY2sgLSBzaG91bGQgZGlzYWJsZVxuXHRcdFx0IyBtYWpvciBoYWNrIGhlcmUsIG5vP1xuXHRcdFx0IyBjb25zb2xlLmxvZyBcIkdsb2JhbFZhckFjY2Vzc1wiXG5cdFx0XHRAdmFsdWUgPSBHbG9iYWxWYXJBY2Nlc3MubmV3KHZhbHVlKVxuXHRcdFx0cmV0dXJuIHNlbGZcblxuXHRcdCMgcmVhbGx5PyB3aGF0IGFib3V0IGp1c3QgbWltaWNraW5nIHRoZSB0d28gZGlmZnJlbnQgaW5zdGVhZD9cblx0XHQjIFNob3VsZCB3ZSBub3QgcmV0dXJuIGEgY2FsbCBkaXJlY3RseSBpbnN0ZWFkP1xuXHRcdEB2YWx1ZSA9IFByb3BlcnR5QWNjZXNzLm5ldyhcIi5cIixzY29wZS5jb250ZXh0LHZhbHVlKVxuXHRcdCMgbWFyayB0aGUgc2NvcGUgLyBjb250ZXh0IC0tIHNvIHdlIGNhbiBzaG93IGNvcnJlY3QgaW1wbGljaXRcblx0XHRAdG9rZW4uQG1ldGEgPSB7dHlwZTogJ0FDQ0VTUyd9XG5cdFx0IyBAdmFsdWUudHJhdmVyc2UgIyBuYWhcblx0XHRzZWxmXG5cblx0ZGVmIGNcblx0XHRtYXJrX18oQHRva2VuKSArIChAdmFyaWFibGUgPyBzdXBlcigpIDogdmFsdWUuYylcblxuXHRkZWYganMgb1xuXG5cdFx0aWYgdmFyIHYgPSBAdmFyaWFibGVcblx0XHRcdHZhciBvdXQgPSB2LmNcblx0XHRcdG91dCArPSBcIigpXCIgaWYgdi5AdHlwZSA9PSAnbWV0aCcgYW5kICEoby51cCBpc2EgQ2FsbClcblx0XHRcdHJldHVybiBvdXRcblx0XHRyZXR1cm4gXCJOT05PXCJcblxuXHRkZWYgbm9kZVxuXHRcdEB2YXJpYWJsZSA/IHNlbGYgOiB2YWx1ZVxuXG5cdGRlZiBzeW1ib2xcblx0XHRAaWRlbnRpZmllci5zeW1ib2xcblx0XHQjIHZhbHVlIGFuZCB2YWx1ZS5zeW1ib2xcblxuXHRkZWYgY2FjaGUgbyA9IHt9XG5cdFx0QHZhcmlhYmxlID8gKG86Zm9yY2UgYW5kIHN1cGVyKG8pKSA6IHZhbHVlLmNhY2hlKG8pXG5cblx0ZGVmIGRlY2FjaGVcblx0XHRAdmFyaWFibGUgPyBzdXBlcigpIDogdmFsdWUuZGVjYWNoZVxuXHRcdHNlbGZcblxuXHRkZWYgZG9tXG5cdFx0dmFsdWUuZG9tXG5cblx0ZGVmIHNhZmVjaGFpblxuXHRcdEBpZGVudGlmaWVyLnNhZmVjaGFpblxuXG5cdGRlZiBkdW1wXG5cdFx0eyBsb2M6IGxvYyB9XG5cblx0ZGVmIGxvY1xuXHRcdHZhciBsb2MgPSBAaWRlbnRpZmllci5yZWdpb25cblx0XHRyZXR1cm4gbG9jIG9yIFswLDBdXG5cblx0ZGVmIHJlZ2lvblxuXHRcdEBpZGVudGlmaWVyLnJlZ2lvblxuXG5cdGRlZiBzaG91bGRQYXJlbnRoZXNpemVJblRlcm5hcnlcblx0XHRAY2FjaGUgb3IgKEB2YWx1ZSBhbmQgQHZhbHVlLkBjYWNoZSkgb3IgQHBhcmVuc1xuXG5cdGRlZiB0b1N0cmluZ1xuXHRcdFwiVmFyT3JBY2Nlc3Moe3ZhbHVlfSlcIlxuXG5cdGRlZiB0b0pTT05cblx0XHR7dHlwZTogdHlwZU5hbWUsIHZhbHVlOiBAaWRlbnRpZmllci50b1N0cmluZ31cblxuI1x0ZGVmIGpzXG4jXHRcdGlmIHJpZ2h0IGlzYSBWYXJpYWJsZSBhbmQgcmlnaHQudHlwZSA9PSAnbWV0aCdcbiNcdFx0XHRyZXR1cm4gXCJ7cmlnaHQuY30oKVwiIHVubGVzcyB1cCBpc2EgQ2FsbFxuI1xuI1x0XHRyaWdodC5jXG4jXG4jXHRkZWYgdmFyaWFibGVcbiNcdFx0cmlnaHRcbiNcbiNcdGRlZiBjYWNoZSBvID0ge31cbiNcdFx0c3VwZXIgaWYgbzpmb3JjZVxuI1x0XHRzZWxmXG4jXG4jXHRkZWYgYWxpYXNcbiNcdFx0dmFyaWFibGUuQGFsaWFzIG9yIHN1cGVyICMgaWYgcmVzb2x2ZWQ/XG4jXG5cbmV4cG9ydCBjbGFzcyBWYXJSZWZlcmVuY2UgPCBWYWx1ZU5vZGVcblxuXHQjIFRPRE8gVmFyQmxvY2sgc2hvdWxkIGNvbnZlcnQgdGhlc2UgdG8gcGxhaW4gLyBkdW1iIG5vZGVzXG5cblx0cHJvcCB2YXJpYWJsZVxuXHRwcm9wIGRlY2xhcmVkXG5cdHByb3AgdHlwZVxuXG5cdGRlZiBpbml0aWFsaXplIHZhbHVlLCB0eXBlXG5cdFx0aWYgdmFsdWUgaXNhIFZhck9yQWNjZXNzXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnZhbHVlXG5cdFx0IyBmb3Igbm93IC0gdGhpcyBjYW4gaGFwcGVuXG5cdFx0c3VwZXIodmFsdWUpXG5cdFx0QGV4cG9ydCA9IG5vXG5cdFx0QHR5cGUgPSB0eXBlIGFuZCBTdHJpbmcodHlwZSlcblx0XHRAdmFyaWFibGUgPSBudWxsXG5cdFx0QGRlY2xhcmVkID0geWVzICMganVzdCB0ZXN0aW5nIG5vd1xuXG5cblx0ZGVmIGxvY1xuXHRcdEB2YWx1ZS5yZWdpb25cblxuXHRkZWYgc2V0IG9cblx0XHQjIGhhY2sgLSB3b3JrYXJvdW5kIGZvciBoaWRkZW4gY2xhc3NlcyBwZXJmXG5cdFx0QGV4cG9ydCA9IHllcyBpZiBvOmV4cG9ydFxuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIGpzIG9cblx0XHQjIGV4cGVyaW1lbnRhbCBmaXhcblxuXHRcdCMgd2hhdCBhYm91dCByZXNvbHZpbmc/XG5cdFx0dmFyIHJlZiA9IEB2YXJpYWJsZVxuXHRcdHZhciBvdXQgPSBcInttYXJrX18oQHZhbHVlKX17cmVmLmN9XCJcblxuXHRcdGlmIHJlZiAmJiAhcmVmLkBkZWNsYXJlZCAjIC5vcHRpb24oOmRlY2xhcmVkKVxuXHRcdFx0aWYgby51cChWYXJCbG9jaykgIyB1cCB2YXJibG9jaz8/XG5cdFx0XHRcdHJlZi5AZGVjbGFyZWQgPSB5ZXNcblxuXHRcdFx0XHQjIHJlZi5zZXQoZGVjbGFyZWQ6IHllcylcblx0XHRcdGVsaWYgby5pc0V4cHJlc3Npb24gb3IgQGV4cG9ydCAjIHdoeT9cblx0XHRcdFx0cmVmLmF1dG9kZWNsYXJlXG5cdFx0XHRlbHNlXG5cdFx0XHRcdG91dCA9IFwidmFyIHtvdXR9XCJcblx0XHRcdFx0cmVmLkBkZWNsYXJlZCA9IHllc1xuXHRcdFx0XHQjIHJlZi5zZXQoZGVjbGFyZWQ6IHllcylcblxuXHRcdCMgbmVlZCB0byB0aGluayB0aGUgZXhwb3J0IHRocm91Z2ggLS0gbGlrZSByZWdpc3RlcmluZyBzb21laG93XG5cdFx0IyBzaG91bGQgcmVnaXN0ZXIgaW4gc2NvcGUgLSBleHBvcnQgb24gYW5hbHlzaXMrK1xuXHRcdGlmIEBleHBvcnRcblx0XHRcdG91dCA9IFwibW9kdWxlLmV4cG9ydHMue3JlZi5jfSA9IHtyZWYuY31cIlxuXG5cdFx0cmV0dXJuIG91dFxuXG5cdGRlZiBkZWNsYXJlXG5cdFx0c2VsZlxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHQjIHJlYWxseT8gdGhlIGNvbnN1bWVkIG5vZGUgZGlzc2FwcGVhcj9cblx0XHRAdmFyaWFibGUgJiYgQHZhcmlhYmxlLmF1dG9kZWNsYXJlXG5cdFx0c2VsZlxuXG5cdGRlZiB2aXNpdFxuXG5cdFx0IyBjb25zb2xlLmxvZyBcInZhbHVlIHR5cGUgZm9yIFZhclJlZmVyZW5jZSB7QHZhbHVlfSB7QHZhbHVlLkBsb2N9IHtAdmFsdWU6Y29uc3RydWN0b3J9XCJcblxuXHRcdCMgc2hvdWxkIGJlIHBvc3NpYmxlIHRvIGhhdmUgYSBWYXJSZWZlcmVuY2Ugd2l0aG91dCBhIG5hbWUgYXMgd2VsbD8gZm9yIGEgc3lzdGVtLXZhcmlhYmxlXG5cdFx0IyBuYW1lIHNob3VsZCBub3Qgc2V0IHRoaXMgd2F5LlxuXHRcdHZhciBuYW1lID0gdmFsdWUuY1xuXG5cdFx0IyB3aGF0IGFib3V0IGxvb2tpbmcgdXA/IC0gb24gcmVnaXN0ZXIgd2Ugd2FudCB0byBtYXJrXG5cdFx0dmFyIHYgPSBAdmFyaWFibGUgfHw9IHNjb3BlX18ucmVnaXN0ZXIobmFtZSwgc2VsZiwgdHlwZTogQHR5cGUpXG5cdFx0IyBGSVhNRSAtLSBzaG91bGQgbm90IHNpbXBseSBvdmVycmlkZSB0aGUgZGVjbGFyYXRvciBoZXJlKCEpXG5cblx0XHRpZiAhdi5kZWNsYXJhdG9yXG5cdFx0XHR2LmRlY2xhcmF0b3IgPSBzZWxmXG5cblx0XHR2LmFkZFJlZmVyZW5jZShAdmFsdWUpIGlmIEB2YWx1ZSAjIGlzIHRoaXMgdGhlIGZpcnN0IHJlZmVyZW5jZT9cblxuXHRcdCMgb25seSBuZWVkZWQgd2hlbiBhbmFseXppbmc/XG5cdFx0QHZhbHVlLkB2YWx1ZS5AdmFyaWFibGUgPSB2XG5cdFx0c2VsZlxuXG5cdGRlZiByZWZuclxuXHRcdHZhcmlhYmxlLnJlZmVyZW5jZXMuaW5kZXhPZih2YWx1ZSlcblxuXHQjIGNvbnZlcnQgdGhpcyBpbnRvIGEgbGlzdCBvZiByZWZlcmVuY2VzXG5cdGRlZiBhZGRFeHByZXNzaW9uIGV4cHJcblx0XHRWYXJCbG9jay5uZXcoW3NlbGZdKS5hZGRFeHByZXNzaW9uKGV4cHIpXG5cblxuIyBBU1NJR05cblxuZXhwb3J0IGNsYXNzIEFzc2lnbiA8IE9wXG5cblx0ZGVmIGluaXRpYWxpemUgbywgbCwgclxuXG5cdFx0IyB3b3JrYXJvdW5kIHVudGlsIHdlIGNvbXBsZXRlIHRyYW5zaXRpb24gZnJvbSBsdWEtc3R5bGUgYXNzaWdubWVudHNcblx0XHQjIHRvIGFsd2F5cyB1c2UgZXhwbGljaXQgdHVwbGVzIC0gdGhlbiB3ZSBjYW4gbW92ZSBhc3NpZ25tZW50cyBvdXQgZXRjXG5cdFx0IyB0aGlzIHdpbGwgbm90IGJlIG5lZWRlZCBhZnRlciB3ZSByZW1vdmUgc3VwcG9ydCBmb3IgdmFyIGEsYixjID0gMSwyLDNcblx0XHRpZiBsIGlzYSBWYXJSZWZlcmVuY2UgYW5kIGwudmFsdWUgaXNhIEFyclxuXHRcdFx0IyBjb252ZXJ0aW5nIGFsbCBub2RlcyB0byB2YXItcmVmZXJlbmNlcyA/XG5cdFx0XHQjIGRvIHdlIG5lZWQgdG8ga2VlcCBpdCBpbiBhIHZhcmJsb2NrIGF0IGFsbD9cblx0XHRcdHZhciB2YXJzID0gbC52YWx1ZS5ub2Rlcy5tYXAgZG8gfHZ8XG5cdFx0XHRcdCMgd2hhdCBhYm91dCBpbm5lciB0dXBsZXMgZXRjP1xuXHRcdFx0XHQjIGtlZXAgdGhlIHNwbGF0cyAtLSBjbHVtc3kgYnV0IHRydWVcblx0XHRcdFx0aWYgdiBpc2EgU3BsYXRcblx0XHRcdFx0XHR2LnZhbHVlID0gVmFyUmVmZXJlbmNlLm5ldyh2LnZhbHVlLGwudHlwZSkgdW5sZXNzIHYudmFsdWUgaXNhIFZhclJlZmVyZW5jZVxuXHRcdFx0XHRlbGlmIHYgaXNhIFZhclJlZmVyZW5jZVxuXHRcdFx0XHRcdHRydWVcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdCMgd2hhdCBhYm91dCByZXRhaW5pbmcgbG9jYXRpb24/XG5cdFx0XHRcdFx0IyB2ID0gdi52YWx1ZSBpZiB2IGlzYSBWYXJPckFjY2Vzc1xuXHRcdFx0XHRcdHYgPSBWYXJSZWZlcmVuY2UubmV3KHYsbC50eXBlKVxuXG5cdFx0XHRcdHJldHVybiB2XG5cblx0XHRcdFx0IyB2IGlzYSBWYXJSZWZlcmVuY2UgPyB2IDogVmFyUmVmZXJlbmNlLm5ldyh2KVxuXG5cdFx0XHRyZXR1cm4gVHVwbGVBc3NpZ24ubmV3KG8sVHVwbGUubmV3KHZhcnMpLHIpXG5cblx0XHRpZiBsIGlzYSBBcnJcblx0XHRcdHJldHVybiBUdXBsZUFzc2lnbi5uZXcobyxUdXBsZS5uZXcobC5ub2RlcykscilcblxuXHRcdCMgc2V0IGV4cHJlc3Npb24geWVzLCBubz9cblx0XHRAZXhwcmVzc2lvbiA9IG5vXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHBhcmVucyA9IG5vXG5cdFx0QGNhY2hlID0gbnVsbFxuXHRcdEBpbnZlcnQgPSBub1xuXHRcdEBvcFRva2VuID0gb1xuXHRcdEBvcCA9IG8gYW5kIG8uQHZhbHVlIG9yIG9cblx0XHRAbGVmdCA9IGxcblx0XHRAcmlnaHQgPSByXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdCFyaWdodCB8fCByaWdodC5pc0V4cHJlc3NhYmxlXG5cblx0ZGVmIGlzVXNlZFxuXHRcdCMgcmVhbGx5P1xuXHRcdCMgaWYgdXAgaXMgYSBibG9jayBpbiBnZW5lcmFsIHRoaXMgc2hvdWxkIG5vdCBiZSB1c2VkIC0tIHNpbmNlIGl0IHNob3VsZCBhbHJlYWR5IGhhdmUgcmVjZWl2ZWQgaW1wbGljaXQgc2VsZj9cblx0XHRpZiB1cCBpc2EgQmxvY2sgIyAmJiB1cC5sYXN0ICE9IHNlbGZcblx0XHRcdHJldHVybiBub1xuXHRcdHJldHVybiB5ZXNcblxuXHQjIEZJWE1FIG9wdGltaXplXG5cdGRlZiB2aXNpdFxuXHRcdHZhciBsID0gQGxlZnRcblx0XHR2YXIgciA9IEByaWdodFxuXG5cdFx0IyBXQVJOSU5HIC0gc2xpZ2h0bHkgdW5kZWZpbmVkXG5cdFx0IyBNQVJLIFRIRSBTVEFDS1xuXHRcdGwudHJhdmVyc2UgaWYgbFxuXG5cdFx0dmFyIGx2YXIgPSBsIGlzYSBWYXJSZWZlcmVuY2UgYW5kIGwudmFyaWFibGVcblxuXHRcdCMgaG93IGRvZXMgdGhpcyB3b3JrIHdpdGggY29uc3RhbnRzIHRoYXQgYXJlIHJlYWxseSB2YXIgcmVmZXJlbmNlcz9cblx0XHQjIHNob3VsZCB3b3JrIHdoZW4gdGhpbmdzIGFyZSBub3QgZGVzY3JpYmVkIGFzIHdlbGwgLSBidXQgdGhpcyBpcyBmb3IgdGVzdGluZ1xuXHRcdCMgYnV0IGlmIGl0IHJlZmVycyB0byBzb21ldGhpbmcgZWxzZVxuXHRcdGlmICFsdmFyIGFuZCBAZGVzY1xuXHRcdFx0IyBlbnRpdGllcyBzaG91bGQgYmUgYWJsZSB0byBleHRyYWN0IHRoZSBuZWVkZWQgaW5mbyBpbnN0ZWFkXG5cdFx0XHRST09ULmVudGl0aWVzLmFkZChsLm5hbWVwYXRoLHtuYW1lcGF0aDogbC5uYW1lcGF0aCwgdHlwZTogci50eXBlTmFtZSwgZGVzYzogQGRlc2N9KVxuXG5cdFx0IyB0aGlzIHNob3VsZCBwcm9iYWJseSBiZSBkb25lIGluIGEgZGlmZmVyZW50IG1hbm5lclxuXHRcdGlmIGx2YXIgYW5kIGx2YXIuZGVjbGFyYXRvciA9PSBsXG5cdFx0XHRsdmFyLkBpbml0aWFsaXplZCA9IG5vXG5cdFx0XHRyLnRyYXZlcnNlIGlmIHJcblx0XHRcdGx2YXIuQGluaXRpYWxpemVkID0geWVzXG5cblx0XHRlbHNlXG5cdFx0XHRyLnRyYXZlcnNlIGlmIHJcblxuXHRcdGlmIGwgaXNhIFZhclJlZmVyZW5jZSBvciBsLkB2YXJpYWJsZVxuXHRcdFx0bC5AdmFyaWFibGUuYXNzaWduZWQocixzZWxmKVxuXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgYyBvXG5cdFx0dW5sZXNzIHJpZ2h0LmlzRXhwcmVzc2FibGVcblx0XHRcdHJldHVybiByaWdodC5jb25zdW1lKHNlbGYpLmMobylcblx0XHQjIHRlc3RpbmcgdGhpc1xuXHRcdHJldHVybiBzdXBlcihvKVxuXG5cdGRlZiBqcyBvXG5cdFx0dW5sZXNzIHJpZ2h0LmlzRXhwcmVzc2FibGVcblx0XHRcdHAgXCJBc3NpZ24janMgcmlnaHQgaXMgbm90IGV4cHJlc3NhYmxlIFwiXG5cdFx0XHQjIGhlcmUgdGhpcyBzaG91bGQgYmUgZ28gb3V0IG9mIHRoZSBzdGFjayghKVxuXHRcdFx0IyBpdCBzaG91bGQgYWxyZWFkeSBiZSBjb25zdW1lZD9cblx0XHRcdHJldHVybiByaWdodC5jb25zdW1lKHNlbGYpLmNcblx0XHR2YXIgbCA9IGxlZnQubm9kZVxuXHRcdHZhciByID0gcmlnaHRcblxuXHRcdCMgV2UgYXJlIHNldHRpbmcgc2VsZighKVxuXHRcdCMgVE9ETyBkb2N1bWVudCBmdW5jdGlvbmFsaXR5XG5cdFx0aWYgbCBpc2EgU2VsZlxuXHRcdFx0dmFyIGN0eCA9IHNjb3BlX18uY29udGV4dFxuXHRcdFx0bCA9IGN0eC5yZWZlcmVuY2VcblxuXG5cdFx0aWYgbCBpc2EgUHJvcGVydHlBY2Nlc3Ncblx0XHRcdHZhciBhc3QgPSBDQUxMKE9QKCcuJyxsLmxlZnQsbC5yaWdodC5zZXR0ZXIpLFtyaWdodF0pXG5cdFx0XHRhc3QucmVjZWl2ZXIgPSBsLnJlY2VpdmVyXG5cblx0XHRcdGlmIGlzVXNlZFxuXHRcdFx0XHQjIGRvbnQgY2FjaGUgaXQgYWdhaW4gaWYgaXQgaXMgYWxyZWFkeSBjYWNoZWQoISlcblx0XHRcdFx0cmlnaHQuY2FjaGUocG9vbDogJ3ZhbCcsIHVzZXM6IDEpIHVubGVzcyByaWdodC5jYWNoZXZhciAjXG5cdFx0XHRcdCMgdGhpcyBpcyBvbmx5IHdoZW4gdXNlZC4uIHNob3VsZCBiZSBtb3JlIGNsZXZlciBhYm91dCBpdFxuXHRcdFx0XHRhc3QgPSBQYXJlbnMubmV3KGJsa19fKFthc3QscmlnaHRdKSlcblxuXHRcdFx0IyBzaG91bGQgY2hlY2sgdGhlIHVwLXZhbHVlIG5vP1xuXHRcdFx0cmV0dXJuIGFzdC5jKGV4cHJlc3Npb246IHllcylcblxuXHRcdCMgaWYgbCBpc2EgVmFyUmVmZXJlbmNlXG5cdFx0IyBcdHAgXCJhc3NpZ24gdmFyLXJlZlwiXG5cdFx0IyBcdGwuQHZhcmlhYmxlLmFzc2lnbmVkKHIpXG5cblx0XHQjIEZJWE1FIC0tIGRvZXMgbm90IGFsd2F5cyBuZWVkIHRvIGJlIGFuIGV4cHJlc3Npb24/XG5cdFx0dmFyIGxjID0gbC5jXG5cblx0XHRpZiBvcHRpb24oOmV4cG9ydClcblx0XHRcdGxldCBlbmFtZSA9IGwgaXNhIFZhclJlZmVyZW5jZSA/IGwudmFyaWFibGUuYyA6IGxjXG5cdFx0XHRyZXR1cm4gXCJ7bGN9IHttYXJrX18oQG9wVG9rZW4pfXtvcH0gZXhwb3J0cy57ZW5hbWV9ID0ge3JpZ2h0LmMoZXhwcmVzc2lvbjogdHJ1ZSl9XCJcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gXCJ7bGN9IHttYXJrX18oQG9wVG9rZW4pfXtvcH0ge3JpZ2h0LmMoZXhwcmVzc2lvbjogdHJ1ZSl9XCJcblx0XHQjIHJldHVybiBvdXRcblxuXHQjIEZJWE1FIG9wIGlzIGEgdG9rZW4/IF9GSVhfXG5cdCMgdGhpcyAoYW5kIHNpbWlsYXIgY2FzZXMpIGlzIGJyb2tlbiB3aGVuIGNhbGxlZCBmcm9tXG5cdCMgYW5vdGhlciBwb3NpdGlvbiBpbiB0aGUgc3RhY2ssIHNpbmNlICd1cCcgaXMgZHluYW1pY1xuXHQjIHNob3VsZCBtYXliZSBmcmVlemUgdXA/XG5cdGRlZiBzaG91bGRQYXJlbnRoZXNpemUgcGFyID0gdXBcblx0XHRAcGFyZW5zIG9yIHBhciBpc2EgT3AgJiYgcGFyLm9wICE9ICc9J1xuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRpZiBpc0V4cHJlc3NhYmxlXG5cdFx0XHRmb3JjZUV4cHJlc3Npb25cblx0XHRcdHJldHVybiBzdXBlcihub2RlKVxuXG5cdFx0dmFyIGFzdCA9IHJpZ2h0LmNvbnN1bWUoc2VsZilcblx0XHRyZXR1cm4gYXN0LmNvbnN1bWUobm9kZSlcblxuXHQjIG1vcmUgd29ya2Fyb3VuZCBkdXJpbmcgdHJhbnNpdGlvbiBhd2F5IGZyb20gYSxiLGMgPSAxLDIsMyBzdHlsZSBhc3NpZ25cblx0ZGVmIGFkZEV4cHJlc3Npb24gZXhwclxuXHRcdCMgcCBcImFkZEV4cHJlc3Npb24ge2V4cHJ9XCJcblx0XHR2YXIgdHlwID0gRXhwcmVzc2lvbkJsb2NrXG5cdFx0aWYgQGxlZnQgYW5kIEBsZWZ0IGlzYSBWYXJSZWZlcmVuY2Vcblx0XHRcdHR5cCA9IFZhckJsb2NrXG5cdFx0IyBtaWdodCBiZSBiZXR0ZXIgdG8gbmVzdCB0aGlzIHVwIGFmdGVyIHBhcnNpbmcgaXMgZG9uZT9cblx0XHR2YXIgbm9kZSA9IHR5cC5uZXcoW3NlbGZdKVxuXHRcdHJldHVybiBub2RlLmFkZEV4cHJlc3Npb24oZXhwcilcblxuXG5leHBvcnQgY2xhc3MgUHVzaEFzc2lnbiA8IEFzc2lnblxuXG5cdGRlZiBqcyBvXG5cdFx0XCJ7bGVmdC5jfS5wdXNoKHtyaWdodC5jfSlcIlxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRyZXR1cm4gc2VsZlxuXG5leHBvcnQgY2xhc3MgVGFnUHVzaEFzc2lnbiA8IFB1c2hBc3NpZ25cblxuXHRkZWYganMgb1xuXHRcdFwie2xlZnQuY30ucHVzaCh7cmlnaHQuY30pXCJcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0cmV0dXJuIHNlbGZcblxuXG5leHBvcnQgY2xhc3MgQ29uZGl0aW9uYWxBc3NpZ24gPCBBc3NpZ25cblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0bm9ybWFsaXplLmNvbnN1bWUobm9kZSlcblxuXHRkZWYgbm9ybWFsaXplXG5cdFx0dmFyIGwgPSBsZWZ0Lm5vZGVcblx0XHR2YXIgbHMgPSBsXG5cblx0XHRpZiBsIGlzYSBBY2Nlc3Ncblx0XHRcdGlmIGwubGVmdFxuXHRcdFx0XHRsLmxlZnQuY2FjaGVcblx0XHRcdGxzID0gbC5jbG9uZShsLmxlZnQsbC5yaWdodCkgIyB0aGlzIHNob3VsZCBzdGlsbCBiZSBjYWNoZWQ/XG5cdFx0XHRsLmNhY2hlIGlmIGwgaXNhIFByb3BlcnR5QWNjZXNzICMgY29ycmVjdCBub3csIHRvIGEgY2VydGFpbiBkZWdyZWVcblx0XHRcdGlmIGwgaXNhIEluZGV4QWNjZXNzXG5cdFx0XHRcdGwucmlnaHQuY2FjaGVcblxuXHRcdFx0IyB3ZSBzaG91bGQgb25seSBjYWNoZSB0aGUgdmFsdWUgaXRzZWxmIGlmIGl0IGlzIGR5bmFtaWM/XG5cdFx0XHQjIGwuY2FjaGUgIyBjYWNoZSB0aGUgdmFsdWUgYXMgd2VsbCAtLSB3ZSBjYW5ub3QgdXNlIHRoaXMgaW4gYXNzaWducyB0aGVtXG5cblx0XHQjIHNvbWUgb3BzIGFyZSBsZXNzIG1lc3N5XG5cdFx0IyBuZWVkIG9wIHRvIHN1cHBvcnQgY29uc3VtZSB0aGVuP1xuXHRcdHZhciBleHByID0gcmlnaHQuaXNFeHByZXNzYWJsZVxuXHRcdHZhciBhc3QgPSBudWxsXG5cdFx0IyBoZXJlIHdlIHNob3VsZCB1c2UgYXN0ID0gaWYgLi4uXG5cdFx0aWYgZXhwciAmJiBvcCA9PSAnfHw9J1xuXHRcdFx0YXN0ID0gT1AoJ3x8JyxsLCBPUCgnPScsbHMscmlnaHQpKVxuXHRcdGVsaWYgZXhwciAmJiBvcCA9PSAnJiY9J1xuXHRcdFx0YXN0ID0gT1AoJyYmJyxsLCBPUCgnPScsbHMscmlnaHQpKVxuXHRcdGVsc2Vcblx0XHRcdGFzdCA9IElGKGNvbmRpdGlvbiwgT1AoJz0nLGxzLHJpZ2h0KSwgbCkgIyBkbyB3ZSBuZWVkIGEgc2NvcGUgZm9yIHRoZXNlP1xuXHRcdFx0YXN0LnNjb3BlID0gbnVsbFxuXHRcdFx0IyBkcm9wIHRoZSBzY29wZVxuXHRcdFx0IyB0b3VjaCBzY29wZSAtLSBzaG91bGQgcHJvYmFibHkgdmlzaXQgdGhlIHdob2xlIHRoaW5nP1xuXHRcdFx0IyBhc3Quc2NvcGUudmlzaXRcblx0XHRhc3QudG9FeHByZXNzaW9uIGlmIGFzdC5pc0V4cHJlc3NhYmxlXG5cdFx0YXN0XG5cblxuXHRkZWYgY1xuXHRcdCMgV0FSTiB3aGF0IGlmIHdlIHJldHVybiB0aGUgc2FtZT9cblx0XHRub3JtYWxpemUuY1xuXG5cdGRlZiBjb25kaXRpb25cblxuXHRcdCMgdXNlIHN3aXRjaCBpbnN0ZWFkIHRvIGNhY2hlIG9wIGFjY2Vzc1xuXHRcdGlmIG9wID09ICc/PSdcblx0XHRcdE9QKCc9PScsbGVmdCxOVUxMKVxuXHRcdGVsaWYgb3AgPT0gJ3x8PSdcblx0XHRcdE9QKCchJyxsZWZ0KVxuXHRcdGVsaWYgb3AgPT0gJyYmPSdcblx0XHRcdGxlZnRcblx0XHRlbGlmIG9wID09ICchPz0nXG5cdFx0XHRPUCgnIT0nLGxlZnQsTlVMTClcblx0XHRlbHNlXG5cdFx0XHRsZWZ0XG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgYXN0ID0gSUYoY29uZGl0aW9uLCBPUCgnPScsbGVmdCxyaWdodCksIGxlZnQpXG5cdFx0YXN0LnNjb3BlID0gbnVsbCAjIG5vdCBzdXJlIGFib3V0IHRoaXNcblx0XHRhc3QudG9FeHByZXNzaW9uIGlmIGFzdC5pc0V4cHJlc3NhYmxlICMgZm9yY2VkIGV4cHJlc3Npb24gYWxyZWFkeVxuXHRcdHJldHVybiBhc3QuY1xuXG5leHBvcnQgY2xhc3MgQ29tcG91bmRBc3NpZ24gPCBBc3NpZ25cblxuXHQjIEZJWE1FIGNhbiB3ZSBtZXJnZSBjb25zdW1lIGFuZCBqcz9cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdHJldHVybiBzdXBlciBpZiBpc0V4cHJlc3NhYmxlXG5cblx0XHR2YXIgYXN0ID0gbm9ybWFsaXplXG5cdFx0cmV0dXJuIGFzdC5jb25zdW1lKG5vZGUpIHVubGVzcyBhc3QgPT0gc2VsZlxuXG5cdFx0YXN0ID0gcmlnaHQuY29uc3VtZShzZWxmKVxuXHRcdHJldHVybiBhc3QuY29uc3VtZShub2RlKVxuXG5cdGRlZiBub3JtYWxpemVcblx0XHR2YXIgbG4gPSBsZWZ0Lm5vZGVcblx0XHQjIHdlIGRvbnQgbmVlZCB0byBjaGFuZ2UgdGhpcyBhdCBhbGxcblx0XHR1bmxlc3MgbG4gaXNhIFByb3BlcnR5QWNjZXNzXG5cdFx0XHRyZXR1cm4gc2VsZlxuXG5cdFx0aWYgbG4gaXNhIEFjY2Vzc1xuXHRcdFx0IyBsZWZ0IG1pZ2h0IGJlIHplcm8/IT8hXG5cdFx0XHRsbi5sZWZ0LmNhY2hlIGlmIGxuLmxlZnRcblx0XHQjIFRPRE8gRklYTUUgd2Ugd2FudCB0byBjYWNoZSB0aGUgY29udGV4dCBvZiB0aGUgYXNzaWdubWVudFxuXHRcdHZhciBhc3QgPSBPUCgnPScsbGVmdCxPUChvcFswXSxsZWZ0LHJpZ2h0KSlcblx0XHRhc3QudG9FeHByZXNzaW9uIGlmIGFzdC5pc0V4cHJlc3NhYmxlXG5cblx0XHRyZXR1cm4gYXN0XG5cblx0ZGVmIGNcblx0XHR2YXIgYXN0ID0gbm9ybWFsaXplXG5cdFx0cmV0dXJuIHN1cGVyIGlmIGFzdCA9PSBzZWxmXG5cblx0XHQjIG90aGVyd2lzZSBpdCBpcyBpbXBvcnRhbnQgdGhhdCB3ZSBhY3R1YWxseSByZXBsYWNlIHRoaXMgbm9kZSBpbiB0aGUgb3V0ZXIgYmxvY2tcblx0XHQjIHdoZW5ldmVyIHdlIG5vcm1hbGl6ZSBhbmQgb3ZlcnJpZGUgYyBpdCBpcyBpbXBvcnRhbnQgdGhhdCB3ZSBjYW4gcGFzcyBvbiBjYWNoaW5nXG5cdFx0IyBldGMgLS0gb3RoZXJ3aXNlIHRoZXJlIFdJTEwgYmUgaXNzdWVzLlxuXHRcdHZhciB1cCA9IFNUQUNLLmN1cnJlbnRcblx0XHRpZiB1cCBpc2EgQmxvY2tcblx0XHRcdCMgYW4gYWx0ZXJuYXRpdmUgd291bGQgYmUgdG8ganVzdCBwYXNzXG5cdFx0XHR1cC5yZXBsYWNlKHNlbGYsYXN0KVxuXHRcdGFzdC5jXG5cblxuZXhwb3J0IGNsYXNzIEFzeW5jQXNzaWduIDwgQXNzaWduXG5cblx0IyB0aGlzIHdpbGwgdHJhbnNmb3JtIHRoZSB0cmVlIGJ5IGEgZGVjZW50IGFtb3VudC5cblx0IyBOZWVkIHRvIGFkanVzdCBCbG9jayB0byBhbGxvdyB0aGlzXG5cblxuZXhwb3J0IGNsYXNzIFR1cGxlQXNzaWduIDwgQXNzaWduXG5cblx0cHJvcCBvcFxuXHRwcm9wIGxlZnRcblx0cHJvcCByaWdodFxuXHRwcm9wIHR5cGVcblxuXHRkZWYgaW5pdGlhbGl6ZSBhLGIsY1xuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBvcCA9IGFcblx0XHRAbGVmdCA9IGJcblx0XHRAcmlnaHQgPSBjXG5cdFx0QHRlbXBvcmFyeSA9IFtdXG5cblx0ZGVmIGlzRXhwcmVzc2FibGVcblx0XHRyaWdodC5pc0V4cHJlc3NhYmxlXG5cblx0ZGVmIGFkZEV4cHJlc3Npb24gZXhwclxuXHRcdGlmIHJpZ2h0IGlzYSBUdXBsZVxuXHRcdFx0cmlnaHQucHVzaChleHByKVxuXHRcdGVsc2Vcblx0XHRcdHNlbGYucmlnaHQgPSBUdXBsZS5uZXcoW3JpZ2h0LGV4cHJdKVxuXG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHQjIGlmIHRoZSBmaXJzdCBsZWZ0LXZhbHVlIGlzIGEgdmFyLXJlZmVyZW5jZSwgdGhlblxuXHRcdCMgYWxsIHRoZSB2YXJpYWJsZXMgc2hvdWxkIGJlIGRlY2xhcmVkIGFzIHZhcmlhYmxlcy5cblx0XHQjIGJ1dCBpZiB3ZSBoYXZlIGNvbXBsZXggaXRlbXMgaW4gdGhlIG90aGVyIGxpc3QgLSBpdCBkb2VzIGJlY29tZSBtdWNoIGhhcmRlclxuXG5cdFx0IyBpZiB0aGUgZmlyc3QgaXMgYSB2YXItcmVmZXJlbmNlLCB0aGV5IHNob3VsZCBhbGwgYmUoISkgLi4gb3Igc3BsYXRzP1xuXHRcdCMgdGhpcyBpcyByZWFsbHkgYSBoYWNreSB3YW8gdG8gZG8gaXQgdGhvdWdoXG5cdFx0aWYgbGVmdC5maXJzdC5ub2RlIGlzYSBWYXJSZWZlcmVuY2Vcblx0XHRcdHNlbGYudHlwZSA9ICd2YXInXG5cdFx0XHQjIHNob3VsZCBwb3NzaWJseSBhbGxvdyByZWFsIHZhcnMgYXMgd2VsbCwgbm8/XG5cdFx0XHRAdmFycyA9IGxlZnQubm9kZXMuZmlsdGVyKHxufCBuIGlzYSBWYXJSZWZlcmVuY2UpXG5cdFx0XHQjIGNvbGxlY3QgdGhlIHZhcnMgZm9yIHR1cGxlIGZvciBlYXN5IGFjY2Vzc1xuXG5cdFx0XHQjIE5PVEUgY2FuIGltcHJvdmUuLiBzaG91bGQgcmF0aGVyIG1ha2UgdGhlIHdob2xlIGxlZnQgYmUgYSBWYXJCbG9jayBvciBUdXBsZVZhckJsb2NrXG5cblx0XHRyaWdodC50cmF2ZXJzZVxuXHRcdGxlZnQudHJhdmVyc2Vcblx0XHRzZWxmXG5cblx0ZGVmIGpzIG9cblx0XHQjIG9ubHkgZm9yIGFjdHVhbCBpbm5lciBleHByZXNzaW9ucywgb3RoZXJ3aXNlIGNhY2hlIHRoZSB3aG9sZSBhcnJheSwgbm8/XG5cdFx0dW5sZXNzIHJpZ2h0LmlzRXhwcmVzc2FibGVcblxuXHRcdFx0cmV0dXJuIHJpZ2h0LmNvbnN1bWUoc2VsZikuY1xuXG5cdFx0IyMjIGEsYixjID0gYXJndW1lbnRzICMjI1xuXHRcdCMgLSBkaXJlY3QuIG5vIG1hdHRlciBpZiBsdmFsdWVzIGFyZSB2YXJpYWJsZXMgb3Igbm90LiBNYWtlIGZha2UgYXJndW1lbnRzIHVwIHRvIHRoZSBzYW1lIGNvdW50IGFzIHR1cGxlXG5cblx0XHQjIyMgYSwqYixiID0gYXJndW1lbnRzICMjI1xuXHRcdCMgTmVlZCB0byBjb252ZXJ0IGFyZ3VtZW50cyB0byBhbiBhcnJheS4gSUYgYXJndW1lbnRzIGlzIG5vdCByZWZlcmVuY2VkIGFueXdoZXJlIGVsc2UgaW4gc2NvcGUsXG5cdFx0IyB3ZSBjYW4gZG8gdGhlIGFzc2lnbm1lbnQgZGlyZWN0bHkgd2hpbGUgcm9sbGluZyB0aHJvdWdoIGFyZ3VtZW50c1xuXG5cdFx0IyMjIGEsYiA9IGIsYSAjIyNcblx0XHQjIGlkZWFsbHkgd2Ugb25seSBuZWVkIHRvIGNhY2hlIHRoZSBmaXJzdCB2YWx1ZSAob3IgbiAtIDEpLCBhc3NpZ24gZGlyZWN0bHkgd2hlbiBwb3NzaWJsZS5cblxuXHRcdCMjIyBhLGIsYyA9IChtZXRob2QgfCBleHByZXNzaW9uKSAjIyNcblx0XHQjIGNvbnZlcnQgcmVzIGludG8gYXJyYXksIGFzc2lnbiBmcm9tIGFycmF5LiBDYW4gY2FjaGUgdGhlIHZhcmlhYmxlIHdoZW4gYXNzaWduaW5nIGZpcnN0IHZhbHVlXG5cblx0XHQjIEZpcnN0IHdlIG5lZWQgdG8gZmluZCBvdXQgd2hldGhlciB3ZSBhcmUgcmVxdWlyZWQgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbiBhbiBhcnJheSBiZWZvcmUgYXNzaWduaW5nXG5cdFx0IyBJZiB0aGlzIG5lZWRzIHRvIGJlIGFuIGV4cHJlc3Npb24gKHJldHVybnM/LCB3ZSBuZWVkIHRvIGZhbGwgYmFjayB0byB0aGUgQ1Mtd2EpXG5cblx0XHR2YXIgYXN0ID0gQmxvY2submV3KFtdKVxuXHRcdHZhciBsZnQgPSBzZWxmLmxlZnRcblx0XHR2YXIgcmd0ID0gc2VsZi5yaWdodFxuXHRcdHZhciB0eXAgPSBzZWxmLnR5cGVcblx0XHR2YXIgdmlhID0gbnVsbFxuXG5cdFx0dmFyIGxpICAgPSAwXG5cdFx0dmFyIHJpICAgPSBsZnQuY291bnRcblx0XHR2YXIgbGxlbiA9IHJpXG5cblxuXHRcdCMgaWYgQHZhcnNcblx0XHQjIFx0cCBcInR1cGxlIGhhcyB7QHZhcnM6bGVuZ3RofSB2YXJzXCJcblxuXHRcdCMgaWYgd2UgaGF2ZSBhIHNwbGF0IG9uIHRoZSBsZWZ0IGl0IGlzIG11Y2ggbW9yZSBsaWtlbHkgdGhhdCB3ZSBuZWVkIHRvIHN0b3JlIHJpZ2h0XG5cdFx0IyBpbiBhIHRlbXBvcmFyeSBhcnJheSwgYnV0IGlmIHRoZSByaWdodCBzaWRlIGhhcyBhIGtub3duIGxlbmd0aCwgaXQgc2hvdWxkIHN0aWxsIG5vdCBiZSBuZWVkZWRcblx0XHR2YXIgbHNwbGF0ID0gbGZ0LmZpbHRlcih8dnwgdiBpc2EgU3BsYXQgKVswXVxuXG5cdFx0IyBpZiByaWdodCBpcyBhbiBhcnJheSB3aXRob3V0IGFueSBzcGxhdHMgKG9yIGlubmVyIHR1cGxlcz8pLCBub3JtYWxpemUgaXQgdG8gdHVwbGVcblx0XHRyZ3QgPSBUdXBsZS5uZXcocmd0Lm5vZGVzKSBpZiByZ3QgaXNhIEFyciAmJiAhcmd0LnNwbGF0XG5cdFx0dmFyIHJsZW4gPSByZ3QgaXNhIFR1cGxlID8gcmd0LmNvdW50IDogbnVsbFxuXG5cdFx0IyBpZiBhbnkgdmFsdWVzIGFyZSBzdGF0ZW1lbnRzIHdlIG5lZWQgdG8gaGFuZGxlIHRoaXMgYmVmb3JlIGNvbnRpbnVpbmdcblxuXHRcdCMjIyBhLGIsYyA9IDEwLDIwLGFyeSAjIyNcblx0XHQjIGlkZWFsbHkgd2Ugb25seSBuZWVkIHRvIGNhY2hlIHRoZSBmaXJzdCB2YWx1ZSAob3IgbiAtIDEpLCBhc3NpZ24gZGlyZWN0bHkgd2hlbiBwb3NzaWJsZS5cblx0XHQjIG9ubHkgaWYgdGhlIHZhcmlhYmxlcyBhcmUgbm90IHByZWRlZmluZWQgb3IgcHJlZGVjbGFyZWQgY2FuIGJlIHdlIGNlcnRhaW4gdGhhdCB3ZSBjYW4gZG8gaXQgd2l0aG91dCBjYWNoaW5nXG5cdFx0IyBpZiBybGVuICYmIHR5cCA9PSAndmFyJyAmJiAhbHNwbGF0XG5cdFx0IyBcdCMgdGhpcyBjYW4gYmUgZGFuZ2Vyb3VzIGluIGVkZ2VjYXNlcyB0aGF0IGFyZSB2ZXJ5IGhhcmQgdG8gZGV0ZWN0XG5cdFx0IyBcdCMgaWYgaXQgYmVjb21lcyBhbiBpc3N1ZSwgZmFsbCBiYWNrIHRvIHNpbXBsZXIgdmVyc2lvbnNcblx0XHQjIFx0IyBkb2VzIG5vdCBldmVuIG1hdHRlciBpZiB0aGVyZSBpcyBhIHNwbGF0P1xuXG5cdFx0IyBzcGVjaWFsIGNhc2UgZm9yIGFyZ3VtZW50cyghKVxuXHRcdGlmICFsc3BsYXQgJiYgcmd0ID09IEFSR1VNRU5UU1xuXG5cdFx0XHR2YXIgcGFycyA9IHNjb3BlX18ucGFyYW1zXG5cdFx0XHQjIGZvcmNpbmcgdGhlIGFyZ3VtZW50cyB0byBiZSBuYW1lZFxuXHRcdFx0bGZ0Lm1hcCBkbyB8bCxpfCBhc3QucHVzaCBPUCgnPScsbC5ub2RlLHBhcnMuYXQoaSx5ZXMpLnZpc2l0LnZhcmlhYmxlKSAjIHMucGFyYW1zLmF0KHZhbHVlIC0gMSx5ZXMpXG5cblxuXHRcdGVsaWYgcmxlblxuXHRcdFx0IyB3ZSBoYXZlIHNldmVyYWwgaXRlbXMgaW4gdGhlIHJpZ2h0IHBhcnQuIHdoYXQgYWJvdXQgc3BsYXRzIGhlcmU/XG5cblx0XHRcdCMgcHJlLWV2YWx1YXRlIHJ2YWx1ZXMgdGhhdCBtaWdodCBiZSByZWZlcmVuY2UgZnJvbSBvdGhlciBhc3NpZ25tZW50c1xuXHRcdFx0IyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSByaWdodHNpZGUgdmFsdWVzIGhhcyBubyBzaWRlLWVmZmVjdHMuIENhdXNlIGlmXG5cdFx0XHQjIHRoZXkgZG9udCwgd2UgcmVhbGx5IGRvIG5vdCBuZWVkIHRlbXBvcmFyeSB2YXJpYWJsZXMuXG5cblx0XHRcdCMgc29tZSBvZiB0aGVzZSBvcHRpbWl6YXRpb25zIGFyZSBxdWl0ZSBwZXR0eSAtIG1ha2VzIHRoaW5ncyBtb3JlIGNvbXBsaWNhdGVkXG5cdFx0XHQjIGluIHRoZSBjb21waWxlciBvbmx5IHRvIGdldCBhcm91bmQgYWRkaW5nIGEgZmV3IHRlbXAtdmFyaWFibGVzIGhlcmUgYW5kIHRoZXJlXG5cblx0XHRcdCMgdmFyIGZpcnN0VW5zYWZlID0gMFxuXHRcdFx0IyBsZnQubWFwIGRvIHx2LGl8XG5cdFx0XHQjIFx0aWYgdiBpc2EgVmFyUmVmZXJlbmNlXG5cdFx0XHQjIFx0XHRwIFwibGVmdCBzaWRlIHtpfSB7dn0ge3YucmVmbnJ9XCJcblxuXHRcdFx0IyByZ3QubWFwIGRvIHx2LGl8XG5cdFx0XHQjIFx0aWYgdi5oYXNTaWRlRWZmZWN0c1xuXHRcdFx0IyBcdFx0IyByZXR1cm4gaWYgaSA9PSAwIG9yICF2Lmhhc1NpZGVFZmZlY3RzXG5cdFx0XHQjIFx0XHQjIHJldHVybiBpZiB2IGlzYSBOdW0gfHwgdiBpc2EgU3RyIHx8IGkgPT0gMFxuXHRcdFx0IyBcdFx0IyB3ZSBjb3VsZCBleHBsaWNpdGx5IGNyZWF0ZSBhIHRlbXBvcmFyeSB2YXJpYWJsZSBhbmQgYWRkaW5nIG5vZGVzIGZvciBhY2Nlc3NpbmcgZXRjXG5cdFx0XHQjIFx0XHQjIGJ1dCB0aGUgYnVpbHRpbiBjYWNoaW5nIHNob3VsZCByZWFsbHkgdGFrZSBjYXJlIG9mIHRoaXMgZm9yIHVzXG5cdFx0XHQjIFx0XHQjIHdlIG5lZWQgdG8gcmVhbGx5IGZvcmNlIHRoZSBjYWNoaW5nIHRob3VnaCAtLSBzaW5jZSB3ZSBuZWVkIGEgY29weSBvZiBpdCBldmVuIGlmIGl0IGlzIGEgbG9jYWxcblx0XHRcdCMgXHRcdCMgd2UgbmVlZCB0byBwcmVkZWNsYXJlIHRoZSB2YXJpYWJsZXMgYXQgdGhlIHRvcCBvZiBzY29wZSBpZiB0aGlzIGRvZXMgbm90IHRha2UgY2FyZSBvZiBpdFxuXHRcdFx0I1xuXHRcdFx0IyBcdFx0IyB0aGVzZSBhcmUgdGhlIGRlY2xhcmF0aW9ucyAtLSB3ZSBuZWVkIHRvIGFkZCB0aGVtIHNvbWV3aGVyZSBzbWFydFxuXHRcdFx0IyBcdFx0QHRlbXBvcmFyeS5wdXNoKHYpICMgbmVlZCBhIGdlbmVyYWxpemVkIHdheSB0byBkbyB0aGlzIHR5cGUgb2YgdGhpbmdcblx0XHRcdCMgXHRcdGFzdC5wdXNoKHYuY2FjaGUoZm9yY2U6IHllcywgdHlwZTogJ3N3YXAnLCBkZWNsYXJlZDogdHlwID09ICd2YXInKSlcblx0XHRcdCMgXHRcdCMgdGhleSBkbyBuZWVkIHRvIGJlIGRlY2xhcmVkLCBubz9cblxuXHRcdFx0IyBub3cgd2UgY2FuIGZyZWUgdGhlIGNhY2hlZCB2YXJpYWJsZXNcblx0XHRcdCMgYXN0Lm1hcCBkbyB8bnwgbi5kZWNhY2hlXG5cblx0XHRcdHZhciBwcmUgPSBbXVxuXHRcdFx0dmFyIHJlc3QgPSBbXVxuXG5cdFx0XHR2YXIgcGFpcnMgPSBsZnQubWFwIGRvIHxsLGl8XG5cdFx0XHRcdHZhciB2ID0gbnVsbFxuXHRcdFx0XHQjIGRldGVybWluZSBpZiB0aGlzIG5lZWRzIHRvIGJlIHByZWNhY2hlZD9cblx0XHRcdFx0IyBpZiBsIGlzYSBWYXJSZWZlcmVuY2Vcblx0XHRcdFx0IyBcdCMgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB0aGUgdmFyaWFibGUgaXMgcmVmZXJlbmNlZFxuXHRcdFx0XHQjIFx0IyBzaG91bGQgYWxzbyBjb3VudCBldmVuIGlmIGl0IGlzIHByZWRlY2xhcmVkIGF0IHRoZSB0b3Bcblx0XHRcdFx0IyBcdGlmIGwucmVmbnIgPT0gMFxuXG5cdFx0XHRcdGlmIGwgPT0gbHNwbGF0XG5cdFx0XHRcdFx0diA9IEFyZ0xpc3QubmV3KFtdKVxuXHRcdFx0XHRcdHZhciB0byA9IChybGVuIC0gKHJpIC0gaSkpXG5cdFx0XHRcdFx0di5wdXNoKHJndC5pbmRleChsaSsrKSkgd2hpbGUgbGkgPD0gdG9cblx0XHRcdFx0XHR2ID0gQXJyLm5ldyh2KVxuXHRcdFx0XHRcdCMgYXN0LnB1c2ggT1AoJz0nLGwubm9kZSxBcnIubmV3KHYpKVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0diA9IHJndC5pbmRleChsaSsrKVxuXHRcdFx0XHRbbC5ub2RlLHZdXG5cblx0XHRcdFx0IyBpZiBsIGlzYSBWYXJSZWZlcmVuY2UgJiYgbC5yZWZuclxuXHRcdFx0dmFyIGNsZWFuID0gdHJ1ZVxuXG5cdFx0XHRwYWlycy5tYXAgZG8gfHYsaXxcblx0XHRcdFx0dmFyIGwgPSB2WzBdXG5cdFx0XHRcdHZhciByID0gdlsxXVxuXG5cdFx0XHRcdGlmIGNsZWFuXG5cdFx0XHRcdFx0aWYgbCBpc2EgVmFyUmVmZXJlbmNlICYmIGwucmVmbnIgPT0gMFxuXHRcdFx0XHRcdFx0IyBzdGlsbCBjbGVhblxuXHRcdFx0XHRcdFx0Y2xlYW4gPSB5ZXNcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRjbGVhbiA9IG5vXG5cdFx0XHRcdFx0XHRwYWlycy5zbGljZShpKS5tYXAgZG8gfHBhcnR8XG5cdFx0XHRcdFx0XHRcdGlmIHBhcnRbMV0uaGFzU2lkZUVmZmVjdHNcblx0XHRcdFx0XHRcdFx0XHRAdGVtcG9yYXJ5LnB1c2gocGFydFsxXSkgIyBuZWVkIGEgZ2VuZXJhbGl6ZWQgd2F5IHRvIGRvIHRoaXMgdHlwZSBvZiB0aGluZ1xuXHRcdFx0XHRcdFx0XHRcdGFzdC5wdXNoKHBhcnRbMV0uY2FjaGUoZm9yY2U6IHllcywgcG9vbDogJ3N3YXAnLCBkZWNsYXJlZDogdHlwID09ICd2YXInKSlcblxuXHRcdFx0XHQjIGlmIHRoZSBwcmV2aW91cyB2YWx1ZSBpbiBhc3QgaXMgYSByZWZlcmVuY2UgdG8gb3VyIHZhbHVlIC0gdGhlIGNhY2hpbmcgd2FzIG5vdCBuZWVkZWRcblx0XHRcdFx0aWYgYXN0Lmxhc3QgPT0gclxuXHRcdFx0XHRcdHIuZGVjYWNoZVxuXHRcdFx0XHRcdCMgc2ltcGxlIGFzc2lnblxuXHRcdFx0XHRcdGFzdC5yZXBsYWNlKHIsT1AoJz0nLGwscikpXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRhc3QucHVzaCBPUCgnPScsbCxyKVxuXG5cdFx0XHQjIFdBUk4gRklYTUUgSXMgdGhlcmUgbm90IGFuIGlzc3VlIHdpdGggVmFyQmxvY2sgdnMgbm90IGhlcmU/XG5cdFx0ZWxzZVxuXHRcdFx0IyB0aGlzIGlzIHdoZXJlIHdlIG5lZWQgdG8gY2FjaGUgdGhlIHJpZ2h0IHNpZGUgYmVmb3JlIGFzc2lnbmluZ1xuXHRcdFx0IyBpZiB0aGUgcmlnaHQgc2lkZSBpcyBhIGZvciBsb29wLCB3ZSBDT1VMRCB0cnkgdG8gYmUgZXh0cmEgY2xldmVyLCBidXRcblx0XHRcdCMgZm9yIG5vdyBpdCBpcyBub3Qgd29ydGggdGhlIGFkZGVkIGNvbXBpbGVyIGNvbXBsZXhpdHlcblxuXHRcdFx0IyBpdGVyLmNhY2hlKGZvcmNlOiB5ZXMsIHR5cGU6ICdpdGVyJylcblx0XHRcdHZhciB0b3AgPSBWYXJCbG9jay5uZXdcblx0XHRcdHZhciBpdGVyID0gdXRpbC5pdGVyYWJsZShyZ3QsIHllcylcblx0XHRcdCMgY291bGQgc2V0IHRoZSB2YXJzIGluc2lkZSAtLSBtb3N0IGxpa2VseVxuXHRcdFx0YXN0LnB1c2godG9wKVxuXHRcdFx0dG9wLnB1c2goaXRlcilcblxuXHRcdFx0aWYgbHNwbGF0XG5cdFx0XHRcdHZhciBsZW4gPSB1dGlsLmxlbihpdGVyLCB5ZXMpXG5cdFx0XHRcdHZhciBpZHggPSB1dGlsLmNvdW50ZXIoMCwgeWVzKVxuXHRcdFx0XHQjIGNhY2hlIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5XG5cdFx0XHRcdHRvcC5wdXNoKGxlbikgIyBwcmVhc3NpZ24gdGhlIGxlbmd0aFxuXHRcdFx0XHQjIGNhY2hlIGNvdW50ZXIgdG8gbG9vcCB0aHJvdWdoXG5cdFx0XHRcdHRvcC5wdXNoKGlkeClcblxuXHRcdFx0IyBvbmx5IGlmIHRoZSBibG9jayBpcyB2YXJpYWJsZSBiYXNlZCwgbm8/XG5cdFx0XHQjIGFzdC5wdXNoKGJsayA9IFZhckJsb2NrLm5ldylcblx0XHRcdCMgYmxrID0gbnVsbFxuXG5cdFx0XHR2YXIgYmxrdHlwZSA9IHR5cCA9PSAndmFyJyA/IFZhckJsb2NrIDogQmxvY2tcblx0XHRcdHZhciBibGsgPSBibGt0eXBlLm5ldyhbXSlcblx0XHRcdCMgYmxrID0gdG9wIGlmIHR5cCA9PSAndmFyJ1xuXHRcdFx0YXN0LnB1c2goYmxrKVxuXG5cdFx0XHQjIGlmIHRoZSBsdmFscyBhcmUgbm90IHZhcmlhYmxlcyAtIHdlIG5lZWQgdG8gcHJlYXNzaWduXG5cdFx0XHQjIGNhbiBhbHNvIHVzZSBzbGljZSBoZXJlIGZvciBzaW1wbGljaXR5LCBidXQgdHJ5IHdpdGggd2hpbGUgbm93XG5cdFx0XHRsZnQubWFwIGRvIHxsLGl8XG5cdFx0XHRcdGlmIGwgPT0gbHNwbGF0XG5cdFx0XHRcdFx0dmFyIGx2YXIgPSBsLm5vZGVcblx0XHRcdFx0XHR2YXIgcmVtID0gbGxlbiAtIGkgLSAxICMgcmVtYWluaW5nIGFmdGVyIHNwbGF0XG5cblx0XHRcdFx0XHRpZiB0eXAgIT0gJ3Zhcidcblx0XHRcdFx0XHRcdHZhciBhcnIgPSB1dGlsLmFycmF5KE9QKCctJyxsZW4sIG51bV9fKGkgKyByZW0pICkseWVzKVxuXHRcdFx0XHRcdFx0dG9wLnB1c2goYXJyKVxuXHRcdFx0XHRcdFx0bHZhciA9IGFyci5jYWNoZXZhclxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdGFzdC5wdXNoKGJsayA9IGJsa3R5cGUubmV3KSB1bmxlc3MgYmxrXG5cdFx0XHRcdFx0XHR2YXIgYXJyID0gdXRpbC5hcnJheSggT1AoJy0nLGxlbixudW1fXyhpICsgcmVtKSApIClcblx0XHRcdFx0XHRcdGJsay5wdXNoKE9QKCc9JyxsdmFyLGFycikpXG5cblx0XHRcdFx0XHQjIGlmICFsdmFyOnZhcmlhYmxlIHx8ICFsdmFyLnZhcmlhYmxlICMgbHZhciA9XG5cdFx0XHRcdFx0IyBcdHRvcC5wdXNoKClcblx0XHRcdFx0XHQjXHRwIFwiaGFzIHZhcmlhYmxlIC0gbm8gbmVlZCB0byBjcmVhdGUgYSB0ZW1wXCJcblx0XHRcdFx0XHQjIGJsay5wdXNoKE9QKCc9JyxsdmFyLEFyci5uZXcoW10pKSkgIyBkb250IHByZWNhbGN1bGF0ZSBzaXplIG5vd1xuXHRcdFx0XHRcdCMgbWF4ID0gdG8gPSAocmxlbiAtIChsbGVuIC0gaSkpXG5cblxuXHRcdFx0XHRcdHZhciB0ZXN0ID0gcmVtID8gT1AoJy0nLGxlbixyZW0pIDogbGVuXG5cblx0XHRcdFx0XHR2YXIgc2V0ID0gT1AoJz0nLFxuXHRcdFx0XHRcdFx0T1AoJy4nLGx2YXIsT1AoJy0nLGlkeCxudW1fXyhpKSkpLFxuXHRcdFx0XHRcdFx0T1AoJy4nLGl0ZXIsT1AoJysrJyxpZHgpKVxuXHRcdFx0XHRcdClcblxuXHRcdFx0XHRcdGFzdC5wdXNoKFdISUxFKE9QKCc8JyxpZHgsdGVzdCksIHNldCkpXG5cblx0XHRcdFx0XHRpZiB0eXAgIT0gJ3Zhcidcblx0XHRcdFx0XHRcdGFzdC5wdXNoKGJsayA9IEJsb2NrLm5ldylcblx0XHRcdFx0XHRcdGJsay5wdXNoKE9QKCc9JyxsLm5vZGUsbHZhcikpXG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0YmxrID0gbnVsbFxuXG5cdFx0XHRcdFx0IyBub3QgaWYgc3BsYXQgd2FzIGxhc3Q/XG5cdFx0XHRcdFx0IyBhc3QucHVzaChibGsgPSBWYXJCbG9jay5uZXcpXG5cblx0XHRcdFx0ZWxpZiBsc3BsYXRcblx0XHRcdFx0XHRhc3QucHVzaChibGsgPSBibGt0eXBlLm5ldykgdW5sZXNzIGJsa1xuXHRcdFx0XHRcdCMgd2UgY291bGQgY2FjaGUgdGhlIHJhdyBjb2RlIG9mIHRoaXMgbm9kZSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG5cdFx0XHRcdFx0YmxrLnB1c2goT1AoJz0nLGwsT1AoJy4nLGl0ZXIsT1AoJysrJyxpZHgpKSkpXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRhc3QucHVzaChibGsgPSBibGt0eXBlLm5ldykgdW5sZXNzIGJsa1xuXHRcdFx0XHRcdGJsay5wdXNoKE9QKCc9JyxsLE9QKCcuJyxpdGVyLG51bV9fKGkpICkpKVxuXG5cdFx0IyBpZiB3ZSBhcmUgaW4gYW4gZXhwcmVzc2lvbiB3ZSByZWFsbHkgbmVlZCB0b1xuXHRcdGlmIG8uaXNFeHByZXNzaW9uIGFuZCBAdmFyc1xuXHRcdFx0Zm9yIHYgaW4gQHZhcnNcblx0XHRcdFx0di52YXJpYWJsZS5hdXRvZGVjbGFyZVxuXG5cdFx0ZWxpZiBAdmFyc1xuXHRcdFx0Zm9yIHYgaW4gQHZhcnNcblx0XHRcdFx0di52YXJpYWJsZS5wcmVkZWNsYXJlZFxuXG5cdFx0IyBpcyB0aGVyZSBhbnkgcmVhc29uIHRvIG1ha2UgaXQgaW50byBhbiBleHByZXNzaW9uP1xuXHRcdGlmIGFzdC5pc0V4cHJlc3NhYmxlICMgTk8hXG5cdFx0XHQjIGlmIHRoaXMgaXMgYW4gZXhwcmVzc2lvblxuXHRcdFx0dmFyIG91dCA9IGFzdC5jKGV4cHJlc3Npb246IHllcylcblx0XHRcdG91dCA9IFwie3R5cH0ge291dH1cIiBpZiB0eXAgYW5kICFvLmlzRXhwcmVzc2lvbiAjIG5vdCBpbiBleHByZXNzaW9uXG5cdFx0XHRyZXR1cm4gb3V0XG5cdFx0ZWxzZVxuXHRcdFx0dmFyIG91dCA9IGFzdC5jXG5cdFx0XHQjIGlmIHRoaXMgaXMgYSB2YXJibG9ja1xuXHRcdFx0cmV0dXJuIG91dFxuXG5cblx0ZGVmIGMgb1xuXHRcdHZhciBvdXQgPSBzdXBlcihvKVxuXHRcdCMgdGhpcyBpcyBvbmx5IHVzZWQgaW4gdHVwbGUgLS0gYmV0dGVyIHRvIGxldCB0aGUgdHVwbGUgaGF2IGEgc2VwYXJhdGUgI2Ncblx0XHRpZiBAdGVtcG9yYXJ5ICYmIEB0ZW1wb3Jhcnk6bGVuZ3RoXG5cdFx0XHRAdGVtcG9yYXJ5Lm1hcCBkbyB8dGVtcHwgdGVtcC5kZWNhY2hlXG5cdFx0cmV0dXJuIG91dFxuXG5cblxuIyBJREVOVElGSUVSU1xuXG4jIHJlYWxseSBuZWVkIHRvIGNsZWFuIHRoaXMgdXBcbiMgRHJvcCB0aGUgdG9rZW4/XG5leHBvcnQgY2xhc3MgSWRlbnRpZmllciA8IE5vZGVcblxuXHRwcm9wIHNhZmVjaGFpblxuXHRwcm9wIHZhbHVlXG5cblx0ZGVmIGluaXRpYWxpemUgdmFsdWVcblx0XHRAdmFsdWUgPSBsb2FkKHZhbHVlKVxuXHRcdEBzeW1ib2wgPSBudWxsXG5cdFx0QHNldHRlciA9IG51bGxcblxuXHRcdGlmIChcIlwiICsgdmFsdWUpLmluZGV4T2YoXCI/XCIpID49IDBcblx0XHRcdEBzYWZlY2hhaW4gPSB5ZXNcblx0XHQjIEBzYWZlY2hhaW4gPSAoXCJcIiArIHZhbHVlKS5pbmRleE9mKFwiP1wiKSA+PSAwXG5cdFx0c2VsZlxuXG5cdGRlZiByZWZlcmVuY2VzIHZhcmlhYmxlXG5cdFx0QHZhbHVlLkB2YXJpYWJsZSA9IHZhcmlhYmxlIGlmIEB2YWx1ZVxuXHRcdHNlbGZcblxuXHRkZWYgc291cmNlTWFwTWFya2VyXG5cdFx0QHZhbHVlLnNvdXJjZU1hcE1hcmtlclxuXG5cdGRlZiBsb2FkIHZcblx0XHRyZXR1cm4gKHYgaXNhIElkZW50aWZpZXIgPyB2LnZhbHVlIDogdilcblxuXHRkZWYgdHJhdmVyc2Vcblx0XHQjIE5PREVTLnB1c2goc2VsZilcblx0XHRzZWxmXG5cblx0ZGVmIHZpc2l0XG5cblx0XHRpZiBAdmFsdWUgaXNhIE5vZGVcblx0XHRcdCMgY29uc29sZS5sb2cgXCJJREVOVElGSUVSIFZBTFVFIElTIE5PREVcIlxuXHRcdFx0QHZhbHVlLnRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cdGRlZiByZWdpb25cblx0XHRbQHZhbHVlLkBsb2MsQHZhbHVlLkBsb2MgKyBAdmFsdWUuQGxlbl1cblxuXHRkZWYgaXNWYWxpZElkZW50aWZpZXJcblx0XHR5ZXNcblxuXHRkZWYgaXNSZXNlcnZlZFxuXHRcdEB2YWx1ZTpyZXNlcnZlZCBvciBSRVNFUlZFRF9URVNULnRlc3QoU3RyaW5nKEB2YWx1ZSkpXG5cblx0ZGVmIHN5bWJvbFxuXHRcdCMgY29uc29sZS5sb2cgXCJJZGVudGlmaWVyI3N5bWJvbCB7dmFsdWV9XCJcblx0XHRAc3ltYm9sIHx8PSBzeW1fXyh2YWx1ZSlcblxuXHRkZWYgc2V0dGVyXG5cdFx0IyBjb25zb2xlLmxvZyBcIklkZW50aWZpZXIjc2V0dGVyXCJcblx0XHRAc2V0dGVyIHx8PSBpZiB0cnVlXG5cdFx0XHR2YXIgdG9rID0gVG9rZW4ubmV3KCdJREVOVElGSUVSJyxzeW1fXygnc2V0LScgKyBAdmFsdWUpLEB2YWx1ZS5AbG9jIG9yIC0xKVxuXHRcdFx0SWRlbnRpZmllci5uZXcodG9rKVxuXHRcdFx0IyBJZGVudGlmaWVyLm5ldyhcInNldC17c3ltYm9sfVwiKVxuXG5cdGRlZiB0b1N0cmluZ1xuXHRcdFN0cmluZyhAdmFsdWUpXG5cblx0ZGVmIHRvSlNPTlxuXHRcdHRvU3RyaW5nXG5cblx0ZGVmIGFsaWFzXG5cdFx0c3ltX18oQHZhbHVlKVxuXG5cdGRlZiBqcyBvXG5cdFx0c3ltYm9sXG5cblx0ZGVmIGNcblx0XHRyZXR1cm4gJycgKyBzeW1ib2wgIyBtYXJrX18oQHZhbHVlKSArXG5cblx0ZGVmIGR1bXBcblx0XHR7IGxvYzogcmVnaW9uIH1cblxuXHRkZWYgbmFtZXBhdGhcblx0XHR0b1N0cmluZ1xuXG5cdGRlZiBzaG91bGRQYXJlbnRoZXNpemVJblRlcm5hcnlcblx0XHRAcGFyZW5zIG9yIEBjYWNoZVxuXG5leHBvcnQgY2xhc3MgVGFnSWQgPCBJZGVudGlmaWVyXG5cblx0ZGVmIGluaXRpYWxpemUgdlxuXHRcdEB2YWx1ZSA9IHYgaXNhIElkZW50aWZpZXIgPyB2LnZhbHVlIDogdlxuXHRcdHNlbGZcblxuXHRkZWYgY1xuXHRcdFwie3Njb3BlX18uaW1iYS5jfS5nZXRUYWdTaW5nbGV0b24oJ3t2YWx1ZS5jLnN1YnN0cigxKX0nKVwiXG5cblxuIyBUaGlzIGlzIG5vdCBhbiBpZGVudGlmaWVyIC0gaXQgaXMgcmVhbGx5IGEgc3RyaW5nXG4jIElzIHRoaXMgbm90IGEgbGl0ZXJhbD9cblxuIyBGSVhNRSBSZW5hbWUgdG8gSXZhckxpdGVyYWw/IG9yIHNpbXBseSBMaXRlcmFsIHdpdGggdHlwZSBJdmFyXG5leHBvcnQgY2xhc3MgSXZhciA8IElkZW50aWZpZXJcblxuXHRkZWYgaW5pdGlhbGl6ZSB2XG5cdFx0QHZhbHVlID0gdiBpc2EgSWRlbnRpZmllciA/IHYudmFsdWUgOiB2XG5cdFx0c2VsZlxuXG5cdGRlZiBuYW1lXG5cdFx0aGVscGVycy5kYXNoVG9DYW1lbENhc2UoQHZhbHVlKS5yZXBsYWNlKC9eQC8sJycpXG5cdFx0IyB2YWx1ZS5jLmNhbWVsQ2FzZS5yZXBsYWNlKC9eQC8sJycpXG5cblx0ZGVmIGFsaWFzXG5cdFx0J18nICsgbmFtZVxuXG5cdCMgdGhlIEAgc2hvdWxkIHBvc3NpYmx5IGJlIGdvbmUgZnJvbSB0aGUgc3RhcnQ/XG5cdGRlZiBqcyBvXG5cdFx0J18nICsgbmFtZVxuXG5cdGRlZiBjXG5cdFx0J18nICsgaGVscGVycy5kYXNoVG9DYW1lbENhc2UoQHZhbHVlKS5zbGljZSgxKSAjIC5yZXBsYWNlKC9eQC8sJycpICMgbWFya19fKEB2YWx1ZSkgK1xuXG5cblxuIyBBbWJpZ3VvdXMgLSBXZSBuZWVkIHRvIGJlIGNvbnNpc3RlbnQgYWJvdXQgQ29uc3QgdnMgQ29uc3RBY2Nlc3NcbiMgQmVjb21lcyBtb3JlIGltcG9ydGFudCB3aGVuIHdlIGltcGxlbWVudCB0eXBlaW5mZXJlbmNlIGFuZCBjb2RlLWFuYWx5c2lzXG5leHBvcnQgY2xhc3MgQ29uc3QgPCBJZGVudGlmaWVyXG5cblx0ZGVmIHN5bWJvbFxuXHRcdCMgY29uc29sZS5sb2cgXCJJZGVudGlmaWVyI3N5bWJvbCB7dmFsdWV9XCJcblx0XHRAc3ltYm9sIHx8PSBzeW1fXyh2YWx1ZSlcblxuXHRkZWYganMgb1xuXHRcdEB2YXJpYWJsZSA/IEB2YXJpYWJsZS5jIDogc3ltYm9sXG5cblx0ZGVmIHRyYXZlcnNlXG5cdFx0aWYgQHRyYXZlcnNlZFxuXHRcdFx0cmV0dXJuXG5cblx0XHRAdHJhdmVyc2VkID0gdHJ1ZVxuXHRcdHZhciBjdXJyID0gU1RBQ0suY3VycmVudFxuXHRcdGlmICEoY3VyciBpc2EgQWNjZXNzKSBvciBjdXJyLmxlZnQgPT0gc2VsZlxuXHRcdFx0aWYgc3ltYm9sID09IFwiSW1iYVwiXG5cdFx0XHRcdEB2YXJpYWJsZSA9IHNjb3BlX18uaW1iYVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRAdmFyaWFibGUgPSBzY29wZV9fLmxvb2t1cCh2YWx1ZSlcblx0XHRzZWxmXG5cblx0ZGVmIGNcblx0XHRpZiBvcHRpb24oOmV4cG9ydClcblx0XHRcdFwiZXhwb3J0cy57QHZhbHVlfSA9IFwiICsgbWFya19fKEB2YWx1ZSkgKyBqc1xuXHRcdGVsc2Vcblx0XHRcdG1hcmtfXyhAdmFsdWUpICsganNcblxuXG5leHBvcnQgY2xhc3MgVGFnVHlwZUlkZW50aWZpZXIgPCBJZGVudGlmaWVyXG5cblx0cHJvcCBuYW1lXG5cdHByb3AgbnNcblxuXHRkZWYgaW5pdGlhbGl6ZSB2YWx1ZVxuXHRcdEB2YWx1ZSA9IGxvYWQodmFsdWUpXG5cdFx0c2VsZlxuXG5cdGRlZiBsb2FkIHZhbFxuXHRcdEBzdHIgPSAoXCJcIiArIHZhbClcblx0XHR2YXIgcGFydHMgPSBAc3RyLnNwbGl0KFwiOlwiKVxuXHRcdEByYXcgPSB2YWxcblx0XHRAbmFtZSA9IHBhcnRzLnBvcFxuXHRcdEBucyA9IHBhcnRzLnNoaWZ0ICMgaWYgYW55P1xuXHRcdHJldHVybiBAc3RyXG5cblx0ZGVmIGpzIG9cblx0XHRyZXR1cm4gXCJ7c2NvcGVfXy50YWdDb250ZXh0UGF0aH0ue0BzdHIucmVwbGFjZShcIjpcIixcIiRcIil9XCJcblxuXHRkZWYgY1xuXHRcdGpzXG5cblx0ZGVmIGZ1bmNcblx0XHR2YXIgbmFtZSA9IEBuYW1lLnJlcGxhY2UoLy0vZywnXycpLnJlcGxhY2UoL1xcIy8sJycpXG5cdFx0bmFtZSArPSBcIiR7QG5zLnRvTG93ZXJDYXNlfVwiIGlmIEBuc1xuXHRcdG5hbWVcblxuXHRkZWYgaXNDbGFzc1xuXHRcdEBuYW1lWzBdID09IEBuYW1lWzBdLnRvVXBwZXJDYXNlXG5cblx0ZGVmIHNwYXduZXJcblx0XHRpZiBAbnNcblx0XHRcdFwiX3tAbnMudG9VcHBlckNhc2V9LntAbmFtZS5yZXBsYWNlKC8tL2csJ18nKS50b1VwcGVyQ2FzZX1cIlxuXHRcdGVsc2Vcblx0XHRcdFwie0BuYW1lLnJlcGxhY2UoLy0vZywnXycpLnRvVXBwZXJDYXNlfVwiXG5cblx0ZGVmIGlkXG5cdFx0dmFyIG0gPSBAc3RyLm1hdGNoKC9cXCMoW1xcd1xcLVxcZFxcX10rKVxcYi8pXG5cdFx0bSA/IG1bMV0gOiBudWxsXG5cblxuXHRkZWYgZmxhZ1xuXHRcdFwiX1wiICsgbmFtZS5yZXBsYWNlKC8tLS9nLCdfJykudG9Mb3dlckNhc2VcblxuXHRkZWYgc2VsXG5cdFx0XCIue2ZsYWd9XCIgIyArIG5hbWUucmVwbGFjZSgvLS9nLCdfJykudG9Mb3dlckNhc2VcblxuXHRkZWYgc3RyaW5nXG5cdFx0dmFsdWVcblxuXG5leHBvcnQgY2xhc3MgQXJndmFyIDwgVmFsdWVOb2RlXG5cblx0ZGVmIGNcblx0XHQjIE5FWFQgLS0gZ2xvYmFsLnBhcnNlSW50IG9yIE51bWJlci5wYXJzZUludCAoYmV0dGVyKVxuXHRcdHZhciB2ID0gcGFyc2VJbnQoU3RyaW5nKHZhbHVlKSlcblx0XHQjIEZJWE1FIE5vdCBuZWVkZWQgYW55bW9yZT8gSSB0aGluayB0aGUgbGV4ZXIgaGFuZGxlcyB0aGlzXG5cdFx0cmV0dXJuIFwiYXJndW1lbnRzXCIgaWYgdiA9PSAwXG5cblx0XHR2YXIgcyA9IHNjb3BlX19cblx0XHQjIHBhcmFtcyBuZWVkIHRvIGdvIHVwIHRvIHRoZSBjbG9zZXN0ZSBtZXRob2Qtc2NvcGVcblx0XHR2YXIgcGFyID0gcy5wYXJhbXMuYXQodiAtIDEseWVzKVxuXHRcdFwie2NfXyhwYXIubmFtZSl9XCIgIyBjXG5cblxuIyBDQUxMXG5cbmV4cG9ydCBjbGFzcyBDYWxsIDwgTm9kZVxuXG5cdHByb3AgY2FsbGVlXG5cdHByb3AgcmVjZWl2ZXJcblx0cHJvcCBhcmdzXG5cdHByb3AgYmxvY2tcblxuXHRkZWYgaW5pdGlhbGl6ZSBjYWxsZWUsIGFyZ3MsIG9wZXhpc3RzXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QGV4cHJlc3Npb24gPSBub1xuXHRcdEBwYXJlbnMgPSBub1xuXHRcdEBjYWNoZSA9IG51bGxcblx0XHRAcmVjZWl2ZXIgPSBudWxsXG5cdFx0QG9wZXhpc3RzID0gb3BleGlzdHNcblx0XHQjIHNvbWUgYXhpb21zIHRoYXQgc2hhcmUgdGhlIHNhbWUgc3ludGF4IGFzIGNhbGxzIHdpbGwgYmUgcmVkaXJlY3RlZCBmcm9tIGhlcmVcblxuXHRcdGlmIGNhbGxlZSBpc2EgVmFyT3JBY2Nlc3Ncblx0XHRcdHZhciBzdHIgPSBjYWxsZWUudmFsdWUuc3ltYm9sXG5cdFx0XHRpZiBzdHIgPT0gJ2V4dGVybidcblx0XHRcdFx0Y2FsbGVlLnZhbHVlLnZhbHVlLkB0eXBlID0gJ0VYVEVSTidcblx0XHRcdFx0cmV0dXJuIEV4dGVybkRlY2xhcmF0aW9uLm5ldyhhcmdzKVxuXHRcdFx0aWYgc3RyID09ICd0YWcnXG5cdFx0XHRcdCMgY29uc29sZS5sb2cgXCJFUlJPUiAtIGFjY2VzcyBhcmdzIGJ5IHNvbWUgbWV0aG9kXCJcblx0XHRcdFx0cmV0dXJuIFRhZ1dyYXBwZXIubmV3KGFyZ3MgYW5kIGFyZ3M6aW5kZXggPyBhcmdzLmluZGV4KDApIDogYXJnc1swXSlcblx0XHRcdGlmIHN0ciA9PSAnZXhwb3J0J1xuXHRcdFx0XHRyZXR1cm4gRXhwb3J0Lm5ldyhhcmdzKVxuXG5cdFx0QGNhbGxlZSA9IGNhbGxlZVxuXHRcdEBhcmdzID0gYXJncyBvciBBcmdMaXN0Lm5ldyhbXSlcblxuXHRcdGlmIGFyZ3MgaXNhIEFycmF5XG5cdFx0XHRAYXJncyA9IEFyZ0xpc3QubmV3KGFyZ3MpXG5cdFx0c2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcdGFyZ3MudHJhdmVyc2Vcblx0XHRjYWxsZWUudHJhdmVyc2Vcblx0XHQjIGlmIHRoZSBjYWxsZWUgaXMgYSBQcm9wZXJ0eUFjY2VzcyAtIGJldHRlciB0byBpbW1lZGlhdGVseSBjaGFuZ2UgaXRcblxuXHRcdEBibG9jayAmJiBAYmxvY2sudHJhdmVyc2VcblxuXHRkZWYgYWRkQmxvY2sgYmxvY2tcblx0XHR2YXIgcG9zID0gQGFyZ3MuZmlsdGVyKHxuLGl8IG4gPT0gJyYnKVswXSAjIFdPVUxEIEJFIFRPS0VOIC0gQ0FSRUZVTFxuXHRcdHBvcyA/IGFyZ3MucmVwbGFjZShwb3MsYmxvY2spIDogYXJncy5wdXNoKGJsb2NrKVxuXHRcdHNlbGZcblxuXHRkZWYgcmVjZWl2ZXJcblx0XHRAcmVjZWl2ZXIgfHw9IChjYWxsZWUgaXNhIEFjY2VzcyAmJiBjYWxsZWUubGVmdCB8fCBOVUxMKVxuXG5cdCMgY2hlY2sgaWYgYWxsIGFyZ3VtZW50cyBhcmUgZXhwcmVzc2lvbnMgLSBvdGhlcndpc2Ugd2UgaGF2ZSBhbiBpc3N1ZVxuXG5cdGRlZiBzYWZlY2hhaW5cblx0XHRjYWxsZWUuc2FmZWNoYWluICMgcmVhbGx5P1xuXG5cdGRlZiBzaG91bGRQYXJlbnRoZXNpemVJblRlcm5hcnlcblx0XHRAcGFyZW5zIG9yIHNhZmVjaGFpbiBvciBAY2FjaGVcblxuXHRkZWYganMgb1xuXHRcdHZhciBvcHQgPSBleHByZXNzaW9uOiB5ZXNcblx0XHR2YXIgcmVjID0gbnVsbFxuXHRcdCMgdmFyIGFyZ3MgPSBjb21wYWN0X18oYXJncykgIyByZWFsbHk/XG5cdFx0dmFyIGFyZ3MgPSBhcmdzXG5cblx0XHQjIGRyb3AgdGhpcz9cblxuXHRcdHZhciBzcGxhdCA9IGFyZ3Muc29tZSBkbyB8dnwgdiBpc2EgU3BsYXRcblxuXHRcdHZhciBvdXQgPSBudWxsXG5cdFx0dmFyIGxmdCA9IG51bGxcblx0XHR2YXIgcmd0ID0gbnVsbFxuXHRcdHZhciB3cmFwID0gbnVsbFxuXG5cdFx0dmFyIGNhbGxlZSA9IEBjYWxsZWUgPSBAY2FsbGVlLm5vZGUgIyBkcm9wIHRoZSB2YXIgb3IgYWNjZXNzP1xuXG5cdFx0IyBpZiBjYWxsZWUgaXNhIENhbGwgJiYgY2FsbGVlLnNhZmVjaGFpblxuXHRcdCNcdHllc1xuXG5cdFx0aWYgY2FsbGVlIGlzYSBBY2Nlc3Ncblx0XHRcdGxmdCA9IGNhbGxlZS5sZWZ0XG5cdFx0XHRyZ3QgPSBjYWxsZWUucmlnaHRcblxuXHRcdGlmIGNhbGxlZSBpc2EgU3VwZXIgb3IgY2FsbGVlIGlzYSBTdXBlckFjY2Vzc1xuXHRcdFx0QHJlY2VpdmVyID0gc2NvcGVfXy5jb250ZXh0XG5cdFx0XHQjIHJldHVybiBcInN1cGVyY2FsbFwiXG5cblx0XHQjIG5ldmVyIGNhbGwgdGhlIHByb3BlcnR5LWFjY2VzcyBkaXJlY3RseT9cblx0XHRpZiBjYWxsZWUgaXNhIFByb3BlcnR5QWNjZXNzICMgJiYgcmVjID0gY2FsbGVlLnJlY2VpdmVyXG5cdFx0XHRAcmVjZWl2ZXIgPSBjYWxsZWUucmVjZWl2ZXJcblx0XHRcdGNhbGxlZSA9IEBjYWxsZWUgPSBBY2Nlc3MubmV3KGNhbGxlZS5vcCxjYWxsZWUubGVmdCxjYWxsZWUucmlnaHQpXG5cdFx0XHQjIGNvbnNvbGUubG9nIFwidW53cmFwcGluZyB0aGUgcHJvcGVydHlBY2Nlc3NcIlxuXG5cdFx0aWYgcmd0IGlzYSBJZGVudGlmaWVyIGFuZCByZ3QudmFsdWUgPT0gJ2xlbicgYW5kIGFyZ3MuY291bnQgPT0gMFxuXHRcdFx0cmV0dXJuIFV0aWwuTGVuLm5ldyhbbGZ0IG9yIGNhbGxlZV0pLmNcblxuXHRcdFx0IyByZXdyaXRlIGEubGVuKC4uKSB0byBsZW4kKGEpXG5cblx0XHRpZiBjYWxsZWUuc2FmZWNoYWluXG5cdFx0XHQjIERvZXMgdGhpcyBhZmZlY3Qgc2hvdWxkUGFyZW50aGVzaXplSW5UZXJuYXJ5P1xuXHRcdFx0IyBpZiBsZnQgaXNhIENhbGxcblx0XHRcdCMgaWYgbGZ0IGlzYSBDYWxsICMgY291bGQgYmUgYSBwcm9wZXJ0eSBhY2Nlc3MgYXMgd2VsbCAtIGl0IGlzIHRoZSBzYW1lP1xuXHRcdFx0IyBpZiBpdCBpcyBhIGxvY2FsIHZhciBhY2Nlc3Mgd2Ugc2ltcGx5IGNoZWNrIGlmIGl0IGlzIGEgZnVuY3Rpb24sIHRoZW4gY2FsbFxuXHRcdFx0IyBidXQgaXQgc2hvdWxkIGJlIHNhZmVjaGFpbmVkIG91dHNpZGUgYXMgd2VsbD9cblx0XHRcdCMgbGZ0LmNhY2hlIGlmIGxmdFxuXHRcdFx0IyB0aGUgb3V0ZXIgc2FmZWNoYWluIHNob3VsZCBub3QgY2FjaGUgdGhlIHdob2xlIGNhbGwgLSBvbmx5IGFzayB0byBjYWNoZVxuXHRcdFx0IyB0aGUgcmVzdWx0PyAtLSBjaGFpbiBvbnRvXG5cdFx0XHR2YXIgaXNmbiA9IFV0aWwuSXNGdW5jdGlvbi5uZXcoW2NhbGxlZV0pXG5cdFx0XHR3cmFwID0gW1wie2lzZm4uY30gICYmICBcIixcIlwiXVxuXHRcdFx0Y2FsbGVlID0gT1AoJy4nLGNhbGxlZS5sZWZ0LGNhbGxlZS5yaWdodClcblx0XHRcdCMgY2FsbGVlIHNob3VsZCBhbHJlYWR5IGJlIGNhY2hlZCBub3cgLVxuXG5cdFx0IyBzaG91bGQganVzdCBmb3JjZSBleHByZXNzaW9uIGZyb20gdGhlIHN0YXJ0LCBubz9cblx0XHRpZiBzcGxhdFxuXHRcdFx0IyBpbXBvcnRhbnQgdG8gd3JhcCB0aGUgc2luZ2xlIHZhbHVlIGluIGEgdmFsdWUsIHRvIGtlZXAgaW1wbGljaXQgY2FsbFxuXHRcdFx0IyB0aGlzIGlzIGR1ZSB0byB0aGUgd2F5IHdlIGNoZWNrIGZvciBhbiBvdXRlciBDYWxsIHdpdGhvdXQgY2hlY2tpbmcgaWZcblx0XHRcdCMgd2UgYXJlIHRoZSByZWNlaXZlciAoaW4gUHJvcGVydHlBY2Nlc3MpLiBTaG91bGQgcmF0aGVyIHdyYXAgaW4gQ2FsbEFyZ3VtZW50c1xuXHRcdFx0bGV0IHJlYyA9IHJlY2VpdmVyXG5cdFx0XHR2YXIgYXJ5ID0gKGFyZ3MuY291bnQgPT0gMSA/IFZhbHVlTm9kZS5uZXcoYXJncy5maXJzdC52YWx1ZSkgOiBBcnIubmV3KGFyZ3MubGlzdCkpXG5cblx0XHRcdHJlYy5jYWNoZSAjIG5lZWQgdG8gY2FjaGUgdGhlIGNvbnRleHQgYXMgaXQgd2lsbCBiZSByZWZlcmVuY2VkIGluIGFwcGx5XG5cdFx0XHRvdXQgPSBcIntjYWxsZWUuYyhleHByZXNzaW9uOiB5ZXMpfS5hcHBseSh7cmVjLmN9LHthcnkuYyhleHByZXNzaW9uOiB5ZXMpfSlcIlxuXG5cdFx0ZWxpZiBAcmVjZWl2ZXJcblx0XHRcdCMgcXVpY2sgd29ya2Fyb3VuZFxuXHRcdFx0QHJlY2VpdmVyLmNhY2hlIHVubGVzcyBAcmVjZWl2ZXIgaXNhIFNjb3BlQ29udGV4dFxuXHRcdFx0YXJncy51bnNoaWZ0KHJlY2VpdmVyKVxuXHRcdFx0IyBzaG91bGQgcmF0aGVyIHJld3JpdGUgdG8gYSBuZXcgY2FsbD9cblx0XHRcdG91dCA9IFwie2NhbGxlZS5jKGV4cHJlc3Npb246IHllcyl9LmNhbGwoe2FyZ3MuYyhleHByZXNzaW9uOiB5ZXMpfSlcIlxuXG5cdFx0ZWxzZVxuXHRcdFx0b3V0ID0gXCJ7Y2FsbGVlLmMoZXhwcmVzc2lvbjogeWVzKX0oe2FyZ3MuYyhleHByZXNzaW9uOiB5ZXMpfSlcIlxuXG5cdFx0aWYgd3JhcFxuXHRcdFx0IyB3ZSBzZXQgdGhlIGNhY2hldmFyIGluc2lkZVxuXHRcdFx0aWYgQGNhY2hlXG5cdFx0XHRcdEBjYWNoZTptYW51YWwgPSB5ZXNcblx0XHRcdFx0b3V0ID0gXCIoe2NhY2hldmFyLmN9PXtvdXR9KVwiXG5cblx0XHRcdG91dCA9IFt3cmFwWzBdLG91dCx3cmFwWzFdXS5qb2luKFwiXCIpXG5cblx0XHRyZXR1cm4gb3V0XG5cblxuXG5cbmV4cG9ydCBjbGFzcyBJbXBsaWNpdENhbGwgPCBDYWxsXG5cblx0ZGVmIGpzIG9cblx0XHRcIntjYWxsZWUuY30oKVwiXG5cbmV4cG9ydCBjbGFzcyBOZXcgPCBDYWxsXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgdGFyZ2V0ID0gY2FsbGVlXG5cblx0XHR3aGlsZSB0YXJnZXQgaXNhIEFjY2Vzc1xuXHRcdFx0bGV0IGxlZnQgPSB0YXJnZXQubGVmdFxuXG5cdFx0XHRpZiAobGVmdCBpc2EgUHJvcGVydHlBY2Nlc3MpIG9yIChsZWZ0IGlzYSBWYXJPckFjY2Vzcylcblx0XHRcdFx0Y2FsbGVlLkBwYXJlbnMgPSB5ZXNcblx0XHRcdFx0YnJlYWtcblxuXHRcdFx0dGFyZ2V0ID0gbGVmdFxuXG5cdFx0dmFyIG91dCA9IFwibmV3IHtjYWxsZWUuY31cIlxuXHRcdG91dCArPSAnKCknIHVubGVzcyBvLnBhcmVudCBpc2EgQ2FsbFxuXHRcdG91dFxuXG5leHBvcnQgY2xhc3MgU3VwZXJDYWxsIDwgQ2FsbFxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIG0gPSBvLm1ldGhvZFxuXHRcdHNlbGYucmVjZWl2ZXIgPSBTRUxGXG5cdFx0c2VsZi5jYWxsZWUgPSBcInttLnRhcmdldC5jfS5zdXBlciQucHJvdG90eXBlLnttLm5hbWUuY31cIlxuXHRcdHN1cGVyXG5cblxuXG5leHBvcnQgY2xhc3MgRXh0ZXJuRGVjbGFyYXRpb24gPCBMaXN0Tm9kZVxuXG5cdGRlZiB2aXNpdFxuXHRcdG5vZGVzID0gbWFwIGRvIHxpdGVtfCBpdGVtLm5vZGUgIyBkcm9wIHZhciBvciBhY2Nlc3MgcmVhbGx5XG5cdFx0IyBvbmx5IGluIGdsb2JhbCBzY29wZT9cblx0XHR2YXIgcm9vdCA9IHNjb3BlX19cblx0XHRmb3IgaXRlbSBpbiBub2Rlc1xuXHRcdFx0dmFyIHZhcmlhYmxlID0gcm9vdC5yZWdpc3RlciBpdGVtLnN5bWJvbCwgaXRlbSwgdHlwZTogJ2dsb2JhbCdcblx0XHRcdHZhcmlhYmxlLmFkZFJlZmVyZW5jZShpdGVtKVxuXHRcdHNlbGZcblxuXHRkZWYgY1xuXHRcdFwiLy8gZXh0ZXJuc1wiXG5cblxuIyBGTE9XXG5cbmV4cG9ydCBjbGFzcyBDb250cm9sRmxvdyA8IE5vZGVcblxuXHRkZWYgbG9jXG5cdFx0QGJvZHkgPyBAYm9keS5sb2MgOiBbMCwwXVxuXG5leHBvcnQgY2xhc3MgQ29udHJvbEZsb3dTdGF0ZW1lbnQgPCBDb250cm9sRmxvd1xuXG5cdGRlZiBpc0V4cHJlc3NhYmxlXG5cdFx0bm9cblxuXG5cbmV4cG9ydCBjbGFzcyBJZiA8IENvbnRyb2xGbG93XG5cblx0cHJvcCB0ZXN0XG5cdHByb3AgYm9keVxuXHRwcm9wIGFsdFxuXHRwcm9wIHNjb3BlXG5cdHByb3AgcHJldklmXG5cblx0ZGVmIHNlbGYudGVybmFyeSBjb25kLCBib2R5LCBhbHRcblx0XHQjIHByZWZlciB0byBjb21waWxlIGl0IHRoaXMgd2F5IGFzIHdlbGxcblx0XHR2YXIgb2JqID0gSWYubmV3KGNvbmQsIEJsb2NrLm5ldyhbYm9keV0pLCB0eXBlOiAnPycpXG5cdFx0b2JqLmFkZEVsc2UgQmxvY2submV3KFthbHRdKVxuXHRcdHJldHVybiBvYmpcblxuXHRkZWYgYWRkRWxzZSBhZGRcblx0XHRpZiBhbHQgJiYgYWx0IGlzYSBJZlxuXHRcdFx0YWx0LmFkZEVsc2UoYWRkKVxuXHRcdGVsc2Vcblx0XHRcdHNlbGYuYWx0ID0gYWRkXG5cdFx0XHRpZiBhZGQgaXNhIElmXG5cdFx0XHRcdGFkZC5wcmV2SWYgPSBzZWxmXG5cdFx0c2VsZlxuXG5cdGRlZiBpbml0aWFsaXplIGNvbmQsIGJvZHksIG8gPSB7fVxuXHRcdHNldHVwXG5cdFx0QHRlc3QgPSBjb25kICMgKG86dHlwZSA9PSAndW5sZXNzJyA/IFVuYXJ5T3AubmV3KCchJyxjb25kLG51bGwpIDogY29uZClcblx0XHRAYm9keSA9IGJvZHlcblx0XHRAYWx0ICA9IG51bGxcblx0XHRAdHlwZSA9IG86dHlwZVxuXHRcdGludmVydCBpZiBAdHlwZSA9PSAndW5sZXNzJ1xuXHRcdEBzY29wZSA9IElmU2NvcGUubmV3KHNlbGYpXG5cdFx0c2VsZlxuXG5cdGRlZiBsb2Ncblx0XHRAbG9jIHx8PSBbQHR5cGUgPyBAdHlwZS5AbG9jIDogMCxib2R5LmxvY1sxXV1cblxuXHRkZWYgaW52ZXJ0XG5cdFx0aWYgQHRlc3QgaXNhIENvbXBhcmlzb25PcFxuXHRcdFx0QHRlc3QgPSBAdGVzdC5pbnZlcnRcblx0XHRlbHNlXG5cdFx0XHRAdGVzdCA9IFVuYXJ5T3AubmV3KCchJyxAdGVzdCxudWxsKVxuXG5cdGRlZiB2aXNpdFxuXHRcdHZhciBhbHQgPSBhbHRcblxuXHRcdEBzY29wZS52aXNpdCBpZiBAc2NvcGVcblx0XHR0ZXN0LnRyYXZlcnNlIGlmIHRlc3RcblxuXHRcdHVubGVzcyBzdGFjay5pc0FuYWx5emluZ1xuXHRcdFx0QHByZXRlc3QgPSB0cnV0aHlfXyh0ZXN0KVxuXG5cdFx0XHRpZiBAcHJldGVzdCA9PT0gdHJ1ZVxuXHRcdFx0XHRhbHQgPSBAYWx0ID0gbnVsbFxuXG5cdFx0XHRlbGlmIEBwcmV0ZXN0ID09PSBmYWxzZVxuXHRcdFx0XHRsb2MgIyBjYWNoZSBsb2NhdGlvbiBiZWZvcmUgcmVtb3ZpbmcgYm9keVxuXHRcdFx0XHRib2R5ID0gbnVsbFxuXG5cdFx0Ym9keS50cmF2ZXJzZSBpZiBib2R5XG5cblx0XHQjIHNob3VsZCBza2lwIHRoZSBzY29wZSBpbiBhbHQuXG5cdFx0aWYgYWx0XG5cdFx0XHRTVEFDSy5wb3Aoc2VsZilcblx0XHRcdGFsdC5Ac2NvcGUgfHw9IEJsb2NrU2NvcGUubmV3KGFsdClcblx0XHRcdGFsdC50cmF2ZXJzZVxuXHRcdFx0U1RBQ0sucHVzaChzZWxmKVxuXG5cdFx0IyBmb3JjZSBpdCBhcyBleHByZXNzaW9uP1xuXHRcdHRvRXhwcmVzc2lvbiBpZiBAdHlwZSA9PSAnPycgYW5kIGlzRXhwcmVzc2FibGVcblx0XHRzZWxmXG5cblxuXHRkZWYganMgb1xuXHRcdHZhciBib2R5ID0gYm9keVxuXHRcdCMgd291bGQgcG9zc2libHkgd2FudCB0byBsb29rIHVwIC8gb3V0XG5cdFx0dmFyIGJyYWNlID0gYnJhY2VzOiB5ZXMsIGluZGVudDogeWVzXG5cblx0XHRpZiBAcHJldGVzdCA9PT0gdHJ1ZVxuXHRcdFx0IyB3aGF0IGlmIGl0IGlzIGluc2lkZSBleHByZXNzaW9uP1xuXHRcdFx0bGV0IGpzID0gYm9keSA/IGJvZHkuYyhicmFjZXM6ICEhcHJldklmKSA6ICd0cnVlJ1xuXG5cdFx0XHR1bmxlc3MgcHJldklmXG5cdFx0XHRcdGpzID0gaGVscGVycy5ub3JtYWxpemVJbmRlbnRhdGlvbihqcylcblxuXHRcdFx0aWYgby5pc0V4cHJlc3Npb25cblx0XHRcdFx0anMgPSAnKCcgKyBqcyArICcpJ1xuXG5cdFx0XHRyZXR1cm4ganNcblxuXHRcdGVsaWYgQHByZXRlc3QgPT09IGZhbHNlXG5cdFx0XHRhbHQucHJldklmID0gcHJldklmIGlmIGFsdCBpc2EgSWZcblx0XHRcdGxldCBqcyA9IGFsdCA/IGFsdC5jKGJyYWNlczogISFwcmV2SWYpIDogJydcblxuXHRcdFx0dW5sZXNzIHByZXZJZlxuXHRcdFx0XHRqcyA9IGhlbHBlcnMubm9ybWFsaXplSW5kZW50YXRpb24oanMpXG5cblx0XHRcdHJldHVybiBqc1xuXHRcdFxuXG5cdFx0aWYgby5pc0V4cHJlc3Npb25cblxuXHRcdFx0aWYgdGVzdD8uc2hvdWxkUGFyZW50aGVzaXplSW5UZXJuYXJ5XG5cdFx0XHRcdHRlc3QuQHBhcmVucyA9IHllc1xuXG5cdFx0XHR2YXIgY29uZCA9IHRlc3QuYyhleHByZXNzaW9uOiB5ZXMpICMgdGhlIGNvbmRpdGlvbiBpcyBhbHdheXMgYW4gZXhwcmVzc2lvblxuXG5cdFx0XHR2YXIgY29kZSA9IGJvZHkgPyBib2R5LmMgOiAndHJ1ZScgIyAoYnJhY2VzOiB5ZXMpXG5cblx0XHRcdGlmIGJvZHkgYW5kIGJvZHkuc2hvdWxkUGFyZW50aGVzaXplSW5UZXJuYXJ5XG5cdFx0XHRcdGNvZGUgPSAnKCcgKyBjb2RlICsgJyknICMgaWYgY29kZS5pbmRleE9mKCcsJykgPj0gMFxuXG5cdFx0XHRpZiBhbHRcblx0XHRcdFx0dmFyIGFsdGJvZHkgPSBhbHQuY1xuXHRcdFx0XHRpZiBhbHQuc2hvdWxkUGFyZW50aGVzaXplSW5UZXJuYXJ5XG5cdFx0XHRcdFx0YWx0Ym9keSA9ICcoJyArIGFsdGJvZHkgKyAnKSdcblxuXHRcdFx0XHRyZXR1cm4gXCJ7Y29uZH0gPyB7Y29kZX0gOiB7YWx0Ym9keX1cIlxuXHRcdFx0ZWxzZVxuXHRcdFx0XHQjIGFnYWluIC0gd2UgbmVlZCBhIGJldHRlciB3YXkgdG8gZGVjaWRlIHdoYXQgbmVlZHMgcGFyZW5zXG5cdFx0XHRcdCMgbWF5YmUgYmV0dGVyIGlmIHdlIHJld3JpdGUgdGhpcyB0byBhbiBPUCgnJiYnKSwgYW5kIHB1dFxuXHRcdFx0XHQjIHRoZSBwYXJlbnMgbG9naWMgdGhlcmVcblx0XHRcdFx0IyBjb25kIHNob3VsZCBwb3NzaWJseSBoYXZlIHBhcmVucyAtIGJ1dCB3aGVyZSBkbyB3ZSBkZWNpZGU/XG5cdFx0XHRcdGlmIEB0YWd0cmVlXG5cdFx0XHRcdFx0cmV0dXJuIFwie2NvbmR9ID8ge2NvZGV9IDogdm9pZCgwKVwiXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gXCJ7Y29uZH0gJiYge2NvZGV9XCJcblx0XHRlbHNlXG5cdFx0XHQjIGlmIHRoZXJlIGlzIG9ubHkgYSBzaW5nbGUgaXRlbSAtIGFuZCBpdCBpcyBhbiBleHByZXNzaW9uP1xuXHRcdFx0dmFyIGNvZGUgPSBudWxsXG5cdFx0XHR2YXIgY29uZCA9IHRlc3QuYyhleHByZXNzaW9uOiB5ZXMpICMgdGhlIGNvbmRpdGlvbiBpcyBhbHdheXMgYW4gZXhwcmVzc2lvblxuXG5cdFx0XHQjIGlmIGJvZHkuY291bnQgPT0gMSAjIGRvbnQgaW5kZW50IGJ5IG91cnNlbHZlcz9cblxuXHRcdFx0aWYgYm9keSBpc2EgQmxvY2sgYW5kIGJvZHkuY291bnQgPT0gMSBhbmQgIShib2R5LmZpcnN0IGlzYSBMb29wRmxvd1N0YXRlbWVudClcblx0XHRcdFx0Ym9keSA9IGJvZHkuZmlyc3RcblxuXHRcdFx0IyBpZiBib2R5LmNvdW50ID09IDFcblx0XHRcdCNcdHAgXCJvbmUgaXRlbSBvbmx5IVwiXG5cdFx0XHQjXHRib2R5ID0gYm9keS5maXJzdFxuXG5cdFx0XHRjb2RlID0gYm9keSA/IGJvZHkuYyhicmFjZXM6IHllcykgOiAne30nICMgKGJyYWNlczogeWVzKVxuXG5cdFx0XHQjIGRvbid0IHdyYXAgaWYgaXQgaXMgb25seSBhIHNpbmdsZSBleHByZXNzaW9uP1xuXHRcdFx0dmFyIG91dCA9IFwie21hcmtfXyhAdHlwZSl9aWYgKHtjb25kfSkgXCIgKyBjb2RlICMgJyB7JyArIGNvZGUgKyAnfScgIyAneycgKyBjb2RlICsgJ30nXG5cdFx0XHRvdXQgKz0gXCIgZWxzZSB7YWx0LmMoYWx0IGlzYSBJZiA/IHt9IDogYnJhY2UpfVwiIGlmIGFsdFxuXHRcdFx0b3V0XG5cblx0ZGVmIHNvdXJjZU1hcE1hcmtlclxuXHRcdHNlbGZcblxuXHRkZWYgc2hvdWxkUGFyZW50aGVzaXplXG5cdFx0ISFAcGFyZW5zXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdCMgaWYgaXQgaXMgcG9zc2libGUsIGNvbnZlcnQgaW50byBleHByZXNzaW9uXG5cdFx0aWYgbm9kZSBpc2EgVGFnVHJlZVxuXHRcdFx0QGJvZHkgPSBAYm9keS5jb25zdW1lKG5vZGUpIGlmIEBib2R5XG5cdFx0XHRAYWx0ID0gQGFsdC5jb25zdW1lKG5vZGUpIGlmIEBhbHRcblx0XHRcdEB0YWd0cmVlID0gbm9kZVxuXHRcdFx0cmV0dXJuIHNlbGZcblxuXHRcdGlmIG5vZGUgaXNhIFRhZ1B1c2hBc3NpZ25cblx0XHRcdEBib2R5ID0gQGJvZHkuY29uc3VtZShub2RlKSBpZiBAYm9keVxuXHRcdFx0QGFsdCA9IEBhbHQuY29uc3VtZShub2RlKSBpZiBAYWx0XG5cdFx0XHRyZXR1cm4gc2VsZlxuXG5cdFx0IyBzcGVjaWFsIGNhc2UgZm9yIElmIGNyZWF0ZWQgZnJvbSBjb25kaXRpb25hbCBhc3NpZ24gYXMgd2VsbD9cblx0XHQjIEB0eXBlID09ICc/JyBhbmRcblx0XHQjIGlkZWFsbHkgd2UgZG9udCByZWFsbHkgd2FudCB0byBtYWtlIGFueSBleHByZXNzaW9uIGxpa2UgdGhpcyBieSBkZWZhdWx0XG5cdFx0dmFyIGlzUmV0ID0gbm9kZSBpc2EgUmV0dXJuXG5cblx0XHQjIG1pZ2h0IGhhdmUgYmVlbiBmb3JjZWQgdG8gZXhwcmVzc2lvbiBhbHJlYWR5XG5cdFx0IyBpZiBpdCB3YXMgb3JpZ2luYWxseSBhIHRlcm5hcnkgLSB3aHkgbm90XG5cdFx0aWYgQGV4cHJlc3Npb24gb3IgKCghaXNSZXQgb3IgQHR5cGUgPT0gJz8nKSBhbmQgaXNFeHByZXNzYWJsZSlcblx0XHRcdHRvRXhwcmVzc2lvbiAjIG1hcmsgYXMgZXhwcmVzc2lvbighKSAtIGlzIHRoaXMgbmVlZGVkP1xuXHRcdFx0cmV0dXJuIHN1cGVyKG5vZGUpXG5cdFx0ZWxzZVxuXHRcdFx0QGJvZHkgPSBAYm9keS5jb25zdW1lKG5vZGUpIGlmIEBib2R5XG5cdFx0XHRAYWx0ID0gQGFsdC5jb25zdW1lKG5vZGUpIGlmIEBhbHRcblx0XHRzZWxmXG5cblxuXHRkZWYgaXNFeHByZXNzYWJsZVxuXHRcdCMgcHJvY2VzczpzdGRvdXQud3JpdGUgJ3gnXG5cdFx0dmFyIGV4cCA9ICghYm9keSB8fCBib2R5LmlzRXhwcmVzc2FibGUpICYmICghYWx0IHx8IGFsdC5pc0V4cHJlc3NhYmxlKVxuXHRcdHJldHVybiBleHBcblxuXG5cbmV4cG9ydCBjbGFzcyBMb29wIDwgU3RhdGVtZW50XG5cblxuXHRwcm9wIHNjb3BlXG5cdHByb3Agb3B0aW9uc1xuXHRwcm9wIGJvZHlcblx0cHJvcCBjYXRjaGVyXG5cblx0ZGVmIGxvY1xuXHRcdHZhciBhID0gQG9wdGlvbnM6a2V5d29yZFxuXHRcdHZhciBiID0gQGJvZHlcblxuXHRcdGlmIGEgYW5kIGJcblx0XHRcdCMgRklYTUUgZG9lcyBub3Qgc3VwcG9ydCBQT1NUXyB2YXJpYW50cyB5ZXRcblx0XHRcdFthLkBsb2MsYi5sb2NbMV1dXG5cdFx0ZWxzZVxuXHRcdFx0WzAsMF1cblxuXHRkZWYgaW5pdGlhbGl6ZSBvcHRpb25zID0ge31cblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAb3B0aW9ucyA9IG9wdGlvbnNcblx0XHRAYm9keSA9IG51bGxcblx0XHRzZWxmXG5cblx0ZGVmIHNldCBvYmpcblx0XHRAb3B0aW9ucyB8fD0ge31cblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iailcblx0XHRmb3IgayBpbiBrZXlzXG5cdFx0XHRAb3B0aW9uc1trXSA9IG9ialtrXVxuXHRcdHNlbGZcblxuXG5cdGRlZiBhZGRCb2R5IGJvZHlcblx0XHRzZWxmLmJvZHkgPSBibGtfXyhib2R5KVxuXHRcdHNlbGZcblxuXG5cdGRlZiBjIG9cblxuXHRcdHZhciBzID0gc3RhY2tcblx0XHR2YXIgY3VyciA9IHMuY3VycmVudFxuXG5cblxuXHRcdGlmIHN0YWNrLmlzRXhwcmVzc2lvbiBvciBpc0V4cHJlc3Npb25cblx0XHRcdCMgd2hhdCB0aGUgaW5uZXIgb25lIHNob3VsZCBub3QgYmUgYW4gZXhwcmVzc2lvbiB0aG91Z2g/XG5cdFx0XHQjIHRoaXMgd2lsbCByZXN1dCBpbiBhbiBpbmZpbml0ZSBsb29wLCBubz8hP1xuXHRcdFx0c2NvcGUuY2xvc2VTY29wZVxuXHRcdFx0dmFyIGFzdCA9IENBTEwoRk4oW10sW3NlbGZdKSxbXSlcblx0XHRcdHJldHVybiBhc3QuYyBvXG5cblx0XHRlbGlmIHN0YWNrLmN1cnJlbnQgaXNhIEJsb2NrIG9yIChzLnVwIGlzYSBCbG9jayBhbmQgcy5jdXJyZW50LkBjb25zdW1lciA9PSBzZWxmKVxuXHRcdFx0c3VwZXIuYyBvXG5cdFx0ZWxzZVxuXHRcdFx0c2NvcGUuY2xvc2VTY29wZVxuXHRcdFx0dmFyIGFzdCA9IENBTEwoRk4oW10sW3NlbGZdKSxbXSlcblx0XHRcdCMgc2NvcGUuY29udGV4dC5yZWZlcmVuY2Vcblx0XHRcdHJldHVybiBhc3QuYyBvXG5cdFx0XHQjIG5lZWQgdG8gd3JhcCBpbiBmdW5jdGlvblxuXG5cblxuZXhwb3J0IGNsYXNzIFdoaWxlIDwgTG9vcFxuXG5cdHByb3AgdGVzdFxuXG5cdGRlZiBpbml0aWFsaXplIHRlc3QsIG9wdHNcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAdGVzdCA9IHRlc3Rcblx0XHRAb3B0aW9ucyA9IG9wdHMgb3Ige31cblx0XHRAc2NvcGUgPSBXaGlsZVNjb3BlLm5ldyhzZWxmKVxuXHRcdCMgc2V0KG9wdHMpIGlmIG9wdHNcblx0XHRpZiBvcHRpb24oOmludmVydClcblx0XHRcdCMgXCJpbnZlcnQgdGVzdCBmb3Igd2hpbGUge0B0ZXN0fVwiXG5cdFx0XHRAdGVzdCA9IHRlc3QuaW52ZXJ0XG5cdFx0IyBpbnZlcnQgdGhlIHRlc3RcblxuXG5cdGRlZiB2aXNpdFxuXHRcdHNjb3BlLnZpc2l0XG5cdFx0dGVzdC50cmF2ZXJzZSBpZiB0ZXN0XG5cdFx0Ym9keS50cmF2ZXJzZSBpZiBib2R5XG5cblx0ZGVmIGxvY1xuXHRcdHZhciBvID0gQG9wdGlvbnNcblx0XHRoZWxwZXJzLnVuaW9uT2ZMb2NhdGlvbnMobzprZXl3b3JkLEBib2R5LG86Z3VhcmQsQHRlc3QpXG5cblx0IyBUT0RPIEJVRyAtLSB3aGVuIHdlIGRlY2xhcmUgYSB2YXIgbGlrZTogd2hpbGUgdmFyIHkgPSAuLi5cblx0IyB0aGUgdmFyaWFibGUgd2lsbCBiZSBkZWNsYXJlZCBpbiB0aGUgV2hpbGVTY29wZSB3aGljaCBuZXZlclxuXHQjIGZvcmNlLWRlY2xhcmVzIHRoZSBpbm5lciB2YXJpYWJsZXMgaW4gdGhlIHNjb3BlXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdCMgVGhpcyBpcyBuZXZlciBleHByZXNzYWJsZSwgYnV0IGF0IHNvbWUgcG9pbnRcblx0XHQjIHdlIG1pZ2h0IHdhbnQgdG8gd3JhcCBpdCBpbiBhIGZ1bmN0aW9uIChsaWtlIENTKVxuXHRcdHJldHVybiBzdXBlciBpZiBpc0V4cHJlc3NhYmxlXG5cblx0XHRpZiBub2RlIGlzYSBUYWdUcmVlXG5cdFx0XHQjIFdBUk4gdGhpcyBpcyBhIGhhY2sgdG8gYWxsb3cgcmVmZXJlbmNlcyBjb21pbmcgdGhyb3VnaCB0aGUgd3JhcHBpbmcgc2NvcGVcblx0XHRcdCMgd2lsbCByZXN1bHQgaW4gdW5uZWVkZWQgc2VsZi1kZWNsYXJhdGlvbnMgYW5kIG90aGVyIG9kZGl0aWVzXG5cdFx0XHRzY29wZS5jbG9zZVNjb3BlXG5cdFx0XHRyZXR1cm4gQ0FMTChGTihbXSxbc2VsZl0pLFtdKVxuXG5cdFx0dmFyIHJldXNlID0gbm9cblx0XHQjIFdBUk4gT3B0aW1pemF0aW9uIC0gbWlnaHQgaGF2ZSB1bnRlbmRlZCBzaWRlLWVmZmVjdHNcblx0XHQjIGlmIHdlIGFyZSBhc3NpZ25pbmcgZGlyZWN0bHkgdG8gYSBsb2NhbCB2YXJpYWJsZSwgd2Ugc2ltcGx5XG5cdFx0IyB1c2Ugc2FpZCB2YXJpYWJsZSBmb3IgdGhlIGlubmVyIHJlc1xuXHRcdCMgaWYgcmV1c2Vcblx0XHQjIFx0cmVzdmFyID0gc2NvcGUuZGVjbGFyZShub2RlLmxlZnQubm9kZS52YXJpYWJsZSxBcnIubmV3KFtdKSxwcm94eTogeWVzKVxuXHRcdCMgXHRub2RlID0gbnVsbFxuXHRcdCMgXHRwIFwiY29uc3VtZSB2YXJpYWJsZSBkZWNsYXJhdG9yIT9cIi5jeWFuXG5cdFx0IyBlbHNlXG5cdFx0IyBkZWNsYXJlIHRoZSB2YXJpYWJsZSB3ZSB3aWxsIHVzZSB0byBzb2FrIHVwIHJlc3VsdHNcblx0XHQjIFRPRE8gVXNlIGEgc3BlY2lhbCB2YXJ0eXBlIGZvciB0aGlzP1xuXHRcdHZhciByZXN2YXIgPSBzY29wZS5kZWNsYXJlKDpyZXMsQXJyLm5ldyhbXSksc3lzdGVtOiB5ZXMpXG5cdFx0IyBXSEFUIC0tIGZpeCB0aGlzIC0tXG5cdFx0QGNhdGNoZXIgPSBQdXNoQXNzaWduLm5ldyhcInB1c2hcIixyZXN2YXIsbnVsbCkgIyB0aGUgdmFsdWUgaXMgbm90IHByZXNldCAjIHdoYXRcblx0XHRib2R5LmNvbnN1bWUoQGNhdGNoZXIpICMgc2hvdWxkIHN0aWxsIHJldHVybiB0aGUgc2FtZSBib2R5XG5cblx0XHQjIHNjb3BlIHZhcnMgbXVzdCBub3QgYmUgY29tcGlsZWQgYmVmb3JlIHRoaXMgLS0gdGhpcyBpcyBpbXBvcnRhbnRcblx0XHR2YXIgYXN0ID0gQmxvY2submV3KFtzZWxmLHJlc3Zhci5hY2Nlc3Nvcl0pICMgc2hvdWxkIGJlIHZhcmFjY2VzcyBpbnN0ZWFkP1xuXHRcdGFzdC5jb25zdW1lKG5vZGUpXG5cdFx0IyBOT1RFIEhlcmUgd2UgY2FuIGZpbmQgYSB3YXkgdG8ga25vdyB3aGV0ZXIgb3Igbm90IHdlIGV2ZW4gbmVlZCB0b1xuXHRcdCMgcmV0dXJuIHRoZSByZXN2YXIuIE9mdGVuIGl0IHdpbGwgbm90IGJlIG5lZWRlZFxuXHRcdCMgRklYTUUgd2hhdCBoYXBwZW5zIGlmIHRoZXJlIGlzIG5vIG5vZGU/IT9cblxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIG91dCA9IFwid2hpbGUgKHt0ZXN0LmMoZXhwcmVzc2lvbjogeWVzKX0pXCIgKyBib2R5LmMoYnJhY2VzOiB5ZXMsIGluZGVudDogeWVzKSAjIC53cmFwXG5cblx0XHRpZiBzY29wZS52YXJzLmNvdW50ID4gMFxuXHRcdFx0cmV0dXJuIFtzY29wZS52YXJzLmMsb3V0XVxuXHRcdG91dFxuXG5cblxuIyBUaGlzIHNob3VsZCBkZWZpbmUgYW4gb3BlbiBzY29wZVxuIyBzaG91bGQgcmF0aGVyXG5leHBvcnQgY2xhc3MgRm9yIDwgTG9vcFxuXG5cblx0ZGVmIGluaXRpYWxpemUgbyA9IHt9XG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QG9wdGlvbnMgPSBvXG5cdFx0QHNjb3BlID0gRm9yU2NvcGUubmV3KHNlbGYpXG5cdFx0QGNhdGNoZXIgPSBudWxsXG5cblx0ZGVmIGxvY1xuXHRcdHZhciBvID0gQG9wdGlvbnNcblx0XHRoZWxwZXJzLnVuaW9uT2ZMb2NhdGlvbnMobzprZXl3b3JkLEBib2R5LG86Z3VhcmQsbzpzdGVwLG86c291cmNlKVxuXG5cdGRlZiB2aXNpdFxuXHRcdHNjb3BlLnZpc2l0XG5cblx0XHRvcHRpb25zWzpzb3VyY2VdLnRyYXZlcnNlICMgd2hhdCBhYm91dCBhd2FrZW5pbmcgdGhlIHZhcnMgaGVyZT9cblx0XHRkZWNsYXJlXG5cdFx0IyBzaG91bGQgYmUgYWJsZSB0byB0b2dnbGUgd2hldGhlciB0byBrZWVwIHRoZSByZXN1bHRzIGhlcmUgYWxyZWFkeSghKVxuXG5cdFx0IyBhZGQgZ3VhcmQgdG8gYm9keVxuXHRcdGlmIG9wdGlvbnM6Z3VhcmRcblx0XHRcdHZhciBvcCA9IElGKG9wdGlvbnM6Z3VhcmQuaW52ZXJ0LEJsb2NrLndyYXAoW0NvbnRpbnVlU3RhdGVtZW50Lm5ldyhcImNvbnRpbnVlXCIpXSkpXG5cdFx0XHRib2R5LnVuc2hpZnQob3AsQlIpXG5cblx0XHRib2R5LnRyYXZlcnNlXG5cblx0ZGVmIGlzQmFyZSBzcmNcblx0XHRzcmMgYW5kIHNyYy5AdmFyaWFibGUgYW5kIHNyYy5AdmFyaWFibGUuQGlzQXJyYXlcblxuXHRkZWYgZGVjbGFyZVxuXHRcdHZhciBvID0gb3B0aW9uc1xuXHRcdHZhciBzY29wZSA9IHNjb3BlXG5cdFx0dmFyIHNyYyAgPSBvOnNvdXJjZVxuXHRcdHZhciB2YXJzID0gb1s6dmFyc10gPSB7fVxuXHRcdHZhciBvaSAgID0gbzppbmRleFxuXG5cdFx0dmFyIGJhcmUgPSBpc0JhcmUoc3JjKVxuXG5cdFx0IyB3aGF0IGFib3V0IGEgcmFuZ2Ugd2hlcmUgd2UgYWxzbyBpbmNsdWRlIGFuIGluZGV4P1xuXHRcdGlmIHNyYyBpc2EgUmFuZ2Vcblx0XHRcdFxuXHRcdFx0bGV0IGZyb20gPSBzcmMubGVmdFxuXHRcdFx0bGV0IHRvID0gc3JjLnJpZ2h0XG5cdFx0XHRsZXQgZHluYW1pYyA9IGZyb20gIWlzYSBOdW0gb3IgdG8gIWlzYSBOdW1cblxuXHRcdFx0aWYgdG8gaXNhIE51bVxuXHRcdFx0XHR2YXJzOmxlbiA9IHRvXG5cdFx0XHRlbHNlXG5cdFx0XHRcdCMgdmFyczpsZW4gPSBzY29wZS52YXJzLnB1c2godmFyczppbmRleC5hc3NpZ25tZW50KHNyYy5sZWZ0KSlcblx0XHRcdFx0IyB2YXJzOmxlbiA9IHRvLmNhY2hlKGZvcmNlOiB5ZXMsIHBvb2w6ICdsZW4nKS5wcmVkZWNsYXJlXG5cdFx0XHRcdHZhcnM6bGVuID0gc2NvcGUuZGVjbGFyZSgnbGVuJyx0byx0eXBlOiAnbGV0Jylcblx0XHRcdFx0IyB0by5jYWNoZShmb3JjZTogeWVzLCBwb29sOiAnbGVuJykucHJlZGVjbGFyZVxuXHRcdFx0XHRcblx0XHRcdCMgc2NvcGUudmFycy5wdXNoKHZhcnM6aW5kZXguYXNzaWdubWVudChzcmMubGVmdCkpXG5cdFx0XHR2YXJzOnZhbHVlID0gc2NvcGUuZGVjbGFyZShvOm5hbWUsZnJvbSx0eXBlOiAnbGV0Jylcblx0XHRcdHZhcnM6dmFsdWUuYWRkUmVmZXJlbmNlKG86bmFtZSkgaWYgbzpuYW1lXG5cdFx0XHRcblx0XHRcdGlmIG86aW5kZXhcblx0XHRcdFx0dmFyczppbmRleCA9IHNjb3BlLmRlY2xhcmUobzppbmRleCwwLHR5cGU6ICdsZXQnKVxuXHRcdFx0XHR2YXJzOmluZGV4LmFkZFJlZmVyZW5jZShvOmluZGV4KVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHR2YXJzOmluZGV4ID0gdmFyczp2YWx1ZVxuXHRcdFx0XHRcblx0XHRcdGlmIGR5bmFtaWNcblx0XHRcdFx0dmFyczpkaWZmID0gc2NvcGUuZGVjbGFyZSgncmQnLE9QKCctJyx2YXJzOmxlbix2YXJzOnZhbHVlKSx0eXBlOiAnbGV0JylcblxuXHRcdGVsc2Vcblx0XHRcdCMgd2UgYXJlIHVzaW5nIGF1dG9tYXRpYyBjYWNoaW5nIGZhciB0b28gbXVjaCBoZXJlXG5cdFx0XHR2YXIgaSA9IHZhcnM6aW5kZXggPSBvaSA/IHNjb3BlLmRlY2xhcmUob2ksMCx0eXBlOiAnbGV0JykgOiB1dGlsLmNvdW50ZXIoMCx5ZXMsc2NvcGUpLnByZWRlY2xhcmVcblxuXHRcdFx0dmFyczpzb3VyY2UgPSBiYXJlID8gc3JjIDogdXRpbC5pdGVyYWJsZShzcmMseWVzKS5wcmVkZWNsYXJlXG5cdFx0XHR2YXJzOmxlbiAgICA9IHV0aWwubGVuKHZhcnM6c291cmNlLHllcykucHJlZGVjbGFyZVxuXG5cdFx0XHR2YXJzOnZhbHVlID0gc2NvcGUuZGVjbGFyZShvOm5hbWUsbnVsbCx0eXBlOiAnbGV0Jylcblx0XHRcdHZhcnM6dmFsdWUuYWRkUmVmZXJlbmNlKG86bmFtZSkgIyBhZGRpbmcgcmVmZXJlbmNlIVxuXHRcdFx0aS5hZGRSZWZlcmVuY2Uob2kpIGlmIG9pXG5cblx0XHRyZXR1cm4gc2VsZlxuXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXG5cdFx0aWYgaXNFeHByZXNzYWJsZVxuXHRcdFx0cmV0dXJuIHN1cGVyXG5cblx0XHQjIG90aGVyIGNhc2VzIGFzIHdlbGwsIG5vP1xuXHRcdGlmIG5vZGUgaXNhIFRhZ1RyZWVcblx0XHRcdHNjb3BlLmNsb3NlU2NvcGVcblxuXHRcdFx0bm9kZS5AbG9vcCA9IHNlbGZcblx0XHRcdEB0YWd0cmVlID0gbm9kZVxuXG5cdFx0XHRib2R5LmNvbnN1bWUobm9kZSlcblxuXHRcdFx0bm9kZS5AbG9vcCA9IG51bGxcblx0XHRcdGxldCBmbiA9IExhbWJkYS5uZXcoW10sW3NlbGZdKVxuXHRcdFx0Zm4uc2NvcGUud3JhcChzY29wZSlcblx0XHRcdCMgVE9ETyBTY29wZSBvZiBnZW5lcmF0ZWQgbGFtYmRhIHNob3VsZCBiZSBhZGRlZCBpbnRvIHN0YWNrIGZvclxuXHRcdFx0IyB2YXJpYWJsZSBuYW1pbmcgLyByZXNvbHV0aW9uXG5cdFx0XHRyZXR1cm4gQ0FMTChmbixbXSlcblxuXG5cdFx0aWYgQHJlc3ZhclxuXHRcdFx0dmFyIGFzdCA9IEJsb2NrLm5ldyhbc2VsZixCUixAcmVzdmFyLmFjY2Vzc29yXSlcblx0XHRcdGFzdC5jb25zdW1lKG5vZGUpXG5cdFx0XHRyZXR1cm4gYXN0XG5cblx0XHR2YXIgcmVzdmFyID0gbnVsbFxuXHRcdHZhciByZXVzZWFibGUgPSBubyAjIG5vZGUgaXNhIEFzc2lnbiAmJiBub2RlLmxlZnQubm9kZSBpc2EgTG9jYWxWYXJBY2Nlc3Ncblx0XHR2YXIgYXNzaWduZWUgPSBudWxsXG5cdFx0IyBtaWdodCBvbmx5IHdvcmsgZm9yIGxvY2Fscz9cblx0XHRpZiBub2RlIGlzYSBBc3NpZ25cblx0XHRcdGlmIHZhciByZWNlaXZlciA9IG5vZGUubGVmdFxuXHRcdFx0XHRpZiBhc3NpZ25lZSA9IHJlY2VpdmVyLkB2YXJpYWJsZVxuXHRcdFx0XHRcdCMgd2UgY2FuIG9ubHkgcHVsbCB0aGUgdmFyIHJlZmVyZW5jZSBpbnRvIHRoZSBzY29wZVxuXHRcdFx0XHRcdCMgaWYgd2Uga25vdyB0aGF0IHRoZSB2YXJpYWJsZSBpcyBkZWNsYXJlZCBpbiB0aGlzIHNjb3BlXG5cdFx0XHRcdFx0cmV1c2VhYmxlID0gKHJlY2VpdmVyIGlzYSBWYXJSZWZlcmVuY2UpXG5cblx0XHQjIFdBUk4gT3B0aW1pemF0aW9uIC0gbWlnaHQgaGF2ZSB1bnRlbmRlZCBzaWRlLWVmZmVjdHNcblx0XHQjIGlmIHdlIGFyZSBhc3NpZ25pbmcgZGlyZWN0bHkgdG8gYSBsb2NhbCB2YXJpYWJsZSwgd2Ugc2ltcGx5XG5cdFx0IyB1c2Ugc2FpZCB2YXJpYWJsZSBmb3IgdGhlIGlubmVyIHJlc1xuXHRcdGlmIHJldXNlYWJsZSBhbmQgYXNzaWduZWVcblx0XHRcdCMgaW5zdGVhZCBvZiBkZWNsYXJpbmcgaXQgaW4gdGhlIHNjb3BlIC0gd2h5IG5vdCBkZWNsYXJlIGl0IG91dHNpZGU/XG5cdFx0XHQjIGl0IG1pZ2h0IGFscmVhZHkgZXhpc3QgaW4gdGhlIG91dGVyIHNjb3BlIG5vP1xuXHRcdFx0IyBhc3NpZ25lZS5yZXNvbHZlXG5cdFx0XHQjIHNob3VsZCBwcm9iYWJseSBpbnN0ZWFkIGFsdGVyIHRoZSBhc3NpZ24tbm9kZSB0byBzZXQgdmFsdWUgdG8gYSBibGFuayBhcnJheVxuXHRcdFx0IyByZXN2YXIgPSBzY29wZS5wYXJlbnQuZGVjbGFyZShhc3NpZ25lZSxBcnIubmV3KFtdKSxwcm94eTogeWVzLHBvczogMClcblxuXHRcdFx0IyB0aGlzIHZhcmlhYmxlIHNob3VsZCByZWFsbHkgbm90IGJlIHJlZGVjbGFyZWQgaW5zaWRlIGhlcmUgYXQgYWxsXG5cdFx0XHRhc3NpZ25lZS5yZXNvbHZlXG5cdFx0XHQjIHJlc3ZhciA9IEByZXN2YXIgPSBzY29wZS5kZWNsYXJlKGFzc2lnbmVlLEFyci5uZXcoW10pLHByb3h5OiB5ZXMpXG5cblx0XHRcdCMgZG9udCBkZWNsYXJlIGl0IC0gc2ltcGx5IHB1c2ggYW4gYXNzaWduIGludG8gdGhlIHZhcmRlY2wgb2Ygc2NvcGVcblx0XHRcdHNjb3BlLnZhcnMudW5zaGlmdChPUCgnPScsYXNzaWduZWUsQXJyLm5ldyhbXSkpKVxuXHRcdFx0cmVzdmFyID0gQHJlc3ZhciA9IGFzc2lnbmVlXG5cdFx0XHRcblxuXHRcdFx0bm9kZS5AY29uc3VtZXIgPSBzZWxmXG5cdFx0XHRub2RlID0gbnVsbFxuXG5cdFx0ZWxzZVxuXHRcdFx0IyBkZWNsYXJlIHRoZSB2YXJpYWJsZSB3ZSB3aWxsIHVzZSB0byBzb2FrIHVwIHJlc3VsdHNcblx0XHRcdCMgd2hhdCBhYm91dCBhIHBvb2wgaGVyZT9cblx0XHRcdHJlc3ZhciA9IEByZXN2YXIgfHw9IHNjb3BlLmRlY2xhcmUoOnJlcyxBcnIubmV3KFtdKSxzeXN0ZW06IHllcywgdHlwZTogJ2xldCcpXG5cblx0XHRpZiBAdGFndHJlZVxuXHRcdFx0QGNhdGNoZXIgPSBUYWdQdXNoQXNzaWduLm5ldyhcInB1c2hcIixyZXN2YXIsbnVsbClcblx0XHRlbHNlXG5cdFx0XHRAY2F0Y2hlciA9IFB1c2hBc3NpZ24ubmV3KFwicHVzaFwiLHJlc3ZhcixudWxsKSAjIHRoZSB2YWx1ZSBpcyBub3QgcHJlc2V0XG5cblx0XHRib2R5LmNvbnN1bWUoQGNhdGNoZXIpICMgc2hvdWxkIHN0aWxsIHJldHVybiB0aGUgc2FtZSBib2R5XG5cblx0XHRpZiBub2RlXG5cdFx0XHR2YXIgYXN0ID0gQmxvY2submV3KFtzZWxmLEJSLHJlc3Zhci5hY2Nlc3Nvci5jb25zdW1lKG5vZGUpXSlcblx0XHRcdHJldHVybiBhc3Rcblx0XHQjIHZhciBhc3QgPSBCbG9jay5uZXcoW3NlbGYsQlIscmVzdmFyLmFjY2Vzc29yXSlcblx0XHQjIGFzdC5jb25zdW1lKG5vZGUpIGlmIG5vZGVcblx0XHQjIHJldHVybiBhc3Rcblx0XHRyZXR1cm4gc2VsZlxuXG5cdFx0IyB0aGlzIGlzIG5ldmVyIGFuIGV4cHJlc3Npb24gKGZvciBub3cgLS0gYnV0IHN0aWxsKVxuXHRcdCMgcmV0dXJuIGFzdFxuXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgdmFycyA9IG9wdGlvbnM6dmFyc1xuXHRcdHZhciBpZHggPSB2YXJzOmluZGV4XG5cdFx0dmFyIHZhbCA9IHZhcnM6dmFsdWVcblx0XHR2YXIgc3JjID0gb3B0aW9uczpzb3VyY2Vcblx0XHRcblx0XHR2YXIgY29uZFxuXHRcdHZhciBmaW5hbFxuXHRcdFxuXHRcdFxuXHRcdGlmIHNyYyBpc2EgUmFuZ2Vcblx0XHRcdGxldCBhID0gc3JjLmxlZnRcblx0XHRcdGxldCBiID0gc3JjLnJpZ2h0XG5cdFx0XHRsZXQgaW5jID0gc3JjLmluY2x1c2l2ZVxuXG5cdFx0XHRjb25kID0gT1AoaW5jID8gJzw9JyA6ICc8Jyx2YWwsdmFyczpsZW4pXG5cdFx0XHRmaW5hbCA9IE9QKCcrKycsdmFsKVxuXG5cdFx0XHRpZiB2YXJzOmRpZmZcblx0XHRcdFx0Y29uZCA9IElmLnRlcm5hcnkoIE9QKCc+Jyx2YXJzOmRpZmYsTnVtLm5ldygwKSksIGNvbmQsIE9QKGluYyA/ICc+PScgOiAnPicsdmFsLHZhcnM6bGVuKSlcblx0XHRcdFx0ZmluYWwgPSBJZi50ZXJuYXJ5KCBPUCgnPicsdmFyczpkaWZmLE51bS5uZXcoMCkpLE9QKCcrKycsdmFsKSxPUCgnLS0nLHZhbCkpXG5cdFx0XHRcblx0XHRcdGlmIGlkeCBhbmQgaWR4ICE9IHZhbFxuXHRcdFx0XHRmaW5hbCA9IEV4cHJlc3Npb25CbG9jay5uZXcoW2ZpbmFsLE9QKCcrKycsaWR4KV0pXG5cdFx0XHRcblx0XHRlbHNlXG5cdFx0XHRjb25kID0gT1AoJzwnLGlkeCx2YXJzOmxlbilcblx0XHRcdFxuXHRcdFx0aWYgdmFsLnJlZmNvdW50IDwgMyBhbmQgdmFsLmFzc2lnbm1lbnRzOmxlbmd0aCA9PSAwXG5cdFx0XHRcdHZhbC5wcm94eSh2YXJzOnNvdXJjZSxpZHgpXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGJvZHkudW5zaGlmdChPUCgnPScsdmFsLE9QKCcuJyx2YXJzOnNvdXJjZSxpZHgpKSwgQlIpXG5cblx0XHRcdGlmIG9wdGlvbnM6c3RlcFxuXHRcdFx0XHRmaW5hbCA9IE9QKCc9JyxpZHgsT1AoJysnLGlkeCxvcHRpb25zOnN0ZXApKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRmaW5hbCA9IE9QKCcrKycsaWR4KVxuXG5cdFx0dmFyIGhlYWQgPSBcInttYXJrX18ob3B0aW9uczprZXl3b3JkKX1mb3IgKHtzY29wZS52YXJzLmN9OyB7Y29uZC5jKGV4cHJlc3Npb246IHllcyl9OyB7ZmluYWwuYyhleHByZXNzaW9uOiB5ZXMpfSkgXCJcblx0XHRyZXR1cm4gaGVhZCArIGJvZHkuYyhicmFjZXM6IHllcywgaW5kZW50OiB5ZXMpXG5cblxuXG5leHBvcnQgY2xhc3MgRm9ySW4gPCBGb3JcblxuXG5cbmV4cG9ydCBjbGFzcyBGb3JPZiA8IEZvclxuXG5cdGRlZiBkZWNsYXJlXG5cdFx0dmFyIG8gPSBvcHRpb25zXG5cdFx0dmFyIHZhcnMgPSBvOnZhcnMgPSB7fVxuXG5cdFx0dmFyIHNyYyA9IHZhcnM6c291cmNlID0gbzpzb3VyY2UuQHZhcmlhYmxlIHx8IHNjb3BlLmRlY2xhcmUoJ28nLG86c291cmNlLCBzeXN0ZW06IHRydWUsIHR5cGU6ICdsZXQnKVxuXHRcdHZhciB2ID0gdmFyczp2YWx1ZSA9IHNjb3BlLmRlY2xhcmUobzppbmRleCxudWxsLGxldDogeWVzLCB0eXBlOiAnbGV0JykgaWYgbzppbmRleFxuXG5cdFx0IyBwb3NzaWJseSBwcm94eSB0aGUgaW5kZXgtdmFyaWFibGU/XG5cblx0XHRpZiBvOm93blxuXHRcdFx0IyB2YXIgaSA9IHZhcnM6aW5kZXggPSBzY29wZS5kZWNsYXJlKCdpJywwLHN5c3RlbTogdHJ1ZSwgdHlwZTogJ2xldCcpICMgbWFyayBhcyBhIGNvdW50ZXI/XG5cdFx0XHQjIHZhciBpID0gdmFyczppbmRleCA9IHV0aWwuY291bnRlcigwLHllcyxzY29wZSkucHJlZGVjbGFyZVxuXHRcdFx0dmFyIGkgPSB2YXJzOmluZGV4ID0gc2NvcGUuZGVjbGFyZSgnaScsTnVtLm5ldygwKSxzeXN0ZW06IHllcywgdHlwZTogJ2NvdW50ZXInLCB1bmlxdWU6IHllcylcblxuXHRcdFx0IyBzeXN0ZW12YXJpYWJsZSAtLSBzaG91bGQgbm90IHJlYWxseSBiZSBhZGRlZCB0byB0aGUgbWFwXG5cdFx0XHR2YXIga2V5cyA9IHZhcnM6a2V5cyA9IHNjb3BlLmRlY2xhcmUoJ2tleXMnLFV0aWwua2V5cyhzcmMuYWNjZXNzb3IpLHN5c3RlbTogeWVzLCB0eXBlOiAnbGV0JykgIyB0aGUgb3V0ZXIgb25lIHNob3VsZCByZXNvbHZlIGZpcnN0XG5cdFx0XHR2YXIgbCA9IHZhcnM6bGVuID0gc2NvcGUuZGVjbGFyZSgnbCcsVXRpbC5sZW4oa2V5cy5hY2Nlc3Nvciksc3lzdGVtOiB5ZXMsIHR5cGU6ICdsZXQnKVxuXHRcdFx0dmFyIGsgPSB2YXJzOmtleSA9IHNjb3BlLmRlY2xhcmUobzpuYW1lLG51bGwsdHlwZTogJ2xldCcpICMgc2NvcGUuZGVjbGFyZShvOm5hbWUsbnVsbCxzeXN0ZW06IHllcylcblx0XHRlbHNlXG5cdFx0XHQjIHdlIHNldCB0aGUgdmFyIC0tIHdoeSBldmVuIGRlY2xhcmUgaXRcblx0XHRcdCMgbm8gbmVlZCB0byBkZWNsYXJlIC0tIGl0IHdpbGwgZGVjbGFyZSBpdHNlbGYgaW4gdGhlIGxvb3AgLSBubz9cblx0XHRcdHZhciBrID0gdmFyczprZXkgPSBzY29wZS5yZWdpc3RlcihvOm5hbWUsbzpuYW1lLHR5cGU6ICdsZXQnKVxuXG5cdFx0IyBUT0RPIHVzZSB1dGlsIC0gd2h5IGFkZCByZWZlcmVuY2VzIGFscmVhZHk/IEFoIC0tIHRoaXMgaXMgZm9yIHRoZSBoaWdobGlnaHRpbmdcblx0XHR2LmFkZFJlZmVyZW5jZShvOmluZGV4KSBpZiB2IGFuZCBvOmluZGV4XG5cdFx0ay5hZGRSZWZlcmVuY2UobzpuYW1lKSBpZiBrIGFuZCBvOm5hbWVcblxuXHRcdHNlbGZcblxuXHRkZWYganMgb1xuXHRcdHZhciB2YXJzID0gb3B0aW9uczp2YXJzXG5cblx0XHR2YXIgbyA9IHZhcnM6c291cmNlXG5cdFx0dmFyIGsgPSB2YXJzOmtleVxuXHRcdHZhciB2ID0gdmFyczp2YWx1ZVxuXHRcdHZhciBpID0gdmFyczppbmRleFxuXG5cdFx0dmFyIGNvZGVcblxuXHRcdGlmIHZcblx0XHRcdCMgc2V0IHZhbHVlIGFzIHByb3h5IG9mIG9iamVjdFtrZXldXG5cdFx0XHQjIHBvc3NpYmx5IG1ha2UgaXQgYSByZWY/IHdoYXQgaXMgaGFwcGVuaW5nP1xuXHRcdFx0IyB2LnJlZmNvdW50IDwgMyA/IHYucHJveHkobyxrKSA6IFxuXHRcdFx0aWYgdi5yZWZjb3VudCA+IDBcblx0XHRcdFx0Ym9keS51bnNoaWZ0KE9QKCc9Jyx2LE9QKCcuJyxvLGspKSlcblxuXHRcdGlmIG9wdGlvbnM6b3duXG5cblx0XHRcdCMgaWYgay5yZWZjb3VudCA8IDMgIyBzaG91bGQgcHJvYmFibHkgYWRqdXN0IHRoZXNlXG5cdFx0XHQjXHRrLnByb3h5KHZhcnM6a2V5cyxpKVxuXHRcdFx0IyBlbHNlXG5cdFx0XHRib2R5LnVuc2hpZnQoT1AoJz0nLGssT1AoJy4nLHZhcnM6a2V5cyxpKSkpXG5cdFx0XHRjb2RlID0gYm9keS5jKGluZGVudDogeWVzLCBicmFjZXM6IHllcykgIyAud3JhcFxuXHRcdFx0dmFyIGhlYWQgPSBcInttYXJrX18ob3B0aW9uczprZXl3b3JkKX1mb3IgKHtzY29wZS52YXJzLmN9OyB7T1AoJzwnLGksdmFyczpsZW4pLmN9OyB7T1AoJysrJyxpKS5jfSlcIlxuXHRcdFx0cmV0dXJuIGhlYWQgKyBjb2RlXG5cblx0XHRjb2RlID0gYm9keS5jKGJyYWNlczogeWVzLCBpbmRlbnQ6IHllcylcblx0XHQjIGl0IGlzIHJlYWxseSBpbXBvcnRhbnQgdGhhdCB0aGlzIGlzIGEgdHJlYXRlZCBhcyBhIHN0YXRlbWVudFxuXHRcdHNjb3BlLnZhcnMuYyArIFwiO1xcbnttYXJrX18ob3B0aW9uczprZXl3b3JkKX1mb3IgKHZhciB7ay5jfSBpbiB7by5jfSlcIiArIGNvZGVcblxuXHRkZWYgaGVhZFxuXHRcdHZhciB2ID0gb3B0aW9uczp2YXJzXG5cblx0XHRbXG5cdFx0XHRPUCgnPScsdjprZXksT1AoJy4nLHY6a2V5cyx2OmluZGV4KSlcblx0XHRcdE9QKCc9Jyx2OnZhbHVlLE9QKCcuJyx2OnNvdXJjZSx2OmtleSkpIGlmIHY6dmFsdWVcblx0XHRdXG5cbiMgTk8gTkVFRD9cbmV4cG9ydCBjbGFzcyBCZWdpbiA8IEJsb2NrXG5cblxuXHRkZWYgaW5pdGlhbGl6ZSBib2R5XG5cdFx0QG5vZGVzID0gYmxrX18oYm9keSkubm9kZXNcblxuXG5cdGRlZiBzaG91bGRQYXJlbnRoZXNpemVcblx0XHRpc0V4cHJlc3Npb25cblxuXG5cbmV4cG9ydCBjbGFzcyBTd2l0Y2ggPCBDb250cm9sRmxvd1N0YXRlbWVudFxuXG5cblx0cHJvcCBzb3VyY2Vcblx0cHJvcCBjYXNlc1xuXHRwcm9wIGZhbGxiYWNrXG5cblxuXHRkZWYgaW5pdGlhbGl6ZSBhLGIsY1xuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBzb3VyY2UgPSBhXG5cdFx0QGNhc2VzID0gYlxuXHRcdEBmYWxsYmFjayA9IGNcblxuXG5cdGRlZiB2aXNpdFxuXHRcdGMudHJhdmVyc2UgZm9yIGMgaW4gY2FzZXNcblx0XHRmYWxsYmFjay52aXNpdCBpZiBmYWxsYmFja1xuXHRcdHNvdXJjZS52aXNpdCBpZiBzb3VyY2Vcblx0XHRyZXR1cm5cblxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHQjIFRPRE8gd29yayBpbnNpZGUgdGFncyAobGlrZSBsb29wcylcblx0XHRAY2FzZXMgPSBAY2FzZXMubWFwKHxpdGVtfCBpdGVtLmNvbnN1bWUobm9kZSkpXG5cdFx0QGZhbGxiYWNrID0gQGZhbGxiYWNrLmNvbnN1bWUobm9kZSkgaWYgQGZhbGxiYWNrXG5cdFx0c2VsZlxuXG5cdGRlZiBjIG9cblx0XHRpZiBzdGFjay5pc0V4cHJlc3Npb24gb3IgaXNFeHByZXNzaW9uXG5cdFx0XHR2YXIgYXN0ID0gQ0FMTChGTihbXSxbc2VsZl0pLFtdKVxuXHRcdFx0cmV0dXJuIGFzdC5jIG9cblxuXHRcdHN1cGVyLmMobylcblxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIGJvZHkgPSBbXVxuXG5cdFx0Zm9yIHBhcnQgaW4gY2FzZXNcblx0XHRcdHBhcnQuYXV0b2JyZWFrXG5cdFx0XHRib2R5LnB1c2gocGFydClcblxuXHRcdGlmIGZhbGxiYWNrXG5cdFx0XHRib2R5LnB1c2goXCJkZWZhdWx0OlxcblwiICsgZmFsbGJhY2suYyhpbmRlbnQ6IHllcykpXG5cblx0XHRcInN3aXRjaCAoe3NvdXJjZS5jfSkgXCIgKyBoZWxwZXJzLmJyYWNrZXRpemUoY2FyeV9fKGJvZHkpLmpvaW4oXCJcXG5cIikseWVzKVxuXG5cblxuZXhwb3J0IGNsYXNzIFN3aXRjaENhc2UgPCBDb250cm9sRmxvd1N0YXRlbWVudFxuXG5cblx0cHJvcCB0ZXN0XG5cdHByb3AgYm9keVxuXG5cblx0ZGVmIGluaXRpYWxpemUgdGVzdCwgYm9keVxuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEB0ZXN0ID0gdGVzdFxuXHRcdEBib2R5ID0gYmxrX18oYm9keSlcblxuXHRkZWYgdmlzaXRcblx0XHRib2R5LnRyYXZlcnNlXG5cblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0Ym9keS5jb25zdW1lKG5vZGUpXG5cdFx0c2VsZlxuXG5cblx0ZGVmIGF1dG9icmVha1xuXHRcdGJvZHkucHVzaChCcmVha1N0YXRlbWVudC5uZXcpIHVubGVzcyBib2R5Lmxhc3QgaXNhIEJyZWFrU3RhdGVtZW50XG5cdFx0c2VsZlxuXG5cblx0ZGVmIGpzIG9cblx0XHRAdGVzdCA9IFtAdGVzdF0gdW5sZXNzIEB0ZXN0IGlzYSBBcnJheVxuXHRcdHZhciBjYXNlcyA9IEB0ZXN0Lm1hcCBkbyB8aXRlbXwgXCJjYXNlIHtpdGVtLmN9OlwiXG5cdFx0Y2FzZXMuam9pbihcIlxcblwiKSArIGJvZHkuYyhpbmRlbnQ6IHllcykgIyAuaW5kZW50XG5cblxuXG5leHBvcnQgY2xhc3MgVHJ5IDwgQ29udHJvbEZsb3dTdGF0ZW1lbnRcblxuXG5cdHByb3AgYm9keVxuXHQjIHByb3AgbmNhdGNoXG5cdCMgcHJvcCBuZmluYWxseVxuXG5cdGRlZiBpbml0aWFsaXplIGJvZHksIGMsIGZcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAYm9keSA9IGJsa19fKGJvZHkpXG5cdFx0QGNhdGNoID0gY1xuXHRcdEBmaW5hbGx5ID0gZlxuXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdEBib2R5ID0gQGJvZHkuY29uc3VtZShub2RlKVxuXHRcdEBjYXRjaCA9IEBjYXRjaC5jb25zdW1lKG5vZGUpIGlmIEBjYXRjaFxuXHRcdEBmaW5hbGx5ID0gQGZpbmFsbHkuY29uc3VtZShub2RlKSBpZiBAZmluYWxseVxuXHRcdHNlbGZcblxuXG5cdGRlZiB2aXNpdFxuXHRcdEBib2R5LnRyYXZlcnNlXG5cdFx0QGNhdGNoLnRyYXZlcnNlIGlmIEBjYXRjaFxuXHRcdEBmaW5hbGx5LnRyYXZlcnNlIGlmIEBmaW5hbGx5XG5cdFx0IyBubyBibG9ja3MgLSBhZGQgYW4gZW1wdHkgY2F0Y2hcblxuXG5cdGRlZiBqcyBvXG5cdFx0dmFyIG91dCA9IFwidHJ5IFwiICsgYm9keS5jKGJyYWNlczogeWVzLCBpbmRlbnQ6IHllcylcblx0XHRvdXQgKz0gXCIgXCIgKyBAY2F0Y2guYyBpZiBAY2F0Y2hcblx0XHRvdXQgKz0gXCIgXCIgKyBAZmluYWxseS5jIGlmIEBmaW5hbGx5XG5cblx0XHR1bmxlc3MgQGNhdGNoIG9yIEBmaW5hbGx5XG5cdFx0XHRvdXQgKz0gXCIgY2F0Y2ggKGUpIFxceyBcXH1cIlxuXHRcdG91dCArPSBcIjtcIlxuXHRcdG91dFxuXG5cblxuZXhwb3J0IGNsYXNzIENhdGNoIDwgQ29udHJvbEZsb3dTdGF0ZW1lbnRcblxuXHRwcm9wIGJvZHlcblxuXHRkZWYgaW5pdGlhbGl6ZSBib2R5LCB2YXJuYW1lXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QGJvZHkgPSBibGtfXyhib2R5IG9yIFtdKVxuXHRcdEBzY29wZSA9IENhdGNoU2NvcGUubmV3KHNlbGYpXG5cdFx0QHZhcm5hbWUgPSB2YXJuYW1lXG5cdFx0c2VsZlxuXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRAYm9keSA9IEBib2R5LmNvbnN1bWUobm9kZSlcblx0XHRzZWxmXG5cblxuXHRkZWYgdmlzaXRcblx0XHRAc2NvcGUudmlzaXRcblx0XHRAdmFyaWFibGUgPSBAc2NvcGUucmVnaXN0ZXIoQHZhcm5hbWUsc2VsZixwb29sOiAnY2F0Y2h2YXInKVxuXHRcdEBib2R5LnRyYXZlcnNlXG5cblxuXHRkZWYganMgb1xuXHRcdCMgb25seSBpbmRlbnQgaWYgaW5kZW50ZWQgYnkgZGVmYXVsdD9cblx0XHRcImNhdGNoICh7QHZhcmlhYmxlLmN9KSBcIiArIEBib2R5LmMoYnJhY2VzOiB5ZXMsIGluZGVudDogeWVzKVxuXG5cbiMgcmVwZWF0aW5nIG15c2VsZi4uIGRvbid0IGRlYWwgd2l0aCBpdCB1bnRpbCB3ZSBtb3ZlIHRvIGNvbXBhY3QgdHVwbGUtYXJnc1xuIyBmb3IgYWxsIGFzdG5vZGVzXG5cblxuZXhwb3J0IGNsYXNzIEZpbmFsbHkgPCBDb250cm9sRmxvd1N0YXRlbWVudFxuXG5cdGRlZiBpbml0aWFsaXplIGJvZHlcblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAYm9keSA9IGJsa19fKGJvZHkgb3IgW10pXG5cblxuXHRkZWYgdmlzaXRcblx0XHRAYm9keS50cmF2ZXJzZVxuXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdCMgc3dhbGxvdyBzaWxlbnRseVxuXHRcdHNlbGZcblxuXG5cdGRlZiBqcyBvXG5cdFx0XCJmaW5hbGx5IFwiICsgQGJvZHkuYyhicmFjZXM6IHllcywgaW5kZW50OiB5ZXMpXG5cblxuIyBSQU5HRVxuXG5leHBvcnQgY2xhc3MgUmFuZ2UgPCBPcFxuXG5cdGRlZiBpbmNsdXNpdmVcblx0XHRvcCA9PSAnLi4nXG5cblx0ZGVmIGNcblx0XHRcInJhbmdlXCJcblxuXG5leHBvcnQgY2xhc3MgU3BsYXQgPCBWYWx1ZU5vZGVcblxuXHRkZWYganMgb1xuXHRcdHZhciBwYXIgPSBzdGFjay5wYXJlbnRcblx0XHRpZiBwYXIgaXNhIEFyZ0xpc3Qgb3IgcGFyIGlzYSBBcnJcblx0XHRcdFwiW10uc2xpY2UuY2FsbCh7dmFsdWUuY30pXCJcblx0XHRlbHNlXG5cdFx0XHRwIFwid2hhdCBpcyB0aGUgcGFyZW50PyB7cGFyfVwiXG5cdFx0XHRcIlNQTEFUXCJcblxuXHRkZWYgbm9kZVxuXHRcdHZhbHVlXG5cblxuXG5cblxuIyBUQUdTXG5cbnZhciBUQUdfVFlQRVMgPSB7fVxudmFyIFRBR19BVFRSUyA9IHt9XG5cblRBR19UWVBFUy5IVE1MID0gXCJhIGFiYnIgYWRkcmVzcyBhcmVhIGFydGljbGUgYXNpZGUgYXVkaW8gYiBiYXNlIGJkaSBiZG8gYmlnIGJsb2NrcXVvdGUgYm9keSBiclxuIGJ1dHRvbiBjYW52YXMgY2FwdGlvbiBjaXRlIGNvZGUgY29sIGNvbGdyb3VwIGRhdGEgZGF0YWxpc3QgZGQgZGVsIGRldGFpbHMgZGZuXG4gZGl2IGRsIGR0IGVtIGVtYmVkIGZpZWxkc2V0IGZpZ2NhcHRpb24gZmlndXJlIGZvb3RlciBmb3JtIGgxIGgyIGgzIGg0IGg1IGg2XG4gaGVhZCBoZWFkZXIgaHIgaHRtbCBpIGlmcmFtZSBpbWcgaW5wdXQgaW5zIGtiZCBrZXlnZW4gbGFiZWwgbGVnZW5kIGxpIGxpbmtcbiBtYWluIG1hcCBtYXJrIG1lbnUgbWVudWl0ZW0gbWV0YSBtZXRlciBuYXYgbm9zY3JpcHQgb2JqZWN0IG9sIG9wdGdyb3VwIG9wdGlvblxuIG91dHB1dCBwIHBhcmFtIHByZSBwcm9ncmVzcyBxIHJwIHJ0IHJ1YnkgcyBzYW1wIHNjcmlwdCBzZWN0aW9uIHNlbGVjdCBzbWFsbFxuIHNvdXJjZSBzcGFuIHN0cm9uZyBzdHlsZSBzdWIgc3VtbWFyeSBzdXAgdGFibGUgdGJvZHkgdGQgdGV4dGFyZWEgdGZvb3QgdGhcbiB0aGVhZCB0aW1lIHRpdGxlIHRyIHRyYWNrIHUgdWwgdmFyIHZpZGVvIHdiclwiLnNwbGl0KFwiIFwiKVxuXG5UQUdfVFlQRVMuU1ZHID0gXCJjaXJjbGUgZGVmcyBlbGxpcHNlIGcgbGluZSBsaW5lYXJHcmFkaWVudCBtYXNrIHBhdGggcGF0dGVybiBwb2x5Z29uIHBvbHlsaW5lXG5yYWRpYWxHcmFkaWVudCByZWN0IHN0b3Agc3ZnIHRleHQgdHNwYW5cIi5zcGxpdChcIiBcIilcblxuVEFHX0FUVFJTLkhUTUwgPSBcImFjY2VwdCBhY2Nlc3NLZXkgYWN0aW9uIGFsbG93RnVsbFNjcmVlbiBhbGxvd1RyYW5zcGFyZW5jeSBhbHQgYXN5bmNcbiBhdXRvQ29tcGxldGUgYXV0b0ZvY3VzIGF1dG9QbGF5IGNlbGxQYWRkaW5nIGNlbGxTcGFjaW5nIGNoYXJTZXQgY2hlY2tlZFxuIGNsYXNzTmFtZSBjb2xzIGNvbFNwYW4gY29udGVudCBjb250ZW50RWRpdGFibGUgY29udGV4dE1lbnUgY29udHJvbHMgY29vcmRzXG4gY3Jvc3NPcmlnaW4gZGF0YSBkYXRlVGltZSBkZWZlciBkaXIgZGlzYWJsZWQgZG93bmxvYWQgZHJhZ2dhYmxlIGVuY1R5cGUgZm9ybVxuIGZvcm1Ob1ZhbGlkYXRlIGZyYW1lQm9yZGVyIGhlaWdodCBoaWRkZW4gaHJlZiBocmVmTGFuZyBodG1sRm9yIGh0dHBFcXVpdiBpY29uXG4gaWQgbGFiZWwgbGFuZyBsaXN0IGxvb3AgbWF4IG1heExlbmd0aCBtZWRpYUdyb3VwIG1ldGhvZCBtaW4gbXVsdGlwbGUgbXV0ZWRcbiBuYW1lIG5vVmFsaWRhdGUgcGF0dGVybiBwbGFjZWhvbGRlciBwb3N0ZXIgcHJlbG9hZCByYWRpb0dyb3VwIHJlYWRPbmx5IHJlbFxuIHJlcXVpcmVkIHJvbGUgcm93cyByb3dTcGFuIHNhbmRib3ggc2NvcGUgc2Nyb2xsTGVmdCBzY3JvbGxpbmcgc2Nyb2xsVG9wXG4gc2VhbWxlc3Mgc2VsZWN0ZWQgc2hhcGUgc2l6ZSBzcGFuIHNwZWxsQ2hlY2sgc3JjIHNyY0RvYyBzcmNTZXQgc3RhcnQgc3RlcFxuIHN0eWxlIHRhYkluZGV4IHRhcmdldCB0aXRsZSB0eXBlIHVzZU1hcCB2YWx1ZSB3aWR0aCB3bW9kZVwiXG5cblRBR19BVFRSUy5TVkcgPSBcImN4IGN5IGQgZHggZHkgZmlsbCBmaWxsT3BhY2l0eSBmb250RmFtaWx5IGZvbnRTaXplIGZ4IGZ5IGdyYWRpZW50VHJhbnNmb3JtXG4gZ3JhZGllbnRVbml0cyBtYXJrZXJFbmQgbWFya2VyTWlkIG1hcmtlclN0YXJ0IG9mZnNldCBvcGFjaXR5XG4gcGF0dGVybkNvbnRlbnRVbml0cyBwYXR0ZXJuVW5pdHMgcG9pbnRzIHByZXNlcnZlQXNwZWN0UmF0aW8gciByeCByeVxuIHNwcmVhZE1ldGhvZCBzdG9wQ29sb3Igc3RvcE9wYWNpdHkgc3Ryb2tlIHN0cm9rZURhc2hhcnJheSBzdHJva2VMaW5lY2FwXG4gc3Ryb2tlT3BhY2l0eSBzdHJva2VXaWR0aCB0ZXh0QW5jaG9yIHRyYW5zZm9ybSB2ZXJzaW9uIHZpZXdCb3ggeDEgeDIgeCB5MSB5MiB5XCJcblxuXG5leHBvcnQgY2xhc3MgVGFnRGVzYyA8IE5vZGVcblxuXHRkZWYgaW5pdGlhbGl6ZVxuXHRcdHAgJ1RhZ0Rlc2MhISEnLCQwXG5cdFx0c2VsZlxuXG5cdGRlZiBjbGFzc2VzXG5cdFx0cCAnVGFnRGVzY0NsYXNzZXMnLCQwXG5cdFx0c2VsZlxuXG5leHBvcnQgY2xhc3MgVGFnIDwgTm9kZVxuXG5cdHByb3AgcGFydHNcblx0cHJvcCBvYmplY3Rcblx0cHJvcCByZWFjdGl2ZVxuXHRwcm9wIHBhcmVudFxuXHRwcm9wIHRyZWVcblxuXHRkZWYgaW5pdGlhbGl6ZSBvID0ge31cblx0XHRAdHJhdmVyc2VkID0gbm9cblx0XHRAcGFydHMgPSBbXVxuXHRcdG86Y2xhc3NlcyB8fD0gW11cblx0XHRvOmF0dHJpYnV0ZXMgfHw9IFtdXG5cdFx0bzpjbGFzc2VzIHx8PSBbXVxuXHRcdEBvcHRpb25zID0gb1xuXHRcdEByZWZlcmVuY2UgPSBudWxsXG5cdFx0QG9iamVjdCA9IG51bGxcblx0XHRAdHJlZSA9IG51bGxcblx0XHRzZWxmXG5cblx0ZGVmIHNldCBvYmpcblx0XHRmb3Igb3duIGssdiBvZiBvYmpcblx0XHRcdGlmIGsgPT0gJ2F0dHJpYnV0ZXMnXG5cdFx0XHRcdGFkZEF0dHJpYnV0ZShhdHIpIGZvciBhdHIgaW4gdlxuXHRcdFx0XHRjb250aW51ZVxuXG5cdFx0XHRAb3B0aW9uc1trXSA9IHZcblx0XHRzZWxmXG5cblx0ZGVmIGFkZENsYXNzIG5vZGVcblx0XHR1bmxlc3Mgbm9kZSBpc2EgVGFnRmxhZ1xuXHRcdFx0bm9kZSA9IFRhZ0ZsYWcubmV3KG5vZGUpXG5cdFx0QG9wdGlvbnM6Y2xhc3Nlcy5wdXNoKG5vZGUpXG5cdFx0QHBhcnRzLnB1c2gobm9kZSlcblx0XHRzZWxmXG5cblx0ZGVmIGFkZEluZGV4IG5vZGVcblx0XHRAcGFydHMucHVzaChub2RlKVxuXHRcdEBvYmplY3QgPSBub2RlXG5cdFx0c2VsZlxuXG5cdGRlZiBhZGRTeW1ib2wgbm9kZVxuXHRcdGlmIEBwYXJ0czpsZW5ndGggPT0gMFxuXHRcdFx0QHBhcnRzLnB1c2gobm9kZSlcblx0XHRcdEBvcHRpb25zOm5zID0gbm9kZVxuXHRcdHNlbGZcblxuXG5cdGRlZiBhZGRBdHRyaWJ1dGUgYXRyXG5cdFx0QHBhcnRzLnB1c2goYXRyKVxuXHRcdEBvcHRpb25zOmF0dHJpYnV0ZXMucHVzaChhdHIpXG5cdFx0c2VsZlxuXG5cdGRlZiBlbmNsb3Npbmdcblx0XHQoQG9wdGlvbnM6Y2xvc2UgYW5kIEBvcHRpb25zOmNsb3NlLnZhbHVlKVxuXG5cdGRlZiB0eXBlXG5cdFx0QG9wdGlvbnM6dHlwZSB8fCA6ZGl2XG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdHZhciBvID0gQG9wdGlvbnNcblxuXG5cdFx0aWYgbm9kZSBpc2EgVGFnVHJlZVxuXHRcdFx0cGFyZW50ID0gbm9kZS5yb290XG5cblx0XHRcdGlmIG5vZGUuQGxvb3Bcblx0XHRcdFx0IyBhbHdhdHlzIG1ha2UgaXRlbXMgaW4gbG9vcCByZWFjdGl2ZVxuXHRcdFx0XHRyZWFjdGl2ZSA9IG5vZGUucmVhY3RpdmUgb3Igb3B0aW9uKDprZXkpXG5cdFx0XHRcdG9wdGlvbig6bG9vcCxub2RlLkBsb29wKVxuXG5cdFx0XHRcdGlmIG9wdGlvbig6aXZhcilcblx0XHRcdFx0XHR3YXJuIFwiVGFnIGluc2lkZSBsb29wIGNhbiBub3QgaGF2ZSBhIHN0YXRpYyByZWZlcmVuY2Uge29wdGlvbig6aXZhcil9XCIsIHR5cGU6ICdlcnJvcicsIHRva2VuOiBvcHRpb24oOml2YXIpLnZhbHVlXG5cblx0XHRcdGVsc2Vcblx0XHRcdFx0cmVhY3RpdmUgPSBub2RlLnJlYWN0aXZlIG9yICEhb3B0aW9uKDppdmFyKVxuXG5cdFx0XHRyZXR1cm4gc2VsZlxuXG5cdFx0c3VwZXJcblxuXG5cdGRlZiB2aXNpdFxuXHRcdHZhciBvID0gQG9wdGlvbnNcblxuXHRcdGlmIG86aXZhciBvciBvOmtleVxuXHRcdFx0cmVhY3RpdmUgPSB5ZXNcblxuXHRcdHZhciB0eXAgPSBlbmNsb3NpbmdcblxuXHRcdGlmIHR5cCA9PSAnLT4nIG9yIHR5cCA9PSAnPT4nXG5cdFx0XHRAdHJlZSA9IFRhZ0ZyYWdtZW50VHJlZS5uZXcoc2VsZixvOmJvZHksIHJvb3Q6IHNlbGYsIHJlYWN0aXZlOiB5ZXMpXG5cdFx0XHRAZnJhZ21lbnQgPSBvOmJvZHkgPSBUYWdGcmFnbWVudEZ1bmMubmV3KFtdLEJsb2NrLndyYXAoW0B0cmVlXSksbnVsbCxudWxsLGNsb3NlZDogdHlwID09ICctPicpXG5cblx0XHRvOmtleS50cmF2ZXJzZSBpZiBvOmtleVxuXHRcdG86Ym9keS50cmF2ZXJzZSBpZiBvOmJvZHlcblx0XHRvOmlkLnRyYXZlcnNlIGlmIG86aWRcblxuXHRcdGZvciBwYXJ0IGluIEBwYXJ0c1xuXHRcdFx0cGFydC50cmF2ZXJzZVxuXG5cdFx0IyByZW1lbWJlciBzY29wZVxuXHRcdEB0YWdTY29wZSA9IHNjb3BlX19cblx0XHQjIGlmIHR5cCA9PSAnLT4nIG9yIHR5cCA9PSAnPT4nXG5cdFx0IyBcdEB0YWdTY29wZSA9IG86Ym9keS5zY29wZVxuXG5cdFx0c2VsZlxuXG5cdGRlZiByZWZlcmVuY2Vcblx0XHRAcmVmZXJlbmNlIHx8PSBAdGFnU2NvcGUuY2xvc3VyZS50ZW1wb3Jhcnkoc2VsZixwb29sOiAndGFnJykucmVzb2x2ZVxuXG5cdGRlZiBjbG9zdXJlQ2FjaGVcblx0XHRAY2xvc3VyZUNhY2hlIHx8PSBAdGFnU2NvcGUudGFnQ29udGV4dENhY2hlXG5cblxuXHRkZWYgc3RhdGljQ2FjaGVcblx0XHRpZiBAZnJhZ21lbnRcblx0XHRcdEBzdGF0aWNDYWNoZSB8fD0gQGZyYWdtZW50LnNjb3BlLmRlY2xhcmUoXCJfX1wiLE9QKCcuJyxUaGlzLm5ldywnX18nKSkgIyAudGFnQ29udGV4dENhY2hlXG5cdFx0ZWxpZiB0eXBlIGlzYSBTZWxmXG5cdFx0XHRAc3RhdGljQ2FjaGUgfHw9IEB0YWdTY29wZS50YWdDb250ZXh0Q2FjaGVcblx0XHRlbGlmIGV4cGxpY2l0S2V5IG9yIG9wdGlvbig6bG9vcClcblx0XHRcdEBzdGF0aWNDYWNoZSB8fD0gT1AoJy4nLHJlZmVyZW5jZSwnX18nKVxuXHRcdGVsaWYgQHBhcmVudFxuXHRcdFx0QHN0YXRpY0NhY2hlIHx8PSBAcGFyZW50LnN0YXRpY0NhY2hlXG5cblx0ZGVmIGV4cGxpY2l0S2V5XG5cdFx0b3B0aW9uKDppdmFyKSBvciBvcHRpb24oOmtleSlcblxuXHRkZWYganMganNvXG5cdFx0dmFyIG8gPSBAb3B0aW9uc1xuXHRcdHZhciBhID0ge31cblx0XHR2YXIgZW5jID0gZW5jbG9zaW5nXG5cblx0XHR2YXIgc2V0dXAgPSBbXVxuXHRcdHZhciBjYWxscyA9IFtdXG5cdFx0dmFyIHN0YXRpY3MgPSBbXVxuXG5cdFx0dmFyIHNjb3BlID0gc2NvcGVfX1xuXHRcdHZhciBjb21taXQgPSBcImVuZFwiXG5cdFx0dmFyIGNvbnRlbnQgPSBvOmJvZHlcblxuXHRcdHZhciBpc1NlbGYgPSB0eXBlIGlzYSBTZWxmXG5cdFx0dmFyIGJvZHlTZXR0ZXIgPSBpc1NlbGYgPyBcInNldENoaWxkcmVuXCIgOiBcInNldENvbnRlbnRcIlxuXG5cdFx0IyBpZiB3ZSBhcmUgcmVhY3RpdmUgLSBmaW5kIHRoZVxuXG5cdFx0IyBzaG91bGQgbm90IGNhY2hlIHN0YXRpY3MgaWYgdGhlIG5vZGUgaXRzZWxmIGlzIG5vdCBjYWNoZWRcblx0XHQjIHRoYXQgd291bGQgb25seSBtYW5nbGUgdGhlIG9yZGVyIGluIHdoaWNoIHdlIHNldCB0aGUgcHJvcGVydGllc1xuXHRcdHZhciBjYWNoZVN0YXRpY3MgPSB5ZXNcblxuXHRcdGZvciBhdHIgaW4gbzphdHRyaWJ1dGVzXG5cdFx0XHRhW2F0ci5rZXldID0gYXRyLnZhbHVlXG5cblx0XHR2YXIgcXVvdGUgPSBkbyB8c3RyfCBoZWxwZXJzLnNpbmdsZXF1b3RlKHN0cilcblx0XHR2YXIgaWQgPSBvOmlkIGlzYSBOb2RlID8gbzppZC5jIDogKG86aWQgYW5kIHF1b3RlKG86aWQuYykpXG5cdFx0dmFyIHRyZWUgPSBAdHJlZSBvciBudWxsXG5cdFx0dmFyIHBhcmVudCA9IHNlbGYucGFyZW50XG5cdFx0dmFyIGNfem9uZSA9IHNjb3BlLmNvbnRleHQuY1xuXG5cdFx0dmFyIG91dCA9IGlmIGlzU2VsZlxuXHRcdFx0Y29tbWl0ID0gXCJzeW5jZWRcIlxuXHRcdFx0cmVhY3RpdmUgPSB5ZXNcblx0XHRcdEByZWZlcmVuY2UgPSBzY29wZS5jb250ZXh0XG5cdFx0XHRzY29wZS5jb250ZXh0LmNcblxuXHRcdGVsaWYgdHlwZS5pc0NsYXNzXG5cdFx0XHRcInttYXJrX18obzpvcGVuKX17dHlwZS5uYW1lfS5idWlsZCh7Y196b25lfSlcIlxuXHRcdGVsc2Vcblx0XHRcdFwie21hcmtfXyhvOm9wZW4pfXtzY29wZS50YWdDb250ZXh0UGF0aH0ue3R5cGUuc3Bhd25lcn0oe2Nfem9uZX0pXCJcblxuXHRcdGlmIG86aWRcblx0XHRcdHN0YXRpY3MucHVzaChcIi5zZXRJZCh7cXVvdGUobzppZCl9KVwiKVxuXG5cdFx0IyB0aGlzIGlzIHJlYWN0aXZlIGlmIGl0IGhhcyBhbiBpdmFyXG5cdFx0aWYgbzppdmFyXG5cdFx0XHRyZWFjdGl2ZSA9IHllc1xuXHRcdFx0c3RhdGljcy5wdXNoKFwiLnJlZl8oe3F1b3RlKG86aXZhci5uYW1lKX0se2Nfem9uZX0pXCIpXG5cblx0XHRpZiBvOmJvZHkgaXNhIEZ1bmNcblx0XHRcdGJvZHlTZXR0ZXIgPSBcInNldFRlbXBsYXRlXCJcblxuXHRcdGVsaWYgbzpib2R5XG5cdFx0XHRpZiBvOmJvZHkgaXNhIEFyZ0xpc3QgYW5kIG86Ym9keS5jb3VudCA9PSAxIGFuZCBvOmJvZHkuZmlyc3QuaXNTdHJpbmdcblx0XHRcdFx0Ym9keVNldHRlciA9IFwic2V0VGV4dFwiXG5cblx0XHRcdGVsc2Vcblx0XHRcdFx0IyB3b3VsZCBwcm9iYWJseSBiZSBiZXR0ZXIgdG8gY29udmVydCB0byBhIHRhZ3RyZWUgZHVyaW5nIHRoZSBpbml0aWFsIHZpc2l0XG5cdFx0XHRcdHRyZWUgPSBUYWdUcmVlLm5ldyhzZWxmLCBvOmJvZHksIHJvb3Q6IHNlbGYsIHJlYWN0aXZlOiByZWFjdGl2ZSlcblx0XHRcdFx0Y29udGVudCA9IHRyZWVcblx0XHRcdFx0c2VsZi50cmVlID0gdHJlZVxuXG5cdFx0aWYgdHJlZVxuXHRcdFx0IyB0aGlzIGlzIHRoZSBwb2ludCB3aGVyZSB3ZSB0cmF2ZXJzZSB0aGUgaW5uZXIgbm9kZXMgd2l0aCBvdXIgdHJlZVxuXHRcdFx0IyBzaG91bGQgcmF0aGVyIGhhcHBlbiBpbiB2aXNpdCAtIGxvbmcgYmVmb3JlLlxuXHRcdFx0dHJlZS5yZXNvbHZlXG5cblx0XHR2YXIgZHluYW1pY0ZsYWdJbmRleCA9IGlzU2VsZiA/IDEgOiAwXG5cblx0XHRmb3IgcGFydCBpbiBAcGFydHNcblx0XHRcdHZhciBwanNcblx0XHRcdHZhciBwY2FjaGUgPSBub1xuXG5cdFx0XHRpZiBwYXJ0IGlzYSBUYWdBdHRyXG5cdFx0XHRcdHZhciBha2V5ID0gU3RyaW5nKHBhcnQua2V5KVxuXHRcdFx0XHR2YXIgYXZhbCA9IHBhcnQudmFsdWVcblxuXHRcdFx0XHRwY2FjaGUgPSBhdmFsLmlzUHJpbWl0aXZlXG5cblxuXHRcdFx0XHRpZiBha2V5WzBdID09ICcuJ1xuXHRcdFx0XHRcdHBjYWNoZSA9IG5vXG5cdFx0XHRcdFx0cGpzID0gXCIuZmxhZyh7cXVvdGUoYWtleS5zdWJzdHIoMSkpfSx7YXZhbC5jfSlcIlxuXHRcdFx0XHRlbGlmIGFrZXlbMF0gPT0gJzonXG5cdFx0XHRcdFx0cGpzID0gXCIuc2V0SGFuZGxlcih7cXVvdGUoYWtleS5zdWJzdHIoMSkpfSx7YXZhbC5jfSx7c2NvcGUuY29udGV4dC5jfSlcIlxuXG5cdFx0XHRcdGVsaWYgYWtleS5zdWJzdHIoMCw1KSA9PSAnZGF0YS0nXG5cdFx0XHRcdFx0cGpzID0gXCIuZGF0YXNldCgne2FrZXkuc2xpY2UoNSl9Jyx7YXZhbC5jfSlcIlxuXHRcdFx0XHRlbGlmIHBhcnQuaXNOYW1lc3BhY2VkXG5cdFx0XHRcdFx0bGV0IG5zID0gYWtleS5zcGxpdChcIjpcIilbMF1cblx0XHRcdFx0XHRsZXQgayA9IGFrZXkuc3BsaXQoXCI6XCIpWzFdXG5cblx0XHRcdFx0XHRpZiBucyA9PSAnY3NzJ1xuXHRcdFx0XHRcdFx0cGpzID0gXCIue21hcmtfXyhwYXJ0LmtleSl9Y3NzKCd7a30nLHthdmFsLmN9KVwiXG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0cGpzID0gXCIue21hcmtfXyhwYXJ0LmtleSl9c2V0TmVzdGVkQXR0cigne25zfScsJ3trfScse2F2YWwuY30pXCJcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHBqcyA9IFwiLnttYXJrX18ocGFydC5rZXkpfXtoZWxwZXJzLnNldHRlclN5bShha2V5KX0oe2F2YWwuY30pXCJcblxuXHRcdFx0XHRpZiBhdmFsIGlzYSBQYXJlbnNcblx0XHRcdFx0XHRhdmFsID0gYXZhbC52YWx1ZVxuXG5cdFx0XHRcdCMgaWYgdGhlIHZhbHVlIGlzIGEgZnVuY3Rpb24gd2hpY2ggZG9lcyBub3QgcmVmZXIgdG8gYW55IG91dGVyXG5cdFx0XHRcdCMgdmFyaWFibGVzIChiZXNpZGVzIHNlbGYpLCB3ZSBjYW4gbWFrZSBpdCBzdGF0aWMsIHNvIGFzIHRvIG5vdFxuXHRcdFx0XHQjIHJlY3JlYXRlIHRoZSBmdW5jdGlvbiBvbiBldmVyeSByZW5kZXJcblx0XHRcdFx0aWYgYXZhbCBpc2EgRnVuYyBhbmQgIWF2YWwubm9ubG9jYWxzXG5cdFx0XHRcdFx0cGNhY2hlID0geWVzXG5cblxuXHRcdFx0ZWxpZiBwYXJ0IGlzYSBUYWdGbGFnXG5cdFx0XHRcdGlmIHBhcnQudmFsdWUgaXNhIE5vZGVcblx0XHRcdFx0XHRpZiByZWFjdGl2ZVxuXHRcdFx0XHRcdFx0bGV0IGlkeCA9IGR5bmFtaWNGbGFnSW5kZXhcblx0XHRcdFx0XHRcdHBqcyA9IFwiLnNldEZsYWcoe2lkeH0se3BhcnQudmFsdWUuY30pXCJcblx0XHRcdFx0XHRcdGR5bmFtaWNGbGFnSW5kZXggPSBpZHggKyAyXG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0cGpzID0gcGFydC5jXG5cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHBqcyA9IHBhcnQuY1xuXHRcdFx0XHRcdHBjYWNoZSA9IHllc1xuXG5cdFx0XHRpZiBwanNcblx0XHRcdFx0Y2FjaGVTdGF0aWNzICYmIHBjYWNoZSA/IHN0YXRpY3MucHVzaChwanMpIDogY2FsbHMucHVzaChwanMpXG5cblx0XHRpZiBvYmplY3Rcblx0XHRcdGNhbGxzLnB1c2goXCIuc2V0RGF0YSh7b2JqZWN0LmN9KVwiKVxuXG5cdFx0IyB3ZSBuZWVkIHRvIHRyaWdnZXIgb3VyIG93biByZWZlcmVuY2UgYmVmb3JlIHRoZSBib2R5IGRvZXNcblx0XHQjIGJ1dCB3ZSBkbyBub3QgbmVlZCBhIHJlZmVyZW5jZSBpZiB3ZSBoYXZlIG5vIGJvZHlcblx0XHRpZiByZWFjdGl2ZSBhbmQgdHJlZSBhbmQgKGV4cGxpY2l0S2V5IG9yIG86bG9vcClcblx0XHRcdHJlZmVyZW5jZVxuXHRcdFx0IyBzZWxmXG5cblx0XHRpZiByZWFjdGl2ZSBhbmQgcGFyZW50IGFuZCBwYXJlbnQudHJlZSBhbmQgIW9wdGlvbig6aXZhcilcblx0XHRcdCMgbm90IGlmIGl0IGhhcyBhIHNlcGFyYXRlIHRhZz9cblx0XHRcdG86dHJlZVJlZiA9IHBhcmVudC50cmVlLm5leHRDYWNoZUtleShzZWxmKVxuXHRcdFx0aWYgcGFyZW50Lm9wdGlvbig6dHJlZVJlZikgYW5kICFwYXJlbnQuZXhwbGljaXRLZXkgYW5kICFwYXJlbnQub3B0aW9uKDpsb29wKSBhbmQgIShwYXJlbnQudHJlZSBpc2EgVGFnRnJhZ21lbnRUcmVlKVxuXHRcdFx0XHRvOnRyZWVSZWYgPSBwYXJlbnQub3B0aW9uKDp0cmVlUmVmKSArIG86dHJlZVJlZlxuXG5cdFx0aWYgdmFyIGJvZHkgPSBjb250ZW50IGFuZCBjb250ZW50LmMoZXhwcmVzc2lvbjogeWVzKVxuXHRcdFx0bGV0IHR5cCA9IDBcblxuXHRcdFx0aWYgdHJlZVxuXHRcdFx0XHRpZiB0cmVlLnN0YXRpY1xuXHRcdFx0XHRcdHR5cCA9IDJcblx0XHRcdFx0ZWxpZiByZWFjdGl2ZSBvciB0cmVlLnJlYWN0aXZlXG5cdFx0XHRcdFx0aWYgIXRyZWUuc2luZ2xlIG9yIHRyZWUuc2luZ2xlIGlzYSBJZlxuXHRcdFx0XHRcdFx0dHlwID0gMVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHR5cCA9IDNcblxuXG5cdFx0XHRpZiBib2R5U2V0dGVyID09ICdzZXRDaGlsZHJlbicgb3IgYm9keVNldHRlciA9PSAnc2V0Q29udGVudCdcblx0XHRcdFx0Y2FsbHMucHVzaCBcIi57Ym9keVNldHRlcn0oe2JvZHl9LHt0eXB9KVwiXG5cdFx0XHRlbGlmIGJvZHlTZXR0ZXIgPT0gJ3NldFRleHQnXG5cdFx0XHRcdHN0YXRpY3MucHVzaCBcIi57Ym9keVNldHRlcn0oe2JvZHl9KVwiXG5cdFx0XHRlbHNlXG5cdFx0XHRcdGNhbGxzLnB1c2ggXCIue2JvZHlTZXR0ZXJ9KHtib2R5fSlcIlxuXG5cblx0XHRjYWxscy5wdXNoIFwiLntjb21taXR9KClcIlxuXG5cdFx0bGV0IGxpbmVMZW4gPSBvdXQ6bGVuZ3RoXG5cblx0XHRpZiBzdGF0aWNzOmxlbmd0aFxuXHRcdFx0IyBmb3IgaXRlbSBpbiBzdGF0aWNzXG5cdFx0XHQjIFx0aWYgbGluZUxlbiA+IDQwXG5cdFx0XHQjIFx0XHRvdXQgKz0gXCJcXG5cXHRcXHRcXHRcIlxuXHRcdFx0IyBcdFx0bGluZUxlbiA9IDBcblx0XHRcdCMgXHRvdXQgKz0gaXRlbVxuXHRcdFx0IyBcdGxpbmVMZW4gKz0gaXRlbTpsZW5ndGhcblxuXHRcdFx0b3V0ID0gb3V0ICsgc3RhdGljcy5qb2luKFwiXCIpXG5cblx0XHRpZiAobzppdmFyIG9yIG86a2V5IG9yIHJlYWN0aXZlKSBhbmQgISh0eXBlIGlzYSBTZWxmKVxuXHRcdFx0IyBpZiB0aGlzIGlzIGFuIGl2YXIsIHdlIHNob3VsZCBzZXQgdGhlIHJlZmVyZW5jZSByZWxhdGl2ZVxuXHRcdFx0IyB0byB0aGUgb3V0ZXIgcmVmZXJlbmNlLCBvciBwb3NzaWJseSByaWdodCBvbiBjb250ZXh0P1xuXHRcdFx0dmFyIHBhcnRyZWUgPSBwYXJlbnQgYW5kIHBhcmVudC50cmVlXG5cdFx0XHR2YXIgYWNjXG5cblx0XHRcdGxldCBuciA9IFNUQUNLLmluY3IoJ3RhZ0NhY2hlS2V5Jylcblx0XHRcdGxldCBrZXkgPSBvOnRyZWVSZWYgb3IgY291bnRlclRvU2hvcnRSZWYobnIpICsgJ19fJ1xuXHRcdFx0bGV0IGN0eFxuXG5cdFx0XHRpZiBvOml2YXJcblx0XHRcdFx0Y3R4ID0gc2NvcGUuY29udGV4dFxuXHRcdFx0XHRrZXkgPSBvOml2YXJcblxuXHRcdFx0ZWxpZiBvOmtleSBhbmQgIW86dHJlZVJlZlxuXHRcdFx0XHQjIHAgXCJoYXMgZHluYW1pYyBrZXkgYnV0IG5vdCBpbnNpZGUgYW55IG5vZGVcIixvOmtleS5jXG5cdFx0XHRcdGxldCBtZXRob2QgPSBTVEFDSy5tZXRob2Rcblx0XHRcdFx0bGV0IHBhdGhzID0gT1AoJy4nLE9QKCcuJyxTZWxmLm5ldywnX18nKSwnXycgKyBtZXRob2QubmFtZSlcblx0XHRcdFx0bGV0IHNldHRlciA9IE9QKCc9JyxwYXRocyxPUCgnfHwnLHBhdGhzLExJVCgne30nKSkpXG5cdFx0XHRcdGN0eCA9IHNjb3BlLmNsb3N1cmUuZGVjbGFyZSgnX18nLFBhcmVucy5uZXcoc2V0dGVyKSlcblx0XHRcdFx0a2V5ID0gbzprZXlcblxuXHRcdFx0ZWxpZiBvOmtleSBhbmQgIW86bG9vcFxuXHRcdFx0XHRrZXkgPSBPUCgnKycsXCIne2tleX0kJCdcIixvOmtleSlcblx0XHRcdFx0a2V5LmNhY2hlKClcblx0XHRcdFx0Y3R4ID0gcGFyZW50ID8gcGFyZW50LnN0YXRpY0NhY2hlIDogY2xvc3VyZUNhY2hlXG5cblx0XHRcdGVsaWYgbzpsb29wIG9yIG86a2V5XG5cdFx0XHRcdGlmIHBhcmVudFxuXHRcdFx0XHRcdGN0eCA9IHBhcmVudC5zdGF0aWNDYWNoZVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0Y3R4ID0gY2xvc3VyZUNhY2hlXG5cblx0XHRcdFx0IyBjdHggPSBwYXJlbnQgYW5kIHBhcmVudC5yZWZlcmVuY2Vcblx0XHRcdFx0bGV0IHMgPSBzY29wZS5jbG9zdXJlXG5cdFx0XHRcdGxldCBwYXRoID0gT1AoJy4nLGN0eCxrZXkpXG5cdFx0XHRcdGxldCBrdmFyID0gXCIke2tleX1cIlxuXHRcdFx0XHRsZXQgY2FjaGVEZWZhdWx0ID0gTElUKCd7fScpXG5cblx0XHRcdFx0aWYgbzprZXlcblx0XHRcdFx0XHRrZXkgPSBvOmtleVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0a3ZhciA9ICdfJCdcblx0XHRcdFx0XHRpZiBvOmxvb3Bcblx0XHRcdFx0XHRcdG86bG9vcC5AdGFnQ291bnQgfHw9IDBcblxuXHRcdFx0XHRcdFx0aWYgbzpsb29wLkB0YWdDb3VudCA+IDBcblx0XHRcdFx0XHRcdFx0a3ZhciArPSBvOmxvb3AuQHRhZ0NvdW50XG5cdFx0XHRcdFx0XHRvOmxvb3AuQHRhZ0NvdW50KytcblxuXHRcdFx0XHRcdGxldCBpZHggPSBvOmxvb3Aub3B0aW9uKDp2YXJzKVs6aW5kZXhdXG5cdFx0XHRcdFx0Y2FjaGVEZWZhdWx0ID0gTElUKCdbXScpXG5cdFx0XHRcdFx0a2V5ID0gaWR4XG5cblx0XHRcdFx0bGV0IHNldHRlciA9IE9QKCc9JyxwYXRoLE9QKCd8fCcscGF0aCxjYWNoZURlZmF1bHQpKVxuXHRcdFx0XHQjIGRvbnQgcmVkZWNsYXJlP1xuXHRcdFx0XHRjdHggPSBzLmRlY2xhcmUoa3ZhcixQYXJlbnMubmV3KHNldHRlcikpXG5cdFx0XHRlbHNlXG5cdFx0XHRcdCMgb3IgdGhlIHRyZWUtY2FjaGUgbm8/XG5cdFx0XHRcdGN0eCA9IHBhcmVudCA/IHBhcmVudC5zdGF0aWNDYWNoZSA6IGNsb3N1cmVDYWNoZVxuXG5cdFx0XHQjIHVubGVzcyBjdHhcblx0XHRcdCMgXHRpZiBwYXJlbnRcblx0XHRcdCMgXHRcdHZhciB0cmVlID0gcGFyZW50LnRyZWVcblx0XHRcdCMgXHRcdGNvbnNvbGUubG9nICdubyBjb250ZXh0IScsdHJlZVxuXHRcdFx0IyBcdFx0Y3R4ID0gcGFyZW50LnRyZWUuc3RhdGljQ2FjaGVcblxuXHRcdFx0IyBuZWVkIHRoZSBjb250ZXh0IC0tIG1pZ2h0IGJlIGJldHRlciB0byByZXdyaXRlIGl0IGZvciByZWFsP1xuXHRcdFx0IyBwYXJzZSB0aGUgd2hvbGUgdGhpbmcgaW50byBjYWxscyBldGNcblx0XHRcdGFjYyB8fD0gT1AoJy4nLGN0eCxrZXkpICMgLmNcblxuXHRcdFx0aWYgbzppdmFyXG5cdFx0XHRcdG91dCA9IFwie2FjYy5jfSB8fCB7b3V0fVwiXG5cdFx0XHRlbHNlXG5cdFx0XHRcdG91dCA9IFwie2FjYy5jfSA9IHthY2MuY30gfHwge291dH1cIlxuXG5cdFx0XHRpZiBAcmVmZXJlbmNlXG5cdFx0XHRcdG91dCA9IFwie3JlZmVyZW5jZS5jfSA9IHtvdXR9XCJcblxuXHRcdFx0b3V0ID0gXCIoe291dH0pXCJcblxuXHRcdFx0I1xuXHRcdFx0IyBcdG91dCA9IFwiKHtyZWZlcmVuY2UuY30gPSB7YWNjLmN9PXthY2MuY30gfHwge291dH0pXCJcblx0XHRcdCMgZWxzZVxuXHRcdFx0IyBcdG91dCA9IFwiKHthY2MuY30gPSB7YWNjLmN9IHx8IHtvdXR9KVwiXG5cblx0XHRyZXR1cm4gb3V0ICsgY2FsbHMuam9pbihcIlwiKVxuXG4jIFRoaXMgaXMgYSBoZWxwZXItbm9kZVxuIyBTaG91bGQgcHJvYmFibHkgdXNlIHRoZSBzYW1lIHR5cGUgb2YgbGlzdG5vZGUgZXZlcnl3aGVyZVxuIyBhbmQgc2ltcGx5IGZsYWcgdGhlIHR5cGUgYXMgVGFnVHJlZSBpbnN0ZWFkXG5leHBvcnQgY2xhc3MgVGFnVHJlZSA8IExpc3ROb2RlXG5cblx0cHJvcCBjb3VudGVyXG5cdHByb3AgY29uZGl0aW9uc1xuXHRwcm9wIGJsb2Nrc1xuXHRwcm9wIGNhY2hlclxuXG5cdGRlZiBpbml0aWFsaXplIG93bmVyLCBsaXN0LCBvcHRpb25zID0ge31cblx0XHRAb3duZXIgPSBvd25lclxuXHRcdEBub2RlcyA9IGxvYWQobGlzdClcblx0XHRAb3B0aW9ucyA9IG9wdGlvbnNcblx0XHRAY29uZGl0aW9ucyA9IFtdXG5cdFx0QGJsb2NrcyA9IFtzZWxmXVxuXHRcdEBjb3VudGVyID0gMFxuXHRcdHNlbGZcblxuXHRkZWYgcGFyZW50XG5cdFx0QHBhcmVudCB8fD0gQG93bmVyLnBhcmVudFxuXG5cdGRlZiBzdGF0aWNDYWNoZVxuXHRcdEBvd25lci5zdGF0aWNDYWNoZVxuXG5cdGRlZiBuZXh0Q2FjaGVLZXlcblx0XHR2YXIgbnVtID0gQGNvdW50ZXIrK1xuXHRcdHZhciByZWYgPSBjb3VudGVyVG9TaG9ydFJlZihudW0pXG5cblx0XHRpZiByZWY6bGVuZ3RoID4gMVxuXHRcdFx0cmVmID0gcmVmICsgcmVmOmxlbmd0aFxuXG5cdFx0IyBpZiBAb3duZXIuZXhwbGljaXRLZXkgb3IgQG93bmVyLm9wdGlvbig6bG9vcClcblx0XHRyZWYgPSBjYWNoZVByZWZpeCArIHJlZlxuXHRcdCMgcmVmID0gcmVmLnRvTG93ZXJDYXNlIHVubGVzcyBAb3duZXIudHlwZSBpc2EgU2VsZlxuXHRcdHJldHVybiByZWZcblxuXHRkZWYgY2FjaGVQcmVmaXhcblx0XHRpZiBAb3duZXIuZXhwbGljaXRLZXkgb3IgQG93bmVyLm9wdGlvbig6bG9vcClcblx0XHRcdCckJ1xuXHRcdGVsc2Vcblx0XHRcdCcnXG5cblx0ZGVmIGxvYWQgbGlzdFxuXHRcdGlmIGxpc3QgaXNhIExpc3ROb2RlXG5cdFx0XHQjIHdlIHN0aWxsIHdhbnQgdGhlIGluZGVudGF0aW9uIGlmIHdlIGFyZSBub3QgaW4gYSB0ZW1wbGF0ZVxuXHRcdFx0IyBvciwgcmF0aGVyIC0gd2Ugd2FudCB0aGUgYmxvY2sgdG8gZ2V0IHRoZSBpbmRlbnRhdGlvbiAtIG5vdCB0aGUgdHJlZVxuXHRcdFx0QGluZGVudGF0aW9uIHx8PSBsaXN0LkBpbmRlbnRhdGlvbiAjIGlmIGxpc3QuY291bnQgPiAxXG5cdFx0XHRsaXN0Lm5vZGVzXG5cdFx0ZWxzZVxuXHRcdFx0Y29tcGFjdF9fKGxpc3QgaXNhIEFycmF5ID8gbGlzdCA6IFtsaXN0XSlcblxuXHRkZWYgcm9vdFxuXHRcdG9wdGlvbig6cm9vdClcblxuXHRkZWYgcmVhY3RpdmVcblx0XHRvcHRpb24oOnJlYWN0aXZlKVxuXG5cdGRlZiByZXNvbHZlXG5cdFx0cmVtYXAgZG8gfGN8IGMuY29uc3VtZShzZWxmKVxuXHRcdHNlbGZcblxuXHRkZWYgc3RhdGljXG5cdFx0IyBldmVyeSByZWFsIG5vZGVcblx0XHRAc3RhdGljID89IGV2ZXJ5IGRvIHxjfCAoYyBpc2EgVGFnIG9yIGMgaXNhIFN0ciBvciBjIGlzYSBNZXRhKVxuXG5cdGRlZiBzaW5nbGVcblx0XHRAc2luZ2xlID89IChyZWFsQ291bnQgPT0gMSA/IGxhc3QgOiBubylcblxuXHRkZWYgaGFzVGFnc1xuXHRcdHNvbWUgZG8gfGN8IGMgaXNhIFRhZ1xuXG5cdGRlZiBjIG9cblx0XHQjIEZJWE1FIFRFU1Qgd2hhdCBhYm91dCBjb21tZW50cz8/P1xuXHRcdHZhciBzaW5nbGUgPSBzaW5nbGVcblxuXHRcdCMgbm8gaW5kZW50YXRpb24gaWYgdGhpcyBzaG91bGQgcmV0dXJuXG5cdFx0aWYgc2luZ2xlIGFuZCBTVEFDSy5jdXJyZW50IGlzYSBSZXR1cm5cblx0XHRcdEBpbmRlbnRhdGlvbiA9IG51bGxcblxuXHRcdHZhciBvdXQgPSBzdXBlcihvKVxuXG5cdFx0aWYgIXNpbmdsZSBvciBzaW5nbGUgaXNhIElmXG5cdFx0XHRpZiBzaG91bGRNYXJrQXJyYXlcblx0XHRcdFx0XCJ7c2NvcGVfXy5pbWJhLmN9LnN0YXRpYyhbe291dH1dLDEpXCJcblx0XHRcdGVsc2Vcblx0XHRcdFx0XCJbe291dH1dXCJcblx0XHRlbHNlXG5cdFx0XHRvdXRcblxuXHRkZWYgc2hvdWxkTWFya0FycmF5XG5cdFx0bm9cblxuZXhwb3J0IGNsYXNzIFRhZ0ZyYWdtZW50VHJlZSA8IFRhZ1RyZWVcblxuXHRkZWYgY2FjaGVQcmVmaXhcblx0XHQnJCdcblxuXHRkZWYgdmlzaXRcblx0XHRzdXBlclxuXHRcdEBjbG9zdXJlID0gc2NvcGVfX1xuXHRcdHNlbGZcblxuXHRkZWYgc3RhdGljQ2FjaGVcblx0XHRAb3duZXIuc3RhdGljQ2FjaGVcblxuXHRkZWYgc2hvdWxkTWFya0FycmF5XG5cdFx0eWVzXG5cbmV4cG9ydCBjbGFzcyBUYWdXcmFwcGVyIDwgVmFsdWVOb2RlXG5cblx0ZGVmIHZpc2l0XG5cdFx0aWYgdmFsdWUgaXNhIEFycmF5XG5cdFx0XHR2YWx1ZS5tYXAofHZ8IHYudHJhdmVyc2UpXG5cdFx0ZWxzZVxuXHRcdFx0dmFsdWUudHJhdmVyc2Vcblx0XHRzZWxmXG5cblx0ZGVmIGNcblx0XHRcIntzY29wZV9fLmltYmEuY30uZ2V0VGFnRm9yRG9tKHt2YWx1ZS5jKGV4cHJlc3Npb246IHllcyl9KVwiXG5cbmV4cG9ydCBjbGFzcyBUYWdBdHRyaWJ1dGVzIDwgTGlzdE5vZGVcblxuXHRkZWYgZ2V0IG5hbWVcblx0XHRmb3Igbm9kZSBpbiBub2Rlc1xuXHRcdFx0cmV0dXJuIG5vZGUgaWYgbm9kZS5rZXkgPT0gbmFtZVxuXG5cbmV4cG9ydCBjbGFzcyBUYWdBdHRyIDwgTm9kZVxuXG5cdHByb3Aga2V5XG5cdHByb3AgdmFsdWVcblxuXHRkZWYgdmlzaXRcblx0XHR2YWx1ZS50cmF2ZXJzZSBpZiB2YWx1ZVxuXHRcdHNlbGZcblxuXHRkZWYgaW5pdGlhbGl6ZSBrLCB2XG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QGtleSA9IGtcblx0XHRAdmFsdWUgPSB2XG5cblx0ZGVmIHBvcHVsYXRlIG9ialxuXHRcdG9iai5hZGQoa2V5LCB2YWx1ZSlcblx0XHRzZWxmXG5cblx0ZGVmIGlzTmFtZXNwYWNlZFxuXHRcdFN0cmluZyhrZXkpLmluZGV4T2YoJzonKSA+IDBcblxuXHRkZWYgY1xuXHRcdFwiYXR0cmlidXRlXCJcblxuXG5leHBvcnQgY2xhc3MgVGFnRmxhZyA8IE5vZGVcblxuXHRwcm9wIHZhbHVlXG5cdHByb3AgdG9nZ2xlclxuXG5cdGRlZiBpbml0aWFsaXplIHZhbHVlXG5cdFx0QHRyYXZlcnNlZCA9IG5vXG5cdFx0QHZhbHVlID0gdmFsdWVcblx0XHRzZWxmXG5cblx0ZGVmIHZpc2l0XG5cdFx0dW5sZXNzIEB2YWx1ZSBpc2EgU3RyaW5nXG5cdFx0XHRAdmFsdWUudHJhdmVyc2Vcblx0XHRzZWxmXG5cblx0ZGVmIGNcblx0XHRpZiB2YWx1ZSBpc2EgTm9kZVxuXHRcdFx0XCIuZmxhZyh7dmFsdWUuY30pXCJcblx0XHRlbHNlXG5cdFx0XHRcIi5mbGFnKHtoZWxwZXJzLnNpbmdsZXF1b3RlKHZhbHVlKX0pXCJcblxuXG5cbiMgU0VMRUNUT1JTXG5cblxuZXhwb3J0IGNsYXNzIFNlbGVjdG9yIDwgTGlzdE5vZGVcblxuXHRkZWYgaW5pdGlhbGl6ZSBsaXN0LCBvcHRpb25zXG5cdFx0QG5vZGVzID0gbGlzdCBvciBbXVxuXHRcdEBvcHRpb25zID0gb3B0aW9uc1xuXG5cdGRlZiBhZGQgcGFydCwgdHlwXG5cdFx0cHVzaChwYXJ0KVxuXHRcdHNlbGZcblxuXHRkZWYgZ3JvdXBcblx0XHQjIGZvciBub3cgd2Ugc2ltcGx5IGFkZCBhIGNvbW1hXG5cdFx0IyBob3cgd291bGQgdGhpcyB3b3JrIGZvciBkc3Q/XG5cdFx0QG5vZGVzLnB1c2goU2VsZWN0b3JHcm91cC5uZXcoXCIsXCIpKVxuXHRcdHNlbGZcblxuXHRkZWYgcXVlcnlcblx0XHR2YXIgc3RyID0gXCJcIlxuXHRcdHZhciBhcnkgPSBbXVxuXG5cdFx0Zm9yIGl0ZW0gaW4gbm9kZXNcblx0XHRcdHZhciB2YWwgPSBpdGVtLmNcblx0XHRcdGlmIHZhbCBpc2EgU3RyaW5nXG5cdFx0XHRcdHN0ciA9IFwie3N0cn17dmFsfVwiXG5cblx0XHRcIid7c3RyfSdcIlxuXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgdHlwID0gb3B0aW9uKDp0eXBlKVxuXHRcdHZhciBxID0gY19fKHF1ZXJ5KVxuXHRcdHZhciBpbWJhID0gc2NvcGVfXy5pbWJhLmNcblxuXHRcdGlmIHR5cCA9PSAnJSdcblx0XHRcdFwie2ltYmF9LnEkKHtxfSx7by5zY29wZS5jb250ZXh0LmMoZXhwbGljaXQ6IHllcyl9KVwiICMgZXhwbGljaXQgY29udGV4dFxuXHRcdGVsaWYgdHlwID09ICclJSdcblx0XHRcdFwie2ltYmF9LnEkJCh7cX0se28uc2NvcGUuY29udGV4dC5jKGV4cGxpY2l0OiB5ZXMpfSlcIlxuXHRcdGVsc2Vcblx0XHRcdFwie2ltYmF9LnF7dHlwfSh7cX0pXCJcblxuXHRcdCMgcmV0dXJuIFwie3R5cH0ge3Njb3BlZH0gLSB7YWxsfVwiXG5cblxuZXhwb3J0IGNsYXNzIFNlbGVjdG9yUGFydCA8IFZhbHVlTm9kZVxuXG5cdGRlZiBjXG5cdFx0Y19fKEB2YWx1ZSlcblxuZXhwb3J0IGNsYXNzIFNlbGVjdG9yR3JvdXAgPCBTZWxlY3RvclBhcnRcblxuXHRkZWYgY1xuXHRcdFwiLFwiXG5cbmV4cG9ydCBjbGFzcyBTZWxlY3RvclR5cGUgPCBTZWxlY3RvclBhcnRcblxuXHRkZWYgY1xuXHRcdHZhciBuYW1lID0gdmFsdWUubmFtZVxuXG5cdFx0IyBhdCBsZWFzdCBiZSB2ZXJ5IGNvbnNlcnZhdGl2ZSBhYm91dCB3aGljaCB0YWdzIHdlXG5cdFx0IyBjYW4gZHJvcCB0aGUgdGFnIGZvcj9cblx0XHQjIG91dCBpbiBUQUdfVFlQRVMuSFRNTCA/XG5cdFx0bmFtZSBpbiBUQUdfVFlQRVMuSFRNTCA/IG5hbWUgOiB2YWx1ZS5zZWxcblxuXG5leHBvcnQgY2xhc3MgU2VsZWN0b3JVbml2ZXJzYWwgPCBTZWxlY3RvclBhcnRcblxuZXhwb3J0IGNsYXNzIFNlbGVjdG9yTmFtZXNwYWNlIDwgU2VsZWN0b3JQYXJ0XG5cbmV4cG9ydCBjbGFzcyBTZWxlY3RvckNsYXNzIDwgU2VsZWN0b3JQYXJ0XG5cblx0ZGVmIGNcblx0XHRpZiBAdmFsdWUgaXNhIE5vZGVcblx0XHRcdFwiLicre0B2YWx1ZS5jfSsnXCJcblx0XHRlbHNlXG5cdFx0XHRcIi57Y19fKEB2YWx1ZSl9XCJcblxuZXhwb3J0IGNsYXNzIFNlbGVjdG9ySWQgPCBTZWxlY3RvclBhcnRcblxuXHRkZWYgY1xuXHRcdGlmIEB2YWx1ZSBpc2EgTm9kZVxuXHRcdFx0XCIjJyt7QHZhbHVlLmN9KydcIlxuXHRcdGVsc2Vcblx0XHRcdFwiI3tjX18oQHZhbHVlKX1cIlxuXG5leHBvcnQgY2xhc3MgU2VsZWN0b3JDb21iaW5hdG9yIDwgU2VsZWN0b3JQYXJ0XG5cblx0ZGVmIGNcblx0XHRcIntjX18oQHZhbHVlKX1cIlxuXG5leHBvcnQgY2xhc3MgU2VsZWN0b3JQc2V1ZG9DbGFzcyA8IFNlbGVjdG9yUGFydFxuXG5leHBvcnQgY2xhc3MgU2VsZWN0b3JBdHRyaWJ1dGUgPCBTZWxlY3RvclBhcnRcblxuXHQjIHJlbWVtYmVyIHRvIHZpc2l0IG5vZGVzIGluc2lkZSBoZXJlP1xuXHRkZWYgaW5pdGlhbGl6ZSBsZWZ0LG9wLHJpZ2h0XG5cdFx0QGxlZnQgPSBsZWZ0XG5cdFx0QG9wID0gb3Bcblx0XHRAcmlnaHQgPSBAdmFsdWUgPSByaWdodFxuXG5cdGRlZiBjXG5cdFx0IyBUT0RPIHBvc3NpYmx5IHN1cHBvcnQgLnRvU2VsIG9yIHNlbCQodikgZm9yIGl0ZW1zIGluc2lkZSBxdWVyeVxuXHRcdCMgY291bGQgZWFzaWx5IGRvIGl0IHdpdGggYSBoZWxwZXItZnVuY3Rpb24gdGhhdCBpcyBhZGRlZCB0byB0aGUgdG9wIG9mIHRoZSBmaWxlc2NvcGVcblx0XHRpZiBAcmlnaHQgaXNhIFN0clxuXHRcdFx0XCJbe0BsZWZ0LmN9e0BvcH17QHJpZ2h0LmN9XVwiXG5cdFx0ZWxpZiBAcmlnaHRcblx0XHRcdCMgdGhpcyBpcyBub3QgYXQgYWxsIGdvb2Rcblx0XHRcdFwiW3tAbGVmdC5jfXtAb3B9XFxcIicre2NfXyhAcmlnaHQpfSsnXFxcIl1cIlxuXHRcdGVsc2Vcblx0XHRcdFwiW3tAbGVmdC5jfV1cIlxuXG5cdFx0XHQjIC4uLlxuXG5cblxuXG4jIERFRkVSXG5cbmV4cG9ydCBjbGFzcyBBd2FpdCA8IFZhbHVlTm9kZVxuXG5cdHByb3AgZnVuY1xuXG5cdGRlZiBqcyBvXG5cdFx0IyBpbnRyb2R1Y2UgYSB1dGlsIGhlcmUsIG5vP1xuXHRcdENBTEwoT1AoJy4nLFV0aWwuUHJvbWlzaWZ5Lm5ldyhbdmFsdWVdKSwndGhlbicpLFtmdW5jXSkuY1xuXHRcdCMgdmFsdWUuY1xuXG5cdGRlZiB2aXNpdCBvXG5cdFx0IyB0aGluZ3MgYXJlIG5vdyB0cmF2ZXJzZWQgaW4gYSBzb21ld2hhdCBjaGFvdGljIG9yZGVyLiBOZWVkIHRvIHRpZ2h0ZW5cblx0XHQjIENyZWF0ZSBhd2FpdCBmdW5jdGlvbiAtIHB1c2ggdGhpcyB2YWx1ZSB1cCB0byBibG9jaywgdGFrZSB0aGUgb3V0ZXJcblx0XHR2YWx1ZS50cmF2ZXJzZVxuXG5cdFx0dmFyIGJsb2NrID0gby51cChCbG9jaykgIyBvciB1cCB0byB0aGUgY2xvc2VzdCBGVU5DVElPTj9cblx0XHR2YXIgb3V0ZXIgPSBvLnJlbGF0aXZlKGJsb2NrLDEpXG5cdFx0dmFyIHBhciA9IG8ucmVsYXRpdmUoc2VsZiwtMSlcblxuXHRcdGZ1bmMgPSBBc3luY0Z1bmMubmV3KFtdLFtdKVxuXHRcdCMgbm93IHdlIG1vdmUgdGhpcyBub2RlIHVwIHRvIHRoZSBibG9ja1xuXHRcdGZ1bmMuYm9keS5ub2RlcyA9IGJsb2NrLmRlZmVycyhvdXRlcixzZWxmKVxuXHRcdGZ1bmMuc2NvcGUudmlzaXRcblxuXHRcdCMgaWYgdGhlIG91dGVyIGlzIGEgdmFyLWFzc2lnbm1lbnQsIHdlIGNhbiBzaW1wbHkgc2V0IHRoZSBwYXJhbXNcblx0XHRpZiBwYXIgaXNhIEFzc2lnblxuXHRcdFx0cGFyLmxlZnQudHJhdmVyc2Vcblx0XHRcdHZhciBsZnQgPSBwYXIubGVmdC5ub2RlXG5cdFx0XHQjIENhbiBiZSBhIHR1cGxlIGFzIHdlbGwsIG5vP1xuXHRcdFx0aWYgbGZ0IGlzYSBWYXJSZWZlcmVuY2Vcblx0XHRcdFx0IyB0aGUgcGFyYW0gaXMgYWxyZWFkeSByZWdpc3RlcmVkP1xuXHRcdFx0XHQjIHNob3VsZCBub3QgZm9yY2UgdGhlIG5hbWUgYWxyZWFkeT8/XG5cdFx0XHRcdCMgYmV3YXJlIG9mIGJ1Z3Ncblx0XHRcdFx0ZnVuYy5wYXJhbXMuYXQoMCx5ZXMsbGZ0LnZhcmlhYmxlLm5hbWUpXG5cdFx0XHRlbGlmIGxmdCBpc2EgVHVwbGVcblx0XHRcdFx0IyBpZiB0aGlzIGFuIHVuZmFuY3kgdHVwbGUsIHdpdGggb25seSB2YXJzXG5cdFx0XHRcdCMgd2UgY2FuIGp1c3QgdXNlIGFyZ3VtZW50c1xuXG5cdFx0XHRcdGlmIHBhci50eXBlID09ICd2YXInICYmICFsZnQuaGFzU3BsYXRcblx0XHRcdFx0XHRsZnQubWFwIGRvIHxlbCxpfFxuXHRcdFx0XHRcdFx0ZnVuYy5wYXJhbXMuYXQoaSx5ZXMsZWwudmFsdWUpXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHQjIG90aGVyd2lzZSwgZG8gdGhlIHdob2xlIHR1cGxlXG5cdFx0XHRcdFx0IyBtYWtlIHN1cmUgaXQgaXMgYSB2YXIgYXNzaWdubWVudD9cblx0XHRcdFx0XHRwYXIucmlnaHQgPSBBUkdVTUVOVFNcblx0XHRcdFx0XHRmdW5jLmJvZHkudW5zaGlmdChwYXIpXG5cdFx0XHRcdFx0ZnVuYy5zY29wZS5jb250ZXh0XG5cdFx0XHRlbHNlXG5cdFx0XHRcdCMgcmVndWxhciBzZXR0ZXJzXG5cdFx0XHRcdHBhci5yaWdodCA9IGZ1bmMucGFyYW1zLmF0KDAseWVzKVxuXHRcdFx0XHRmdW5jLmJvZHkudW5zaGlmdChwYXIpXG5cdFx0XHRcdGZ1bmMuc2NvcGUuY29udGV4dFxuXG5cdFx0IyBJZiBpdCBpcyBhbiBhZHZhbmNlIHR1cGxlIG9yIHNvbWV0aGluZywgaXQgc2hvdWxkIGJlIHBvc3NpYmxlIHRvXG5cdFx0IyBmZWVkIGluIHRoZSBwYXJhbWxpc3QsIGFuZCBsZXQgdGhlIHR1cGxlIGhhbmRsZSBpdCBhcyBpZiBpdCB3YXMgYW55XG5cdFx0IyBvdGhlciB2YWx1ZVxuXG5cdFx0IyBDQVNFIElmIHRoaXMgaXMgYSB0dXBsZSAvIG11bHRpc2V0IHdpdGggbW9yZSB0aGFuIG9uZSBhc3luYyB2YWx1ZVxuXHRcdCMgd2UgbmVlZCB0byB0aGluayBkaWZmZXJlbnRseS5cblxuXHRcdCMgbm93IHdlIG5lZWQgdG8gdmlzaXQgdGhlIGZ1bmN0aW9uIGFzIHdlbGxcblx0XHRmdW5jLnRyYXZlcnNlXG5cdFx0IyBwdWxsIHRoZSBvdXRlciBpblxuXHRcdHNlbGZcblxuZXhwb3J0IGNsYXNzIEFzeW5jRnVuYyA8IEZ1bmNcblxuXHRkZWYgaW5pdGlhbGl6ZSBwYXJhbXMsIGJvZHksIG5hbWUsIHRhcmdldCwgb3B0aW9uc1xuXHRcdHN1cGVyKHBhcmFtcyxib2R5LG5hbWUsdGFyZ2V0LG9wdGlvbnMpXG5cblx0ZGVmIHNjb3BldHlwZSBkbyBMYW1iZGFTY29wZVxuXG5cbiMgSU1QT1JUU1xuXG5leHBvcnQgY2xhc3MgSW1wb3J0U3RhdGVtZW50IDwgU3RhdGVtZW50XG5cblxuXHRwcm9wIG5zXG5cdHByb3AgaW1wb3J0c1xuXHRwcm9wIHNvdXJjZVxuXG5cblx0ZGVmIGluaXRpYWxpemUgaW1wb3J0cywgc291cmNlLCBuc1xuXHRcdEB0cmF2ZXJzZWQgPSBub1xuXHRcdEBpbXBvcnRzID0gaW1wb3J0c1xuXHRcdEBzb3VyY2UgPSBzb3VyY2Vcblx0XHRAbnMgPSBuc1xuXHRcdHNlbGZcblxuXHRkZWYgdmlzaXRcblx0XHRpZiBAbnNcblx0XHRcdEBuc3ZhciB8fD0gc2NvcGVfXy5yZWdpc3RlcihAbnMsc2VsZilcblx0XHRlbHNlXG5cdFx0XHR2YXIgc3JjID0gc291cmNlLmNcblx0XHRcdHZhciBtID0gc3JjLm1hdGNoKC8oXFx3KykoXFwuanN8aW1iYSk/W1xcXCJcXCddJC8pXG5cdFx0XHRAYWxpYXMgPSBtID8gbVsxXSArICckJyA6ICdtb2QkJ1xuXG5cdFx0IyBzaG91bGQgYWxzbyByZWdpc3RlciB0aGUgaW1wb3J0ZWQgaXRlbXMsIG5vP1xuXHRcdGlmIEBpbXBvcnRzXG5cdFx0XHR2YXIgZGVjID0gQGRlY2xhcmF0aW9ucyA9IFZhcmlhYmxlRGVjbGFyYXRpb24ubmV3KFtdKVxuXG5cdFx0XHRpZiBAaW1wb3J0czpsZW5ndGggPT0gMVxuXHRcdFx0XHRAYWxpYXMgPSBAaW1wb3J0c1swXVxuXHRcdFx0XHRkZWMuYWRkKEBhbGlhcyxPUCgnLicsUmVxdWlyZS5uZXcoc291cmNlKSxAYWxpYXMpKVxuXHRcdFx0XHRkZWMudHJhdmVyc2Vcblx0XHRcdFx0cmV0dXJuIHNlbGZcblxuXHRcdFx0IyBAZGVjbGFyYXRpb25zID0gVmFyaWFibGVEZWNsYXJhdGlvbi5uZXcoW10pXG5cdFx0XHRAbW9kdWxlZGVjbCA9IGRlYy5hZGQoQGFsaWFzLFJlcXVpcmUubmV3KHNvdXJjZSkpXG5cdFx0XHRAbW9kdWxlZGVjbC50cmF2ZXJzZVxuXG5cblx0XHRcdGlmIEBpbXBvcnRzOmxlbmd0aCA+IDFcblx0XHRcdFx0Zm9yIGltcCBpbiBAaW1wb3J0c1xuXHRcdFx0XHRcdEBkZWNsYXJhdGlvbnMuYWRkKGltcCxPUCgnLicsQG1vZHVsZWRlY2wudmFyaWFibGUsaW1wKSlcblxuXHRcdFx0ZGVjLnRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cblx0ZGVmIGpzIG9cblxuXHRcdGlmIEBkZWNsYXJhdGlvbnNcblx0XHRcdHJldHVybiBAZGVjbGFyYXRpb25zLmNcblxuXHRcdHZhciByZXEgPSBSZXF1aXJlLm5ldyhzb3VyY2UpXG5cblx0XHRpZiBAbnNcblx0XHRcdCMgbXVzdCByZWdpc3RlciBucyBhcyBhIHJlYWwgdmFyaWFibGVcblx0XHRcdHJldHVybiBcInZhciB7QG5zdmFyLmN9ID0ge3JlcS5jfVwiXG5cblx0XHRpZiBAaW1wb3J0c1xuXG5cdFx0XHR2YXIgc3JjID0gc291cmNlLmNcblx0XHRcdHZhciBhbGlhcyA9IFtdXG5cdFx0XHR2YXIgdmFycyA9IFZhckJsb2NrLm5ldyhbXSlcblxuXHRcdFx0aWYgdmFyIGZuYW1lID0gc3JjLm1hdGNoKC8oXFx3KykoXFwuanN8aW1iYSk/W1xcXCJcXCddJC8pXG5cdFx0XHRcdGFsaWFzLnB1c2goZm5hbWVbMV0pXG5cblx0XHRcdCMgdmFyIGFsaWFzID0gc3JjLm1hdGNoKC8oXFx3KykoXFwuanN8aW1iYSk/W1xcXCJcXCddJC8pXG5cdFx0XHQjIGNyZWF0ZSBhIHJlcXVpcmUgZm9yIHRoZSBzb3VyY2UsIHdpdGggYSB0ZW1wb3JhcnkgbmFtZT9cblx0XHRcdHZhciBvdXQgPSBbcmVxLmNhY2hlKG5hbWVzOiBhbGlhcykuY11cblxuXHRcdFx0Zm9yIGltcCBpbiBAaW1wb3J0c1xuXHRcdFx0XHQjIHdlIGFsc28gbmVlZCB0byByZWdpc3RlciB0aGVzZSBpbXBvcnRzIGFzIHZhcmlhYmxlcywgbm8/XG5cdFx0XHRcdHZhciBvID0gT1AoJz0nLGltcCxPUCgnLicscmVxLGltcCkpXG5cdFx0XHRcdG91dC5wdXNoKFwidmFyIHtvLmN9XCIpXG5cblx0XHRcdHJldHVybiBvdXRcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gcmVxLmNcblxuXHRkZWYgY29uc3VtZSBub2RlXG5cdFx0cmV0dXJuIHNlbGZcblxuXG4jIEVYUE9SVFxuXG5leHBvcnQgY2xhc3MgRXhwb3J0U3RhdGVtZW50IDwgVmFsdWVOb2RlXG5cblx0ZGVmIGpzIG9cblx0XHR2YXIgbm9kZXMgPSBAdmFsdWUubWFwIGRvIHxhcmd8IFwibW9kdWxlLmV4cG9ydHMue2FyZy5jfSA9IHthcmcuY31cIlxuXG5cdFx0aWYgbm9kZXM6bGVuZ3RoID4gMSBhbmQgdXAgaXNhIFJldHVyblxuXHRcdFx0cmV0dXJuICdbJyArIG5vZGVzLmpvaW4oJywnKSArICddJ1xuXG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIG5vZGVzLmpvaW4oJztcXG4nKSArICc7J1xuXG5leHBvcnQgY2xhc3MgRXhwb3J0IDwgVmFsdWVOb2RlXG5cblx0ZGVmIGFkZEV4cHJlc3Npb24gZXhwclxuXHRcdHZhbHVlID0gdmFsdWUuYWRkRXhwcmVzc2lvbihleHByKVxuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIGNvbnN1bWUgbm9kZVxuXHRcdGlmIG5vZGUgaXNhIFJldHVyblxuXHRcdFx0b3B0aW9uKCdyZXR1cm4nLHllcylcblx0XHRcdHJldHVybiBzZWxmXG5cdFx0c3VwZXJcblxuXHRkZWYganMgb1xuXHRcdCMgcCBcIkV4cG9ydCB7dmFsdWV9XCJcblx0XHR2YWx1ZS5zZXQgZXhwb3J0OiBzZWxmLCByZXR1cm46IG9wdGlvbig6cmV0dXJuKSwgZGVmYXVsdDogb3B0aW9uKDpkZWZhdWx0KVxuXG5cdFx0aWYgdmFsdWUgaXNhIFZhck9yQWNjZXNzXG5cdFx0XHRyZXR1cm4gXCJleHBvcnRzLnt2YWx1ZS5jfSA9IHt2YWx1ZS5jfTtcIlxuXG5cdFx0aWYgdmFsdWUgaXNhIExpc3ROb2RlXG5cdFx0XHR2YWx1ZS5tYXAgZG8gfGl0ZW18IGl0ZW0uc2V0IGV4cG9ydDogc2VsZlxuXG5cdFx0cmV0dXJuIHZhbHVlLmNcblxuZXhwb3J0IGNsYXNzIFJlcXVpcmUgPCBWYWx1ZU5vZGVcblxuXHRkZWYganMgb1xuXHRcdHZhciBvdXQgPSB2YWx1ZSBpc2EgUGFyZW5zID8gdmFsdWUudmFsdWUuYyA6IHZhbHVlLmNcblx0XHRvdXQgPT0gJ3JlcXVpcmUnID8gJ3JlcXVpcmUnIDogXCJyZXF1aXJlKHtvdXR9KVwiXG5cbmV4cG9ydCBjbGFzcyBFbnZGbGFnIDwgVmFsdWVOb2RlXG5cblx0ZGVmIHJhd1xuXHRcdEByYXcgPz0gU1RBQ0suZW52KFwiXCIgKyBAdmFsdWUpXG5cblx0ZGVmIGlzVHJ1dGh5XG5cdFx0dmFyIHZhbCA9IHJhd1xuXHRcdHJldHVybiAhIXZhbCBpZiB2YWwgIT09IHVuZGVmaW5lZFxuXHRcdHJldHVybiB1bmRlZmluZWRcblxuXHRkZWYgbG9jXG5cdFx0WzAsMF1cblxuXHRkZWYgY1xuXHRcdHZhciB2YWwgPSByYXdcblx0XHRpZiB2YWwgIT09IHVuZGVmaW5lZFxuXHRcdFx0aWYgdmFsIGlzYSBTdHJpbmdcblx0XHRcdFx0aWYgdmFsLm1hdGNoKC9eXFxkKyhcXC5cXGQrKT8kLylcblx0XHRcdFx0XHRwYXJzZUZsb2F0KHZhbClcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFwiJ3t2YWx9J1wiXG5cdFx0XHRlbHNlXG5cdFx0XHRcdFwie3ZhbH1cIlxuXG5cdFx0ZWxzZVxuXHRcdFx0XCJFTlZfe0B2YWx1ZX1cIlxuXG5cbiMgVVRJTFNcblxuZXhwb3J0IGNsYXNzIFV0aWwgPCBOb2RlXG5cblx0cHJvcCBhcmdzXG5cblx0ZGVmIGluaXRpYWxpemUgYXJnc1xuXHRcdEBhcmdzID0gYXJnc1xuXG5cdCMgdGhpcyBpcyBob3cgd2UgZGVhbCB3aXRoIGl0IG5vd1xuXHRkZWYgc2VsZi5leHRlbmQgYSxiXG5cdFx0VXRpbC5FeHRlbmQubmV3KFthLGJdKVxuXG5cdGRlZiBzZWxmLmNhbGxJbWJhIHNjb3BlLCBtZXRoLCBhcmdzXG5cdFx0Q0FMTChPUCgnLicsc2NvcGUuaW1iYSxJZGVudGlmaWVyLm5ldyhtZXRoKSksYXJncylcblxuXHRkZWYgc2VsZi5yZXBlYXQgc3RyLCB0aW1lc1xuXHRcdHZhciByZXMgPSAnJ1xuXHRcdHdoaWxlIHRpbWVzID4gMFxuXHRcdFx0aWYgdGltZXMgJSAyID09IDFcblx0XHRcdFx0cmVzICs9IHN0clxuXHRcdFx0c3RyICs9IHN0clxuXHRcdFx0dGltZXMgPj49IDFcblx0XHRyZXR1cm4gcmVzXG5cblxuXG5cdGRlZiBzZWxmLmtleXMgb2JqXG5cdFx0dmFyIGwgPSBDb25zdC5uZXcoXCJPYmplY3RcIilcblx0XHR2YXIgciA9IElkZW50aWZpZXIubmV3KFwia2V5c1wiKVxuXHRcdENBTEwoT1AoJy4nLGwsciksW29ial0pXG5cblx0ZGVmIHNlbGYubGVuIG9iaiwgY2FjaGVcblx0XHR2YXIgciA9IElkZW50aWZpZXIubmV3KFwibGVuZ3RoXCIpXG5cdFx0dmFyIG5vZGUgPSBPUCgnLicsIG9iaiwgcilcblx0XHRub2RlLmNhY2hlKGZvcmNlOiB5ZXMsIHBvb2w6ICdsZW4nKSBpZiBjYWNoZVxuXHRcdHJldHVybiBub2RlXG5cblx0ZGVmIHNlbGYuaW5kZXhPZiBsZnQsIHJndFxuXHRcdHZhciBub2RlID0gVXRpbC5JbmRleE9mLm5ldyhbbGZ0LHJndF0pXG5cdFx0IyBub2RlLmNhY2hlKGZvcmNlOiB5ZXMsIHR5cGU6ICdpdGVyJykgaWYgY2FjaGVcblx0XHRyZXR1cm4gbm9kZVxuXG5cdGRlZiBzZWxmLnNsaWNlIG9iaiwgYSwgYlxuXHRcdHZhciBzbGljZSA9IElkZW50aWZpZXIubmV3KFwic2xpY2VcIilcblx0XHRjb25zb2xlLmxvZyBcInNsaWNlIHthfSB7Yn1cIlxuXHRcdHJldHVybiBDQUxMKE9QKCcuJyxvYmosc2xpY2UpLGNvbXBhY3RfXyhbYSxiXSkpXG5cblx0ZGVmIHNlbGYuaXRlcmFibGUgb2JqLCBjYWNoZVxuXHRcdHZhciBub2RlID0gVXRpbC5JdGVyYWJsZS5uZXcoW29ial0pXG5cdFx0bm9kZS5jYWNoZShmb3JjZTogeWVzLCBwb29sOiAnaXRlcicpIGlmIGNhY2hlXG5cdFx0cmV0dXJuIG5vZGVcblxuXG5cblx0ZGVmIHNlbGYudW5pb24gYSxiXG5cdFx0VXRpbC5Vbmlvbi5uZXcoW2EsYl0pXG5cblx0ZGVmIHNlbGYuaW50ZXJzZWN0IGEsYlxuXHRcdFV0aWwuSW50ZXJzZWN0Lm5ldyhbYSxiXSlcblxuXHRkZWYgc2VsZi5jb3VudGVyIHN0YXJ0LCBjYWNoZVxuXHRcdCMgc2hvdWxkIGl0IG5vdCByYXRoZXIgYmUgYSB2YXJpYWJsZT8hP1xuXHRcdHZhciBub2RlID0gTnVtLm5ldyhzdGFydCkgIyBtYWtlIHN1cmUgaXQgcmVhbGx5IGlzIGEgbnVtYmVyXG5cdFx0bm9kZS5jYWNoZShmb3JjZTogeWVzLCBwb29sOiAnY291bnRlcicpIGlmIGNhY2hlXG5cdFx0cmV0dXJuIG5vZGVcblxuXHRkZWYgc2VsZi5hcnJheSBzaXplLCBjYWNoZVxuXHRcdHZhciBub2RlID0gVXRpbC5BcnJheS5uZXcoW3NpemVdKVxuXHRcdG5vZGUuY2FjaGUoZm9yY2U6IHllcywgcG9vbDogJ2xpc3QnKSBpZiBjYWNoZVxuXHRcdHJldHVybiBub2RlXG5cblx0ZGVmIHNlbGYuZGVmaW5lVGFnIHR5cGUsIGN0b3IsIHN1cHJcblx0XHRDQUxMKFRBR0RFRixbdHlwZSxjdG9yLHN1cHJdKVxuXG5cblx0ZGVmIHNlbGYuZGVmaW5lQ2xhc3MgbmFtZSwgc3VwciwgaW5pdG9yXG5cdFx0Q0FMTChDTEFTU0RFRixbbmFtZSBvciBpbml0b3Isc3VwXSlcblxuXHRkZWYgaW5saW5lSGVscGVyc1xuXHRcdCEhT1BUUzppbmxpbmVIZWxwZXJzXG5cblx0ZGVmIGpzIG9cblx0XHRcImhlbHBlclwiXG5cbiMgVE9ETyBEZXByZWNhdGUgYW5kIHJlbW92ZVxuZXhwb3J0IGNsYXNzIFV0aWwuVW5pb24gPCBVdGlsXG5cblx0ZGVmIGhlbHBlclxuXHRcdCcnJ1xuXHRcdGZ1bmN0aW9uIHVuaW9uJChhLGIpe1xuXHRcdFx0aWYoYSAmJiBhLl9fdW5pb24pIHJldHVybiBhLl9fdW5pb24oYik7XG5cblx0XHRcdHZhciB1ID0gYS5zbGljZSgwKTtcblx0XHRcdGZvcih2YXIgaT0wLGw9Yi5sZW5ndGg7aTxsO2krKykgaWYodS5pbmRleE9mKGJbaV0pID09IC0xKSB1LnB1c2goYltpXSk7XG5cdFx0XHRyZXR1cm4gdTtcblx0XHR9O1xuXG5cdFx0JycnXG5cblx0ZGVmIGpzIG9cblx0XHRzY29wZV9fLnJvb3QuaGVscGVyKHNlbGYsaGVscGVyKVxuXHRcdCMgV2hlbiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIHRvcCBvZiBmaWxlP1xuXHRcdFwidW5pb24kKHthcmdzLm1hcCh8dnwgdi5jICkuam9pbignLCcpfSlcIlxuXG4jIFRPRE8gRGVwcmVjYXRlIGFuZCByZW1vdmVcbmV4cG9ydCBjbGFzcyBVdGlsLkludGVyc2VjdCA8IFV0aWxcblxuXHRkZWYgaGVscGVyXG5cdFx0JycnXG5cdFx0ZnVuY3Rpb24gaW50ZXJzZWN0JChhLGIpe1xuXHRcdFx0aWYoYSAmJiBhLl9faW50ZXJzZWN0KSByZXR1cm4gYS5fX2ludGVyc2VjdChiKTtcblx0XHRcdHZhciByZXMgPSBbXTtcblx0XHRcdGZvcih2YXIgaT0wLCBsPWEubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdiA9IGFbaV07XG5cdFx0XHRcdGlmKGIuaW5kZXhPZih2KSAhPSAtMSkgcmVzLnB1c2godik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH07XG5cblx0XHQnJydcblxuXHRkZWYganMgb1xuXHRcdCMgV2hlbiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIHRvcCBvZiBmaWxlP1xuXHRcdHNjb3BlX18ucm9vdC5oZWxwZXIoc2VsZixoZWxwZXIpXG5cdFx0XCJpbnRlcnNlY3QkKHthcmdzLm1hcCh8dnwgdi5jICkuam9pbignLCcpfSlcIlxuXG5leHBvcnQgY2xhc3MgVXRpbC5FeHRlbmQgPCBVdGlsXG5cblx0ZGVmIGpzIG9cblx0XHQjIFdoZW4gdGhpcyBpcyB0cmlnZ2VyZWQsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSB0b3Agb2YgZmlsZT9cblx0XHRcImV4dGVuZCQoe2NvbXBhY3RfXyhjYXJ5X18oYXJncykpLmpvaW4oJywnKX0pXCJcblxuZXhwb3J0IGNsYXNzIFV0aWwuSW5kZXhPZiA8IFV0aWxcblxuXHRkZWYgaGVscGVyXG5cdFx0JycnXG5cdFx0ZnVuY3Rpb24gaWR4JChhLGIpe1xuXHRcdFx0cmV0dXJuIChiICYmIGIuaW5kZXhPZikgPyBiLmluZGV4T2YoYSkgOiBbXS5pbmRleE9mLmNhbGwoYSxiKTtcblx0XHR9O1xuXHRcdCcnJ1xuXG5cdGRlZiBqcyBvXG5cdFx0aWYgaW5saW5lSGVscGVyc1xuXHRcdFx0c2NvcGVfXy5yb290LmhlbHBlcihzZWxmLGhlbHBlcilcblx0XHRcdCMgV2hlbiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIHRvcCBvZiBmaWxlP1xuXHRcdFx0XCJpZHgkKHthcmdzLm1hcCh8dnwgdi5jICkuam9pbignLCcpfSlcIlxuXHRcdGVsc2Vcblx0XHRcdFwie3Njb3BlX18uaW1iYS5jfS5pbmRleE9mKHthcmdzLm1hcCh8dnwgdi5jICkuam9pbignLCcpfSlcIlxuXG5leHBvcnQgY2xhc3MgVXRpbC5MZW4gPCBVdGlsXG5cblx0ZGVmIGhlbHBlclxuXHRcdCcnJ1xuXHRcdGZ1bmN0aW9uIGxlbiQoYSl7XG5cdFx0XHRyZXR1cm4gYSAmJiAoYS5sZW4gaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGEubGVuKCkgOiBhLmxlbmd0aCkgfHwgMDtcblx0XHR9O1xuXHRcdCcnJ1xuXG5cdGRlZiBqcyBvXG5cdFx0IyBcblx0XHRpZiB0cnVlICMgaXNTdGFuZGFsb25lXG5cdFx0XHRzY29wZV9fLnJvb3QuaGVscGVyKHNlbGYsaGVscGVyKVxuXHRcdFx0IyBXaGVuIHRoaXMgaXMgdHJpZ2dlcmVkLCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgdG9wIG9mIGZpbGU/XG5cdFx0XHRcImxlbiQoe2FyZ3MubWFwKHx2fCB2LmMgKS5qb2luKCcsJyl9KVwiXG5cdFx0ZWxzZVxuXHRcdFx0XCJ7c2NvcGVfXy5pbWJhLmN9Lmxlbih7YXJncy5tYXAofHZ8IHYuYyApLmpvaW4oJywnKX0pXCJcblxuXG5leHBvcnQgY2xhc3MgVXRpbC5TdWJjbGFzcyA8IFV0aWxcblxuXHRkZWYgaGVscGVyXG5cdFx0IyBzaG91bGQgYWxzbyBjaGVjayBpZiBpdCBpcyBhIHJlYWwgcHJvbWlzZVxuXHRcdCcnJ1xuXHRcdC8vIGhlbHBlciBmb3Igc3ViY2xhc3Npbmdcblx0XHRmdW5jdGlvbiBzdWJjbGFzcyQob2JqLHN1cCkge1xuXHRcdFx0Zm9yICh2YXIgayBpbiBzdXApIHtcblx0XHRcdFx0aWYgKHN1cC5oYXNPd25Qcm9wZXJ0eShrKSkgb2JqW2tdID0gc3VwW2tdO1xuXHRcdFx0fTtcblx0XHRcdC8vIG9iai5fX3N1cGVyX18gPSBzdXA7XG5cdFx0XHRvYmoucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXAucHJvdG90eXBlKTtcblx0XHRcdG9iai5fX3N1cGVyX18gPSBvYmoucHJvdG90eXBlLl9fc3VwZXJfXyA9IHN1cC5wcm90b3R5cGU7XG5cdFx0XHRvYmoucHJvdG90eXBlLmluaXRpYWxpemUgPSBvYmoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gb2JqO1xuXHRcdH07XG5cblx0XHQnJydcblxuXHRkZWYganMgb1xuXHRcdGlmIGlubGluZUhlbHBlcnNcblx0XHRcdCMgV2hlbiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIHRvcCBvZiBmaWxlP1xuXHRcdFx0c2NvcGVfXy5yb290LmhlbHBlcihzZWxmLGhlbHBlcilcblx0XHRcdFwic3ViY2xhc3MkKHthcmdzLm1hcCh8dnwgdi5jKS5qb2luKCcsJyl9KTtcXG5cIlxuXHRcdGVsc2Vcblx0XHRcdFwie3Njb3BlX18uaW1iYS5jfS5zdWJjbGFzcyh7YXJncy5tYXAofHZ8IHYuYykuam9pbignLCcpfSk7XFxuXCJcblxuZXhwb3J0IGNsYXNzIFV0aWwuUHJvbWlzaWZ5IDwgVXRpbFxuXG5cdGRlZiBoZWxwZXJcblx0XHQjIHNob3VsZCBhbHNvIGNoZWNrIGlmIGl0IGlzIGEgcmVhbCBwcm9taXNlXG5cdFx0XCJmdW5jdGlvbiBwcm9taXNlJChhKVxceyByZXR1cm4gYSBpbnN0YW5jZW9mIEFycmF5ID8gUHJvbWlzZS5hbGwoYSkgOiAoYSAmJiBhLnRoZW4gPyBhIDogUHJvbWlzZS5yZXNvbHZlKGEpKTsgXFx9XCJcblxuXHRkZWYganMgb1xuXHRcdGlmIGlubGluZUhlbHBlcnNcblx0XHRcdCMgV2hlbiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIHRvcCBvZiBmaWxlP1xuXHRcdFx0c2NvcGVfXy5yb290LmhlbHBlcihzZWxmLGhlbHBlcilcblx0XHRcdFwicHJvbWlzZSQoe2FyZ3MubWFwKHx2fCB2LmMpLmpvaW4oJywnKX0pXCJcblx0XHRlbHNlXG5cdFx0XHRcIntzY29wZV9fLmltYmEuY30uYXdhaXQoe2FyZ3MubWFwKHx2fCB2LmMpLmpvaW4oJywnKX0pXCJcblxuIyBUT0RPIGRlcHJlY2F0ZWQ6IGNhbiByZW1vdmVcbmV4cG9ydCBjbGFzcyBVdGlsLkNsYXNzIDwgVXRpbFxuXG5cdGRlZiBqcyBvXG5cdFx0IyBXaGVuIHRoaXMgaXMgdHJpZ2dlcmVkLCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgdG9wIG9mIGZpbGU/XG5cdFx0XCJjbGFzcyQoe2FyZ3MubWFwKHx2fCB2LmMpLmpvaW4oJywnKX0pXCJcblxuZXhwb3J0IGNsYXNzIFV0aWwuSXRlcmFibGUgPCBVdGlsXG5cblx0ZGVmIGhlbHBlclxuXHRcdCMgbm93IHdlIHdhbnQgdG8gYWxsb3cgbnVsbCB2YWx1ZXMgYXMgd2VsbCAtIGp1c3QgcmV0dXJuIGFzIGVtcHR5IGNvbGxlY3Rpb25cblx0XHQjIHNob3VsZCBiZSB0aGUgc2FtZSBmb3IgZm9yIG93biBvZiBJIGd1ZXNzXG5cdFx0XCJmdW5jdGlvbiBpdGVyJChhKVxceyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IFxcfTtcIlxuXG5cdGRlZiBqcyBvXG5cdFx0cmV0dXJuIGFyZ3NbMF0uYyBpZiBhcmdzWzBdIGlzYSBBcnIgIyBvciBpZiB3ZSBrbm93IGZvciBzdXJlIHRoYXQgaXQgaXMgYW4gYXJyYXlcblxuXHRcdGlmIHRydWUgIyBpc1N0YW5kYWxvbmVcblx0XHRcdHNjb3BlX18ucm9vdC5oZWxwZXIoc2VsZixoZWxwZXIpXG5cdFx0XHRyZXR1cm4gXCJpdGVyJCh7YXJnc1swXS5jfSlcIlxuXHRcdGVsc2Vcblx0XHRcdHJldHVybiBcIntzY29wZV9fLmltYmEuY30uaXRlcmFibGUoe2FyZ3NbMF0uY30pXCJcblxuZXhwb3J0IGNsYXNzIFV0aWwuSXNGdW5jdGlvbiA8IFV0aWxcblxuXHRkZWYganMgb1xuXHRcdFwie2FyZ3NbMF0uY31cIlxuXG5leHBvcnQgY2xhc3MgVXRpbC5BcnJheSA8IFV0aWxcblxuXHRkZWYganMgb1xuXHRcdCMgV2hlbiB0aGlzIGlzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIHRvcCBvZiBmaWxlP1xuXHRcdFwibmV3IEFycmF5KHthcmdzLm1hcCh8dnwgdi5jKX0pXCJcblxuXG5cblxuY2xhc3MgRW50aXRpZXNcblxuXHRkZWYgaW5pdGlhbGl6ZSByb290XG5cdFx0QHJvb3QgPSByb290XG5cdFx0QG1hcCA9IHt9XG5cdFx0cmV0dXJuIHNlbGZcblxuXHRkZWYgYWRkIHBhdGgsIG9iamVjdFxuXHRcdEBtYXBbcGF0aF0gPSBvYmplY3Rcblx0XHRzZWxmXG5cblx0ZGVmIHJlZ2lzdGVyIGVudGl0eVxuXHRcdHZhciBwYXRoID0gZW50aXR5Lm5hbWVwYXRoXG5cdFx0QG1hcFtwYXRoXSB8fD0gZW50aXR5XG5cdFx0c2VsZlxuXG5cdGRlZiBwbGFpblxuXHRcdEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoQG1hcCkpXG5cblx0ZGVmIHRvSlNPTlxuXHRcdEBtYXBcblxuIyBTQ09QRVNcblxuIyBoYW5kbGVzIGxvY2FsIHZhcmlhYmxlcywgc2VsZiBldGMuIFNob3VsZCBjcmVhdGUgcmVmZXJlbmNlcyB0byBvdXRlciBzY29wZXNcbiMgd2hlbiBuZWVkZWQgZXRjLlxuXG4jIGFkZCBjbGFzcyBmb3IgYW5ub3RhdGlvbnMgLyByZWdpc3RlcmluZyBtZXRob2RzLCBldGM/XG4jIGNsYXNzIEludGVyZmFjZVxuXG4jIHNob3VsZCBtb3ZlIHRoZSB3aG9sZSBjb250ZXh0LXRoaW5naWUgcmlnaHQgaW50byBzY29wZVxuZXhwb3J0IGNsYXNzIFNjb3BlXG5cblx0cHJvcCBsZXZlbFxuXHRwcm9wIGNvbnRleHRcblx0cHJvcCBub2RlXG5cdHByb3AgcGFyZW50XG5cdHByb3AgdmFybWFwXG5cdHByb3AgdmFycG9vbFxuXHRwcm9wIHBhcmFtc1xuXHRwcm9wIGhlYWRcblx0cHJvcCB2YXJzXG5cdHByb3AgY291bnRlclxuXG5cdGRlZiBwXG5cdFx0aWYgU1RBQ0subG9nbGV2ZWwgPiAwXG5cdFx0XHRjb25zb2xlLmxvZygqYXJndW1lbnRzKVxuXHRcdHNlbGZcblxuXHRkZWYgc3RhY2tcblx0XHRTVEFDS1xuXG5cdGRlZiBpbml0aWFsaXplIG5vZGUsIHBhcmVudFxuXHRcdEBuciA9IFNUQUNLLmluY3IoJ3Njb3BlcycpXG5cdFx0QGhlYWQgPSBbXVxuXHRcdEBub2RlID0gbm9kZVxuXHRcdEBwYXJlbnQgPSBwYXJlbnRcblx0XHRAdmFycyA9IFZhcmlhYmxlRGVjbGFyYXRpb24ubmV3KFtdKVxuXHRcdEBtZXRhID0ge31cblx0XHRAYW5ub3RhdGlvbnMgPSBbXVxuXHRcdEBjbG9zdXJlID0gc2VsZlxuXHRcdEB2aXJ0dWFsID0gbm9cblx0XHRAY291bnRlciA9IDBcblx0XHRAdmFybWFwICA9IHt9XG5cdFx0QHZhcnBvb2wgPSBbXVxuXG5cdGRlZiBtZXRhIGtleSwgdmFsdWVcblx0XHRpZiB2YWx1ZSAhPSB1bmRlZmluZWRcblx0XHRcdEBtZXRhW2tleV0gPSB2YWx1ZVxuXHRcdFx0cmV0dXJuIHNlbGZcblx0XHRAbWV0YVtrZXldXG5cblx0ZGVmIG5hbWVwYXRoXG5cdFx0Jz8nXG5cblx0ZGVmIGltYmFUYWdzXG5cdFx0XCJ7aW1iYS5jfS5UQUdTXCJcblxuXHRkZWYgdGFnQ29udGV4dFBhdGhcblx0XHQjIGJ5cGFzc2luZyBmb3Igbm93XG5cdFx0QHRhZ0NvbnRleHRQYXRoIHx8PSBpbWJhVGFnc1xuXG5cdGRlZiB0YWdDb250ZXh0Q2FjaGVcblx0XHRAdGFnQ29udGV4dENhY2hlIHx8PSBjbG9zdXJlLmRlY2xhcmUoXCJfX1wiLE9QKCcuJyxjb250ZXh0LnJlZmVyZW5jZSwnX18nKSlcblxuXHRkZWYgY29udGV4dFxuXHRcdEBjb250ZXh0IHx8PSBTY29wZUNvbnRleHQubmV3KHNlbGYpXG5cblx0ZGVmIHRyYXZlcnNlXG5cdFx0c2VsZlxuXG5cdGRlZiB2aXNpdFxuXHRcdHJldHVybiBzZWxmIGlmIEBwYXJlbnRcblx0XHRAcGFyZW50ID0gU1RBQ0suc2NvcGUoMSkgIyB0aGUgcGFyZW50IHNjb3BlXG5cdFx0QGxldmVsID0gU1RBQ0suc2NvcGVzOmxlbmd0aCAtIDFcblxuXHRcdFNUQUNLLmFkZFNjb3BlKHNlbGYpXG5cdFx0cm9vdC5zY29wZXMucHVzaChzZWxmKVxuXHRcdHNlbGZcblxuXHRkZWYgd3JhcCBzY29wZVxuXHRcdEBwYXJlbnQgPSBzY29wZS5AcGFyZW50XG5cdFx0c2NvcGUuQHBhcmVudCA9IHNlbGZcblx0XHRzZWxmXG5cblx0IyBjYWxsZWQgZm9yIHNjb3BlcyB0aGF0IGFyZSBub3QgcmVhbCBzY29wZXMgaW4ganNcblx0IyBtdXN0IGVuc3VyZSB0aGF0IHRoZSBsb2NhbCB2YXJpYWJsZXMgaW5zaWRlIG9mIHRoZSBzY29wZXMgZG8gbm90XG5cdCMgY29sbGlkZSB3aXRoIHZhcmlhYmxlcyBpbiBvdXRlciBzY29wZXMgLS0gcmVuYW1lIGlmIG5lZWRlZFxuXHRkZWYgdmlydHVhbGl6ZVxuXHRcdHNlbGZcblxuXHRkZWYgcm9vdFxuXHRcdHJldHVybiBTVEFDSy5ST09UXG5cblx0XHR2YXIgc2NvcGUgPSBzZWxmXG5cdFx0d2hpbGUgc2NvcGVcblx0XHRcdHJldHVybiBzY29wZSBpZiBzY29wZSBpc2EgUm9vdFNjb3BlXG5cdFx0XHRzY29wZSA9IHNjb3BlLnBhcmVudFxuXHRcdHJldHVybiBudWxsXG5cblx0ZGVmIHJlZ2lzdGVyIG5hbWUsIGRlY2wgPSBudWxsLCBvID0ge31cblx0XHQjIEZJWE1FIHJlLXJlZ2lzdGVyaW5nIGEgdmFyaWFibGUgc2hvdWxkIHJlYWxseSByZXR1cm4gdGhlIGV4aXN0aW5nIG9uZVxuXHRcdCMgQWdhaW4sIGhlcmUgd2Ugc2hvdWxkIG5vdCByZWFsbHkgaGF2ZSB0byBkZWFsIHdpdGggc3lzdGVtLWdlbmVyYXRlZCB2YXJzXG5cdFx0IyBCdXQgYWdhaW4sIGl0IGlzIGltcG9ydGFudFxuXG5cdFx0bmFtZSA9IGhlbHBlcnMuc3ltYm9saXplKG5hbWUpXG5cblx0XHQjIGFsc28gbG9vayBhdCBvdXRlciBzY29wZXMgaWYgdGhpcyBpcyBub3QgY2xvc2VkP1xuXHRcdHZhciBleGlzdGluZyA9IEB2YXJtYXAuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgQHZhcm1hcFtuYW1lXVxuXHRcdHJldHVybiBleGlzdGluZyBpZiBleGlzdGluZyBhbmQgIW86dW5pcXVlXG5cblx0XHR2YXIgaXRlbSA9IFZhcmlhYmxlLm5ldyhzZWxmLG5hbWUsZGVjbCxvKVxuXHRcdCMgbmVlZCB0byBjaGVjayBmb3IgZHVwbGljYXRlcywgYW5kIGhhbmRsZSB0aGlzIGdyYWNlZnVsbHkgLVxuXHRcdCMgZ29pbmcgdG8gcmVmYWN0b3IgbGF0ZXJcblx0XHRAdmFybWFwW25hbWVdID0gaXRlbSBpZiAhbzpzeXN0ZW0gYW5kICFleGlzdGluZ1xuXHRcdHJldHVybiBpdGVtXG5cblx0ZGVmIGFubm90YXRlIG9ialxuXHRcdEBhbm5vdGF0aW9ucy5wdXNoKG9iailcblx0XHRzZWxmXG5cblx0IyBqdXN0IGxpa2UgcmVnaXN0ZXIsIGJ1dCB3ZSBhdXRvbWF0aWNhbGx5XG5cdGRlZiBkZWNsYXJlIG5hbWUsIGluaXQgPSBudWxsLCBvID0ge31cblx0XHR2YXIgdmFyaWFibGUgPSByZWdpc3RlcihuYW1lLG51bGwsbylcblx0XHQjIFRPRE8gY3JlYXRlIHRoZSB2YXJpYWJsZWRlY2xhcmF0aW9uIGhlcmUgaW5zdGVhZD9cblx0XHQjIGlmIHRoaXMgaXMgYSBzeXN2YXIgd2UgbmVlZCBpdCB0byBiZSByZW5hbWVhYmxlXG5cdFx0dmFyIGRlYyA9IEB2YXJzLmFkZCh2YXJpYWJsZSxpbml0KVxuXHRcdHZhcmlhYmxlLmRlY2xhcmF0b3IgfHw9IGRlY1xuXHRcdHJldHVybiB2YXJpYWJsZVxuXG5cdCMgd2hhdCBhcmUgdGhlIGRpZmZlcmVuY2VzIGhlcmU/IG9talxuXHQjIHdlIG9ubHkgbmVlZCBhIHRlbXBvcmFyeSB0aGluZyB3aXRoIGRlZmF1bHRzIC0tIHRoYXQgaXMgYWxsXG5cdCMgY2hhbmdlIHRoZXNlIHZhbHVlcywgbm8/XG5cdGRlZiB0ZW1wb3JhcnkgcmVmbm9kZSwgbyA9IHt9LCBuYW1lID0gbnVsbFxuXG5cdFx0aWYgbzpwb29sXG5cdFx0XHRmb3IgdiBpbiBAdmFycG9vbFxuXHRcdFx0XHRpZiB2LnBvb2wgPT0gbzpwb29sICYmIHYuZGVjbGFyYXRvciA9PSBudWxsXG5cdFx0XHRcdFx0cmV0dXJuIHYucmV1c2UocmVmbm9kZSlcblxuXHRcdHZhciBpdGVtID0gU3lzdGVtVmFyaWFibGUubmV3KHNlbGYsbmFtZSxyZWZub2RlLG8pXG5cdFx0XG5cdFx0QHZhcnBvb2wucHVzaChpdGVtKSAjIEl0IHNob3VsZCBub3QgYmUgaW4gdGhlIHBvb2wgdW5sZXNzIGV4cGxpY2l0bHkgcHV0IHRoZXJlP1xuXHRcdEB2YXJzLnB1c2goaXRlbSkgIyBXQVJOIHZhcmlhYmxlcyBzaG91bGQgbm90IGdvIGRpcmVjdGx5IGludG8gYSBkZWNsYXJhdGlvbi1saXN0XG5cdFx0cmV0dXJuIGl0ZW1cblxuXHRkZWYgbG9va3VwIG5hbWVcblx0XHRAbG9va3VwcyB8fD0ge31cblx0XHR2YXIgcmV0ID0gbnVsbFxuXHRcdG5hbWUgPSBoZWxwZXJzLnN5bWJvbGl6ZShuYW1lKVxuXHRcdGlmIEB2YXJtYXAuaGFzT3duUHJvcGVydHkobmFtZSlcblx0XHRcdHJldCA9IEB2YXJtYXBbbmFtZV1cblx0XHRlbHNlXG5cdFx0XHRyZXQgPSBwYXJlbnQgJiYgcGFyZW50Lmxvb2t1cChuYW1lKVxuXG5cdFx0XHRpZiByZXRcblx0XHRcdFx0QG5vbmxvY2FscyB8fD0ge31cblx0XHRcdFx0QG5vbmxvY2Fsc1tuYW1lXSA9IHJldFxuXHRcdHJldFxuXG5cdGRlZiByZXF1aXJlcyBwYXRoLCBuYW1lID0gJydcblx0XHRyb290LnJlcXVpcmVzKHBhdGgsbmFtZSlcblxuXHRkZWYgaW1iYVxuXHRcdHJvb3QucmVxdWlyZXMoJ2ltYmEnLCAnSW1iYScpXG5cblx0ZGVmIGF1dG9kZWNsYXJlIHZhcmlhYmxlXG5cdFx0dmFycy5wdXNoKHZhcmlhYmxlKSAjIG9ubHkgaWYgaXQgZG9lcyBub3QgZXhpc3QgaGVyZSEhIVxuXG5cdGRlZiBmcmVlIHZhcmlhYmxlXG5cdFx0dmFyaWFibGUuZnJlZSAjIDpvd25lciA9IG51bGxcblx0XHQjIEB2YXJwb29sLnB1c2godmFyaWFibGUpXG5cdFx0c2VsZlxuXG5cdGRlZiBpc0Nsb3NlZFxuXHRcdG5vXG5cblx0ZGVmIGNsb3N1cmVcblx0XHRAY2xvc3VyZVxuXG5cdGRlZiBmaW5hbGl6ZVxuXHRcdHNlbGZcblxuXHRkZWYga2xhc3Ncblx0XHR2YXIgc2NvcGUgPSBzZWxmXG5cdFx0d2hpbGUgc2NvcGVcblx0XHRcdHNjb3BlID0gc2NvcGUucGFyZW50XG5cdFx0XHRyZXR1cm4gc2NvcGUgaWYgc2NvcGUgaXNhIENsYXNzU2NvcGVcblx0XHRyZXR1cm4gbnVsbFxuXG5cdGRlZiBoZWFkXG5cdFx0W0B2YXJzLEBwYXJhbXNdXG5cblx0ZGVmIGMgbyA9IHt9XG5cdFx0bzpleHByZXNzaW9uID0gbm9cblx0XHQjIG5lZWQgdG8gZml4IHRoaXNcblx0XHRub2RlLmJvZHkuaGVhZCA9IGhlYWRcblx0XHR2YXIgYm9keSA9IG5vZGUuYm9keS5jKG8pXG5cblx0ZGVmIHJlZ2lvblxuXHRcdG5vZGUuYm9keS5yZWdpb25cblxuXHRkZWYgbG9jXG5cdFx0bm9kZS5sb2NcblxuXHRkZWYgZHVtcFxuXHRcdHZhciB2YXJzID0gT2JqZWN0LmtleXMoQHZhcm1hcCkubWFwIGRvIHxrfFxuXHRcdFx0dmFyIHYgPSBAdmFybWFwW2tdXG5cdFx0XHQjIHVubGVzcyB2LkBkZWNsYXJhdG9yIGlzYSBTY29wZVxuXHRcdFx0IyBcdGNvbnNvbGUubG9nIHYubmFtZSwgdi5AZGVjbGFyYXRvcjpjb25zdHJ1Y3RvcjpuYW1lXG5cdFx0XHQjIGR1bXBfXyh2KVxuXHRcdFx0di5yZWZlcmVuY2VzOmxlbmd0aCA/IGR1bXBfXyh2KSA6IG51bGxcblxuXHRcdHZhciBkZXNjID1cblx0XHRcdG5yOiBAbnJcblx0XHRcdHR5cGU6IHNlbGY6Y29uc3RydWN0b3I6bmFtZVxuXHRcdFx0bGV2ZWw6IChsZXZlbCBvciAwKVxuXHRcdFx0dmFyczogY29tcGFjdF9fKHZhcnMpXG5cdFx0XHRsb2M6IGxvY1xuXG5cdFx0cmV0dXJuIGRlc2NcblxuXHRkZWYgdG9KU09OXG5cdFx0ZHVtcFxuXG5cdGRlZiB0b1N0cmluZ1xuXHRcdFwie3NlbGY6Y29uc3RydWN0b3I6bmFtZX1cIlxuXG5cdGRlZiBjbG9zZVNjb3BlXG5cdFx0c2VsZlxuXG5cbiMgUm9vdFNjb3BlIGlzIHdyb25nPyBSYXRoZXIgVG9wU2NvcGUgb3IgUHJvZ3JhbVNjb3BlXG5leHBvcnQgY2xhc3MgUm9vdFNjb3BlIDwgU2NvcGVcblxuXHRwcm9wIHdhcm5pbmdzXG5cdHByb3Agc2NvcGVzXG5cdHByb3AgZW50aXRpZXNcblxuXHRkZWYgaW5pdGlhbGl6ZVxuXHRcdHN1cGVyXG5cblx0XHRyZWdpc3RlciAnZ2xvYmFsJywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAnbW9kdWxlJywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAnd2luZG93Jywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAnZG9jdW1lbnQnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdleHBvcnRzJywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAnY29uc29sZScsIHNlbGYsIHR5cGU6ICdnbG9iYWwnXG5cdFx0cmVnaXN0ZXIgJ3Byb2Nlc3MnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdwYXJzZUludCcsIHNlbGYsIHR5cGU6ICdnbG9iYWwnXG5cdFx0cmVnaXN0ZXIgJ3BhcnNlRmxvYXQnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdzZXRUaW1lb3V0Jywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAnc2V0SW50ZXJ2YWwnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdzZXRJbW1lZGlhdGUnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdjbGVhclRpbWVvdXQnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdjbGVhckludGVydmFsJywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAnY2xlYXJJbW1lZGlhdGUnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdfX2Rpcm5hbWUnLCBzZWxmLCB0eXBlOiAnZ2xvYmFsJ1xuXHRcdHJlZ2lzdGVyICdfX2ZpbGVuYW1lJywgc2VsZiwgdHlwZTogJ2dsb2JhbCdcblx0XHRyZWdpc3RlciAnXycsIHNlbGYsIHR5cGU6ICdnbG9iYWwnXG5cblx0XHQjIHByZXJlZ2lzdGVyIGdsb2JhbCBzcGVjaWFsIHZhcmlhYmxlcyBoZXJlXG5cdFx0QHJlcXVpcmVzID0ge31cblx0XHRAd2FybmluZ3MgPSBbXVxuXHRcdEBzY29wZXMgICA9IFtdXG5cdFx0QGhlbHBlcnMgID0gW11cblx0XHRAZW50aXRpZXMgPSBFbnRpdGllcy5uZXcoc2VsZilcblx0XHRAaGVhZCA9IFtAdmFyc11cblxuXHRkZWYgY29udGV4dFxuXHRcdEBjb250ZXh0IHx8PSBSb290U2NvcGVDb250ZXh0Lm5ldyhzZWxmKVxuXG5cdCMgZGVmIHRhZ0NvbnRleHRQYXRoXG5cdCMgXHRAdGFnQ29udGV4dFBhdGggfHw9IFwiX1RcIlxuXG5cdGRlZiBsb29rdXAgbmFtZVxuXHRcdG5hbWUgPSBoZWxwZXJzLnN5bWJvbGl6ZShuYW1lKVxuXHRcdEB2YXJtYXBbbmFtZV0gaWYgQHZhcm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuXG5cdGRlZiB2aXNpdFxuXHRcdFNUQUNLLmFkZFNjb3BlKHNlbGYpXG5cdFx0c2VsZlxuXG5cdGRlZiBoZWxwZXIgdHlwLCB2YWx1ZVxuXHRcdCMgbG9nIFwiYWRkIGhlbHBlclwiLHR5cCx2YWx1ZVxuXHRcdGlmIEBoZWxwZXJzLmluZGV4T2YodmFsdWUpID09IC0xXG5cdFx0XHRAaGVscGVycy5wdXNoKHZhbHVlKVxuXHRcdFx0QGhlYWQudW5zaGlmdCh2YWx1ZSlcblxuXHRcdHJldHVybiBzZWxmXG5cblx0ZGVmIGhlYWRcblx0XHRAaGVhZFxuXG5cdGRlZiB3YXJuIGRhdGFcblx0XHQjIGhhY2t5XG5cdFx0ZGF0YTpub2RlID0gbnVsbFxuXHRcdEB3YXJuaW5ncy5wdXNoKGRhdGEpXG5cdFx0c2VsZlxuXG5cdGRlZiBkdW1wXG5cdFx0dmFyIG9iaiA9IHt3YXJuaW5nczogZHVtcF9fKEB3YXJuaW5ncyl9XG5cblx0XHRpZiBPUFRTOmFuYWx5c2lzOnNjb3Blc1xuXHRcdFx0dmFyIHNjb3BlcyA9IEBzY29wZXMubWFwKHxzfCBzLmR1bXApXG5cdFx0XHRzY29wZXMudW5zaGlmdChzdXBlci5kdW1wKVxuXHRcdFx0b2JqOnNjb3BlcyA9IHNjb3Blc1xuXG5cdFx0aWYgT1BUUzphbmFseXNpczplbnRpdGllc1xuXHRcdFx0b2JqOmVudGl0aWVzID0gQGVudGl0aWVzXG5cblx0XHRyZXR1cm4gb2JqXG5cblx0IyBub3QgeWV0IHVzZWRcblx0ZGVmIHJlcXVpcmVzIHBhdGgsIG5hbWVcblx0XHRpZiB2YXIgdmFyaWFibGUgPSBsb29rdXAobmFtZSlcblx0XHRcdHJldHVybiB2YXJpYWJsZVxuXG5cdFx0aWYgdmFyIHZhcmlhYmxlID0gQHJlcXVpcmVzW25hbWVdXG5cdFx0XHRpZiB2YXJpYWJsZS5AcmVxdWlyZVBhdGggIT0gcGF0aFxuXHRcdFx0XHR0aHJvdyBFcnJvci5uZXcoXCJ7bmFtZX0gaXMgYWxyZWFkeSBkZWZpbmVkIGFzIHJlcXVpcmUoJ3t2YXJpYWJsZS5AcmVxdWlyZVBhdGh9JylcIilcblx0XHRcdHJldHVybiB2YXJpYWJsZVxuXG5cdFx0dmFyIHJlcSA9IFJlcXVpcmUubmV3KFN0ci5uZXcoXCInXCIgKyBwYXRoICsgXCInXCIpKVxuXHRcdHZhciB2YXJpYWJsZSA9IFZhcmlhYmxlLm5ldyhzZWxmLG5hbWUsbnVsbCxzeXN0ZW06IHllcylcblx0XHR2YXIgZGVjID0gQHZhcnMuYWRkKHZhcmlhYmxlLCByZXEpXG5cdFx0dmFyaWFibGUuZGVjbGFyYXRvciB8fD0gZGVjXG5cdFx0dmFyaWFibGUuQHJlcXVpcmVQYXRoID0gcGF0aFxuXHRcdEByZXF1aXJlc1tuYW1lXSA9IHZhcmlhYmxlXG5cdFx0cmV0dXJuIHZhcmlhYmxlXG5cblx0ZGVmIGMgbyA9IHt9XG5cdFx0bzpleHByZXNzaW9uID0gbm9cblx0XHQjIG5lZWQgdG8gZml4IHRoaXNcblx0XHRub2RlLmJvZHkuaGVhZCA9IGhlYWRcblx0XHR2YXIgYm9keSA9IG5vZGUuYm9keS5jKG8pXG5cblx0XHRyZXR1cm4gYm9keVxuXG5cblxuZXhwb3J0IGNsYXNzIENsYXNzU2NvcGUgPCBTY29wZVxuXG5cdGRlZiBuYW1lcGF0aFxuXHRcdEBub2RlLm5hbWVwYXRoXG5cblxuXHQjIGNhbGxlZCBmb3Igc2NvcGVzIHRoYXQgYXJlIG5vdCByZWFsIHNjb3BlcyBpbiBqc1xuXHQjIG11c3QgZW5zdXJlIHRoYXQgdGhlIGxvY2FsIHZhcmlhYmxlcyBpbnNpZGUgb2YgdGhlIHNjb3BlcyBkbyBub3Rcblx0IyBjb2xsaWRlIHdpdGggdmFyaWFibGVzIGluIG91dGVyIHNjb3BlcyAtLSByZW5hbWUgaWYgbmVlZGVkXG5cdGRlZiB2aXJ0dWFsaXplXG5cdFx0IyBjb25zb2xlLmxvZyBcInZpcnR1YWxpemluZyBDbGFzc1Njb3BlXCJcblx0XHR2YXIgdXAgPSBwYXJlbnRcblx0XHRmb3Igb3duIGssdiBvZiBAdmFybWFwXG5cdFx0XHR2LnJlc29sdmUodXAseWVzKSAjIGZvcmNlIG5ldyByZXNvbHZlXG5cdFx0c2VsZlxuXG5cdGRlZiBpc0Nsb3NlZFxuXHRcdHllc1xuXG5leHBvcnQgY2xhc3MgVGFnU2NvcGUgPCBDbGFzc1Njb3BlXG5cbmV4cG9ydCBjbGFzcyBDbG9zdXJlU2NvcGUgPCBTY29wZVxuXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25TY29wZSA8IFNjb3BlXG5cbmV4cG9ydCBjbGFzcyBNZXRob2RTY29wZSA8IFNjb3BlXG5cblxuXHRkZWYgaXNDbG9zZWRcblx0XHR5ZXNcblxuXHRkZWYgdGFnQ29udGV4dFxuXHRcdEB0YWdDb250ZXh0IHx8PSBzZWxmLmRlY2xhcmUoXCIkXCIsT1AoJy4nLFRoaXMubmV3LCdfXycpKVxuXG5leHBvcnQgY2xhc3MgTGFtYmRhU2NvcGUgPCBTY29wZVxuXG5cdGRlZiBjb250ZXh0XG5cdFx0IyB3aHkgZG8gd2UgbmVlZCB0byBtYWtlIHN1cmUgaXQgaXMgcmVmZXJlbmNlZD9cblx0XHR1bmxlc3MgQGNvbnRleHRcblx0XHRcdEBjb250ZXh0ID0gcGFyZW50LmNvbnRleHRcblx0XHRcdEBjb250ZXh0LnJlZmVyZW5jZShzZWxmKVxuXHRcdEBjb250ZXh0XG5cblxuZXhwb3J0IGNsYXNzIEZsb3dTY29wZSA8IFNjb3BlXG5cblx0IyB0aGVzZSBoYXZlIG5vIHBhcmFtcyB0aGVtc2VsdmVzLCByZWZlciB0byBvdXRlciBzY29wZXMgLS0gaGptbVxuXHRkZWYgcGFyYW1zXG5cdFx0QHBhcmVudC5wYXJhbXMgaWYgQHBhcmVudFxuXG5cdGRlZiByZWdpc3RlciBuYW1lLCBkZWNsID0gbnVsbCwgbyA9IHt9XG5cdFx0aWYgbzp0eXBlICE9ICdsZXQnIGFuZCAoY2xvc3VyZSAhPSBzZWxmKVxuXHRcdFx0aWYgdmFyIGZvdW5kID0gbG9va3VwKG5hbWUpXG5cdFx0XHRcdGlmIGZvdW5kLnR5cGUgPT0gJ2xldCdcblx0XHRcdFx0XHRwIFwie25hbWV9IGFscmVhZHkgZXhpc3RzIGFzIGEgYmxvY2stdmFyaWFibGUge2RlY2x9XCJcblx0XHRcdFx0XHQjIFRPRE8gc2hvdWxkIHRocm93IGVycm9yIGluc3RlYWRcblx0XHRcdFx0XHRkZWNsLndhcm4gXCJWYXJpYWJsZSBhbHJlYWR5IGV4aXN0cyBpbiBibG9ja1wiIGlmIGRlY2xcblx0XHRcdFx0XHQjIHJvb3Qud2FybiBtZXNzYWdlOiBcIkhvbHkgc2hpdFwiXG5cdFx0XHRjbG9zdXJlLnJlZ2lzdGVyKG5hbWUsZGVjbCxvKVxuXHRcdGVsc2Vcblx0XHRcdHN1cGVyKG5hbWUsZGVjbCxvKVxuXG5cdCMgRklYTUUgc2hvdWxkIG92ZXJyaWRlIHRlbXBvcmFyeSBhcyB3ZWxsXG5cblx0ZGVmIGF1dG9kZWNsYXJlIHZhcmlhYmxlXG5cdFx0cGFyZW50LmF1dG9kZWNsYXJlKHZhcmlhYmxlKVxuXG5cdGRlZiBjbG9zdXJlXG5cdFx0QHBhcmVudC5jbG9zdXJlICMgdGhpcyBpcyBpbXBvcnRhbnQ/XG5cblx0ZGVmIGNvbnRleHRcblx0XHRAY29udGV4dCB8fD0gcGFyZW50LmNvbnRleHRcblxuXHRkZWYgY2xvc2VTY29wZVxuXHRcdEBjb250ZXh0LnJlZmVyZW5jZSBpZiBAY29udGV4dFxuXHRcdHNlbGZcblxuZXhwb3J0IGNsYXNzIENhdGNoU2NvcGUgPCBGbG93U2NvcGVcblxuZXhwb3J0IGNsYXNzIFdoaWxlU2NvcGUgPCBGbG93U2NvcGVcblxuXHRkZWYgYXV0b2RlY2xhcmUgdmFyaWFibGVcblx0XHR2YXJzLnB1c2godmFyaWFibGUpXG5cbmV4cG9ydCBjbGFzcyBGb3JTY29wZSA8IEZsb3dTY29wZVxuXG5cdGRlZiBhdXRvZGVjbGFyZSB2YXJpYWJsZVxuXHRcdHZhcnMucHVzaCh2YXJpYWJsZSlcblxuZXhwb3J0IGNsYXNzIElmU2NvcGUgPCBGbG93U2NvcGVcblxuXHRkZWYgdGVtcG9yYXJ5IHJlZm5vZGUsIG8gPSB7fSwgbmFtZSA9IG51bGxcblx0XHRwYXJlbnQudGVtcG9yYXJ5KHJlZm5vZGUsbyxuYW1lKVxuXG5leHBvcnQgY2xhc3MgQmxvY2tTY29wZSA8IEZsb3dTY29wZVxuXG5cdGRlZiB0ZW1wb3JhcnkgcmVmbm9kZSwgbyA9IHt9LCBuYW1lID0gbnVsbFxuXHRcdHBhcmVudC50ZW1wb3JhcnkocmVmbm9kZSxvLG5hbWUpXG5cblx0ZGVmIHJlZ2lvblxuXHRcdG5vZGUucmVnaW9uXG5cbiMgbGl2ZXMgaW4gc2NvcGUgLS0gcmVhbGx5IGEgbm9kZT8/P1xuZXhwb3J0IGNsYXNzIFZhcmlhYmxlIDwgTm9kZVxuXG5cdHByb3Agc2NvcGVcblx0cHJvcCBuYW1lXG5cdHByb3AgYWxpYXNcblx0cHJvcCB0eXBlXG5cdHByb3Agb3B0aW9uc1xuXHRwcm9wIGluaXRpYWxpemVkXG5cdHByb3AgZGVjbGFyZWRcblx0cHJvcCBkZWNsYXJhdG9yXG5cdHByb3AgYXV0b2RlY2xhcmVcblx0cHJvcCByZWZlcmVuY2VzXG5cdHByb3AgZXhwb3J0XG5cblx0ZGVmIHBvb2xcblx0XHRudWxsXG5cblx0ZGVmIGluaXRpYWxpemUgc2NvcGUsIG5hbWUsIGRlY2wsIG9cblx0XHRAcmVmID0gU1RBQ0suQGNvdW50ZXIrK1xuXHRcdEBjID0gbnVsbFxuXHRcdEBzY29wZSA9IHNjb3BlXG5cdFx0QG5hbWUgID0gbmFtZVxuXHRcdEBhbGlhcyA9IG51bGxcblx0XHRAaW5pdGlhbGl6ZWQgICAgPSB5ZXNcblx0XHRAZGVjbGFyYXRvciAgXHQ9IGRlY2xcblx0XHRAYXV0b2RlY2xhcmUgXHQ9IG5vXG5cdFx0QGRlY2xhcmVkXHRcdD0gbyBhbmQgbzpkZWNsYXJlZCB8fCBub1xuXHRcdEByZXNvbHZlZFx0XHQ9IG5vXG5cdFx0QG9wdGlvbnMgXHRcdD0gbyB8fCB7fVxuXHRcdEB0eXBlXHRcdFx0PSBvIGFuZCBvOnR5cGUgfHwgJ3ZhcicgIyB3aGF0IGFib3V0IGxldCBoZXJlPVxuXHRcdEBleHBvcnRcdFx0XHQ9IG5vXG5cdFx0QHJlZmVyZW5jZXMgXHQ9IFtdICMgb25seSBuZWVkZWQgd2hlbiBwcm9maWxpbmdcblx0XHRAYXNzaWdubWVudHMgXHQ9IFtdXG5cdFx0c2VsZlxuXG5cdGRlZiBjbG9zdXJlXG5cdFx0QHNjb3BlLmNsb3N1cmVcblxuXHRkZWYgYXNzaWdubWVudHNcblx0XHRAYXNzaWdubWVudHNcblxuXHQjIEhlcmUgd2UgY2FuIGNvbGxlY3QgbG90cyBvZiB0eXBlLWluZm8gYWJvdXQgdmFyaWFibGVzXG5cdCMgYW5kIHNob3cgd2FybmluZ3MgLyBnaXZlIGFkdmljZSBpZiB2YXJpYWJsZXMgYXJlIGFtYmlndW91cyBldGNcblx0ZGVmIGFzc2lnbmVkIHZhbCwgc291cmNlXG5cdFx0QGFzc2lnbm1lbnRzLnB1c2godmFsKVxuXHRcdGlmIHZhbCBpc2EgQXJyXG5cdFx0XHQjIGp1c3QgZm9yIHRlc3RpbmcgcmVhbGx5XG5cdFx0XHRAaXNBcnJheSA9IHllc1xuXHRcdGVsc2Vcblx0XHRcdEBpc0FycmF5ID0gbm9cblx0XHRzZWxmXG5cblx0ZGVmIHJlc29sdmUgc2NvcGUgPSBzY29wZSwgZm9yY2UgPSBub1xuXHRcdHJldHVybiBzZWxmIGlmIEByZXNvbHZlZCBhbmQgIWZvcmNlXG5cblx0XHRAcmVzb2x2ZWQgPSB5ZXNcblx0XHR2YXIgY2xvc3VyZSA9IEBzY29wZS5jbG9zdXJlXG5cdFx0dmFyIGl0ZW0gPSBzY29wZS5sb29rdXAoQG5hbWUpXG5cblx0XHQjIGlmIHRoaXMgaXMgYSBsZXQtZGVmaW5pdGlvbiBpbnNpZGUgYSB2aXJ0dWFsIHNjb3BlIHdlIGRvIG5lZWRcblx0XHQjXG5cdFx0aWYgQHNjb3BlICE9IGNsb3N1cmUgYW5kIEB0eXBlID09ICdsZXQnICMgb3IgaWYgaXQgaXMgYSBzeXN0ZW0tdmFyaWFibGVcblx0XHRcdGl0ZW0gPSBjbG9zdXJlLmxvb2t1cChAbmFtZSlcblxuXHRcdFx0IyB3ZSBub3cgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGlzIHZhcmlhYmxlIGlzIHVuaXF1ZSBpbnNpZGVcblx0XHRcdCMgdGhlIHdob2xlIGNsb3N1cmUuXG5cdFx0XHRzY29wZSA9IGNsb3N1cmVcblxuXHRcdGlmIGl0ZW0gPT0gc2VsZlxuXHRcdFx0c2NvcGUudmFybWFwW0BuYW1lXSA9IHNlbGZcblx0XHRcdHJldHVybiBzZWxmXG5cblx0XHRlbGlmIGl0ZW1cblx0XHRcdCMgcG9zc2libHkgcmVkZWZpbmUgdGhpcyBpbnNpZGUsIHVzZSBpdCBvbmx5IGluIHRoaXMgc2NvcGVcblx0XHRcdCMgaWYgdGhlIGl0ZW0gaXMgZGVmaW5lZCBpbiBhbiBvdXRlciBzY29wZSAtIHdlIHJlc2VydmUgdGhlXG5cdFx0XHRpZiBpdGVtLnNjb3BlICE9IHNjb3BlICYmIChvcHRpb25zOmxldCBvciBAdHlwZSA9PSAnbGV0Jylcblx0XHRcdFx0c2NvcGUudmFybWFwW0BuYW1lXSA9IHNlbGZcblxuXHRcdFx0IyBkaWZmZXJlbnQgcnVsZXMgZm9yIGRpZmZlcmVudCB2YXJpYWJsZXM/XG5cdFx0XHRpZiBAb3B0aW9uczpwcm94eVxuXHRcdFx0XHR5ZXNcblx0XHRcdGVsc2Vcblx0XHRcdFx0dmFyIGkgPSAwXG5cdFx0XHRcdHZhciBvcmlnID0gQG5hbWVcblx0XHRcdFx0IyBpdCBpcyB0aGUgY2xvc3VyZSB0aGF0IHdlIHNob3VsZCB1c2Vcblx0XHRcdFx0d2hpbGUgc2NvcGUubG9va3VwKEBuYW1lKVxuXHRcdFx0XHRcdEBuYW1lID0gXCJ7b3JpZ317aSArPSAxfVwiXG5cblx0XHRzY29wZS52YXJtYXBbQG5hbWVdID0gc2VsZlxuXHRcdGNsb3N1cmUudmFybWFwW0BuYW1lXSA9IHNlbGZcblx0XHRyZXR1cm4gc2VsZlxuXG5cdGRlZiByZWZlcmVuY2Vcblx0XHRzZWxmXG5cblx0ZGVmIG5vZGVcblx0XHRzZWxmXG5cblx0ZGVmIGNhY2hlXG5cdFx0c2VsZlxuXG5cdGRlZiB0cmF2ZXJzZVxuXHRcdHNlbGZcblxuXHRkZWYgZnJlZSByZWZcblx0XHRAZGVjbGFyYXRvciA9IG51bGxcblx0XHRzZWxmXG5cblx0ZGVmIHJldXNlIHJlZlxuXHRcdEBkZWNsYXJhdG9yID0gcmVmXG5cdFx0c2VsZlxuXG5cdGRlZiBwcm94eSBwYXIsIGluZGV4XG5cdFx0QHByb3h5ID0gW3BhcixpbmRleF1cblx0XHRzZWxmXG5cblx0ZGVmIHJlZmNvdW50XG5cdFx0QHJlZmVyZW5jZXM6bGVuZ3RoXG5cblx0ZGVmIGNcblx0XHRyZXR1cm4gQGMgaWYgQGNcblx0XHQjIG9wdGlvbnMgLSBwcm94eT8/XG5cdFx0aWYgQHByb3h5XG5cdFx0XHRAYyA9IEBwcm94eVswXS5jICsgJ1snICsgQHByb3h5WzFdLmMgKyAnXSdcblx0XHRlbHNlXG5cdFx0XHRyZXNvbHZlIHVubGVzcyBAcmVzb2x2ZWRcblx0XHRcdHZhciB2ID0gKGFsaWFzIG9yIG5hbWUpXG5cdFx0XHRAYyA9IHR5cGVvZiB2ID09ICdzdHJpbmcnID8gdiA6IHYuY1xuXHRcdFx0IyBhbGxvdyBjZXJ0YWluIHJlc2VydmVkIHdvcmRzXG5cdFx0XHQjIHNob3VsZCB3YXJuIG9uIG90aGVycyB0aG91Z2ggKCEhISlcblx0XHRcdCMgaWYgQGMgPT0gJ25ldydcblx0XHRcdCMgXHRAYyA9ICdfbmV3J1xuXHRcdFx0IyBcdCMgc2hvdWxkIGhhcHBlbiBhdCBlYXJsaWVyIHN0YWdlIHRvXG5cdFx0XHQjIFx0IyBnZXQgYXJvdW5kIG5hbWluZyBjb252ZW50aW9uc1xuXHRcdFx0QGMgPSBcIntjfSRcIiBpZiBSRVNFUlZFRF9SRUdFWC50ZXN0KEBjKSAjIEBjLm1hdGNoKC9eKGRlZmF1bHQpJC8pXG5cdFx0cmV0dXJuIEBjXG5cblx0IyB2YXJpYWJsZXMgc2hvdWxkIHByb2JhYmx5IGluaGVyaXQgZnJvbSBub2RlKCEpXG5cdGRlZiBjb25zdW1lIG5vZGVcblx0XHRyZXR1cm4gc2VsZlxuXG5cdCMgdGhpcyBzaG91bGQgb25seSBnZW5lcmF0ZSB0aGUgYWNjZXNzb3JzIC0gbm90IGRhZWwgd2l0aCByZWZlcmVuY2VzXG5cdGRlZiBhY2Nlc3NvciByZWZcblx0XHR2YXIgbm9kZSA9IExvY2FsVmFyQWNjZXNzLm5ldyhcIi5cIixudWxsLHNlbGYpXG5cdFx0IyB0aGlzIGlzIGp1c3Qgd3JvbmcgLi4gc2hvdWxkIG5vdCBiZSBhIHJlZ3VsYXIgYWNjZXNzb3Jcblx0XHQjIEByZWZlcmVuY2VzLnB1c2goW3JlZixlbF0pIGlmIHJlZiAjIHdlaXJkIHRlbXAgZm9ybWF0XG5cdFx0cmV0dXJuIG5vZGVcblxuXHRkZWYgYXNzaWdubWVudCB2YWxcblx0XHRBc3NpZ24ubmV3KCc9JyxzZWxmLHZhbClcblxuXHRkZWYgYWRkUmVmZXJlbmNlIHJlZlxuXHRcdGlmIHJlZiBpc2EgSWRlbnRpZmllclxuXHRcdFx0cmVmLnJlZmVyZW5jZXMoc2VsZilcblxuXHRcdGlmIHJlZjpyZWdpb24gYW5kIHJlZi5yZWdpb25cblx0XHRcdEByZWZlcmVuY2VzLnB1c2gocmVmKVxuXG5cdFx0c2VsZlxuXG5cdGRlZiBhdXRvZGVjbGFyZVxuXHRcdHJldHVybiBzZWxmIGlmIEBkZWNsYXJlZFxuXHRcdEBhdXRvZGVjbGFyZSA9IHllc1xuXHRcdHNjb3BlLmF1dG9kZWNsYXJlKHNlbGYpXG5cdFx0QGRlY2xhcmVkID0geWVzXG5cdFx0c2VsZlxuXG5cdGRlZiBwcmVkZWNsYXJlZFxuXHRcdEBkZWNsYXJlZCA9IHllc1xuXHRcdHNlbGZcblxuXG5cdGRlZiB0b1N0cmluZ1xuXHRcdFN0cmluZyhuYW1lKVxuXG5cdGRlZiBkdW1wIHR5cFxuXHRcdHZhciBuYW1lID0gbmFtZVxuXHRcdHJldHVybiBudWxsIGlmIG5hbWVbMF0ubWF0Y2goL1tBLVpdLylcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiB0eXBlXG5cdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHRyZWZzOiBkdW1wX18oQHJlZmVyZW5jZXMsIHR5cClcblx0XHR9XG5cblxuZXhwb3J0IGNsYXNzIFN5c3RlbVZhcmlhYmxlIDwgVmFyaWFibGVcblxuXHRkZWYgcG9vbFxuXHRcdEBvcHRpb25zOnBvb2xcblxuXHQjIHdlaXJkIG5hbWUgZm9yIHRoaXNcblx0ZGVmIHByZWRlY2xhcmVkXG5cdFx0c2NvcGUudmFycy5yZW1vdmUoc2VsZilcblx0XHRzZWxmXG5cblx0ZGVmIHJlc29sdmVcblx0XHRyZXR1cm4gc2VsZiBpZiBAcmVzb2x2ZWQgfHwgQG5hbWVcblx0XHRAcmVzb2x2ZWQgPSB5ZXNcblx0XHQjIHVubGVzcyBAbmFtZVxuXHRcdCMgYWRkcyBhIHZlcnkgcmFuZG9tIGluaXRpYWwgbmFtZVxuXHRcdCMgdGhlIGF1dG8tbWFnaWNhbCBnb2VzIGxhc3QsIG9yIGF0IGxlYXN0LCBwb3NzaWJseSByZXVzZSBvdGhlciBuYW1lc1xuXHRcdCMgXCIke01hdGguZmxvb3IoTWF0aC5yYW5kb20gKiAxMDAwKX1cIlxuXG5cdFx0dmFyIHR5cCA9IEBvcHRpb25zOnBvb2xcblx0XHR2YXIgbmFtZXMgPSBbXS5jb25jYXQoQG9wdGlvbnM6bmFtZXMpXG5cdFx0dmFyIGFsdCA9IG51bGxcblx0XHR2YXIgbm9kZSA9IG51bGxcblxuXHRcdHZhciBzY29wZSA9IHNlbGYuc2NvcGVcblxuXHRcdGlmIHR5cCA9PSAndGFnJ1xuXHRcdFx0dmFyIGkgPSAwXG5cdFx0XHR3aGlsZSAhQG5hbWVcblx0XHRcdFx0dmFyIGFsdCA9IFwidHtpKyt9XCJcblx0XHRcdFx0QG5hbWUgPSBhbHQgdW5sZXNzIHNjb3BlLmxvb2t1cChhbHQpXG5cblx0XHRlbGlmIHR5cCA9PSAnaXRlcidcblx0XHRcdG5hbWVzID0gWydhcnlfXycsJ2FyeV8nLCdjb2xsJywnYXJyYXknLCdpdGVtcycsJ2FyeSddXG5cblx0XHRlbGlmIHR5cCA9PSAndmFsJ1xuXHRcdFx0bmFtZXMgPSBbJ3ZfJ11cblxuXHRcdGVsaWYgdHlwID09ICdhcmd1bWVudHMnXG5cdFx0XHRuYW1lcyA9IFsnJF8nLCckMCddXG5cblx0XHRlbGlmIHR5cCA9PSAna2V5cGFycydcblx0XHRcdG5hbWVzID0gWydvcHRzJywnb3B0aW9ucycsJ3BhcnMnXVxuXG5cdFx0ZWxpZiB0eXAgPT0gJ2NvdW50ZXInXG5cdFx0XHRuYW1lcyA9IFsnaV9fJywnaV8nLCdrJywnaicsJ2knXVxuXG5cdFx0ZWxpZiB0eXAgPT0gJ2xlbidcblx0XHRcdG5hbWVzID0gWydsZW5fXycsJ2xlbl8nLCdsZW4nXVxuXG5cdFx0ZWxpZiB0eXAgPT0gJ2xpc3QnXG5cdFx0XHRuYW1lcyA9IFsndG1wbGlzdF8nLCd0bXBsaXN0JywndG1wJ11cblx0XHQjIG9yIGlmIHR5cGUgcGxhY2Vob2xkZXIgLyBjYWNoZXIgKGFkZCAwKVxuXG5cdFx0d2hpbGUgIUBuYW1lICYmIGFsdCA9IG5hbWVzLnBvcFxuXHRcdFx0QG5hbWUgPSBhbHQgdW5sZXNzIHNjb3BlLmxvb2t1cChhbHQpXG5cblx0XHRpZiAhQG5hbWUgYW5kIEBkZWNsYXJhdG9yXG5cdFx0XHRpZiBub2RlID0gZGVjbGFyYXRvci5ub2RlXG5cdFx0XHRcdG5hbWVzLnB1c2goYWxpYXMgKyBcIl9cIikgaWYgdmFyIGFsaWFzID0gbm9kZS5hbGlhc1xuXG5cdFx0d2hpbGUgIUBuYW1lICYmIGFsdCA9IG5hbWVzLnBvcFxuXHRcdFx0QG5hbWUgPSBhbHQgdW5sZXNzIHNjb3BlLmxvb2t1cChhbHQpXG5cblx0XHRAbmFtZSB8fD0gXCIke3Njb3BlLmNvdW50ZXIgKz0gMX1cIlxuXHRcdFxuXHRcdHNjb3BlLnZhcm1hcFtAbmFtZV0gPSBzZWxmXG5cdFx0Y2xvc3VyZS52YXJtYXBbQG5hbWVdID0gc2VsZlxuXHRcdHNlbGZcblxuXHRkZWYgbmFtZVxuXHRcdHJlc29sdmVcblx0XHRAbmFtZVxuXG5cbmV4cG9ydCBjbGFzcyBTY29wZUNvbnRleHQgPCBOb2RlXG5cblx0cHJvcCBzY29wZVxuXHRwcm9wIHZhbHVlXG5cdHByb3AgcmVmZXJlbmNlXG5cblx0ZGVmIGluaXRpYWxpemUgc2NvcGUsIHZhbHVlXG5cdFx0QHNjb3BlID0gc2NvcGVcblx0XHRAdmFsdWUgPSB2YWx1ZVxuXHRcdEByZWZlcmVuY2UgPSBudWxsXG5cdFx0c2VsZlxuXG5cdGRlZiBuYW1lcGF0aFxuXHRcdEBzY29wZS5uYW1lcGF0aFxuXG5cdCMgaW5zdGVhZCBvZiBhbGwgdGhlc2UgcmVmZXJlbmNlcyB3ZSBzaG91bGQgcHJvYmFibHlcblx0IyBqdXN0IHJlZ2lzdGVyIHdoZW4gaXQgaXMgYWNjZXNzZWQgLyBsb29rZWQgdXAgZnJvbVxuXHQjIGEgZGVlcGVyIGZ1bmN0aW9uLXNjb3BlLCBhbmQgd2hlbiBpdCBpcywgd2Ugc2hvdWxkXG5cdCMgcmVnaXN0ZXIgdGhlIHZhcmlhYmxlIGluIHNjb3BlLCBhbmQgdGhlbiBzdGFydCB0b1xuXHQjIHVzZSB0aGF0IGZvciBmdXJ0aGVyIHJlZmVyZW5jZXMuIE1pZ2h0IGNsZWFuIHRoaW5nc1xuXHQjIHVwIGZvciB0aGUgY2FzZXMgd2hlcmUgd2UgaGF2ZSB5ZXQgdG8gZGVjaWRlIHRoZVxuXHQjIG5hbWUgb2YgdGhlIHZhcmlhYmxlIGV0Yz9cblxuXHRkZWYgcmVmZXJlbmNlXG5cdFx0QHJlZmVyZW5jZSB8fD0gc2NvcGUuZGVjbGFyZShcInNlbGZcIixUaGlzLm5ldylcblxuXHRkZWYgY1xuXHRcdHZhciB2YWwgPSBAdmFsdWUgfHwgQHJlZmVyZW5jZVxuXHRcdCh2YWwgPyB2YWwuYyA6IFwidGhpc1wiKVxuXG5cdGRlZiBjYWNoZVxuXHRcdHNlbGZcblxuZXhwb3J0IGNsYXNzIFJvb3RTY29wZUNvbnRleHQgPCBTY29wZUNvbnRleHRcblxuXHRkZWYgYyBvXG5cdFx0IyByZXR1cm4gXCJcIiBpZiBvIGFuZCBvOmV4cGxpY2l0XG5cdFx0dmFyIHZhbCA9IEB2YWx1ZSB8fCBAcmVmZXJlbmNlXG5cdFx0cmV0dXJuICh2YWwgYW5kIHZhbCAhPSB0aGlzKSA/IHZhbC5jIDogXCJ0aGlzXCJcblx0XHQjIHNob3VsZCBiZSB0aGUgb3RoZXIgd2F5IGFyb3VuZCwgbm8/XG5cdFx0IyBvIGFuZCBvOmV4cGxpY2l0ID8gc3VwZXIgOiBcIlwiXG5cbmV4cG9ydCBjbGFzcyBTdXBlciA8IE5vZGVcblxuXHRkZWYgY1xuXHRcdCMgbmVlZCB0byBmaW5kIHRoZSBzdHVmZiBoZXJlXG5cdFx0IyB0aGlzIGlzIHJlYWxseSBub3QgdGhhdCBnb29kOFxuXHRcdHZhciBtID0gU1RBQ0subWV0aG9kXG5cdFx0dmFyIG91dCA9IG51bGxcblx0XHR2YXIgdXAgPSBTVEFDSy5jdXJyZW50XG5cdFx0dmFyIGRlZXAgPSB1cCBpc2EgQWNjZXNzXG5cblx0XHQjIFRPRE8gb3B0aW1pemF0aW9uIGZvciBsYXRlciAtIHByb2JsZW1hdGljIGlmIHRoZXJlIGlzIGEgZGlmZmVyZW50IHJlZmVyZW5jZSBpbiB0aGUgZW5kXG5cdFx0aWYgZmFsc2UgJiYgbSAmJiBtLnR5cGUgPT0gOmNvbnN0cnVjdG9yXG5cdFx0XHRvdXQgPSBcInttLnRhcmdldC5jfS5zdXBlcmNsYXNzXCJcblx0XHRcdG91dCArPSBcIi5hcHBseSh7bS5zY29wZS5jb250ZXh0LmN9LGFyZ3VtZW50cylcIiB1bmxlc3MgZGVlcFxuXHRcdGVsc2Vcblx0XHRcdG91dCA9IFwie20udGFyZ2V0LmN9Ll9fc3VwZXJfX1wiXG5cdFx0XHR1bmxlc3MgdXAgaXNhIEFjY2Vzc1xuXHRcdFx0XHRvdXQgKz0gXCIue2NfXyhtLnN1cGVybmFtZSl9XCJcblx0XHRcdFx0dW5sZXNzIHVwIGlzYSBDYWxsICMgYXV0b2NhbGw/XG5cdFx0XHRcdFx0b3V0ICs9IFwiLmFwcGx5KHttLnNjb3BlLmNvbnRleHQuY30sYXJndW1lbnRzKVwiXG5cdFx0b3V0XG5cbiMgY29uc3RhbnRzXG5cbmV4cG9ydCB2YXIgQlIgPSBOZXdsaW5lLm5ldygnXFxuJylcbmV4cG9ydCB2YXIgQlIyID0gTmV3bGluZS5uZXcoJ1xcblxcbicpXG5leHBvcnQgdmFyIFNFTEYgPSBTZWxmLm5ld1xuZXhwb3J0IHZhciBTVVBFUiA9IFN1cGVyLm5ld1xuXG5leHBvcnQgdmFyIFRSVUUgPSBUcnVlLm5ldygndHJ1ZScpXG5leHBvcnQgdmFyIEZBTFNFID0gRmFsc2UubmV3KCdmYWxzZScpXG5leHBvcnQgdmFyIFVOREVGSU5FRCA9IFVuZGVmaW5lZC5uZXdcbmV4cG9ydCB2YXIgTklMID0gTmlsLm5ld1xuXG5leHBvcnQgdmFyIEFSR1VNRU5UUyA9IEFyZ3NSZWZlcmVuY2UubmV3KCdhcmd1bWVudHMnKVxuZXhwb3J0IHZhciBFTVBUWSA9ICcnXG5leHBvcnQgdmFyIE5VTEwgPSAnbnVsbCdcblxuZXhwb3J0IHZhciBSRVNFUlZFRCA9IFsnZGVmYXVsdCcsJ25hdGl2ZScsJ2VudW0nLCd3aXRoJ11cbmV4cG9ydCB2YXIgUkVTRVJWRURfUkVHRVggPSAvXihkZWZhdWx0fG5hdGl2ZXxlbnVtfHdpdGh8bmV3fGNoYXIpJC9cblxuZXhwb3J0IHZhciBVTklPTiA9IENvbnN0Lm5ldygndW5pb24kJylcbmV4cG9ydCB2YXIgSU5URVJTRUNUID0gQ29uc3QubmV3KCdpbnRlcnNlY3QkJylcbmV4cG9ydCB2YXIgQ0xBU1NERUYgPSBDb25zdC5uZXcoJ2ltYmEkY2xhc3MnKVxuZXhwb3J0IHZhciBUQUdERUYgPSBDb25zdC5uZXcoJ0ltYmEuVEFHUy5kZWZpbmUnKVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vaW1iYS9zcmMvY29tcGlsZXIvbm9kZXMuaW1iYSIsIiMgaW1iYSRpbmxpbmVIZWxwZXJzPTFcblxuaW1wb3J0ICdwYXRoJyBhcyBwYXRoXG5pbXBvcnQgJy4vaGVscGVycycgYXMgdXRpbFxuXG5leHBvcnQgY2xhc3MgU291cmNlTWFwXG5cblx0ZGVmIHNvdXJjZVxuXHRcdEBzb3VyY2VcblxuXHRkZWYgb3B0aW9uc1xuXHRcdEBzb3VyY2VcblxuXHRkZWYgaW5pdGlhbGl6ZSBzb3VyY2Vcblx0XHRAc291cmNlID0gc291cmNlXG5cdFx0QG1hcHMgPSBbXVxuXHRcdEBtYXAgPSBcIlwiXG5cdFx0QGpzID0gXCJcIlxuXG5cdGRlZiBmaWxlbmFtZVxuXHRcdG9wdGlvbnM6b3B0aW9uczpmaWxlbmFtZVxuXG5cdGRlZiBzb3VyY2VDb2RlXG5cdFx0b3B0aW9uczpvcHRpb25zLkBzb3VyY2VcblxuXHRkZWYgdGFyZ2V0UGF0aFxuXHRcdG9wdGlvbnM6b3B0aW9uczp0YXJnZXRQYXRoXG5cblx0ZGVmIHNvdXJjZVBhdGhcblx0XHRvcHRpb25zOm9wdGlvbnM6c291cmNlUGF0aFxuXG5cdGRlZiBzb3VyY2VOYW1lXG5cdFx0cGF0aC5iYXNlbmFtZShzb3VyY2VQYXRoKVxuXG5cdGRlZiB0YXJnZXROYW1lXG5cdFx0cGF0aC5iYXNlbmFtZSh0YXJnZXRQYXRoKVxuXHRcdFxuXG5cdGRlZiBzb3VyY2VGaWxlc1xuXHRcdFtzb3VyY2VOYW1lXVxuXG5cdGRlZiBwYXJzZVxuXHRcdHZhciBtYXRjaGVyID0gL1xcJVxcJChcXGQqKVxcJFxcJS9cblx0XHR2YXIgcmVwbGFjZXIgPSAvXiguKj8pXFwlXFwkKFxcZCopXFwkXFwlL1xuXHRcdHZhciBsaW5lcyA9IG9wdGlvbnM6anMuc3BsaXQoL1xcbi9nKSAjIHdoYXQgYWJvdXQganM/XG5cdFx0IyByZXR1cm4gc2VsZlxuXHRcdHZhciBsb2NtYXAgPSB1dGlsLmxvY2F0aW9uVG9MaW5lQ29sTWFwKHNvdXJjZUNvZGUpXG5cdFx0QG1hcHMgPSBbXVxuXHRcdFxuXHRcdHZhciBtYXRjaFxuXHRcdCMgc3BsaXQgdGhlIGNvZGUgaW4gbGluZXMuIGdvIHRocm91Z2ggZWFjaCBsaW5lIFxuXHRcdCMgZ28gdGhyb3VnaCB0aGUgY29kZSBsb29raW5nIGZvciBMT0MgbWFya2Vyc1xuXHRcdCMgcmVtb3ZlIG1hcmtlcnMgYWxvbmcgdGhlIHdheSBhbmQga2VlcCB0cmFjayBvZlxuXHRcdCMgY29uc29sZS5sb2cgc291cmNlOmpzXG5cblx0XHRmb3IgbGluZSxpIGluIGxpbmVzXG5cdFx0XHQjIGNvdWxkIHNwbGl0IG9uIHRoZXNlP1xuXHRcdFx0dmFyIGNvbCA9IDBcblx0XHRcdHZhciBjYXJldCA9IDBcblxuXHRcdFx0QG1hcHNbaV0gPSBbXVxuXHRcdFx0d2hpbGUgbGluZS5tYXRjaChtYXRjaGVyKVxuXHRcdFx0XHRsaW5lID0gbGluZS5yZXBsYWNlKHJlcGxhY2VyKSBkbyB8bSxwcmUsbG9jfFxuXHRcdFx0XHRcdHZhciBsYyA9IGxvY21hcFtwYXJzZUludChsb2MpXVxuXHRcdFx0XHRcdGNhcmV0ID0gcHJlOmxlbmd0aFxuXHRcdFx0XHRcdHZhciBtYXBwaW5nID0gWyBbbGNbMF0sbGNbMV1dLCBbaSxjYXJldF0gXSAjIHNvdXJjZSBhbmQgb3V0cHV0XG5cdFx0XHRcdFx0QG1hcHNbaV0ucHVzaChtYXBwaW5nKVxuXHRcdFx0XHRcdHJldHVybiBwcmVcblx0XHRcdGxpbmVzW2ldID0gbGluZVxuXG5cdFx0XG5cdFx0c291cmNlOmpzID0gbGluZXMuam9pbignXFxuJylcblx0XHRzZWxmXG5cblx0ZGVmIGdlbmVyYXRlXG5cdFx0cGFyc2VcblxuXHRcdHZhciBsYXN0Q29sdW1uICAgICAgICA9IDBcblx0XHR2YXIgbGFzdFNvdXJjZUxpbmUgICAgPSAwXG5cdFx0dmFyIGxhc3RTb3VyY2VDb2x1bW4gID0gMFxuXHRcdHZhciBidWZmZXIgICAgICAgICAgICA9IFwiXCJcblxuXHRcdGZvciBsaW5lLGxpbmVOdW1iZXIgaW4gQG1hcHNcblx0XHRcdGxhc3RDb2x1bW4gPSAwXG5cblx0XHRcdGZvciBtYXAsbnIgaW4gbGluZVxuXHRcdFx0XHRidWZmZXIgKz0gJywnIHVubGVzcyBuciA9PSAwXG5cdFx0XHRcdHZhciBzcmMgPSBtYXBbMF1cblx0XHRcdFx0dmFyIGRlc3QgPSBtYXBbMV1cblx0XHRcdFx0XG5cdFx0XHRcdGJ1ZmZlciArPSBlbmNvZGVWbHEoZGVzdFsxXSAtIGxhc3RDb2x1bW4pXG5cdFx0XHRcdGxhc3RDb2x1bW4gPSBkZXN0WzFdXG5cdFx0XHRcdCMgYWRkIGluZGV4XG5cdFx0XHRcdGJ1ZmZlciArPSBlbmNvZGVWbHEoMClcblxuXHRcdFx0XHQjIFRoZSBzdGFydGluZyBsaW5lIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBzb3VyY2UgbGluZS5cblx0XHRcdFx0YnVmZmVyICs9IGVuY29kZVZscShzcmNbMF0gLSBsYXN0U291cmNlTGluZSlcblx0XHRcdFx0bGFzdFNvdXJjZUxpbmUgPSBzcmNbMF1cblx0XHRcdFx0IyBUaGUgc3RhcnRpbmcgY29sdW1uIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBjb2x1bW4uXG5cdFx0XHRcdGJ1ZmZlciArPSBlbmNvZGVWbHEoc3JjWzFdIC0gbGFzdFNvdXJjZUNvbHVtbilcblx0XHRcdFx0bGFzdFNvdXJjZUNvbHVtbiA9IHNyY1sxXVxuXG5cdFx0XHRidWZmZXIgKz0gXCI7XCJcblxuXG5cdFx0dmFyIHJlbCA9IHRhcmdldFBhdGggYW5kIHBhdGgucmVsYXRpdmUocGF0aC5kaXJuYW1lKHRhcmdldFBhdGgpLHNvdXJjZVBhdGgpXG5cblx0XHR2YXIgbWFwID1cblx0XHRcdHZlcnNpb246IDNcblx0XHRcdGZpbGU6IHNvdXJjZU5hbWUucmVwbGFjZSgvXFwuaW1iYS8sJy5qcycpIG9yICcnXG5cdFx0XHRzb3VyY2VSb290OiBvcHRpb25zOnNvdXJjZVJvb3Qgb3IgJydcblx0XHRcdHNvdXJjZXM6ICAgIFtyZWwgb3Igc291cmNlUGF0aF1cblx0XHRcdHNvdXJjZXNDb250ZW50OiBbc291cmNlQ29kZV1cblx0XHRcdG5hbWVzOiAgICAgIFtdXG5cdFx0XHRtYXBwaW5nczogICBidWZmZXJcblxuXHRcdCMgc291cmNlOnNvdXJjZW1hcCA9IHNvdXJjZW1hcFxuXHRcdCMgdmFyIGJhc2U2NCA9IEJ1ZmZlci5uZXcoSlNPTi5zdHJpbmdpZnkobWFwKSkudG9TdHJpbmcoXCJiYXNlNjRcIilcblx0XHQjIHNvdXJjZTpqcyArPSBcIlxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQse2Jhc2U2NH1cIlxuXHRcdHJldHVybiBtYXBcblxuXHR2YXIgVkxRX1NISUZUID0gNVxuXHR2YXIgVkxRX0NPTlRJTlVBVElPTl9CSVQgPSAxIDw8IFZMUV9TSElGVFxuXHR2YXIgVkxRX1ZBTFVFX01BU0sgPSBWTFFfQ09OVElOVUFUSU9OX0JJVCAtIDFcblx0dmFyIEJBU0U2NF9DSEFSUyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuXG5cdCMgYm9ycm93ZWQgZnJvbSBDb2ZmZWVTY3JpcHRcblx0ZGVmIGVuY29kZVZscSB2YWx1ZVxuXHRcdHZhciBhbnN3ZXIgPSAnJ1xuXHRcdCMgTGVhc3Qgc2lnbmlmaWNhbnQgYml0IHJlcHJlc2VudHMgdGhlIHNpZ24uXG5cdFx0dmFyIHNpZ25CaXQgPSB2YWx1ZSA8IDAgPyAxIDogMFxuXHRcdHZhciBuZXh0Q2h1bmtcblx0XHQjIFRoZSBuZXh0IGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUuXG5cdFx0dmFyIHZhbHVlVG9FbmNvZGUgPSAoTWF0aC5hYnModmFsdWUpIDw8IDEpICsgc2lnbkJpdFxuXHRcdCMgTWFrZSBzdXJlIHdlIGVuY29kZSBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyLCBldmVuIGlmIHZhbHVlVG9FbmNvZGUgaXMgMC5cblx0XHR3aGlsZSB2YWx1ZVRvRW5jb2RlIG9yICFhbnN3ZXJcblx0XHRcdHZhciBuZXh0Q2h1bmsgPSB2YWx1ZVRvRW5jb2RlICYgVkxRX1ZBTFVFX01BU0tcblx0XHRcdHZhbHVlVG9FbmNvZGUgPSB2YWx1ZVRvRW5jb2RlID4+IFZMUV9TSElGVFxuXHRcdFx0aWYgdmFsdWVUb0VuY29kZVxuXHRcdFx0XHRuZXh0Q2h1bmsgfD0gVkxRX0NPTlRJTlVBVElPTl9CSVRcblxuXHRcdFx0YW5zd2VyICs9IGVuY29kZUJhc2U2NChuZXh0Q2h1bmspXG5cblx0XHRhbnN3ZXJcblxuXHRkZWYgZW5jb2RlQmFzZTY0IHZhbHVlXG5cdFx0QkFTRTY0X0NIQVJTW3ZhbHVlXSAjIG9yIHRocm93IEVycm9yLm5ldyhcIkNhbm5vdCBCYXNlNjQgZW5jb2RlIHZhbHVlOiB7dmFsdWV9XCIpXG5cblx0XHRcblx0XHRcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vaW1iYS9zcmMvY29tcGlsZXIvc291cmNlbWFwLmltYmEiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==