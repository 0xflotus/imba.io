/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		__webpack_require__(1);
		
		// need to use webpack for this include to work as intended
		Scrimbla = __webpack_require__(14);
		
		var App = __webpack_require__(57).App;
		APP = new App();
		APP.schedule();
		
		__webpack_require__(59);
		
		// awaken pages etc
		q$('._page').map(function(el) { return el; });
		return q$('.awaken').map(function(el) { return el; });
	
	})()

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		
		if (typeof Imba === 'undefined') {
			__webpack_require__(2);
			
			Imba.CLIENT = true;
			
			__webpack_require__(3);
			__webpack_require__(4);
			__webpack_require__(5);
			__webpack_require__(6);
			__webpack_require__(7);
			__webpack_require__(8);
			__webpack_require__(9);
			__webpack_require__(10);
			__webpack_require__(11);
			__webpack_require__(12);
			return __webpack_require__(13);
		} else {
			return console.warn("Imba is already loaded");
		};
	
	})()

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {(function(){
		// externs;
		
		if (true) {
			global = window;
		};
		
		/*
		Imba is the namespace for all runtime related utilities
		@namespace
		*/
		
		Imba = {
			VERSION: '0.14.1',
			DEBUG: false
		};
		
		var reg = /-./g;
		
		/*
		True if running in client environment.
		@return {bool}
		*/
		
		Imba.isClient = function (){
			return Imba.CLIENT === true;
		};
		
		/*
		True if running in server environment.
		@return {bool}
		*/
		
		Imba.isServer = function (){
			return (false) === true;
		};
		
		Imba.subclass = function (obj,sup){
			;
			for (var k in sup){
				if (sup.hasOwnProperty(k)) { obj[k] = sup[k] };
			};
			
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
			return obj;
		};
		
		/*
		Lightweight method for making an object iterable in imbas for/in loops.
		If the compiler cannot say for certain that a target in a for loop is an
		array, it will cache the iterable version before looping.
		
		```imba
		# this is the whole method
		def Imba.iterable o
			return o ? (o:toArray ? o.toArray : o) : []
		
		class CustomIterable
			def toArray
				[1,2,3]
		
		# will return [2,4,6]
		for x in CustomIterable.new
			x * 2
		
		```
		*/
		
		Imba.iterable = function (o){
			return o ? ((o.toArray ? (o.toArray()) : (o))) : ([]);
		};
		
		/*
		Coerces a value into a promise. If value is array it will
		call `Promise.all(value)`, or if it is not a promise it will
		wrap the value in `Promise.resolve(value)`. Used for experimental
		await syntax.
		@return {Promise}
		*/
		
		Imba.await = function (value){
			if (value instanceof Array) {
				return Promise.all(value);
			} else if (value && value.then) {
				return value;
			} else {
				return Promise.resolve(value);
			};
		};
		
		Imba.toCamelCase = function (str){
			return str.replace(reg,function(m) { return m.charAt(1).toUpperCase(); });
		};
		
		Imba.toCamelCase = function (str){
			return str.replace(reg,function(m) { return m.charAt(1).toUpperCase(); });
		};
		
		Imba.indexOf = function (a,b){
			return (b && b.indexOf) ? (b.indexOf(a)) : ([].indexOf.call(a,b));
		};
		
		Imba.prop = function (scope,name,opts){
			if (scope.defineProperty) {
				return scope.defineProperty(name,opts);
			};
			return;
		};
		
		return Imba.attr = function (scope,name,opts){
			if (scope.defineAttribute) {
				return scope.defineAttribute(name,opts);
			};
			
			var getName = Imba.toCamelCase(name);
			var setName = Imba.toCamelCase('set-' + name);
			
			scope.prototype[getName] = function() {
				return this.getAttribute(name);
			};
			
			scope.prototype[setName] = function(value) {
				this.setAttribute(name,value);
				return this;
			};
			
			return;
		};
	
	})()
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports) {

	(function(){
		
		
		function emit__(event,args,node){
			// var node = cbs[event]
			var prev,cb,ret;
			
			while ((prev = node) && (node = node.next)){
				if (cb = node.listener) {
					if (node.path && cb[node.path]) {
						ret = args ? (cb[node.path].apply(cb,args)) : (cb[node.path]());
					} else {
						// check if it is a method?
						ret = args ? (cb.apply(node,args)) : (cb.call(node));
					};
				};
				
				if (node.times && --node.times <= 0) {
					prev.next = node.next;
					node.listener = null;
				};
			};
			return;
		};
		
		// method for registering a listener on object
		Imba.listen = function (obj,event,listener,path){
			var $1;
			var cbs,list,tail;
			cbs = obj.__listeners__ || (obj.__listeners__ = {});
			list = cbs[($1 = event)] || (cbs[$1] = {});
			tail = list.tail || (list.tail = (list.next = {}));
			tail.listener = listener;
			tail.path = path;
			list.tail = tail.next = {};
			return tail;
		};
		
		Imba.once = function (obj,event,listener){
			var tail = Imba.listen(obj,event,listener);
			tail.times = 1;
			return tail;
		};
		
		Imba.unlisten = function (obj,event,cb,meth){
			var node,prev;
			var meta = obj.__listeners__;
			if (!meta) { return };
			
			if (node = meta[event]) {
				while ((prev = node) && (node = node.next)){
					if (node == cb || node.listener == cb) {
						prev.next = node.next;
						// check for correct path as well?
						node.listener = null;
						break;
					};
				};
			};
			return;
		};
		
		Imba.emit = function (obj,event,params){
			var cb;
			if (cb = obj.__listeners__) {
				if (cb[event]) { emit__(event,params,cb[event]) };
				if (cb.all) { emit__(event,[event,params],cb.all) }; // and event != 'all'
			};
			return;
		};
		
		return Imba.observeProperty = function (observer,key,trigger,target,prev){
			if (prev && typeof prev == 'object') {
				Imba.unlisten(prev,'all',observer,trigger);
			};
			if (target && typeof target == 'object') {
				Imba.listen(target,'all',observer,trigger);
			};
			return this;
		};
	
	})()

/***/ },
/* 4 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		
		var raf; // very simple raf polyfill
		raf || (raf = global.requestAnimationFrame);
		raf || (raf = global.webkitRequestAnimationFrame);
		raf || (raf = global.mozRequestAnimationFrame);
		raf || (raf = function(blk) { return setTimeout(blk,1000 / 60); });
		
		Imba.tick = function (d){
			if (this._scheduled) { raf(Imba.ticker()) };
			this.emit(this,'tick',[d]);
			return;
		};
		
		Imba.ticker = function (){
			var self = this;
			return self._ticker || (self._ticker = function(e) { return self.tick(e); });
		};
		
		/*
		
		Global alternative to requestAnimationFrame. Schedule a target
		to tick every frame. You can specify which method to call on the
		target (defaults to tick).
		
		*/
		
		Imba.schedule = function (target,method){
			if(method === undefined) method = 'tick';
			this.listen(this,'tick',target,method);
			// start scheduling now if this was the first one
			if (!this._scheduled) {
				this._scheduled = true;
				raf(Imba.ticker());
			};
			return this;
		};
		
		/*
		
		Unschedule a previously scheduled target
		
		*/
		
		Imba.unschedule = function (target,method){
			this.unlisten(this,'tick',target,method);
			var cbs = this.__listeners__ || (this.__listeners__ = {});
			if (!cbs.tick || !cbs.tick.next || !cbs.tick.next.listener) {
				this._scheduled = false;
			};
			return this;
		};
		
		/*
		
		Light wrapper around native setTimeout that expects the block / function
		as last argument (instead of first). It also triggers an event to Imba
		after the timeout to let schedulers update (to rerender etc) afterwards.
		
		*/
		
		Imba.setTimeout = function (delay,block){
			return setTimeout(function() {
				block();
				return Imba.emit(Imba,'timeout',[block]);
			},delay);
		};
		
		/*
		
		Light wrapper around native setInterval that expects the block / function
		as last argument (instead of first). It also triggers an event to Imba
		after every interval to let schedulers update (to rerender etc) afterwards.
		
		*/
		
		Imba.setInterval = function (interval,block){
			return setInterval(function() {
				block();
				return Imba.emit(Imba,'interval',[block]);
			},interval);
		};
		
		/*
		Clear interval with specified id
		*/
		
		Imba.clearInterval = function (interval){
			return clearInterval(interval);
		};
		
		/*
		Clear timeout with specified id
		*/
		
		Imba.clearTimeout = function (timeout){
			return clearTimeout(timeout);
		};
		
		// should add an Imba.run / setImmediate that
		// pushes listener onto the tick-queue with times - once
		
		
		/*
		
		Instances of Imba.Scheduler manages when to call `tick()` on their target,
		at a specified framerate or when certain events occur. Root-nodes in your
		applications will usually have a scheduler to make sure they rerender when
		something changes. It is also possible to make inner components use their
		own schedulers to control when they render.
		
		@iname scheduler
		
		*/
		
		Imba.Scheduler = function Scheduler(target){
			var self = this;
			self._target = target;
			self._marked = false;
			self._active = false;
			self._marker = function() { return self.mark(); };
			self._ticker = function(e) { return self.tick(e); };
			
			self._events = true;
			self._fps = 1;
			
			self._dt = 0;
			self._timestamp = 0;
			self._ticks = 0;
			self._flushes = 0;
		};
		
		/*
			Create a new Imba.Scheduler for specified target
			@return {Imba.Scheduler}
			*/
		
		/*
			Check whether the current scheduler is active or not
			@return {bool}
			*/
		
		Imba.Scheduler.prototype.active = function (){
			return this._active;
		};
		
		/*
			Delta time between the two last ticks
			@return {Number}
			*/
		
		Imba.Scheduler.prototype.dt = function (){
			return this._dt;
		};
		
		/*
			Delta time between the two last ticks
			@return {Number}
			*/
		
		Imba.Scheduler.prototype.configure = function (pars){
			if(!pars||pars.constructor !== Object) pars = {};
			var fps = pars.fps !== undefined ? pars.fps : 1;
			var events = pars.events !== undefined ? pars.events : true;
			if (events != null) { this._events = events };
			if (fps != null) { this._fps = fps };
			return this;
		};
		
		// def reschedule
		// 	raf(@ticker)
		// 	self
		
		/*
			Mark the scheduler as dirty. This will make sure that
			the scheduler calls `target.tick` on the next frame
			@return {self}
			*/
		
		Imba.Scheduler.prototype.mark = function (){
			this._marked = true;
			return this;
		};
		
		/*
			Instantly trigger target.tick and mark scheduler as clean (not dirty/marked).
			This is called implicitly from tick, but can also be called manually if you
			really want to force a tick without waiting for the next frame.
			@return {self}
			*/
		
		Imba.Scheduler.prototype.flush = function (){
			this._marked = false;
			this._flushes++;
			this._target.tick();
			return this;
		};
		
		/*
			@fixme this expects raf to run at 60 fps 
		
			Called automatically on every frame while the scheduler is active.
			It will only call `target.tick` if the scheduler is marked dirty,
			or when according to @fps setting.
		
			If you have set up a scheduler with an fps of 1, tick will still be
			called every frame, but `target.tick` will only be called once every
			second, and it will *make sure* each `target.tick` happens in separate
			seconds according to Date. So if you have a node that renders a clock
			based on Date.now (or something similar), you can schedule it with 1fps,
			never needing to worry about two ticks happening within the same second.
			The same goes for 4fps, 10fps etc.
		
			@protected
			@return {self}
			*/
		
		Imba.Scheduler.prototype.tick = function (delta){
			this._ticks++;
			this._dt = delta;
			
			var fps = this._fps;
			
			if (fps == 60) {
				this._marked = true;
			} else if (fps == 30) {
				if (this._ticks % 2) { this._marked = true };
			} else if (fps) {
				// if it is less round - we trigger based
				// on date, for consistent rendering.
				// ie, if you want to render every second
				// it is important that no two renders
				// happen during the same second (according to Date)
				var period = ((60 / fps) / 60) * 1000;
				var beat = Math.floor(Date.now() / period);
				
				if (this._beat != beat) {
					this._beat = beat;
					this._marked = true;
				};
			};
			
			if (this._marked) this.flush();
			// reschedule if @active
			return this;
		};
		
		/*
			Start the scheduler if it is not already active.
			**While active**, the scheduler will override `target.commit`
			to do nothing. By default Imba.tag#commit calls render, so
			that rendering is cascaded through to children when rendering
			a node. When a scheduler is active (for a node), Imba disables
			this automatic rendering.
			*/
		
		Imba.Scheduler.prototype.activate = function (){
			if (!this._active) {
				this._active = true;
				// override target#commit while this is active
				this._commit = this._target.commit;
				this._target.commit = function() { return this; };
				Imba.schedule(this);
				if (this._events) { Imba.listen(Imba,'event',this,'onevent') };
				this._target && this._target.flag  &&  this._target.flag('scheduled_');
				this.tick(0); // start ticking
			};
			return this;
		};
		
		/*
			Stop the scheduler if it is active.
			*/
		
		Imba.Scheduler.prototype.deactivate = function (){
			if (this._active) {
				this._active = false;
				this._target.commit = this._commit;
				Imba.unschedule(this);
				Imba.unlisten(Imba,'event',this);
				this._target && this._target.unflag  &&  this._target.unflag('scheduled_');
			};
			return this;
		};
		
		Imba.Scheduler.prototype.track = function (){
			return this._marker;
		};
		
		Imba.Scheduler.prototype.onevent = function (event){
			var $1;
			if (this._marked) { return this };
			
			if (this._events instanceof Function) {
				if (this._events(event)) this.mark();
			} else if (this._events instanceof Array) {
				if (idx$(($1 = event) && $1.type  &&  $1.type(),this._events) >= 0) this.mark();
			} else if (this._events) {
				if (event._responder) this.mark();
			};
			return this;
		};
		return Imba.Scheduler;
	
	})()
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 5 */
/***/ function(module, exports) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		Imba.static = function (items,nr){
			items.static = nr;
			return items;
		};
		
		/*
		This is the baseclass that all tags in imba inherit from.
		@iname node
		*/
		
		Imba.Tag = function Tag(dom){
			this.setDom(dom);
		};
		
		Imba.Tag.createNode = function (){
			throw "Not implemented";
		};
		
		Imba.Tag.build = function (){
			return new this(this.createNode());
		};
		
		
		
		Imba.Tag.prototype.object = function(v){ return this._object; }
		Imba.Tag.prototype.setObject = function(v){ this._object = v; return this; };
		
		Imba.Tag.prototype.dom = function (){
			return this._dom;
		};
		
		Imba.Tag.prototype.setDom = function (dom){
			dom._tag = this;
			this._dom = dom;
			return this;
		};
		
		/*
			Setting references for tags like
			`<div@header>` will compile to `tag('div').setRef('header',this).end()`
			By default it adds the reference as a className to the tag.
			@return {self}
			*/
		
		Imba.Tag.prototype.setRef = function (ref,ctx){
			this.flag(this._ref = ref);
			return this;
		};
		
		/*
			Method that is called by the compiled tag-chains, for
			binding events on tags to methods etc.
			`<a :tap=fn>` compiles to `tag('a').setHandler('tap',fn,this).end()`
			where this refers to the context in which the tag is created.
			@return {self}
			*/
		
		Imba.Tag.prototype.setHandler = function (event,handler,ctx){
			var key = 'on' + event;
			
			if (handler instanceof Function) {
				this[key] = handler;
			} else if (handler instanceof Array) {
				var fn = handler.shift();
				this[key] = function(e) { return ctx[fn].apply(ctx,handler.concat(e)); };
			} else {
				this[key] = function(e) { return ctx[handler](e); };
			};
			return this;
		};
		
		Imba.Tag.prototype.setId = function (id){
			this.dom().id = id;
			return this;
		};
		
		Imba.Tag.prototype.id = function (){
			return this.dom().id;
		};
		
		/*
			Adds a new attribute or changes the value of an existing attribute
			on the specified tag. If the value is null or false, the attribute
			will be removed.
			@return {self}
			*/
		
		Imba.Tag.prototype.setAttribute = function (name,value){
			// should this not return self?
			var old = this.dom().getAttribute(name);
			
			if (old == value) {
				return value;
			} else if (value != null && value !== false) {
				return this.dom().setAttribute(name,value);
			} else {
				return this.dom().removeAttribute(name);
			};
		};
		
		/*
			removes an attribute from the specified tag
			*/
		
		Imba.Tag.prototype.removeAttribute = function (name){
			return this.dom().removeAttribute(name);
		};
		
		/*
			returns the value of an attribute on the tag.
			If the given attribute does not exist, the value returned
			will either be null or "" (the empty string)
			*/
		
		Imba.Tag.prototype.getAttribute = function (name){
			return this.dom().getAttribute(name);
		};
		
		/*
			Override this to provide special wrapping etc.
			@return {self}
			*/
		
		Imba.Tag.prototype.setContent = function (content,type){
			this.setChildren(content,type);
			return this;
		};
		
		/*
			Set the children of node. type param is optional,
			and should only be used by Imba when compiling tag trees. 
			@return {self}
			*/
		
		Imba.Tag.prototype.setChildren = function (nodes,type){
			throw "Not implemented";
		};
		
		/*
			Get text of node. Uses textContent behind the scenes (not innerText)
			[https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent]()
			@return {string} inner text of node
			*/
		
		Imba.Tag.prototype.text = function (v){
			return this._dom.textContent;
		};
		
		/*
			Set text of node. Uses textContent behind the scenes (not innerText)
			[https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent]()
			*/
		
		Imba.Tag.prototype.setText = function (txt){
			this._empty = false;
			this._dom.textContent = txt == null ? (txt = "") : (txt);
			return this;
		};
		
		
		/*
			Method for getting and setting data-attributes. When called with zero
			arguments it will return the actual dataset for the tag.
		
				var node = <div data-name='hello'>
				# get the whole dataset
				node.dataset # {name: 'hello'}
				# get a single value
				node.dataset('name') # 'hello'
				# set a single value
				node.dataset('name','newname') # self
		
		
			*/
		
		Imba.Tag.prototype.dataset = function (key,val){
			throw "Not implemented";
		};
		
		/*
			Empty placeholder. Override to implement custom render behaviour.
			Works much like the familiar render-method in React.
			@return {self}
			*/
		
		Imba.Tag.prototype.render = function (){
			return this;
		};
		
		/*
			Called implicitly through Imba.Tag#end, upon creating a tag. All
			properties will have been set before build is called, including
			setContent.
			@return {self}
			*/
		
		Imba.Tag.prototype.build = function (){
			this.render();
			return this;
		};
		
		/*
			Called implicitly through Imba.Tag#end, for tags that are part of
			a tag tree (that are rendered several times).
			@return {self}
			*/
		
		Imba.Tag.prototype.commit = function (){
			this.render();
			return this;
		};
		
		/*
		
			Called by the tag-scheduler (if this tag is scheduled)
			By default it will call this.render. Do not override unless
			you really understand it.
		
			*/
		
		Imba.Tag.prototype.tick = function (){
			this.render();
			return this;
		};
		
		/*
			
			A very important method that you will practically never manually.
			The tag syntax of Imba compiles to a chain of setters, which always
			ends with .end. `<a.large>` compiles to `tag('a').flag('large').end()`
			
			You are highly adviced to not override its behaviour. The first time
			end is called it will mark the tag as built and call Imba.Tag#build,
			and call Imba.Tag#commit on subsequent calls.
			@return {self}
			*/
		
		Imba.Tag.prototype.end = function (){
			if (this._built) {
				this.commit();
			} else {
				this._built = true;
				this.build();
			};
			return this;
		};
		
		/*
			This is called instead of Imba.Tag#end for `<self>` tag chains.
			Defaults to noop
			@return {self}
			*/
		
		Imba.Tag.prototype.synced = function (){
			return this;
		};
		
		// called when the node is awakened in the dom - either automatically
		// upon attachment to the dom-tree, or the first time imba needs the
		// tag for a domnode that has been rendered on the server
		Imba.Tag.prototype.awaken = function (){
			return this;
		};
		
		/*
			List of flags for this node. 
			*/
		
		Imba.Tag.prototype.flags = function (){
			return this._dom.classList;
		};
		
		/*
			Add speficied flag to current node.
			If a second argument is supplied, it will be coerced into a Boolean,
			and used to indicate whether we should remove the flag instead.
			@return {self}
			*/
		
		Imba.Tag.prototype.flag = function (name,toggler){
			// it is most natural to treat a second undefined argument as a no-switch
			// so we need to check the arguments-length
			if (arguments.length == 2 && !toggler) {
				this._dom.classList.remove(name);
			} else {
				this._dom.classList.add(name);
			};
			return this;
		};
		
		/*
			Remove specified flag from node
			@return {self}
			*/
		
		Imba.Tag.prototype.unflag = function (name){
			this._dom.classList.remove(name);
			return this;
		};
		
		/*
			Toggle specified flag on node
			@return {self}
			*/
		
		Imba.Tag.prototype.toggleFlag = function (name){
			this._dom.classList.toggle(name);
			return this;
		};
		
		/*
			Check whether current node has specified flag
			@return {bool}
			*/
		
		Imba.Tag.prototype.hasFlag = function (name){
			return this._dom.classList.contains(name);
		};
		
		/*
			Get the scheduler for this node. A new scheduler will be created
			if it does not already exist.
		
			@return {Imba.Scheduler}
			*/
		
		Imba.Tag.prototype.scheduler = function (){
			return this._scheduler == null ? (this._scheduler = new Imba.Scheduler(this)) : (this._scheduler);
		};
		
		/*
		
			Shorthand to start scheduling a node. The method will basically
			proxy the arguments through to scheduler.configure, and then
			activate the scheduler.
			
			@return {self}
			*/
		
		Imba.Tag.prototype.schedule = function (options){
			if(options === undefined) options = {};
			this.scheduler().configure(options).activate();
			return this;
		};
		
		/*
			Shorthand for deactivating scheduler (if tag has one).
			@deprecated
			*/
		
		Imba.Tag.prototype.unschedule = function (){
			if (this._scheduler) { this.scheduler().deactivate() };
			return this;
		};
		
		
		/*
			Get the parent of current node
			@return {Imba.Tag} 
			*/
		
		Imba.Tag.prototype.parent = function (){
			return tag$wrap(this.dom().parentNode);
		};
		
		/*
			Shorthand for console.log on elements
			@return {self}
			*/
		
		Imba.Tag.prototype.log = function (){
			var $0 = arguments, i = $0.length;
			var args = new Array(i>0 ? i : 0);
			while(i>0) args[i-1] = $0[--i];
			args.unshift(console);
			Function.prototype.call.apply(console.log,args);
			return this;
		};
		
		
		Imba.Tag.prototype.initialize = Imba.Tag;
		
		HTML_TAGS = "a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr".split(" ");
		HTML_TAGS_UNSAFE = "article aside header section".split(" ");
		SVG_TAGS = "circle defs ellipse g line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan".split(" ");
		
		
		function extender(obj,sup){
			for (var i = 0, keys = Object.keys(sup), l = keys.length; i < l; i++){
				obj[($1 = keys[i])] == null ? (obj[$1] = sup[keys[i]]) : (obj[$1]);
			};
			
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
			if (sup.inherit) { sup.inherit(obj) };
			return obj;
		};
		
		function Tag(){
			return function(dom) {
				this.setDom(dom);
				return this;
			};
		};
		
		function TagSpawner(type){
			return function() { return type.build(); };
		};
		
		Imba.Tags = function Tags(){
			this;
		};
		
		Imba.Tags.prototype.__clone = function (ns){
			var clone = Object.create(this);
			clone._parent = this;
			return clone;
		};
		
		Imba.Tags.prototype.defineNamespace = function (name){
			var clone = Object.create(this);
			clone._parent = this;
			clone._ns = name;
			this[name.toUpperCase()] = clone;
			return clone;
		};
		
		Imba.Tags.prototype.baseType = function (name){
			return idx$(name,HTML_TAGS) >= 0 ? ('htmlelement') : ('div');
		};
		
		Imba.Tags.prototype.defineTag = function (name,supr,body){
			if(body==undefined && typeof supr == 'function') body = supr,supr = '';
			if(supr==undefined) supr = '';
			supr || (supr = this.baseType(name));
			var supertype = this[supr];
			var tagtype = Tag();
			var norm = name.replace(/\-/g,'_');
			
			
			tagtype._name = name;
			extender(tagtype,supertype);
			
			if (name[0] == '#') {
				this[name] = tagtype;
				Imba.SINGLETONS[name.slice(1)] = tagtype;
			} else {
				this[name] = tagtype;
				this['$' + norm] = TagSpawner(tagtype);
			};
			
			if (body) {
				if (body.length == 2) {
					// create clone
					if (!tagtype.hasOwnProperty('TAGS')) {
						tagtype.TAGS = (supertype.TAGS || this).__clone();
					};
				};
				
				body.call(tagtype,tagtype,tagtype.TAGS || this);
			};
			
			return tagtype;
		};
		
		Imba.Tags.prototype.defineSingleton = function (name,supr,body){
			return this.defineTag(name,supr,body);
		};
		
		Imba.Tags.prototype.extendTag = function (name,supr,body){
			if(body==undefined && typeof supr == 'function') body = supr,supr = '';
			if(supr==undefined) supr = '';
			var klass = ((typeof name=='string'||name instanceof String) ? (this[name]) : (name));
			// allow for private tags here as well?
			if (body) { body && body.call(klass,klass,klass.prototype) };
			return klass;
		};
		
		
		Imba.TAGS = new Imba.Tags();
		Imba.TAGS.element = Imba.Tag;
		
		var svg = Imba.TAGS.defineNamespace('svg');
		
		svg.baseType = function (name){
			return 'svgelement';
		};
		
		
		Imba.SINGLETONS = {};
		
		
		Imba.defineTag = function (name,supr,body){
			if(body==undefined && typeof supr == 'function') body = supr,supr = '';
			if(supr==undefined) supr = '';
			return Imba.TAGS.defineTag(name,supr,body);
		};
		
		Imba.defineSingletonTag = function (id,supr,body){
			if(body==undefined && typeof supr == 'function') body = supr,supr = 'div';
			if(supr==undefined) supr = 'div';
			return Imba.TAGS.defineTag(this.name(),supr,body);
		};
		
		Imba.extendTag = function (name,body){
			return Imba.TAGS.extendTag(name,body);
		};
		
		Imba.tag = function (name){
			var typ = Imba.TAGS[name];
			if (!typ) { throw new Error(("tag " + name + " is not defined")) };
			return new typ(typ.createNode());
		};
		
		Imba.tagWithId = function (name,id){
			var typ = Imba.TAGS[name];
			if (!typ) { throw new Error(("tag " + name + " is not defined")) };
			var dom = typ.createNode();
			dom.id = id;
			return new typ(dom);
		};
		
		// TODO: Can we move these out and into dom.imba in a clean way?
		// These methods depends on Imba.document.getElementById
		
		Imba.getTagSingleton = function (id){
			var klass;
			var dom,node;
			
			if (klass = Imba.SINGLETONS[id]) {
				if (klass && klass.Instance) { return klass.Instance };
				
				// no instance - check for element
				if (dom = Imba.document().getElementById(id)) {
					// we have a live instance - when finding it through a selector we should awake it, no?
					// console.log('creating the singleton from existing node in dom?',id,type)
					node = klass.Instance = new klass(dom);
					node.awaken(dom); // should only awaken
					return node;
				};
				
				dom = klass.createNode();
				dom.id = id;
				node = klass.Instance = new klass(dom);
				node.end().awaken(dom);
				return node;
			} else if (dom = Imba.document().getElementById(id)) {
				return Imba.getTagForDom(dom);
			};
		};
		
		var svgSupport = typeof SVGElement !== 'undefined';
		
		Imba.getTagForDom = function (dom){
			var m;
			if (!dom) { return null };
			if (dom._dom) { return dom }; // could use inheritance instead
			if (dom._tag) { return dom._tag };
			if (!dom.nodeName) { return null };
			
			var ns = null;
			var id = dom.id;
			var type = dom.nodeName.toLowerCase();
			var tags = Imba.TAGS;
			var native$ = type;
			var cls = dom.className;
			
			if (id && Imba.SINGLETONS[id]) {
				// FIXME control that it is the same singleton?
				// might collide -- not good?
				return Imba.getTagSingleton(id);
			};
			// look for id - singleton
			
			// need better test here
			if (svgSupport && (dom instanceof SVGElement)) {
				ns = "svg";
				cls = dom.className.baseVal;
				tags = tags.SVG;
			};
			
			var spawner;
			
			if (cls) {
				// there can be several matches here - should choose the last
				// should fall back to less specific later? - otherwise things may fail
				// TODO rework this
				if (m = cls.match(/\b_([a-z\-]+)\b(?!\s*_[a-z\-]+)/)) {
					type = m[1]; // .replace(/-/g,'_')
				};
				
				if (m = cls.match(/\b([A-Z\-]+)_\b/)) {
					ns = m[1];
				};
			};
			
			
			spawner = tags[type] || tags[native$];
			return spawner ? (new spawner(dom).awaken(dom)) : (null);
		};
		
		tag$ = Imba.TAGS;
		t$ = Imba.tag;
		tc$ = Imba.tagWithFlags;
		ti$ = Imba.tagWithId;
		tic$ = Imba.tagWithIdAndFlags;
		id$ = Imba.getTagSingleton;
		return tag$wrap = Imba.getTagForDom;
		
	
	})()

/***/ },
/* 6 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		Imba.document = function (){
			return window.document;
		};
		
		/*
		Returns the body element wrapped in an Imba.Tag
		*/
		
		Imba.root = function (){
			return tag$wrap(Imba.document().body);
		};
		
		tag$.defineTag('htmlelement', 'element', function(tag){
			
			/*
				Called when a tag type is being subclassed.
				*/
			
			tag.inherit = function (child){
				child.prototype._empty = true;
				child._protoDom = null;
				
				if (this._nodeType) {
					child._nodeType = this._nodeType;
					
					var className = "_" + child._name.replace(/_/g,'-');
					if (child._name[0] != '#') { return child._classes = this._classes.concat(className) };
				} else {
					child._nodeType = child._name;
					return child._classes = [];
				};
			};
			
			tag.buildNode = function (){
				var dom = Imba.document().createElement(this._nodeType);
				var cls = this._classes.join(" ");
				if (cls) { dom.className = cls };
				return dom;
			};
			
			tag.createNode = function (){
				var proto = (this._protoDom || (this._protoDom = this.buildNode()));
				return proto.cloneNode(false);
			};
			
			tag.dom = function (){
				return this._protoDom || (this._protoDom = this.buildNode());
			};
			
			
			
			tag.prototype.id = function(v){ return this.getAttribute('id'); }
			tag.prototype.setId = function(v){ this.setAttribute('id',v); return this; };
			
			
			tag.prototype.tabindex = function(v){ return this.getAttribute('tabindex'); }
			tag.prototype.setTabindex = function(v){ this.setAttribute('tabindex',v); return this; };
			
			
			tag.prototype.title = function(v){ return this.getAttribute('title'); }
			tag.prototype.setTitle = function(v){ this.setAttribute('title',v); return this; };
			
			
			tag.prototype.role = function(v){ return this.getAttribute('role'); }
			tag.prototype.setRole = function(v){ this.setAttribute('role',v); return this; };
			
			tag.prototype.width = function (){
				return this._dom.offsetWidth;
			};
			
			tag.prototype.height = function (){
				return this._dom.offsetHeight;
			};
			
			tag.prototype.setChildren = function (nodes,type){
				this._empty ? (this.append(nodes)) : (this.empty().append(nodes));
				this._children = null;
				return this;
			};
			
			/*
				Set inner html of node
				*/
			
			tag.prototype.setHtml = function (html){
				this._dom.innerHTML = html;
				return this;
			};
			
			/*
				Get inner html of node
				*/
			
			tag.prototype.html = function (){
				return this._dom.innerHTML;
			};
			
			/*
				Remove all content inside node
				*/
			
			tag.prototype.empty = function (){
				while (this._dom.firstChild){
					this._dom.removeChild(this._dom.firstChild);
				};
				this._children = null;
				this._empty = true;
				return this;
			};
			
			/*
				Remove specified child from current node.
				*/
			
			tag.prototype.remove = function (child){
				var par = this.dom();
				var el = child && child.dom();
				if (el && el.parentNode == par) { par.removeChild(el) };
				return this;
			};
			
			tag.prototype.emit = function (name,pars){
				if(!pars||pars.constructor !== Object) pars = {};
				var data = pars.data !== undefined ? pars.data : null;
				var bubble = pars.bubble !== undefined ? pars.bubble : true;
				Imba.Events.trigger(name,this,{data: data,bubble: bubble});
				return this;
			};
			
			tag.prototype.css = function (key,val){
				if (key instanceof Object) {
					for (var i = 0, keys = Object.keys(key), l = keys.length; i < l; i++){
						this.css(keys[i],key[keys[i]]);
					};
				} else if (val == null) {
					this.dom().style.removeProperty(key);
				} else if (val == undefined) {
					return this.dom().style[key];
				} else {
					if ((typeof val=='number'||val instanceof Number) && key.match(/width|height|left|right|top|bottom/)) {
						val = val + "px";
					};
					this.dom().style[key] = val;
				};
				return this;
			};
			
			tag.prototype.dataset = function (key,val){
				if (key instanceof Object) {
					for (var i = 0, keys = Object.keys(key), l = keys.length; i < l; i++){
						this.dataset(keys[i],key[keys[i]]);
					};
					return this;
				};
				
				if (arguments.length == 2) {
					this.setAttribute(("data-" + key),val);
					return this;
				};
				
				if (key) {
					return this.getAttribute(("data-" + key));
				};
				
				var dataset = this.dom().dataset;
				
				if (!dataset) {
					dataset = {};
					for (var i1 = 0, ary = iter$(this.dom().attributes), len = ary.length, atr; i1 < len; i1++) {
						atr = ary[i1];
						if (atr.name.substr(0,5) == 'data-') {
							dataset[Imba.toCamelCase(atr.name.slice(5))] = atr.value;
						};
					};
				};
				
				return dataset;
			};
			
			/*
				Get descendants of current node, optionally matching selector
				@return {Imba.Selector}
				*/
			
			tag.prototype.find = function (sel){
				return new Imba.Selector(sel,this);
			};
			
			/*
				Get the first matching child of node
			
				@return {Imba.Tag}
				*/
			
			tag.prototype.first = function (sel){
				return sel ? (this.find(sel).first()) : (tag$wrap(this.dom().firstElementChild));
			};
			
			/*
				Get the last matching child of node
			
					node.last # returns the last child of node
					node.last %span # returns the last span inside node
					node.last do |el| el.text == 'Hi' # return last node with text Hi
			
				@return {Imba.Tag}
				*/
			
			tag.prototype.last = function (sel){
				return sel ? (this.find(sel).last()) : (tag$wrap(this.dom().lastElementChild));
			};
			
			/*
				Get the child at index
				*/
			
			tag.prototype.child = function (i){
				return tag$wrap(this.dom().children[i || 0]);
			};
			
			tag.prototype.children = function (sel){
				var nodes = new Imba.Selector(null,this,this._dom.children);
				return sel ? (nodes.filter(sel)) : (nodes);
			};
			
			tag.prototype.orphanize = function (){
				var par;
				if (par = this.dom().parentNode) { par.removeChild(this._dom) };
				return this;
			};
			
			tag.prototype.matches = function (sel){
				var fn;
				if (sel instanceof Function) {
					return sel(this);
				};
				
				if (sel.query) { sel = sel.query() };
				if (fn = (this._dom.webkitMatchesSelector || this._dom.matches)) { return fn.call(this._dom,sel) };
				// TODO support other browsers etc?
			};
			
			/*
				Get the first element matching supplied selector / filter
				traversing upwards, but including the node itself.
				@return {Imba.Tag}
				*/
			
			tag.prototype.closest = function (sel){
				if (!sel) { return this.parent() }; // should return self?!
				var node = this;
				if (sel.query) { sel = sel.query() };
				
				while (node){
					if (node.matches(sel)) { return node };
					node = node.parent();
				};
				return null;
			};
			
			/*
				Get the closest ancestor of node that matches
				specified selector / matcher.
			
				@return {Imba.Tag}
				*/
			
			tag.prototype.up = function (sel){
				if (!sel) { return this.parent() };
				return this.parent() && this.parent().closest(sel);
			};
			
			tag.prototype.path = function (sel){
				var node = this;
				var nodes = [];
				if (sel && sel.query) { sel = sel.query() };
				
				while (node){
					if (!sel || node.matches(sel)) { nodes.push(node) };
					node = node.parent();
				};
				return nodes;
			};
			
			tag.prototype.parents = function (sel){
				var par = this.parent();
				return par ? (par.path(sel)) : ([]);
			};
			
			
			
			tag.prototype.siblings = function (sel){
				var par, self = this;
				if (!(par = this.parent())) { return [] }; // FIXME
				var ary = this.dom().parentNode.children;
				var nodes = new Imba.Selector(null,this,ary);
				return nodes.filter(function(n) { return n != self && (!sel || n.matches(sel)); });
			};
			
			/*
				Get the immediately following sibling of node.
				*/
			
			tag.prototype.next = function (sel){
				if (sel) {
					var el = this;
					while (el = el.next()){
						if (el.matches(sel)) { return el };
					};
					return null;
				};
				return tag$wrap(this.dom().nextElementSibling);
			};
			
			/*
				Get the immediately preceeding sibling of node.
				*/
			
			tag.prototype.prev = function (sel){
				if (sel) {
					var el = this;
					while (el = el.prev()){
						if (el.matches(sel)) { return el };
					};
					return null;
				};
				return tag$wrap(this.dom().previousElementSibling);
			};
			
			tag.prototype.contains = function (node){
				return this.dom().contains(node && node._dom || node);
			};
			
			tag.prototype.index = function (){
				var i = 0;
				var el = this.dom();
				while (el.previousSibling){
					el = el.previousSibling;
					i++;
				};
				return i;
			};
			
			
			/*
				
				@deprecated
				*/
			
			tag.prototype.insert = function (node,pars){
				if(!pars||pars.constructor !== Object) pars = {};
				var before = pars.before !== undefined ? pars.before : null;
				var after = pars.after !== undefined ? pars.after : null;
				if (after) { before = after.next() };
				if (node instanceof Array) {
					node = (tag$.$fragment().setContent(node,0).end());
				};
				if (before) {
					this.dom().insertBefore(node.dom(),before.dom());
				} else {
					this.append(node);
				};
				return this;
			};
			
			/*
				Focus on current node
				@return {self}
				*/
			
			tag.prototype.focus = function (){
				this.dom().focus();
				return this;
			};
			
			/*
				Remove focus from current node
				@return {self}
				*/
			
			tag.prototype.blur = function (){
				this.dom().blur();
				return this;
			};
			
			tag.prototype.template = function (){
				return null;
			};
			
			/*
				@todo Should support multiple arguments like append
			
				The .prepend method inserts the specified content as the first
				child of the target node. If the content is already a child of 
				node it will be moved to the start.
				
			    	node.prepend <div.top> # prepend node
			    	node.prepend "some text" # prepend text
			    	node.prepend [<ul>,<ul>] # prepend array
			
				*/
			
			tag.prototype.prepend = function (item){
				var first = this._dom.childNodes[0];
				first ? (this.insertBefore(item,first)) : (this.appendChild(item));
				return this;
			};
			
			/*
				The .append method inserts the specified content as the last child
				of the target node. If the content is already a child of node it
				will be moved to the end.
				
				# example
				    var root = <div.root>
				    var item = <div.item> "This is an item"
				    root.append item # appends item to the end of root
			
				    root.prepend "some text" # append text
				    root.prepend [<ul>,<ul>] # append array
				*/
			
			tag.prototype.append = function (item){
				// possible to append blank
				// possible to simplify on server?
				if (!item) { return this };
				
				if (item instanceof Array) {
					for (var i = 0, ary = iter$(item), len = ary.length, member; i < len; i++) {
						member = ary[i];
						member && this.append(member);
					};
				} else if ((typeof item=='string'||item instanceof String) || (typeof item=='number'||item instanceof Number)) {
					var node = Imba.document().createTextNode(item);
					this._dom.appendChild(node);
					if (this._empty) { this._empty = false };
				} else {
					this._dom.appendChild(item._dom || item);
					if (this._empty) { this._empty = false };
				};
				
				return this;
			};
			
			/*
				Insert a node into the current node (self), before another.
				The relative node must be a child of current node. 
				*/
			
			tag.prototype.insertBefore = function (node,rel){
				if ((typeof node=='string'||node instanceof String)) { node = Imba.document().createTextNode(node) };
				if (node && rel) { this.dom().insertBefore((node._dom || node),(rel._dom || rel)) };
				return this;
			};
			
			/*
				Append a single item (node or string) to the current node.
				If supplied item is a string it will automatically. This is used
				by Imba internally, but will practically never be used explicitly.
				*/
			
			tag.prototype.appendChild = function (node){
				if ((typeof node=='string'||node instanceof String)) { node = Imba.document().createTextNode(node) };
				if (node) { this.dom().appendChild(node._dom || node) };
				return this;
			};
			
			/*
				Remove a single child from the current node.
				Used by Imba internally.
				*/
			
			tag.prototype.removeChild = function (node){
				if (node) { this.dom().removeChild(node._dom || node) };
				return this;
			};
			
			tag.prototype.toString = function (){
				return this._dom.toString(); // really?
			};
			
			/*
				@deprecated
				*/
			
			tag.prototype.classes = function (){
				console.log('Imba.Tag#classes is deprecated');
				return this._dom.classList;
			};
		});
		
		return tag$.defineTag('svgelement', 'htmlelement');
	
	})()

/***/ },
/* 7 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// Extending Imba.Tag#css to work without prefixes by inspecting
		// the properties of a CSSStyleDeclaration and creating a map
		
		// var prefixes = ['-webkit-','-ms-','-moz-','-o-','-blink-']
		// var props = ['transform','transition','animation']
		
		var styles = window.getComputedStyle(document.documentElement,'');
		
		Imba.CSSKeyMap = {};
		
		for (var i = 0, ary = iter$(styles), len = ary.length, prefixed; i < len; i++) {
			prefixed = ary[i];
			var unprefixed = prefixed.replace(/^-(webkit|ms|moz|o|blink)-/,'');
			var camelCase = unprefixed.replace(/-(\w)/g,function(m,a) { return a.toUpperCase(); });
			
			// if there exists an unprefixed version -- always use this
			if (prefixed != unprefixed) {
				if (styles.hasOwnProperty(unprefixed)) { continue; };
			};
			
			// register the prefixes
			Imba.CSSKeyMap[unprefixed] = Imba.CSSKeyMap[camelCase] = prefixed;
		};
		
		return tag$.extendTag('htmlelement', function(tag){
			
			// override the original css method
			tag.prototype.css = function (key,val){
				if (key instanceof Object) {
					for (var i = 0, keys = Object.keys(key), l = keys.length; i < l; i++){
						this.css(keys[i],key[keys[i]]);
					};
					return this;
				};
				
				key = Imba.CSSKeyMap[key] || key;
				
				if (val == null) {
					this.dom().style.removeProperty(key);
				} else if (val == undefined) {
					return this.dom().style[key];
				} else {
					if ((typeof val=='number'||val instanceof Number) && key.match(/width|height|left|right|top|bottom/)) {
						val = val + "px";
					};
					this.dom().style[key] = val;
				};
				return this;
			};
		});
	
	})()

/***/ },
/* 8 */
/***/ function(module, exports) {

	(function(){
		
		// predefine all supported html tags
		tag$.defineTag('fragment', 'htmlelement', function(tag){
			
			tag.createNode = function (){
				return Imba.document().createDocumentFragment();
			};
		});
		
		tag$.defineTag('a', function(tag){
			
			
			tag.prototype.href = function(v){ return this.getAttribute('href'); }
			tag.prototype.setHref = function(v){ this.setAttribute('href',v); return this; };
		});
		
		tag$.defineTag('abbr');
		tag$.defineTag('address');
		tag$.defineTag('area');
		tag$.defineTag('article');
		tag$.defineTag('aside');
		tag$.defineTag('audio');
		tag$.defineTag('b');
		tag$.defineTag('base');
		tag$.defineTag('bdi');
		tag$.defineTag('bdo');
		tag$.defineTag('big');
		tag$.defineTag('blockquote');
		tag$.defineTag('body');
		tag$.defineTag('br');
		
		tag$.defineTag('button', function(tag){
			
			
			tag.prototype.autofocus = function(v){ return this.getAttribute('autofocus'); }
			tag.prototype.setAutofocus = function(v){ this.setAttribute('autofocus',v); return this; };
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
			
			
			tag.prototype.disabled = function(v){ return this.getAttribute('disabled'); }
			tag.prototype.setDisabled = function(v){ this.setAttribute('disabled',v); return this; };
		});
		
		tag$.defineTag('canvas', function(tag){
			tag.prototype.setWidth = function (val){
				if (this.width() != val) { this.dom().width = val };
				return this;
			};
			
			tag.prototype.setHeight = function (val){
				if (this.height() != val) { this.dom().height = val };
				return this;
			};
			
			tag.prototype.width = function (){
				return this.dom().width;
			};
			
			tag.prototype.height = function (){
				return this.dom().height;
			};
			
			tag.prototype.context = function (type){
				if(type === undefined) type = '2d';
				return this.dom().getContext(type);
			};
		});
		
		tag$.defineTag('caption');
		tag$.defineTag('cite');
		tag$.defineTag('code');
		tag$.defineTag('col');
		tag$.defineTag('colgroup');
		tag$.defineTag('data');
		tag$.defineTag('datalist');
		tag$.defineTag('dd');
		tag$.defineTag('del');
		tag$.defineTag('details');
		tag$.defineTag('dfn');
		tag$.defineTag('div');
		tag$.defineTag('dl');
		tag$.defineTag('dt');
		tag$.defineTag('em');
		tag$.defineTag('embed');
		tag$.defineTag('fieldset');
		tag$.defineTag('figcaption');
		tag$.defineTag('figure');
		tag$.defineTag('footer');
		
		tag$.defineTag('form', function(tag){
			
			
			tag.prototype.method = function(v){ return this.getAttribute('method'); }
			tag.prototype.setMethod = function(v){ this.setAttribute('method',v); return this; };
			
			
			tag.prototype.action = function(v){ return this.getAttribute('action'); }
			tag.prototype.setAction = function(v){ this.setAttribute('action',v); return this; };
		});
		
		tag$.defineTag('h1');
		tag$.defineTag('h2');
		tag$.defineTag('h3');
		tag$.defineTag('h4');
		tag$.defineTag('h5');
		tag$.defineTag('h6');
		tag$.defineTag('head');
		tag$.defineTag('header');
		tag$.defineTag('hr');
		tag$.defineTag('html');
		tag$.defineTag('i');
		
		tag$.defineTag('iframe', function(tag){
			
			
			tag.prototype.src = function(v){ return this.getAttribute('src'); }
			tag.prototype.setSrc = function(v){ this.setAttribute('src',v); return this; };
		});
		
		tag$.defineTag('img', function(tag){
			
			
			tag.prototype.src = function(v){ return this.getAttribute('src'); }
			tag.prototype.setSrc = function(v){ this.setAttribute('src',v); return this; };
		});
		
		tag$.defineTag('input', function(tag){
			// can use attr instead
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
			
			
			tag.prototype.required = function(v){ return this.getAttribute('required'); }
			tag.prototype.setRequired = function(v){ this.setAttribute('required',v); return this; };
			
			
			tag.prototype.disabled = function(v){ return this.getAttribute('disabled'); }
			tag.prototype.setDisabled = function(v){ this.setAttribute('disabled',v); return this; };
			
			
			tag.prototype.autofocus = function(v){ return this.getAttribute('autofocus'); }
			tag.prototype.setAutofocus = function(v){ this.setAttribute('autofocus',v); return this; };
			
			tag.prototype.value = function (){
				return this.dom().value;
			};
			
			tag.prototype.setValue = function (v){
				if (v != this.dom().value) { this.dom().value = v };
				return this;
			};
			
			tag.prototype.setPlaceholder = function (v){
				if (v != this.dom().placeholder) { this.dom().placeholder = v };
				return this;
			};
			
			tag.prototype.placeholder = function (){
				return this.dom().placeholder;
			};
			
			tag.prototype.checked = function (){
				return this.dom().checked;
			};
			
			tag.prototype.setChecked = function (bool){
				if (bool != this.dom().checked) { this.dom().checked = bool };
				return this;
			};
		});
		
		tag$.defineTag('ins');
		tag$.defineTag('kbd');
		tag$.defineTag('keygen');
		tag$.defineTag('label');
		tag$.defineTag('legend');
		tag$.defineTag('li');
		
		tag$.defineTag('link', function(tag){
			
			
			tag.prototype.rel = function(v){ return this.getAttribute('rel'); }
			tag.prototype.setRel = function(v){ this.setAttribute('rel',v); return this; };
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
			
			
			tag.prototype.href = function(v){ return this.getAttribute('href'); }
			tag.prototype.setHref = function(v){ this.setAttribute('href',v); return this; };
			
			
			tag.prototype.media = function(v){ return this.getAttribute('media'); }
			tag.prototype.setMedia = function(v){ this.setAttribute('media',v); return this; };
		});
		
		tag$.defineTag('main');
		tag$.defineTag('map');
		tag$.defineTag('mark');
		tag$.defineTag('menu');
		tag$.defineTag('menuitem');
		
		tag$.defineTag('meta', function(tag){
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			
			tag.prototype.content = function(v){ return this.getAttribute('content'); }
			tag.prototype.setContent = function(v){ this.setAttribute('content',v); return this; };
			
			
			tag.prototype.charset = function(v){ return this.getAttribute('charset'); }
			tag.prototype.setCharset = function(v){ this.setAttribute('charset',v); return this; };
		});
		
		tag$.defineTag('meter');
		tag$.defineTag('nav');
		tag$.defineTag('noscript');
		tag$.defineTag('object');
		tag$.defineTag('ol');
		tag$.defineTag('optgroup');
		
		tag$.defineTag('option', function(tag){
			
			
			tag.prototype.value = function(v){ return this.getAttribute('value'); }
			tag.prototype.setValue = function(v){ this.setAttribute('value',v); return this; };
		});
		
		tag$.defineTag('output');
		tag$.defineTag('p');
		tag$.defineTag('param');
		tag$.defineTag('pre');
		tag$.defineTag('progress');
		tag$.defineTag('q');
		tag$.defineTag('rp');
		tag$.defineTag('rt');
		tag$.defineTag('ruby');
		tag$.defineTag('s');
		tag$.defineTag('samp');
		
		tag$.defineTag('script', function(tag){
			
			
			tag.prototype.src = function(v){ return this.getAttribute('src'); }
			tag.prototype.setSrc = function(v){ this.setAttribute('src',v); return this; };
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
		});
		
		tag$.defineTag('section');
		
		tag$.defineTag('select', function(tag){
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			
			tag.prototype.multiple = function(v){ return this.getAttribute('multiple'); }
			tag.prototype.setMultiple = function(v){ this.setAttribute('multiple',v); return this; };
			
			
			tag.prototype.required = function(v){ return this.getAttribute('required'); }
			tag.prototype.setRequired = function(v){ this.setAttribute('required',v); return this; };
			
			
			tag.prototype.disabled = function(v){ return this.getAttribute('disabled'); }
			tag.prototype.setDisabled = function(v){ this.setAttribute('disabled',v); return this; };
			
			tag.prototype.value = function (){
				return this.dom().value;
			};
			
			tag.prototype.setValue = function (v){
				if (v != this.dom().value) { this.dom().value = v };
				return this;
			};
		});
		
		
		tag$.defineTag('small');
		tag$.defineTag('source');
		tag$.defineTag('span');
		tag$.defineTag('strong');
		tag$.defineTag('style');
		tag$.defineTag('sub');
		tag$.defineTag('summary');
		tag$.defineTag('sup');
		tag$.defineTag('table');
		tag$.defineTag('tbody');
		tag$.defineTag('td');
		
		tag$.defineTag('textarea', function(tag){
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			
			tag.prototype.disabled = function(v){ return this.getAttribute('disabled'); }
			tag.prototype.setDisabled = function(v){ this.setAttribute('disabled',v); return this; };
			
			
			tag.prototype.required = function(v){ return this.getAttribute('required'); }
			tag.prototype.setRequired = function(v){ this.setAttribute('required',v); return this; };
			
			
			tag.prototype.rows = function(v){ return this.getAttribute('rows'); }
			tag.prototype.setRows = function(v){ this.setAttribute('rows',v); return this; };
			
			
			tag.prototype.cols = function(v){ return this.getAttribute('cols'); }
			tag.prototype.setCols = function(v){ this.setAttribute('cols',v); return this; };
			
			
			tag.prototype.autofocus = function(v){ return this.getAttribute('autofocus'); }
			tag.prototype.setAutofocus = function(v){ this.setAttribute('autofocus',v); return this; };
			
			tag.prototype.value = function (){
				return this.dom().value;
			};
			
			tag.prototype.setValue = function (v){
				if (v != this.dom().value) { this.dom().value = v };
				return this;
			};
			
			tag.prototype.setPlaceholder = function (v){
				if (v != this.dom().placeholder) { this.dom().placeholder = v };
				return this;
			};
			
			tag.prototype.placeholder = function (){
				return this.dom().placeholder;
			};
		});
		
		tag$.defineTag('tfoot');
		tag$.defineTag('th');
		tag$.defineTag('thead');
		tag$.defineTag('time');
		tag$.defineTag('title');
		tag$.defineTag('tr');
		tag$.defineTag('track');
		tag$.defineTag('u');
		tag$.defineTag('ul');
		tag$.defineTag('video');
		return tag$.defineTag('wbr');
	
	})()

/***/ },
/* 9 */
/***/ function(module, exports) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		
		tag$.SVG.defineTag('svgelement', function(tag){
			
			tag.namespaceURI = function (){
				return "http://www.w3.org/2000/svg";
			};
			
			var types = "circle defs ellipse g line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan".split(" ");
			
			tag.buildNode = function (){
				var dom = Imba.document().createElementNS(this.namespaceURI(),this._nodeType);
				var cls = this._classes.join(" ");
				if (cls) { dom.className.baseVal = cls };
				return dom;
			};
			
			tag.inherit = function (child){
				child._protoDom = null;
				
				if (idx$(child._name,types) >= 0) {
					child._nodeType = child._name;
					return child._classes = [];
				} else {
					child._nodeType = this._nodeType;
					var className = "_" + child._name.replace(/_/g,'-');
					return child._classes = this._classes.concat(className);
				};
			};
			
			
			Imba.attr(tag,'x');
			Imba.attr(tag,'y');
			
			Imba.attr(tag,'width');
			Imba.attr(tag,'height');
			
			Imba.attr(tag,'stroke');
			Imba.attr(tag,'stroke-width');
		});
		
		tag$.SVG.defineTag('svg', function(tag){
			Imba.attr(tag,'viewbox');
		});
		
		tag$.SVG.defineTag('rect');
		
		tag$.SVG.defineTag('circle', function(tag){
			Imba.attr(tag,'cx');
			Imba.attr(tag,'cy');
			Imba.attr(tag,'r');
		});
		
		tag$.SVG.defineTag('ellipse', function(tag){
			Imba.attr(tag,'cx');
			Imba.attr(tag,'cy');
			Imba.attr(tag,'rx');
			Imba.attr(tag,'ry');
		});
		
		tag$.SVG.defineTag('path', function(tag){
			Imba.attr(tag,'d');
			Imba.attr(tag,'pathLength');
		});
		
		return tag$.SVG.defineTag('line', function(tag){
			Imba.attr(tag,'x1');
			Imba.attr(tag,'x2');
			Imba.attr(tag,'y1');
			Imba.attr(tag,'y2');
		});
	
	})()

/***/ },
/* 10 */
/***/ function(module, exports) {

	(function(){
		if (!document.documentElement.classList) {
			tag$.extendTag('htmlelement', function(tag){
				
				tag.prototype.hasFlag = function (ref){
					return new RegExp('(^|\\s)' + ref + '(\\s|$)').test(this._dom.className);
				};
				
				tag.prototype.addFlag = function (ref){
					if (this.hasFlag(ref)) { return this };
					this._dom.className += (this._dom.className ? (' ') : ('')) + ref;
					return this;
				};
				
				tag.prototype.unflag = function (ref){
					if (!this.hasFlag(ref)) { return this };
					var regex = new RegExp('(^|\\s)*' + ref + '(\\s|$)*','g');
					this._dom.className = this._dom.className.replace(regex,'');
					return this;
				};
				
				tag.prototype.toggleFlag = function (ref){
					return this.hasFlag(ref) ? (this.unflag(ref)) : (this.flag(ref));
				};
				
				tag.prototype.flag = function (ref,bool){
					if (arguments.length == 2 && !!bool === false) {
						return this.unflag(ref);
					};
					return this.addFlag(ref);
				};
			});
			
			return true;
		};
	
	})()

/***/ },
/* 11 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var doc = document;
		var win = window;
		
		var hasTouchEvents = window && window.ontouchstart !== undefined;
		
		Imba.Pointer = function Pointer(){
			this.setButton(-1);
			this.setEvent({x: 0,y: 0,type: 'uninitialized'});
			return this;
		};
		
		
		
		Imba.Pointer.prototype.phase = function(v){ return this._phase; }
		Imba.Pointer.prototype.setPhase = function(v){ this._phase = v; return this; };
		
		
		Imba.Pointer.prototype.prevEvent = function(v){ return this._prevEvent; }
		Imba.Pointer.prototype.setPrevEvent = function(v){ this._prevEvent = v; return this; };
		
		
		Imba.Pointer.prototype.button = function(v){ return this._button; }
		Imba.Pointer.prototype.setButton = function(v){ this._button = v; return this; };
		
		
		Imba.Pointer.prototype.event = function(v){ return this._event; }
		Imba.Pointer.prototype.setEvent = function(v){ this._event = v; return this; };
		
		
		Imba.Pointer.prototype.dirty = function(v){ return this._dirty; }
		Imba.Pointer.prototype.setDirty = function(v){ this._dirty = v; return this; };
		
		
		Imba.Pointer.prototype.events = function(v){ return this._events; }
		Imba.Pointer.prototype.setEvents = function(v){ this._events = v; return this; };
		
		
		Imba.Pointer.prototype.touch = function(v){ return this._touch; }
		Imba.Pointer.prototype.setTouch = function(v){ this._touch = v; return this; };
		
		Imba.Pointer.prototype.update = function (e){
			this.setEvent(e);
			this.setDirty(true);
			return this;
		};
		
		// this is just for regular mouse now
		Imba.Pointer.prototype.process = function (){
			var e1 = this.event();
			
			if (this.dirty()) {
				this.setPrevEvent(e1);
				this.setDirty(false);
				
				// button should only change on mousedown etc
				if (e1.type == 'mousedown') {
					this.setButton(e1.button);
					
					// do not create touch for right click
					if (this.button() == 2 || (this.touch() && this.button() != 0)) {
						return;
					};
					
					// cancel the previous touch
					if (this.touch()) { this.touch().cancel() };
					this.setTouch(new Imba.Touch(e1,this));
					this.touch().mousedown(e1,e1);
				} else if (e1.type == 'mousemove') {
					if (this.touch()) { this.touch().mousemove(e1,e1) };
				} else if (e1.type == 'mouseup') {
					this.setButton(-1);
					
					if (this.touch() && this.touch().button() == e1.button) {
						this.touch().mouseup(e1,e1);
						this.setTouch(null);
					};
					// trigger pointerup
				};
			} else {
				if (this.touch()) { this.touch().idle() };
			};
			return this;
		};
		
		Imba.Pointer.prototype.cleanup = function (){
			return Imba.POINTERS;
		};
		
		Imba.Pointer.prototype.x = function (){
			return this.event().x;
		};
		Imba.Pointer.prototype.y = function (){
			return this.event().y;
		};
		
		// deprecated -- should remove
		Imba.Pointer.update = function (){
			// console.log('update touch')
			for (var i = 0, ary = iter$(Imba.POINTERS), len = ary.length; i < len; i++) {
				ary[i].process();
			};
			// need to be able to prevent the default behaviour of touch, no?
			win.requestAnimationFrame(Imba.Pointer.update);
			return this;
		};
		
		var lastNativeTouchTimeStamp = 0;
		var lastNativeTouchTimeout = 50;
		
		// Imba.Touch
		// Began	A finger touched the screen.
		// Moved	A finger moved on the screen.
		// Stationary	A finger is touching the screen but hasn't moved.
		// Ended	A finger was lifted from the screen. This is the final phase of a touch.
		// Canceled The system cancelled tracking for the touch.
		
		/*
		Consolidates mouse and touch events. Touch objects persist across a touch,
		from touchstart until end/cancel. When a touch starts, it will traverse
		down from the innermost target, until it finds a node that responds to
		ontouchstart. Unless the touch is explicitly redirected, the touch will
		call ontouchmove and ontouchend / ontouchcancel on the responder when appropriate.
		
			tag draggable
				# called when a touch starts
				def ontouchstart touch
					flag 'dragging'
					self
				
				# called when touch moves - same touch object
				def ontouchmove touch
					# move the node with touch
					css top: touch.dy, left: touch.dx
				
				# called when touch ends
				def ontouchend touch
					unflag 'dragging'
		
		@iname touch
		*/
		
		Imba.Touch = function Touch(event,pointer){
			// @native  = false
			this.setEvent(event);
			this.setData({});
			this.setActive(true);
			this._button = event && event.button || 0;
			this._suppress = false; // deprecated
			this._captured = false;
			this.setBubble(false);
			pointer = pointer;
			this.setUpdates(0);
			return this;
		};
		
		var touches = [];
		var count = 0;
		var identifiers = {};
		
		Imba.Touch.count = function (){
			return count;
		};
		
		Imba.Touch.lookup = function (item){
			return item && (item.__touch__ || identifiers[item.identifier]);
		};
		
		Imba.Touch.release = function (item,touch){
			var v_, $1;
			(((v_ = identifiers[item.identifier]),delete identifiers[item.identifier], v_));
			((($1 = item.__touch__),delete item.__touch__, $1));
			return;
		};
		
		Imba.Touch.ontouchstart = function (e){
			for (var i = 0, ary = iter$(e.changedTouches), len = ary.length, t; i < len; i++) {
				t = ary[i];
				if (this.lookup(t)) { continue; };
				var touch = identifiers[t.identifier] = new this(e); // (e)
				t.__touch__ = touch;
				touches.push(touch);
				count++;
				touch.touchstart(e,t);
			};
			return this;
		};
		
		Imba.Touch.ontouchmove = function (e){
			var touch;
			for (var i = 0, ary = iter$(e.changedTouches), len = ary.length, t; i < len; i++) {
				t = ary[i];
				if (touch = this.lookup(t)) {
					touch.touchmove(e,t);
				};
			};
			
			return this;
		};
		
		Imba.Touch.ontouchend = function (e){
			var touch;
			for (var i = 0, ary = iter$(e.changedTouches), len = ary.length, t; i < len; i++) {
				t = ary[i];
				if (touch = this.lookup(t)) {
					touch.touchend(e,t);
					this.release(t,touch);
					count--;
				};
			};
			
			// e.preventDefault
			// not always supported!
			// touches = touches.filter(||)
			return this;
		};
		
		Imba.Touch.ontouchcancel = function (e){
			var touch;
			for (var i = 0, ary = iter$(e.changedTouches), len = ary.length, t; i < len; i++) {
				t = ary[i];
				if (touch = this.lookup(t)) {
					touch.touchcancel(e,t);
					this.release(t,touch);
					count--;
				};
			};
			return this;
		};
		
		Imba.Touch.onmousedown = function (e){
			return this;
		};
		
		Imba.Touch.onmousemove = function (e){
			return this;
		};
		
		Imba.Touch.onmouseup = function (e){
			return this;
		};
		
		
		
		
		Imba.Touch.prototype.phase = function(v){ return this._phase; }
		Imba.Touch.prototype.setPhase = function(v){ this._phase = v; return this; };
		
		
		Imba.Touch.prototype.active = function(v){ return this._active; }
		Imba.Touch.prototype.setActive = function(v){ this._active = v; return this; };
		
		
		Imba.Touch.prototype.event = function(v){ return this._event; }
		Imba.Touch.prototype.setEvent = function(v){ this._event = v; return this; };
		
		
		Imba.Touch.prototype.pointer = function(v){ return this._pointer; }
		Imba.Touch.prototype.setPointer = function(v){ this._pointer = v; return this; };
		
		
		Imba.Touch.prototype.target = function(v){ return this._target; }
		Imba.Touch.prototype.setTarget = function(v){ this._target = v; return this; };
		
		
		Imba.Touch.prototype.handler = function(v){ return this._handler; }
		Imba.Touch.prototype.setHandler = function(v){ this._handler = v; return this; };
		
		
		Imba.Touch.prototype.updates = function(v){ return this._updates; }
		Imba.Touch.prototype.setUpdates = function(v){ this._updates = v; return this; };
		
		
		Imba.Touch.prototype.suppress = function(v){ return this._suppress; }
		Imba.Touch.prototype.setSuppress = function(v){ this._suppress = v; return this; };
		
		
		Imba.Touch.prototype.data = function(v){ return this._data; }
		Imba.Touch.prototype.setData = function(v){ this._data = v; return this; };
		
		Imba.Touch.prototype.__bubble = {chainable: true,name: 'bubble'};
		Imba.Touch.prototype.bubble = function(v){ return v !== undefined ? (this.setBubble(v),this) : this._bubble; }
		Imba.Touch.prototype.setBubble = function(v){ this._bubble = v; return this; };
		
		
		
		Imba.Touch.prototype.gestures = function(v){ return this._gestures; }
		Imba.Touch.prototype.setGestures = function(v){ this._gestures = v; return this; };
		
		/*
			
		
			@internal
			@constructor
			*/
		
		Imba.Touch.prototype.capture = function (){
			this._captured = true;
			this._event && this._event.preventDefault();
			return this;
		};
		
		Imba.Touch.prototype.isCaptured = function (){
			return !!this._captured;
		};
		
		/*
			Extend the touch with a plugin / gesture. 
			All events (touchstart,move etc) for the touch
			will be triggered on the plugins in the order they
			are added.
			*/
		
		Imba.Touch.prototype.extend = function (plugin){
			// console.log "added gesture!!!"
			this._gestures || (this._gestures = []);
			this._gestures.push(plugin);
			return this;
		};
		
		/*
			Redirect touch to specified target. ontouchstart will always be
			called on the new target.
			@return {Number}
			*/
		
		Imba.Touch.prototype.redirect = function (target){
			this._redirect = target;
			return this;
		};
		
		/*
			Suppress the default behaviour. Will call preventDefault for
			all native events that are part of the touch.
			*/
		
		Imba.Touch.prototype.suppress = function (){
			// collision with the suppress property
			this._active = false;
			return this;
		};
		
		Imba.Touch.prototype.setSuppress = function (value){
			console.warn('Imba.Touch#suppress= is deprecated');
			this._supress = value;
			return this;
		};
		
		Imba.Touch.prototype.touchstart = function (e,t){
			this._event = e;
			this._touch = t;
			this._button = 0;
			this._x = t.clientX;
			this._y = t.clientY;
			this.began();
			if (e && this.isCaptured()) { e.preventDefault() };
			return this;
		};
		
		Imba.Touch.prototype.touchmove = function (e,t){
			this._event = e;
			this._x = t.clientX;
			this._y = t.clientY;
			this.update();
			if (e && this.isCaptured()) { e.preventDefault() };
			return this;
		};
		
		Imba.Touch.prototype.touchend = function (e,t){
			this._event = e;
			this._x = t.clientX;
			this._y = t.clientY;
			this.ended();
			
			lastNativeTouchTimeStamp = e.timeStamp;
			
			if (this._maxdr < 20) {
				var tap = new Imba.Event(e);
				tap.setType('tap');
				tap.process();
				if (tap._responder) { e.preventDefault() };
			};
			
			if (e && this.isCaptured()) {
				e.preventDefault();
			};
			
			return this;
		};
		
		Imba.Touch.prototype.touchcancel = function (e,t){
			return this.cancel();
		};
		
		Imba.Touch.prototype.mousedown = function (e,t){
			var self = this;
			self._event = e;
			self._button = e.button;
			self._x = t.clientX;
			self._y = t.clientY;
			self.began();
			
			self._mousemove = function(e) { return self.mousemove(e,e); };
			doc.addEventListener('mousemove',self._mousemove,true);
			return self;
		};
		
		Imba.Touch.prototype.mousemove = function (e,t){
			this._x = t.clientX;
			this._y = t.clientY;
			this._event = e;
			if (this.isCaptured()) { e.preventDefault() };
			this.update();
			this.move();
			return this;
		};
		
		Imba.Touch.prototype.mouseup = function (e,t){
			this._x = t.clientX;
			this._y = t.clientY;
			this.ended();
			doc.removeEventListener('mousemove',this._mousemove,true);
			this._mousemove = null;
			return this;
		};
		
		Imba.Touch.prototype.idle = function (){
			return this.update();
		};
		
		Imba.Touch.prototype.began = function (){
			this._maxdr = this._dr = 0;
			this._x0 = this._x;
			this._y0 = this._y;
			
			var dom = this.event().target;
			var node = null;
			
			this._sourceTarget = dom && tag$wrap(dom);
			
			while (dom){
				node = tag$wrap(dom);
				if (node && node.ontouchstart) {
					this._bubble = false;
					this.setTarget(node);
					this.target().ontouchstart(this);
					if (!this._bubble) { break; };
				};
				dom = dom.parentNode;
			};
			
			this._updates++;
			return this;
		};
		
		Imba.Touch.prototype.update = function (){
			var target_;
			if (!this._active) { return this };
			
			var dr = Math.sqrt(this.dx() * this.dx() + this.dy() * this.dy());
			if (dr > this._dr) { this._maxdr = dr };
			this._dr = dr;
			
			// catching a touch-redirect?!?
			if (this._redirect) {
				if (this._target && this._target.ontouchcancel) {
					this._target.ontouchcancel(this);
				};
				this.setTarget(this._redirect);
				this._redirect = null;
				if (this.target().ontouchstart) { this.target().ontouchstart(this) };
			};
			
			
			this._updates++;
			if (this._gestures) {
				for (var i = 0, ary = iter$(this._gestures), len = ary.length; i < len; i++) {
					ary[i].ontouchupdate(this);
				};
			};
			
			(target_ = this.target()) && target_.ontouchupdate  &&  target_.ontouchupdate(this);
			return this;
		};
		
		Imba.Touch.prototype.move = function (){
			var target_;
			if (!this._active) { return this };
			
			if (this._gestures) {
				for (var i = 0, ary = iter$(this._gestures), len = ary.length, g; i < len; i++) {
					g = ary[i];
					if (g.ontouchmove) { g.ontouchmove(this,this._event) };
				};
			};
			
			(target_ = this.target()) && target_.ontouchmove  &&  target_.ontouchmove(this,this._event);
			return this;
		};
		
		Imba.Touch.prototype.ended = function (){
			var target_;
			if (!this._active) { return this };
			
			this._updates++;
			
			if (this._gestures) {
				for (var i = 0, ary = iter$(this._gestures), len = ary.length; i < len; i++) {
					ary[i].ontouchend(this);
				};
			};
			
			(target_ = this.target()) && target_.ontouchend  &&  target_.ontouchend(this);
			
			return this;
		};
		
		Imba.Touch.prototype.cancel = function (){
			if (!this._cancelled) {
				this._cancelled = true;
				this.cancelled();
				if (this._mousemove) { doc.removeEventListener('mousemove',this._mousemove,true) };
			};
			return this;
		};
		
		Imba.Touch.prototype.cancelled = function (){
			var target_;
			if (!this._active) { return this };
			
			this._cancelled = true;
			this._updates++;
			
			if (this._gestures) {
				for (var i = 0, ary = iter$(this._gestures), len = ary.length, g; i < len; i++) {
					g = ary[i];
					if (g.ontouchcancel) { g.ontouchcancel(this) };
				};
			};
			
			(target_ = this.target()) && target_.ontouchcancel  &&  target_.ontouchcancel(this);
			return this;
		};
		
		/*
			The absolute distance the touch has moved from starting position 
			@return {Number}
			*/
		
		Imba.Touch.prototype.dr = function (){
			return this._dr;
		};
		
		/*
			The distance the touch has moved horizontally
			@return {Number}
			*/
		
		Imba.Touch.prototype.dx = function (){
			return this._x - this._x0;
		};
		
		/*
			The distance the touch has moved vertically
			@return {Number}
			*/
		
		Imba.Touch.prototype.dy = function (){
			return this._y - this._y0;
		};
		
		/*
			Initial horizontal position of touch
			@return {Number}
			*/
		
		Imba.Touch.prototype.x0 = function (){
			return this._x0;
		};
		
		/*
			Initial vertical position of touch
			@return {Number}
			*/
		
		Imba.Touch.prototype.y0 = function (){
			return this._y0;
		};
		
		/*
			Horizontal position of touch
			@return {Number}
			*/
		
		Imba.Touch.prototype.x = function (){
			return this._x;
		};
		
		/*
			Vertical position of touch
			@return {Number}
			*/
		
		Imba.Touch.prototype.y = function (){
			return this._y;
		};
		
		/*
			Horizontal position of touch relative to target
			@return {Number}
			*/
		
		Imba.Touch.prototype.tx = function (){
			this._targetBox || (this._targetBox = this._target.dom().getBoundingClientRect());
			return this._x - this._targetBox.left;
		};
		
		/*
			Vertical position of touch relative to target
			@return {Number}
			*/
		
		Imba.Touch.prototype.ty = function (){
			this._targetBox || (this._targetBox = this._target.dom().getBoundingClientRect());
			return this._y - this._targetBox.top;
		};
		
		/*
			Button pressed in this touch. Native touches defaults to left-click (0)
			@return {Number}
			*/
		
		Imba.Touch.prototype.button = function (){
			return this._button;
		}; // @pointer ? @pointer.button : 0
		
		Imba.Touch.prototype.sourceTarget = function (){
			return this._sourceTarget;
		};
		
		
		Imba.TouchGesture = function TouchGesture(){ };
		
		
		Imba.TouchGesture.prototype.__active = {'default': false,name: 'active'};
		Imba.TouchGesture.prototype.active = function(v){ return this._active; }
		Imba.TouchGesture.prototype.setActive = function(v){ this._active = v; return this; }
		Imba.TouchGesture.prototype._active = false;
		
		Imba.TouchGesture.prototype.ontouchstart = function (e){
			return this;
		};
		
		Imba.TouchGesture.prototype.ontouchupdate = function (e){
			return this;
		};
		
		Imba.TouchGesture.prototype.ontouchend = function (e){
			return this;
		};
		
		
		// A Touch-event is created on mousedown (always)
		// and while it exists, mousemove and mouseup will
		// be delegated to this active event.
		Imba.POINTER = new Imba.Pointer();
		Imba.POINTERS = [Imba.POINTER];
		
		
		// regular event stuff
		Imba.KEYMAP = {
			"8": 'backspace',
			"9": 'tab',
			"13": 'enter',
			"16": 'shift',
			"17": 'ctrl',
			"18": 'alt',
			"19": 'break',
			"20": 'caps',
			"27": 'esc',
			"32": 'space',
			"35": 'end',
			"36": 'home',
			"37": 'larr',
			"38": 'uarr',
			"39": 'rarr',
			"40": 'darr',
			"45": 'insert',
			"46": 'delete',
			"107": 'plus',
			"106": 'mult',
			"91": 'meta'
		};
		
		Imba.CHARMAP = {
			"%": 'modulo',
			"*": 'multiply',
			"+": 'add',
			"-": 'sub',
			"/": 'divide',
			".": 'dot'
		};
		
		/*
		Imba handles all events in the dom through a single manager,
		listening at the root of your document. If Imba finds a tag
		that listens to a certain event, the event will be wrapped 
		in an `Imba.Event`, which normalizes some of the quirks and 
		browser differences.
		
		@iname event
		*/
		
		Imba.Event = function Event(e){
			this.setEvent(e);
			this.setBubble(true);
		};
		
		/* reference to the native event */
		
		
		
		Imba.Event.prototype.event = function(v){ return this._event; }
		Imba.Event.prototype.setEvent = function(v){ this._event = v; return this; };
		
		/* reference to the native event */
		
		
		
		Imba.Event.prototype.prefix = function(v){ return this._prefix; }
		Imba.Event.prototype.setPrefix = function(v){ this._prefix = v; return this; };
		
		
		
		Imba.Event.prototype.data = function(v){ return this._data; }
		Imba.Event.prototype.setData = function(v){ this._data = v; return this; };
		
		/*
			should remove this alltogether?
			@deprecated
			*/
		
		
		
		Imba.Event.prototype.source = function(v){ return this._source; }
		Imba.Event.prototype.setSource = function(v){ this._source = v; return this; };
		
		/* A {Boolean} indicating whether the event bubbles up or not */
		
		
		Imba.Event.prototype.__bubble = {type: Boolean,chainable: true,name: 'bubble'};
		Imba.Event.prototype.bubble = function(v){ return v !== undefined ? (this.setBubble(v),this) : this._bubble; }
		Imba.Event.prototype.setBubble = function(v){ this._bubble = v; return this; };
		
		Imba.Event.wrap = function (e){
			return new this(e);
		};
		
		Imba.Event.prototype.setType = function (type){
			this._type = type;
			return this;
		};
		
		/*
			@return {String} The name of the event (case-insensitive)
			*/
		
		Imba.Event.prototype.type = function (){
			return this._type || this.event().type;
		};
		
		Imba.Event.prototype.name = function (){
			return this._name || (this._name = this.type().toLowerCase().replace(/\:/g,''));
		};
		
		// mimc getset
		Imba.Event.prototype.bubble = function (v){
			if (v != undefined) {
				this.setBubble(v);
				return this;
			};
			return this._bubble;
		};
		
		/*
			Prevents further propagation of the current event.
			@return {self}
			*/
		
		Imba.Event.prototype.halt = function (){
			this.setBubble(false);
			return this;
		};
		
		/*
			Cancel the event (if cancelable). In the case of native events it
			will call `preventDefault` on the wrapped event object.
			@return {self}
			*/
		
		Imba.Event.prototype.cancel = function (){
			if (this.event().preventDefault) { this.event().preventDefault() };
			this._cancel = true;
			return this;
		};
		
		/*
			Indicates whether or not event.cancel has been called.
		
			@return {Boolean}
			*/
		
		Imba.Event.prototype.isPrevented = function (){
			return this.event() && this.event().defaultPrevented || this._cancel;
		};
		
		/*
			A reference to the initial target of the event.
			*/
		
		Imba.Event.prototype.target = function (){
			return tag$wrap(this.event()._target || this.event().target);
		};
		
		/*
			A reference to the object responding to the event.
			*/
		
		Imba.Event.prototype.responder = function (){
			return this._responder;
		};
		
		/*
			Redirect the event to new target
			*/
		
		Imba.Event.prototype.redirect = function (node){
			this._redirect = node;
			return this;
		};
		
		/*
			Get the normalized character for KeyboardEvent/TextEvent
			@return {String}
			*/
		
		Imba.Event.prototype.keychar = function (){
			if (this.event() instanceof TextEvent) {
				return this.event().data;
			};
			
			if (this.event() instanceof KeyboardEvent) {
				var ki = this.event().keyIdentifier;
				var sym = Imba.KEYMAP[this.event().keyCode];
				
				// p 'keysym!',ki,sym
				
				if (!sym && ki.substr(0,2) == "U+") {
					sym = String.fromCharCode(parseInt(ki.substr(2),16));
				};
				return sym;
			};
			
			return null;
		};
		
		/*
			@deprecated
			*/
		
		Imba.Event.prototype.keycombo = function (){
			var sym;
			if (!(sym = this.keychar())) { return };
			sym = Imba.CHARMAP[sym] || sym;
			var combo = [],e = this.event();
			if (e.ctrlKey) { combo.push('ctrl') };
			if (e.shiftKey) { combo.push('shift') };
			if (e.altKey) { combo.push('alt') };
			if (e.metaKey) { combo.push('cmd') };
			combo.push(sym);
			return combo.join("_").toLowerCase();
		};
		
		
		Imba.Event.prototype.process = function (){
			var node;
			var meth = ("on" + (this._prefix || '') + this.name());
			var args = null;
			var domtarget = this.event()._target || this.event().target;
			// var node = <{domtarget:_responder or domtarget}>
			// need to clean up and document this behaviour
			
			var domnode = domtarget._responder || domtarget;
			// @todo need to stop infinite redirect-rules here
			
			var $1;while (domnode){
				this._redirect = null;
				if (node = tag$wrap(domnode)) { // not only tag 
					
					if ((typeof node[($1 = meth)]=='string'||node[$1] instanceof String)) {
						// should remember the receiver of the event
						meth = node[meth];
						continue; // should not continue?
					};
					
					if (node[meth] instanceof Array) {
						args = node[meth].concat(node);
						meth = args.shift();
						continue; // should not continue?
					};
					
					if (node[meth] instanceof Function) {
						this._responder || (this._responder = node);
						// should autostop bubble here?
						args ? (node[meth].apply(node,args)) : (node[meth](this,this.data()));
					};
				};
				
				// add node.nextEventResponder as a separate method here?
				if (!(this.bubble() && (domnode = (this._redirect || (node ? (node.parent()) : (domnode.parentNode)))))) {
					break;
				};
			};
			
			this.processed();
			return this;
		};
		
		
		Imba.Event.prototype.processed = function (){
			Imba.emit(Imba,'event',[this]);
			return this;
		};
		
		/*
			Return the x/left coordinate of the mouse / pointer for this event
			@return {Number} x coordinate of mouse / pointer for event
			*/
		
		Imba.Event.prototype.x = function (){
			return this.event().x;
		};
		
		/*
			Return the y/top coordinate of the mouse / pointer for this event
			@return {Number} y coordinate of mouse / pointer for event
			*/
		
		Imba.Event.prototype.y = function (){
			return this.event().y;
		};
		
		/*
			Returns a Number representing a system and implementation
			dependent numeric code identifying the unmodified value of the
			pressed key; this is usually the same as keyCode.
		
			For mouse-events, the returned value indicates which button was
			pressed on the mouse to trigger the event.
		
			@return {Number}
			*/
		
		Imba.Event.prototype.which = function (){
			return this.event().which;
		};
		
		
		/*
		
		Manager for listening to and delegating events in Imba. A single instance
		is always created by Imba (as `Imba.Events`), which handles and delegates all
		events at the very root of the document. Imba does not capture all events
		by default, so if you want to make sure exotic or custom DOMEvents are delegated
		in Imba you will need to register them in `Imba.Events.register(myCustomEventName)`
		
		@iname manager
		
		*/
		
		Imba.EventManager = function EventManager(node,pars){
			var self = this;
			if(!pars||pars.constructor !== Object) pars = {};
			var events = pars.events !== undefined ? pars.events : [];
			self.setRoot(node);
			self.setCount(0);
			self.setListeners([]);
			self.setDelegators({});
			self.setDelegator(function(e) {
				// console.log "delegating event?! {e}"
				self.delegate(e);
				return true;
			});
			
			for (var i = 0, ary = iter$(events), len = ary.length; i < len; i++) {
				self.register(ary[i]);
			};
			
			return self;
		};
		
		
		
		Imba.EventManager.prototype.root = function(v){ return this._root; }
		Imba.EventManager.prototype.setRoot = function(v){ this._root = v; return this; };
		
		
		Imba.EventManager.prototype.count = function(v){ return this._count; }
		Imba.EventManager.prototype.setCount = function(v){ this._count = v; return this; };
		
		Imba.EventManager.prototype.__enabled = {'default': false,watch: 'enabledDidSet',name: 'enabled'};
		Imba.EventManager.prototype.enabled = function(v){ return this._enabled; }
		Imba.EventManager.prototype.setEnabled = function(v){
			var a = this.enabled();
			if(v != a) { this._enabled = v; }
			if(v != a) { this.enabledDidSet && this.enabledDidSet(v,a,this.__enabled) }
			return this;
		}
		Imba.EventManager.prototype._enabled = false;
		
		
		Imba.EventManager.prototype.listeners = function(v){ return this._listeners; }
		Imba.EventManager.prototype.setListeners = function(v){ this._listeners = v; return this; };
		
		
		Imba.EventManager.prototype.delegators = function(v){ return this._delegators; }
		Imba.EventManager.prototype.setDelegators = function(v){ this._delegators = v; return this; };
		
		
		Imba.EventManager.prototype.delegator = function(v){ return this._delegator; }
		Imba.EventManager.prototype.setDelegator = function(v){ this._delegator = v; return this; };
		
		Imba.EventManager.prototype.enabledDidSet = function (bool){
			bool ? (this.onenable()) : (this.ondisable());
			return this;
		};
		
		/*
		
			Tell the current EventManager to intercept and handle event of a certain name.
			By default, Imba.Events will register interceptors for: *keydown*, *keyup*, 
			*keypress*, *textInput*, *input*, *change*, *submit*, *focusin*, *focusout*, 
			*blur*, *contextmenu*, *dblclick*, *mousewheel*, *wheel*
		
			*/
		
		Imba.EventManager.prototype.register = function (name,handler){
			if(handler === undefined) handler = true;
			if (name instanceof Array) {
				for (var i = 0, ary = iter$(name), len = ary.length; i < len; i++) {
					this.register(ary[i],handler);
				};
				return this;
			};
			
			if (this.delegators()[name]) { return this };
			// console.log("register for event {name}")
			var fn = this.delegators()[name] = handler instanceof Function ? (handler) : (this.delegator());
			if (this.enabled()) { return this.root().addEventListener(name,fn,true) };
		};
		
		Imba.EventManager.prototype.listen = function (name,handler,capture){
			if(capture === undefined) capture = true;
			this.listeners().push([name,handler,capture]);
			if (this.enabled()) { this.root().addEventListener(name,handler,capture) };
			return this;
		};
		
		Imba.EventManager.prototype.delegate = function (e){
			this.setCount(this.count() + 1);
			var event = Imba.Event.wrap(e);
			event.process();
			return this;
		};
		
		Imba.EventManager.prototype.create = function (type,target,pars){
			if(!pars||pars.constructor !== Object) pars = {};
			var data = pars.data !== undefined ? pars.data : null;
			var source = pars.source !== undefined ? pars.source : null;
			var event = Imba.Event.wrap({type: type,target: target});
			if (data) { (event.setData(data),data) };
			if (source) { (event.setSource(source),source) };
			return event;
		};
		
		// use create instead?
		Imba.EventManager.prototype.trigger = function (){
			return this.create.apply(this,arguments).process();
		};
		
		Imba.EventManager.prototype.onenable = function (){
			for (var o = this.delegators(), i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
				this.root().addEventListener(keys[i],o[keys[i]],true);
			};
			
			for (var j = 0, ary = iter$(this.listeners()), len = ary.length, item; j < len; j++) {
				item = ary[j];
				this.root().addEventListener(item[0],item[1],item[2]);
			};
			return this;
		};
		
		Imba.EventManager.prototype.ondisable = function (){
			for (var o = this.delegators(), i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
				this.root().removeEventListener(keys[i],o[keys[i]],true);
			};
			
			for (var j = 0, ary = iter$(this.listeners()), len = ary.length, item; j < len; j++) {
				item = ary[j];
				this.root().removeEventListener(item[0],item[1],item[2]);
			};
			return this;
		};
		
		
		ED = Imba.Events = new Imba.EventManager(document,{events: [
			'keydown','keyup','keypress','textInput','input','change','submit',
			'focusin','focusout','blur','contextmenu','dblclick',
			'mousewheel','wheel'
		]});
		
		// should set these up inside the Imba.Events object itself
		// so that we can have different EventManager for different roots
		
		if (hasTouchEvents) {
			Imba.Events.listen('touchstart',function(e) {
				var Events_, v_;
				(((Events_ = Imba.Events).setCount(v_ = Events_.count() + 1),v_)) - 1;
				return Imba.Touch.ontouchstart(e);
			});
			
			Imba.Events.listen('touchmove',function(e) {
				var Events_, v_;
				(((Events_ = Imba.Events).setCount(v_ = Events_.count() + 1),v_)) - 1;
				return Imba.Touch.ontouchmove(e);
			});
			
			Imba.Events.listen('touchend',function(e) {
				var Events_, v_;
				(((Events_ = Imba.Events).setCount(v_ = Events_.count() + 1),v_)) - 1;
				return Imba.Touch.ontouchend(e);
			});
			
			Imba.Events.listen('touchcancel',function(e) {
				var Events_, v_;
				(((Events_ = Imba.Events).setCount(v_ = Events_.count() + 1),v_)) - 1;
				return Imba.Touch.ontouchcancel(e);
			});
		};
		
		Imba.Events.register('click',function(e) {
			// Only for main mousebutton, no?
			if ((e.timeStamp - lastNativeTouchTimeStamp) > lastNativeTouchTimeout) {
				var tap = new Imba.Event(e);
				tap.setType('tap');
				tap.process();
				if (tap._responder) {
					return e.preventDefault();
				};
			};
			// delegate the real click event
			return Imba.Events.delegate(e);
		});
		
		Imba.Events.listen('mousedown',function(e) {
			if ((e.timeStamp - lastNativeTouchTimeStamp) > lastNativeTouchTimeout) {
				if (Imba.POINTER) { return Imba.POINTER.update(e).process() };
			};
		});
		
		// Imba.Events.listen(:mousemove) do |e|
		// 	# console.log 'mousemove',e:timeStamp
		// 	if (e:timeStamp - lastNativeTouchTimeStamp) > lastNativeTouchTimeout
		// 		Imba.POINTER.update(e).process if Imba.POINTER # .process if touch # should not happen? We process through 
		
		Imba.Events.listen('mouseup',function(e) {
			// console.log 'mouseup',e:timeStamp
			if ((e.timeStamp - lastNativeTouchTimeStamp) > lastNativeTouchTimeout) {
				if (Imba.POINTER) { return Imba.POINTER.update(e).process() };
			};
		});
		
		
		Imba.Events.register(['mousedown','mouseup']);
		return (Imba.Events.setEnabled(true),true);
	
	})()

/***/ },
/* 12 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var ImbaTag = Imba.TAGS.element;
		
		function removeNested(root,node,caret){
			// if node/nodes isa String
			// 	we need to use the caret to remove elements
			// 	for now we will simply not support this
			if (node instanceof ImbaTag) {
				root.removeChild(node);
			} else if (node instanceof Array) {
				for (var i = 0, ary = iter$(node), len = ary.length; i < len; i++) {
					removeNested(root,ary[i],caret);
				};
			} else {
				// what if this is not null?!?!?
				// take a chance and remove a text-elementng
				var next = caret ? (caret.nextSibling) : (root._dom.firstChild);
				if ((next instanceof Text) && next.textContent == node) {
					root.removeChild(next);
				} else {
					throw 'cannot remove string';
				};
			};
			
			return caret;
		};
		
		function appendNested(root,node){
			if (node instanceof ImbaTag) {
				root.appendChild(node);
			} else if (node instanceof Array) {
				for (var i = 0, ary = iter$(node), len = ary.length; i < len; i++) {
					appendNested(root,ary[i]);
				};
			} else if (node != null && node !== false) {
				root.appendChild(Imba.document().createTextNode(node));
			};
			
			return;
		};
		
		
		// insert nodes before a certain node
		// does not need to return any tail, as before
		// will still be correct there
		// before must be an actual domnode
		function insertNestedBefore(root,node,before){
			if (node instanceof ImbaTag) {
				root.insertBefore(node,before);
			} else if (node instanceof Array) {
				for (var i = 0, ary = iter$(node), len = ary.length; i < len; i++) {
					insertNestedBefore(root,ary[i],before);
				};
			} else if (node != null && node !== false) {
				root.insertBefore(Imba.document().createTextNode(node),before);
			};
			
			return before;
		};
		
		// after must be an actual domnode
		function insertNestedAfter(root,node,after){
			var before = after ? (after.nextSibling) : (root._dom.firstChild);
			
			if (before) {
				insertNestedBefore(root,node,before);
				return before.previousSibling;
			} else {
				appendNested(root,node);
				return root._dom.lastChild;
			};
		};
		
		function reconcileCollectionChanges(root,new$,old,caret){
			
			var newLen = new$.length;
			var lastNew = new$[newLen - 1];
			
			// This re-order algorithm is based on the following principle:
			// 
			// We build a "chain" which shows which items are already sorted.
			// If we're going from [1, 2, 3] -> [2, 1, 3], the tree looks like:
			//
			// 	3 ->  0 (idx)
			// 	2 -> -1 (idx)
			// 	1 -> -1 (idx)
			//
			// This tells us that we have two chains of ordered items:
			// 
			// 	(1, 3) and (2)
			// 
			// The optimal re-ordering then becomes two keep the longest chain intact,
			// and move all the other items.
			
			var newPosition = [];
			
			// The tree/graph itself
			var prevChain = [];
			// The length of the chain
			var lengthChain = [];
			
			// Keep track of the longest chain
			var maxChainLength = 0;
			var maxChainEnd = 0;
			
			for (var idx = 0, ary = iter$(old), len = ary.length, node; idx < len; idx++) {
				node = ary[idx];
				var newPos = new$.indexOf(node);
				newPosition.push(newPos);
				
				if (newPos == -1) {
					root.removeChild(node);
					prevChain.push(-1);
					lengthChain.push(-1);
					continue;
				};
				
				var prevIdx = newPosition.length - 2;
				
				// Build the chain:
				while (prevIdx >= 0){
					if (newPosition[prevIdx] == -1) {
						prevIdx--;
					} else if (newPos > newPosition[prevIdx]) {
						// Yay, we're bigger than the previous!
						break;
					} else {
						// Nope, let's walk back the chain
						prevIdx = prevChain[prevIdx];
					};
				};
				
				prevChain.push(prevIdx);
				
				var currLength = (prevIdx == -1) ? (0) : (lengthChain[prevIdx] + 1);
				
				if (currLength > maxChainLength) {
					maxChainLength = currLength;
					maxChainEnd = idx;
				};
				
				lengthChain.push(currLength);
			};
			
			var stickyNodes = [];
			
			// Now we can walk the longest chain backwards and mark them as "sticky",
			// which implies that they should not be moved
			var cursor = newPosition.length - 1;
			while (cursor >= 0){
				if (cursor == maxChainEnd && newPosition[cursor] != -1) {
					stickyNodes[newPosition[cursor]] = true;
					maxChainEnd = prevChain[maxChainEnd];
				};
				
				cursor -= 1;
			};
			
			// And let's iterate forward, but only move non-sticky nodes
			for (var idx1 = 0, ary = iter$(new$), len = ary.length; idx1 < len; idx1++) {
				if (!stickyNodes[idx1]) {
					var after = new$[idx1 - 1];
					insertNestedAfter(root,ary[idx1],(after && after._dom) || caret);
				};
			};
			
			// should trust that the last item in new list is the caret
			return lastNew && lastNew._dom || caret;
		};
		
		
		// expects a flat non-sparse array of nodes in both new and old, always
		function reconcileCollection(root,new$,old,caret){
			var k = new$.length;
			var i = k;
			var last = new$[k - 1];
			
			
			if (k == old.length && new$[0] === old[0]) {
				// running through to compare
				while (i--){
					if (new$[i] !== old[i]) { break; };
				};
			};
			
			if (i == -1) {
				return last && last._dom || caret;
			} else {
				return reconcileCollectionChanges(root,new$,old,caret);
			};
		};
		
		// the general reconciler that respects conditions etc
		// caret is the current node we want to insert things after
		function reconcileNested(root,new$,old,caret){
			
			// if new == null or new === false or new === true
			// 	if new === old
			// 		return caret
			// 	if old && new != old
			// 		removeNested(root,old,caret) if old
			// 
			// 	return caret
			
			// var skipnew = new == null or new === false or new === true
			var newIsNull = new$ == null || new$ === false;
			var oldIsNull = old == null || old === false;
			
			
			if (new$ === old) {
				// remember that the caret must be an actual dom element
				// we should instead move the actual caret? - trust
				if (newIsNull) {
					return caret;
				} else if (new$ && new$._dom) {
					return new$._dom;
				} else {
					return caret ? (caret.nextSibling) : (root._dom.firstChild);
				};
			} else if (new$ instanceof Array) {
				if (old instanceof Array) {
					if (new$.static || old.static) {
						// if the static is not nested - we could get a hint from compiler
						// and just skip it
						if (new$.static == old.static) {
							for (var i = 0, ary = iter$(new$), len = ary.length; i < len; i++) {
								// this is where we could do the triple equal directly
								caret = reconcileNested(root,ary[i],old[i],caret);
							};
							return caret;
						} else {
							removeNested(root,old,caret);
						};
						
						// if they are not the same we continue through to the default
					} else {
						return reconcileCollection(root,new$,old,caret);
					};
				} else if (old instanceof ImbaTag) {
					root.removeChild(old);
				} else if (!oldIsNull) {
					// old was a string-like object?
					root.removeChild(caret ? (caret.nextSibling) : (root._dom.firstChild));
				};
				
				return insertNestedAfter(root,new$,caret);
				// remove old
			} else if (new$ instanceof ImbaTag) {
				if (!oldIsNull) { removeNested(root,old,caret) };
				insertNestedAfter(root,new$,caret);
				return new$;
			} else if (newIsNull) {
				if (!oldIsNull) { removeNested(root,old,caret) };
				return caret;
			} else {
				// if old did not exist we need to add a new directly
				var nextNode;
				// if old was array or imbatag we need to remove it and then add
				if (old instanceof Array) {
					removeNested(root,old,caret);
				} else if (old instanceof ImbaTag) {
					root.removeChild(old);
				} else if (!oldIsNull) {
					// ...
					nextNode = caret ? (caret.nextSibling) : (root._dom.firstChild);
					if ((nextNode instanceof Text) && nextNode.textContent != new$) {
						nextNode.textContent = new$;
						return nextNode;
					};
				};
				
				// now add the textnode
				return insertNestedAfter(root,new$,caret);
			};
		};
		
		
		return tag$.extendTag('htmlelement', function(tag){
			
			tag.prototype.setChildren = function (new$,typ){
				var old = this._children;
				// var isArray = nodes isa Array
				if (new$ === old) {
					return this;
				};
				
				if (!old) {
					this.empty();
					appendNested(this,new$);
				} else if (typ == 2) {
					return this;
				} else if (typ == 1) {
					// here we _know _that it is an array with the same shape
					// every time
					var caret = null;
					for (var i = 0, ary = iter$(new$), len = ary.length; i < len; i++) {
						// prev = old[i]
						caret = reconcileNested(this,ary[i],old[i],caret);
					};
				} else if (typ == 3) {
					// this is possibly fully dynamic. It often is
					// but the old or new could be static while the other is not
					// this is not handled now
					// what if it was previously a static array? edgecase - but must work
					if (new$ instanceof ImbaTag) {
						this.empty();
						this.appendChild(new$);
					} else if (new$ instanceof Array) {
						if (old instanceof Array) {
							// is this not the same as setting staticChildren now but with the
							reconcileCollection(this,new$,old,null);
						} else {
							this.empty();
							appendNested(this,new$);
						};
					} else {
						this.setText(new$);
						return this;
					};
				} else if ((new$ instanceof Array) && (old instanceof Array)) {
					reconcileCollection(this,new$,old,null);
				} else {
					this.empty();
					appendNested(this,new$);
				};
				
				this._children = new$;
				return this;
			};
			
			
			// only ever called with array as argument
			tag.prototype.setStaticChildren = function (new$){
				var old = this._children;
				
				var caret = null;
				for (var i = 0, ary = iter$(new$), len = ary.length; i < len; i++) {
					// prev = old[i]
					caret = reconcileNested(this,ary[i],old[i],caret);
				};
				
				this._children = new$;
				return this;
			};
			
			tag.prototype.content = function (){
				return this._content || this.children().toArray();
			};
			
			tag.prototype.setText = function (text){
				if (text != this._children) {
					this._children = text;
					this.dom().textContent = text == null || text === false ? ('') : (text);
				};
				return this;
			};
		});
	
	})()

/***/ },
/* 13 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		/*
		The special syntax for selectors in Imba creates Imba.Selector
		instances.
		*/
		
		Imba.Selector = function Selector(sel,scope,nodes){
			
			this._query = sel instanceof Imba.Selector ? (sel.query()) : (sel);
			this._context = scope;
			
			if (nodes) {
				for (var i = 0, ary = iter$(nodes), len = ary.length, res = []; i < len; i++) {
					res.push(tag$wrap(ary[i]));
				};
				this._nodes = res;
			};
			
			this._lazy = !nodes;
			return this;
		};
		
		Imba.Selector.one = function (sel,scope){
			var el = (scope || Imba.document()).querySelector(sel);
			return el && tag$wrap(el) || null;
		};
		
		Imba.Selector.all = function (sel,scope){
			return new Imba.Selector(sel,scope);
		};
		
		
		
		Imba.Selector.prototype.query = function(v){ return this._query; }
		Imba.Selector.prototype.setQuery = function(v){ this._query = v; return this; };
		
		Imba.Selector.prototype.reload = function (){
			this._nodes = null;
			return this;
		};
		
		Imba.Selector.prototype.scope = function (){
			var ctx;
			if (this._scope) { return this._scope };
			if (!(ctx = this._context)) { return Imba.document() };
			return this._scope = ctx.toScope ? (ctx.toScope()) : (ctx);
		};
		
		/*
			@returns {Imba.Tag} first node matching this selector
			*/
		
		Imba.Selector.prototype.first = function (){
			if (this._lazy) { return tag$wrap(this._first || (this._first = this.scope().querySelector(this.query()))) } else {
				return this.nodes()[0];
			};
		};
		
		/*
			@returns {Imba.Tag} last node matching this selector
			*/
		
		Imba.Selector.prototype.last = function (){
			return this.nodes()[this._nodes.length - 1];
		};
		
		/*
			@returns [Imba.Tag] all nodes matching this selector
			*/
		
		Imba.Selector.prototype.nodes = function (){
			if (this._nodes) { return this._nodes };
			var items = this.scope().querySelectorAll(this.query());
			for (var i = 0, ary = iter$(items), len = ary.length, res = []; i < len; i++) {
				res.push(tag$wrap(ary[i]));
			};
			this._nodes = res;
			this._lazy = false;
			return this._nodes;
		};
		
		/*
			The number of nodes matching this selector
			*/
		
		Imba.Selector.prototype.count = function (){
			return this.nodes().length;
		};
		
		Imba.Selector.prototype.len = function (){
			return this.nodes().length;
		};
		
		/*
			@todo Add support for block or selector?
			*/
		
		Imba.Selector.prototype.some = function (){
			return this.count() >= 1;
		};
		
		/*
			Get node at index
			*/
		
		Imba.Selector.prototype.at = function (idx){
			return this.nodes()[idx];
		};
		
		/*
			Loop through nodes
			*/
		
		Imba.Selector.prototype.forEach = function (block){
			this.nodes().forEach(block);
			return this;
		};
		
		/*
			Map nodes
			*/
		
		Imba.Selector.prototype.map = function (block){
			return this.nodes().map(block);
		};
		
		/*
			Returns a plain array containing nodes. Implicitly called
			when iterating over a selector in Imba `(node for node in $(selector))`
			*/
		
		Imba.Selector.prototype.toArray = function (){
			return this.nodes();
		};
		
		// Get the first element that matches the selector, 
		// beginning at the current element and progressing up through the DOM tree
		Imba.Selector.prototype.closest = function (sel){
			// seems strange that we alter this selector?
			this._nodes = this.map(function(node) { return node.closest(sel); });
			return this;
		};
		
		// Get the siblings of each element in the set of matched elements, 
		// optionally filtered by a selector.
		// TODO remove duplicates?
		Imba.Selector.prototype.siblings = function (sel){
			this._nodes = this.map(function(node) { return node.siblings(sel); });
			return this;
		};
		
		// Get the descendants of each element in the current set of matched 
		// elements, filtered by a selector.
		Imba.Selector.prototype.find = function (sel){
			this._nodes = this.__query__(sel.query(),this.nodes());
			return this;
		};
		
		Imba.Selector.prototype.reject = function (blk){
			return this.filter(blk,false);
		};
		
		/*
			Filter the nodes in selector by a function or other selector
			*/
		
		Imba.Selector.prototype.filter = function (blk,bool){
			if(bool === undefined) bool = true;
			var fn = (blk instanceof Function) && blk || function(n) { return n.matches(blk); };
			var ary = this.nodes().filter(function(n) { return fn(n) == bool; });
			// if we want to return a new selector for this, we should do that for
			// others as well
			return new Imba.Selector("",this._scope,ary);
		};
		
		Imba.Selector.prototype.__query__ = function (query,contexts){
			var nodes = [];
			var i = 0;
			var l = contexts.length;
			
			while (i < l){
				nodes.push.apply(nodes,contexts[i++].querySelectorAll(query));
			};
			return nodes;
		};
		
		Imba.Selector.prototype.__matches__ = function (){
			return true;
		};
		
		/*
			Add specified flag to all nodes in selector
			*/
		
		Imba.Selector.prototype.flag = function (flag){
			return this.forEach(function(n) { return n.flag(flag); });
		};
		
		/*
			Remove specified flag from all nodes in selector
			*/
		
		Imba.Selector.prototype.unflag = function (flag){
			return this.forEach(function(n) { return n.unflag(flag); });
		};
		
		
		// def Imba.querySelectorAll
		q$ = function(sel,scope) { return new Imba.Selector(sel,scope); };
		
		// def Imba.Selector.one
		q$$ = function(sel,scope) {
			var el = (scope || Imba.document()).querySelector(sel);
			return el && tag$wrap(el) || null;
		};
		
		
		// extending tags with query-methods
		// must be a better way to reopen classes
		return tag$.extendTag('element', function(tag){
			tag.prototype.querySelectorAll = function (q){
				return this._dom.querySelectorAll(q);
			};
			tag.prototype.querySelector = function (q){
				return this._dom.querySelector(q);
			};
			
			// should be moved to Imba.Tag instead?
			// or we should implement all of them here
			tag.prototype.find = function (sel){
				return new Imba.Selector(sel,this);
			};
		});
		
	
	})()

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		var util;
		IMDEBUG = true;
		
		// wtf er alt dette?
		IM = {};
		IM.NEWLINE = '\n';
		IM.CHAR = 0;
		IM.WORD_START = 1;
		IM.WORD_END = 2;
		IM.PUNCTUATION_START = 3;
		IM.PUNCTUATION_END = 4;
		IM.SUB_WORD_START = 5;
		IM.SUB_WORD_END = 6;
		IM.LINE_START = 7;
		IM.LINE_END = 8;
		IM.EMPTY_LINE = 9;
		
		IM.FS = __webpack_require__(15);
		
		var SourceMap = __webpack_require__(16);
		
		// if global:require
		var Region = __webpack_require__(27).Region;
		
		__webpack_require__(28);
		
		__webpack_require__(35);
		__webpack_require__(36);
		__webpack_require__(37);
		
		__webpack_require__(38);
		__webpack_require__(39);
		__webpack_require__(45);
		
		var Highlighter = __webpack_require__(29).Highlighter;
		var ImbacWorker = __webpack_require__(46).ImbacWorker;
		
		IM.worker = function (){
			return this._worker || (this._worker = new ImbacWorker());
		};
		
		module.exports.util = util = __webpack_require__(34);
		// nodes
		__webpack_require__(47);
		
		
		function worker(){
			return IM.worker();
		}; exports.worker = worker;
		
		module.exports.SourceMap = SourceMap;
		module.exports.Region = Region;
		return module.exports.Highlighter = Highlighter;
	
	})()

/***/ },
/* 15 */
/***/ function(module, exports) {

	(function(){
		// externs;
		function save(path,content,encoding,cb){
			if(cb==undefined && typeof encoding == 'function') cb = encoding,encoding = 'utf-8';
			if(encoding==undefined) encoding = 'utf-8';
			console.log('save',path,content,encoding);
			
			return xr.post(path,{body: content}).then(function() {
				console.log('responded');
				return cb && cb(arguments);
			});
		}; exports.save = save;
		
		function readFileAsync(path,encoding,cb){
			if(cb==undefined && typeof encoding == 'function') cb = encoding,encoding = 'utf-8';
			if(encoding==undefined) encoding = 'utf-8';
			console.log('save',path,encoding);
			
			return xr.get(path).then(function(res) {
				console.log('responded',res);
				cb && cb(arguments);
				return res;
			});
		}; exports.readFileAsync = readFileAsync;; return readFileAsync;
	
	})()

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	exports.SourceMapGenerator = __webpack_require__(17).SourceMapGenerator;
	exports.SourceMapConsumer = __webpack_require__(23).SourceMapConsumer;
	exports.SourceNode = __webpack_require__(26).SourceNode;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var base64VLQ = __webpack_require__(18);
	  var util = __webpack_require__(20);
	  var ArraySet = __webpack_require__(21).ArraySet;
	  var MappingList = __webpack_require__(22).MappingList;
	
	  /**
	   * An instance of the SourceMapGenerator represents a source map which is
	   * being built incrementally. You may pass an object with the following
	   * properties:
	   *
	   *   - file: The filename of the generated source.
	   *   - sourceRoot: A root for all relative URLs in this source map.
	   */
	  function SourceMapGenerator(aArgs) {
	    if (!aArgs) {
	      aArgs = {};
	    }
	    this._file = util.getArg(aArgs, 'file', null);
	    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	    this._sources = new ArraySet();
	    this._names = new ArraySet();
	    this._mappings = new MappingList();
	    this._sourcesContents = null;
	  }
	
	  SourceMapGenerator.prototype._version = 3;
	
	  /**
	   * Creates a new SourceMapGenerator based on a SourceMapConsumer
	   *
	   * @param aSourceMapConsumer The SourceMap.
	   */
	  SourceMapGenerator.fromSourceMap =
	    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	      var sourceRoot = aSourceMapConsumer.sourceRoot;
	      var generator = new SourceMapGenerator({
	        file: aSourceMapConsumer.file,
	        sourceRoot: sourceRoot
	      });
	      aSourceMapConsumer.eachMapping(function (mapping) {
	        var newMapping = {
	          generated: {
	            line: mapping.generatedLine,
	            column: mapping.generatedColumn
	          }
	        };
	
	        if (mapping.source != null) {
	          newMapping.source = mapping.source;
	          if (sourceRoot != null) {
	            newMapping.source = util.relative(sourceRoot, newMapping.source);
	          }
	
	          newMapping.original = {
	            line: mapping.originalLine,
	            column: mapping.originalColumn
	          };
	
	          if (mapping.name != null) {
	            newMapping.name = mapping.name;
	          }
	        }
	
	        generator.addMapping(newMapping);
	      });
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content != null) {
	          generator.setSourceContent(sourceFile, content);
	        }
	      });
	      return generator;
	    };
	
	  /**
	   * Add a single mapping from original source line and column to the generated
	   * source's line and column for this source map being created. The mapping
	   * object should have the following properties:
	   *
	   *   - generated: An object with the generated line and column positions.
	   *   - original: An object with the original line and column positions.
	   *   - source: The original source file (relative to the sourceRoot).
	   *   - name: An optional original token name for this mapping.
	   */
	  SourceMapGenerator.prototype.addMapping =
	    function SourceMapGenerator_addMapping(aArgs) {
	      var generated = util.getArg(aArgs, 'generated');
	      var original = util.getArg(aArgs, 'original', null);
	      var source = util.getArg(aArgs, 'source', null);
	      var name = util.getArg(aArgs, 'name', null);
	
	      if (!this._skipValidation) {
	        this._validateMapping(generated, original, source, name);
	      }
	
	      if (source != null && !this._sources.has(source)) {
	        this._sources.add(source);
	      }
	
	      if (name != null && !this._names.has(name)) {
	        this._names.add(name);
	      }
	
	      this._mappings.add({
	        generatedLine: generated.line,
	        generatedColumn: generated.column,
	        originalLine: original != null && original.line,
	        originalColumn: original != null && original.column,
	        source: source,
	        name: name
	      });
	    };
	
	  /**
	   * Set the source content for a source file.
	   */
	  SourceMapGenerator.prototype.setSourceContent =
	    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	      var source = aSourceFile;
	      if (this._sourceRoot != null) {
	        source = util.relative(this._sourceRoot, source);
	      }
	
	      if (aSourceContent != null) {
	        // Add the source content to the _sourcesContents map.
	        // Create a new _sourcesContents map if the property is null.
	        if (!this._sourcesContents) {
	          this._sourcesContents = {};
	        }
	        this._sourcesContents[util.toSetString(source)] = aSourceContent;
	      } else if (this._sourcesContents) {
	        // Remove the source file from the _sourcesContents map.
	        // If the _sourcesContents map is empty, set the property to null.
	        delete this._sourcesContents[util.toSetString(source)];
	        if (Object.keys(this._sourcesContents).length === 0) {
	          this._sourcesContents = null;
	        }
	      }
	    };
	
	  /**
	   * Applies the mappings of a sub-source-map for a specific source file to the
	   * source map being generated. Each mapping to the supplied source file is
	   * rewritten using the supplied source map. Note: The resolution for the
	   * resulting mappings is the minimium of this map and the supplied map.
	   *
	   * @param aSourceMapConsumer The source map to be applied.
	   * @param aSourceFile Optional. The filename of the source file.
	   *        If omitted, SourceMapConsumer's file property will be used.
	   * @param aSourceMapPath Optional. The dirname of the path to the source map
	   *        to be applied. If relative, it is relative to the SourceMapConsumer.
	   *        This parameter is needed when the two source maps aren't in the same
	   *        directory, and the source map to be applied contains relative source
	   *        paths. If so, those relative source paths need to be rewritten
	   *        relative to the SourceMapGenerator.
	   */
	  SourceMapGenerator.prototype.applySourceMap =
	    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	      var sourceFile = aSourceFile;
	      // If aSourceFile is omitted, we will use the file property of the SourceMap
	      if (aSourceFile == null) {
	        if (aSourceMapConsumer.file == null) {
	          throw new Error(
	            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	            'or the source map\'s "file" property. Both were omitted.'
	          );
	        }
	        sourceFile = aSourceMapConsumer.file;
	      }
	      var sourceRoot = this._sourceRoot;
	      // Make "sourceFile" relative if an absolute Url is passed.
	      if (sourceRoot != null) {
	        sourceFile = util.relative(sourceRoot, sourceFile);
	      }
	      // Applying the SourceMap can add and remove items from the sources and
	      // the names array.
	      var newSources = new ArraySet();
	      var newNames = new ArraySet();
	
	      // Find mappings for the "sourceFile"
	      this._mappings.unsortedForEach(function (mapping) {
	        if (mapping.source === sourceFile && mapping.originalLine != null) {
	          // Check if it can be mapped by the source map, then update the mapping.
	          var original = aSourceMapConsumer.originalPositionFor({
	            line: mapping.originalLine,
	            column: mapping.originalColumn
	          });
	          if (original.source != null) {
	            // Copy mapping
	            mapping.source = original.source;
	            if (aSourceMapPath != null) {
	              mapping.source = util.join(aSourceMapPath, mapping.source)
	            }
	            if (sourceRoot != null) {
	              mapping.source = util.relative(sourceRoot, mapping.source);
	            }
	            mapping.originalLine = original.line;
	            mapping.originalColumn = original.column;
	            if (original.name != null) {
	              mapping.name = original.name;
	            }
	          }
	        }
	
	        var source = mapping.source;
	        if (source != null && !newSources.has(source)) {
	          newSources.add(source);
	        }
	
	        var name = mapping.name;
	        if (name != null && !newNames.has(name)) {
	          newNames.add(name);
	        }
	
	      }, this);
	      this._sources = newSources;
	      this._names = newNames;
	
	      // Copy sourcesContents of applied map.
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content != null) {
	          if (aSourceMapPath != null) {
	            sourceFile = util.join(aSourceMapPath, sourceFile);
	          }
	          if (sourceRoot != null) {
	            sourceFile = util.relative(sourceRoot, sourceFile);
	          }
	          this.setSourceContent(sourceFile, content);
	        }
	      }, this);
	    };
	
	  /**
	   * A mapping can have one of the three levels of data:
	   *
	   *   1. Just the generated position.
	   *   2. The Generated position, original position, and original source.
	   *   3. Generated and original position, original source, as well as a name
	   *      token.
	   *
	   * To maintain consistency, we validate that any new mapping being added falls
	   * in to one of these categories.
	   */
	  SourceMapGenerator.prototype._validateMapping =
	    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                                aName) {
	      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	          && aGenerated.line > 0 && aGenerated.column >= 0
	          && !aOriginal && !aSource && !aName) {
	        // Case 1.
	        return;
	      }
	      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	               && aGenerated.line > 0 && aGenerated.column >= 0
	               && aOriginal.line > 0 && aOriginal.column >= 0
	               && aSource) {
	        // Cases 2 and 3.
	        return;
	      }
	      else {
	        throw new Error('Invalid mapping: ' + JSON.stringify({
	          generated: aGenerated,
	          source: aSource,
	          original: aOriginal,
	          name: aName
	        }));
	      }
	    };
	
	  /**
	   * Serialize the accumulated mappings in to the stream of base 64 VLQs
	   * specified by the source map format.
	   */
	  SourceMapGenerator.prototype._serializeMappings =
	    function SourceMapGenerator_serializeMappings() {
	      var previousGeneratedColumn = 0;
	      var previousGeneratedLine = 1;
	      var previousOriginalColumn = 0;
	      var previousOriginalLine = 0;
	      var previousName = 0;
	      var previousSource = 0;
	      var result = '';
	      var mapping;
	      var nameIdx;
	      var sourceIdx;
	
	      var mappings = this._mappings.toArray();
	      for (var i = 0, len = mappings.length; i < len; i++) {
	        mapping = mappings[i];
	
	        if (mapping.generatedLine !== previousGeneratedLine) {
	          previousGeneratedColumn = 0;
	          while (mapping.generatedLine !== previousGeneratedLine) {
	            result += ';';
	            previousGeneratedLine++;
	          }
	        }
	        else {
	          if (i > 0) {
	            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	              continue;
	            }
	            result += ',';
	          }
	        }
	
	        result += base64VLQ.encode(mapping.generatedColumn
	                                   - previousGeneratedColumn);
	        previousGeneratedColumn = mapping.generatedColumn;
	
	        if (mapping.source != null) {
	          sourceIdx = this._sources.indexOf(mapping.source);
	          result += base64VLQ.encode(sourceIdx - previousSource);
	          previousSource = sourceIdx;
	
	          // lines are stored 0-based in SourceMap spec version 3
	          result += base64VLQ.encode(mapping.originalLine - 1
	                                     - previousOriginalLine);
	          previousOriginalLine = mapping.originalLine - 1;
	
	          result += base64VLQ.encode(mapping.originalColumn
	                                     - previousOriginalColumn);
	          previousOriginalColumn = mapping.originalColumn;
	
	          if (mapping.name != null) {
	            nameIdx = this._names.indexOf(mapping.name);
	            result += base64VLQ.encode(nameIdx - previousName);
	            previousName = nameIdx;
	          }
	        }
	      }
	
	      return result;
	    };
	
	  SourceMapGenerator.prototype._generateSourcesContent =
	    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	      return aSources.map(function (source) {
	        if (!this._sourcesContents) {
	          return null;
	        }
	        if (aSourceRoot != null) {
	          source = util.relative(aSourceRoot, source);
	        }
	        var key = util.toSetString(source);
	        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
	                                                    key)
	          ? this._sourcesContents[key]
	          : null;
	      }, this);
	    };
	
	  /**
	   * Externalize the source map.
	   */
	  SourceMapGenerator.prototype.toJSON =
	    function SourceMapGenerator_toJSON() {
	      var map = {
	        version: this._version,
	        sources: this._sources.toArray(),
	        names: this._names.toArray(),
	        mappings: this._serializeMappings()
	      };
	      if (this._file != null) {
	        map.file = this._file;
	      }
	      if (this._sourceRoot != null) {
	        map.sourceRoot = this._sourceRoot;
	      }
	      if (this._sourcesContents) {
	        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	      }
	
	      return map;
	    };
	
	  /**
	   * Render the source map being generated to a string.
	   */
	  SourceMapGenerator.prototype.toString =
	    function SourceMapGenerator_toString() {
	      return JSON.stringify(this.toJSON());
	    };
	
	  exports.SourceMapGenerator = SourceMapGenerator;
	}


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	{
	  var base64 = __webpack_require__(19);
	
	  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
	  // length quantities we use in the source map spec, the first bit is the sign,
	  // the next four bits are the actual value, and the 6th bit is the
	  // continuation bit. The continuation bit tells us whether there are more
	  // digits in this value following this digit.
	  //
	  //   Continuation
	  //   |    Sign
	  //   |    |
	  //   V    V
	  //   101011
	
	  var VLQ_BASE_SHIFT = 5;
	
	  // binary: 100000
	  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	
	  // binary: 011111
	  var VLQ_BASE_MASK = VLQ_BASE - 1;
	
	  // binary: 100000
	  var VLQ_CONTINUATION_BIT = VLQ_BASE;
	
	  /**
	   * Converts from a two-complement value to a value where the sign bit is
	   * placed in the least significant bit.  For example, as decimals:
	   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	   */
	  function toVLQSigned(aValue) {
	    return aValue < 0
	      ? ((-aValue) << 1) + 1
	      : (aValue << 1) + 0;
	  }
	
	  /**
	   * Converts to a two-complement value from a value where the sign bit is
	   * placed in the least significant bit.  For example, as decimals:
	   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	   */
	  function fromVLQSigned(aValue) {
	    var isNegative = (aValue & 1) === 1;
	    var shifted = aValue >> 1;
	    return isNegative
	      ? -shifted
	      : shifted;
	  }
	
	  /**
	   * Returns the base 64 VLQ encoded value.
	   */
	  exports.encode = function base64VLQ_encode(aValue) {
	    var encoded = "";
	    var digit;
	
	    var vlq = toVLQSigned(aValue);
	
	    do {
	      digit = vlq & VLQ_BASE_MASK;
	      vlq >>>= VLQ_BASE_SHIFT;
	      if (vlq > 0) {
	        // There are still more digits in this value, so we must make sure the
	        // continuation bit is marked.
	        digit |= VLQ_CONTINUATION_BIT;
	      }
	      encoded += base64.encode(digit);
	    } while (vlq > 0);
	
	    return encoded;
	  };
	
	  /**
	   * Decodes the next base 64 VLQ value from the given string and returns the
	   * value and the rest of the string via the out parameter.
	   */
	  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	    var strLen = aStr.length;
	    var result = 0;
	    var shift = 0;
	    var continuation, digit;
	
	    do {
	      if (aIndex >= strLen) {
	        throw new Error("Expected more digits in base 64 VLQ value.");
	      }
	
	      digit = base64.decode(aStr.charCodeAt(aIndex++));
	      if (digit === -1) {
	        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	      }
	
	      continuation = !!(digit & VLQ_CONTINUATION_BIT);
	      digit &= VLQ_BASE_MASK;
	      result = result + (digit << shift);
	      shift += VLQ_BASE_SHIFT;
	    } while (continuation);
	
	    aOutParam.value = fromVLQSigned(result);
	    aOutParam.rest = aIndex;
	  };
	}


/***/ },
/* 19 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
	
	  /**
	   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	   */
	  exports.encode = function (number) {
	    if (0 <= number && number < intToCharMap.length) {
	      return intToCharMap[number];
	    }
	    throw new TypeError("Must be between 0 and 63: " + number);
	  };
	
	  /**
	   * Decode a single base 64 character code digit to an integer. Returns -1 on
	   * failure.
	   */
	  exports.decode = function (charCode) {
	    var bigA = 65;     // 'A'
	    var bigZ = 90;     // 'Z'
	
	    var littleA = 97;  // 'a'
	    var littleZ = 122; // 'z'
	
	    var zero = 48;     // '0'
	    var nine = 57;     // '9'
	
	    var plus = 43;     // '+'
	    var slash = 47;    // '/'
	
	    var littleOffset = 26;
	    var numberOffset = 52;
	
	    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	    if (bigA <= charCode && charCode <= bigZ) {
	      return (charCode - bigA);
	    }
	
	    // 26 - 51: abcdefghijklmnopqrstuvwxyz
	    if (littleA <= charCode && charCode <= littleZ) {
	      return (charCode - littleA + littleOffset);
	    }
	
	    // 52 - 61: 0123456789
	    if (zero <= charCode && charCode <= nine) {
	      return (charCode - zero + numberOffset);
	    }
	
	    // 62: +
	    if (charCode == plus) {
	      return 62;
	    }
	
	    // 63: /
	    if (charCode == slash) {
	      return 63;
	    }
	
	    // Invalid base64 digit.
	    return -1;
	  };
	}


/***/ },
/* 20 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  /**
	   * This is a helper function for getting values from parameter/options
	   * objects.
	   *
	   * @param args The object we are extracting values from
	   * @param name The name of the property we are getting.
	   * @param defaultValue An optional value to return if the property is missing
	   * from the object. If this is not specified and the property is missing, an
	   * error will be thrown.
	   */
	  function getArg(aArgs, aName, aDefaultValue) {
	    if (aName in aArgs) {
	      return aArgs[aName];
	    } else if (arguments.length === 3) {
	      return aDefaultValue;
	    } else {
	      throw new Error('"' + aName + '" is a required argument.');
	    }
	  }
	  exports.getArg = getArg;
	
	  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
	  var dataUrlRegexp = /^data:.+\,.+$/;
	
	  function urlParse(aUrl) {
	    var match = aUrl.match(urlRegexp);
	    if (!match) {
	      return null;
	    }
	    return {
	      scheme: match[1],
	      auth: match[2],
	      host: match[3],
	      port: match[4],
	      path: match[5]
	    };
	  }
	  exports.urlParse = urlParse;
	
	  function urlGenerate(aParsedUrl) {
	    var url = '';
	    if (aParsedUrl.scheme) {
	      url += aParsedUrl.scheme + ':';
	    }
	    url += '//';
	    if (aParsedUrl.auth) {
	      url += aParsedUrl.auth + '@';
	    }
	    if (aParsedUrl.host) {
	      url += aParsedUrl.host;
	    }
	    if (aParsedUrl.port) {
	      url += ":" + aParsedUrl.port
	    }
	    if (aParsedUrl.path) {
	      url += aParsedUrl.path;
	    }
	    return url;
	  }
	  exports.urlGenerate = urlGenerate;
	
	  /**
	   * Normalizes a path, or the path portion of a URL:
	   *
	   * - Replaces consequtive slashes with one slash.
	   * - Removes unnecessary '.' parts.
	   * - Removes unnecessary '<dir>/..' parts.
	   *
	   * Based on code in the Node.js 'path' core module.
	   *
	   * @param aPath The path or url to normalize.
	   */
	  function normalize(aPath) {
	    var path = aPath;
	    var url = urlParse(aPath);
	    if (url) {
	      if (!url.path) {
	        return aPath;
	      }
	      path = url.path;
	    }
	    var isAbsolute = exports.isAbsolute(path);
	
	    var parts = path.split(/\/+/);
	    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	      part = parts[i];
	      if (part === '.') {
	        parts.splice(i, 1);
	      } else if (part === '..') {
	        up++;
	      } else if (up > 0) {
	        if (part === '') {
	          // The first part is blank if the path is absolute. Trying to go
	          // above the root is a no-op. Therefore we can remove all '..' parts
	          // directly after the root.
	          parts.splice(i + 1, up);
	          up = 0;
	        } else {
	          parts.splice(i, 2);
	          up--;
	        }
	      }
	    }
	    path = parts.join('/');
	
	    if (path === '') {
	      path = isAbsolute ? '/' : '.';
	    }
	
	    if (url) {
	      url.path = path;
	      return urlGenerate(url);
	    }
	    return path;
	  }
	  exports.normalize = normalize;
	
	  /**
	   * Joins two paths/URLs.
	   *
	   * @param aRoot The root path or URL.
	   * @param aPath The path or URL to be joined with the root.
	   *
	   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	   *   first.
	   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	   *   is updated with the result and aRoot is returned. Otherwise the result
	   *   is returned.
	   *   - If aPath is absolute, the result is aPath.
	   *   - Otherwise the two paths are joined with a slash.
	   * - Joining for example 'http://' and 'www.example.com' is also supported.
	   */
	  function join(aRoot, aPath) {
	    if (aRoot === "") {
	      aRoot = ".";
	    }
	    if (aPath === "") {
	      aPath = ".";
	    }
	    var aPathUrl = urlParse(aPath);
	    var aRootUrl = urlParse(aRoot);
	    if (aRootUrl) {
	      aRoot = aRootUrl.path || '/';
	    }
	
	    // `join(foo, '//www.example.org')`
	    if (aPathUrl && !aPathUrl.scheme) {
	      if (aRootUrl) {
	        aPathUrl.scheme = aRootUrl.scheme;
	      }
	      return urlGenerate(aPathUrl);
	    }
	
	    if (aPathUrl || aPath.match(dataUrlRegexp)) {
	      return aPath;
	    }
	
	    // `join('http://', 'www.example.com')`
	    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	      aRootUrl.host = aPath;
	      return urlGenerate(aRootUrl);
	    }
	
	    var joined = aPath.charAt(0) === '/'
	      ? aPath
	      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
	
	    if (aRootUrl) {
	      aRootUrl.path = joined;
	      return urlGenerate(aRootUrl);
	    }
	    return joined;
	  }
	  exports.join = join;
	
	  exports.isAbsolute = function (aPath) {
	    return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
	  };
	
	  /**
	   * Make a path relative to a URL or another path.
	   *
	   * @param aRoot The root path or URL.
	   * @param aPath The path or URL to be made relative to aRoot.
	   */
	  function relative(aRoot, aPath) {
	    if (aRoot === "") {
	      aRoot = ".";
	    }
	
	    aRoot = aRoot.replace(/\/$/, '');
	
	    // It is possible for the path to be above the root. In this case, simply
	    // checking whether the root is a prefix of the path won't work. Instead, we
	    // need to remove components from the root one by one, until either we find
	    // a prefix that fits, or we run out of components to remove.
	    var level = 0;
	    while (aPath.indexOf(aRoot + '/') !== 0) {
	      var index = aRoot.lastIndexOf("/");
	      if (index < 0) {
	        return aPath;
	      }
	
	      // If the only part of the root that is left is the scheme (i.e. http://,
	      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	      // have exhausted all components, so the path is not relative to the root.
	      aRoot = aRoot.slice(0, index);
	      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	        return aPath;
	      }
	
	      ++level;
	    }
	
	    // Make sure we add a "../" for each component we removed from the root.
	    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	  }
	  exports.relative = relative;
	
	  /**
	   * Because behavior goes wacky when you set `__proto__` on objects, we
	   * have to prefix all the strings in our set with an arbitrary character.
	   *
	   * See https://github.com/mozilla/source-map/pull/31 and
	   * https://github.com/mozilla/source-map/issues/30
	   *
	   * @param String aStr
	   */
	  function toSetString(aStr) {
	    return '$' + aStr;
	  }
	  exports.toSetString = toSetString;
	
	  function fromSetString(aStr) {
	    return aStr.substr(1);
	  }
	  exports.fromSetString = fromSetString;
	
	  /**
	   * Comparator between two mappings where the original positions are compared.
	   *
	   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	   * mappings with the same original source/line/column, but different generated
	   * line and column the same. Useful when searching for a mapping with a
	   * stubbed out mapping.
	   */
	  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	    var cmp = mappingA.source - mappingB.source;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp !== 0 || onlyCompareOriginal) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    return mappingA.name - mappingB.name;
	  }
	  exports.compareByOriginalPositions = compareByOriginalPositions;
	
	  /**
	   * Comparator between two mappings with deflated source and name indices where
	   * the generated positions are compared.
	   *
	   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	   * mappings with the same generated line and column, but different
	   * source/name/original line and column the same. Useful when searching for a
	   * mapping with a stubbed out mapping.
	   */
	  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	    var cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp !== 0 || onlyCompareGenerated) {
	      return cmp;
	    }
	
	    cmp = mappingA.source - mappingB.source;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    return mappingA.name - mappingB.name;
	  }
	  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
	
	  function strcmp(aStr1, aStr2) {
	    if (aStr1 === aStr2) {
	      return 0;
	    }
	
	    if (aStr1 > aStr2) {
	      return 1;
	    }
	
	    return -1;
	  }
	
	  /**
	   * Comparator between two mappings with inflated source and name strings where
	   * the generated positions are compared.
	   */
	  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	    var cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = strcmp(mappingA.source, mappingB.source);
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    return strcmp(mappingA.name, mappingB.name);
	  }
	  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	}


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var util = __webpack_require__(20);
	
	  /**
	   * A data structure which is a combination of an array and a set. Adding a new
	   * member is O(1), testing for membership is O(1), and finding the index of an
	   * element is O(1). Removing elements from the set is not supported. Only
	   * strings are supported for membership.
	   */
	  function ArraySet() {
	    this._array = [];
	    this._set = {};
	  }
	
	  /**
	   * Static method for creating ArraySet instances from an existing array.
	   */
	  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	    var set = new ArraySet();
	    for (var i = 0, len = aArray.length; i < len; i++) {
	      set.add(aArray[i], aAllowDuplicates);
	    }
	    return set;
	  };
	
	  /**
	   * Return how many unique items are in this ArraySet. If duplicates have been
	   * added, than those do not count towards the size.
	   *
	   * @returns Number
	   */
	  ArraySet.prototype.size = function ArraySet_size() {
	    return Object.getOwnPropertyNames(this._set).length;
	  };
	
	  /**
	   * Add the given string to this set.
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	    var sStr = util.toSetString(aStr);
	    var isDuplicate = this._set.hasOwnProperty(sStr);
	    var idx = this._array.length;
	    if (!isDuplicate || aAllowDuplicates) {
	      this._array.push(aStr);
	    }
	    if (!isDuplicate) {
	      this._set[sStr] = idx;
	    }
	  };
	
	  /**
	   * Is the given string a member of this set?
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.has = function ArraySet_has(aStr) {
	    var sStr = util.toSetString(aStr);
	    return this._set.hasOwnProperty(sStr);
	  };
	
	  /**
	   * What is the index of the given string in the array?
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	    var sStr = util.toSetString(aStr);
	    if (this._set.hasOwnProperty(sStr)) {
	      return this._set[sStr];
	    }
	    throw new Error('"' + aStr + '" is not in the set.');
	  };
	
	  /**
	   * What is the element at the given index?
	   *
	   * @param Number aIdx
	   */
	  ArraySet.prototype.at = function ArraySet_at(aIdx) {
	    if (aIdx >= 0 && aIdx < this._array.length) {
	      return this._array[aIdx];
	    }
	    throw new Error('No element indexed by ' + aIdx);
	  };
	
	  /**
	   * Returns the array representation of this set (which has the proper indices
	   * indicated by indexOf). Note that this is a copy of the internal array used
	   * for storing the members so that no one can mess with internal state.
	   */
	  ArraySet.prototype.toArray = function ArraySet_toArray() {
	    return this._array.slice();
	  };
	
	  exports.ArraySet = ArraySet;
	}


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var util = __webpack_require__(20);
	
	  /**
	   * Determine whether mappingB is after mappingA with respect to generated
	   * position.
	   */
	  function generatedPositionAfter(mappingA, mappingB) {
	    // Optimized for most common case
	    var lineA = mappingA.generatedLine;
	    var lineB = mappingB.generatedLine;
	    var columnA = mappingA.generatedColumn;
	    var columnB = mappingB.generatedColumn;
	    return lineB > lineA || lineB == lineA && columnB >= columnA ||
	           util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	  }
	
	  /**
	   * A data structure to provide a sorted view of accumulated mappings in a
	   * performance conscious manner. It trades a neglibable overhead in general
	   * case for a large speedup in case of mappings being added in order.
	   */
	  function MappingList() {
	    this._array = [];
	    this._sorted = true;
	    // Serves as infimum
	    this._last = {generatedLine: -1, generatedColumn: 0};
	  }
	
	  /**
	   * Iterate through internal items. This method takes the same arguments that
	   * `Array.prototype.forEach` takes.
	   *
	   * NOTE: The order of the mappings is NOT guaranteed.
	   */
	  MappingList.prototype.unsortedForEach =
	    function MappingList_forEach(aCallback, aThisArg) {
	      this._array.forEach(aCallback, aThisArg);
	    };
	
	  /**
	   * Add the given source mapping.
	   *
	   * @param Object aMapping
	   */
	  MappingList.prototype.add = function MappingList_add(aMapping) {
	    if (generatedPositionAfter(this._last, aMapping)) {
	      this._last = aMapping;
	      this._array.push(aMapping);
	    } else {
	      this._sorted = false;
	      this._array.push(aMapping);
	    }
	  };
	
	  /**
	   * Returns the flat, sorted array of mappings. The mappings are sorted by
	   * generated position.
	   *
	   * WARNING: This method returns internal data without copying, for
	   * performance. The return value must NOT be mutated, and should be treated as
	   * an immutable borrow. If you want to take ownership, you must make your own
	   * copy.
	   */
	  MappingList.prototype.toArray = function MappingList_toArray() {
	    if (!this._sorted) {
	      this._array.sort(util.compareByGeneratedPositionsInflated);
	      this._sorted = true;
	    }
	    return this._array;
	  };
	
	  exports.MappingList = MappingList;
	}


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var util = __webpack_require__(20);
	  var binarySearch = __webpack_require__(24);
	  var ArraySet = __webpack_require__(21).ArraySet;
	  var base64VLQ = __webpack_require__(18);
	  var quickSort = __webpack_require__(25).quickSort;
	
	  function SourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    return sourceMap.sections != null
	      ? new IndexedSourceMapConsumer(sourceMap)
	      : new BasicSourceMapConsumer(sourceMap);
	  }
	
	  SourceMapConsumer.fromSourceMap = function(aSourceMap) {
	    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
	  }
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  SourceMapConsumer.prototype._version = 3;
	
	  // `__generatedMappings` and `__originalMappings` are arrays that hold the
	  // parsed mapping coordinates from the source map's "mappings" attribute. They
	  // are lazily instantiated, accessed via the `_generatedMappings` and
	  // `_originalMappings` getters respectively, and we only parse the mappings
	  // and create these arrays once queried for a source location. We jump through
	  // these hoops because there can be many thousands of mappings, and parsing
	  // them is expensive, so we only want to do it if we must.
	  //
	  // Each object in the arrays is of the form:
	  //
	  //     {
	  //       generatedLine: The line number in the generated code,
	  //       generatedColumn: The column number in the generated code,
	  //       source: The path to the original source file that generated this
	  //               chunk of code,
	  //       originalLine: The line number in the original source that
	  //                     corresponds to this chunk of generated code,
	  //       originalColumn: The column number in the original source that
	  //                       corresponds to this chunk of generated code,
	  //       name: The name of the original symbol which generated this chunk of
	  //             code.
	  //     }
	  //
	  // All properties except for `generatedLine` and `generatedColumn` can be
	  // `null`.
	  //
	  // `_generatedMappings` is ordered by the generated positions.
	  //
	  // `_originalMappings` is ordered by the original positions.
	
	  SourceMapConsumer.prototype.__generatedMappings = null;
	  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	    get: function () {
	      if (!this.__generatedMappings) {
	        this._parseMappings(this._mappings, this.sourceRoot);
	      }
	
	      return this.__generatedMappings;
	    }
	  });
	
	  SourceMapConsumer.prototype.__originalMappings = null;
	  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	    get: function () {
	      if (!this.__originalMappings) {
	        this._parseMappings(this._mappings, this.sourceRoot);
	      }
	
	      return this.__originalMappings;
	    }
	  });
	
	  SourceMapConsumer.prototype._charIsMappingSeparator =
	    function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	      var c = aStr.charAt(index);
	      return c === ";" || c === ",";
	    };
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  SourceMapConsumer.prototype._parseMappings =
	    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      throw new Error("Subclasses must implement _parseMappings");
	    };
	
	  SourceMapConsumer.GENERATED_ORDER = 1;
	  SourceMapConsumer.ORIGINAL_ORDER = 2;
	
	  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
	
	  /**
	   * Iterate over each mapping between an original source/line/column and a
	   * generated line/column in this source map.
	   *
	   * @param Function aCallback
	   *        The function that is called with each mapping.
	   * @param Object aContext
	   *        Optional. If specified, this object will be the value of `this` every
	   *        time that `aCallback` is called.
	   * @param aOrder
	   *        Either `SourceMapConsumer.GENERATED_ORDER` or
	   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	   *        iterate over the mappings sorted by the generated file's line/column
	   *        order or the original's source/line/column order, respectively. Defaults to
	   *        `SourceMapConsumer.GENERATED_ORDER`.
	   */
	  SourceMapConsumer.prototype.eachMapping =
	    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	      var context = aContext || null;
	      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
	
	      var mappings;
	      switch (order) {
	      case SourceMapConsumer.GENERATED_ORDER:
	        mappings = this._generatedMappings;
	        break;
	      case SourceMapConsumer.ORIGINAL_ORDER:
	        mappings = this._originalMappings;
	        break;
	      default:
	        throw new Error("Unknown order of iteration.");
	      }
	
	      var sourceRoot = this.sourceRoot;
	      mappings.map(function (mapping) {
	        var source = mapping.source === null ? null : this._sources.at(mapping.source);
	        if (source != null && sourceRoot != null) {
	          source = util.join(sourceRoot, source);
	        }
	        return {
	          source: source,
	          generatedLine: mapping.generatedLine,
	          generatedColumn: mapping.generatedColumn,
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: mapping.name === null ? null : this._names.at(mapping.name)
	        };
	      }, this).forEach(aCallback, context);
	    };
	
	  /**
	   * Returns all generated line and column information for the original source,
	   * line, and column provided. If no column is provided, returns all mappings
	   * corresponding to a either the line we are searching for or the next
	   * closest line that has any mappings. Otherwise, returns all mappings
	   * corresponding to the given line and either the column we are searching for
	   * or the next closest column that has any offsets.
	   *
	   * The only argument is an object with the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: Optional. the column number in the original source.
	   *
	   * and an array of objects is returned, each with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  SourceMapConsumer.prototype.allGeneratedPositionsFor =
	    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	      var line = util.getArg(aArgs, 'line');
	
	      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	      // returns the index of the closest mapping less than the needle. By
	      // setting needle.originalColumn to 0, we thus find the last mapping for
	      // the given line, provided such a mapping exists.
	      var needle = {
	        source: util.getArg(aArgs, 'source'),
	        originalLine: line,
	        originalColumn: util.getArg(aArgs, 'column', 0)
	      };
	
	      if (this.sourceRoot != null) {
	        needle.source = util.relative(this.sourceRoot, needle.source);
	      }
	      if (!this._sources.has(needle.source)) {
	        return [];
	      }
	      needle.source = this._sources.indexOf(needle.source);
	
	      var mappings = [];
	
	      var index = this._findMapping(needle,
	                                    this._originalMappings,
	                                    "originalLine",
	                                    "originalColumn",
	                                    util.compareByOriginalPositions,
	                                    binarySearch.LEAST_UPPER_BOUND);
	      if (index >= 0) {
	        var mapping = this._originalMappings[index];
	
	        if (aArgs.column === undefined) {
	          var originalLine = mapping.originalLine;
	
	          // Iterate until either we run out of mappings, or we run into
	          // a mapping for a different line than the one we found. Since
	          // mappings are sorted, this is guaranteed to find all mappings for
	          // the line we found.
	          while (mapping && mapping.originalLine === originalLine) {
	            mappings.push({
	              line: util.getArg(mapping, 'generatedLine', null),
	              column: util.getArg(mapping, 'generatedColumn', null),
	              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	            });
	
	            mapping = this._originalMappings[++index];
	          }
	        } else {
	          var originalColumn = mapping.originalColumn;
	
	          // Iterate until either we run out of mappings, or we run into
	          // a mapping for a different line than the one we were searching for.
	          // Since mappings are sorted, this is guaranteed to find all mappings for
	          // the line we are searching for.
	          while (mapping &&
	                 mapping.originalLine === line &&
	                 mapping.originalColumn == originalColumn) {
	            mappings.push({
	              line: util.getArg(mapping, 'generatedLine', null),
	              column: util.getArg(mapping, 'generatedColumn', null),
	              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	            });
	
	            mapping = this._originalMappings[++index];
	          }
	        }
	      }
	
	      return mappings;
	    };
	
	  exports.SourceMapConsumer = SourceMapConsumer;
	
	  /**
	   * A BasicSourceMapConsumer instance represents a parsed source map which we can
	   * query for information about the original file positions by giving it a file
	   * position in the generated source.
	   *
	   * The only parameter is the raw source map (either as a JSON string, or
	   * already parsed to an object). According to the spec, source maps have the
	   * following attributes:
	   *
	   *   - version: Which version of the source map spec this map is following.
	   *   - sources: An array of URLs to the original source files.
	   *   - names: An array of identifiers which can be referrenced by individual mappings.
	   *   - sourceRoot: Optional. The URL root from which all sources are relative.
	   *   - sourcesContent: Optional. An array of contents of the original source files.
	   *   - mappings: A string of base64 VLQs which contain the actual mappings.
	   *   - file: Optional. The generated file this source map is associated with.
	   *
	   * Here is an example source map, taken from the source map spec[0]:
	   *
	   *     {
	   *       version : 3,
	   *       file: "out.js",
	   *       sourceRoot : "",
	   *       sources: ["foo.js", "bar.js"],
	   *       names: ["src", "maps", "are", "fun"],
	   *       mappings: "AA,AB;;ABCDE;"
	   *     }
	   *
	   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	   */
	  function BasicSourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    var version = util.getArg(sourceMap, 'version');
	    var sources = util.getArg(sourceMap, 'sources');
	    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	    // requires the array) to play nice here.
	    var names = util.getArg(sourceMap, 'names', []);
	    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	    var mappings = util.getArg(sourceMap, 'mappings');
	    var file = util.getArg(sourceMap, 'file', null);
	
	    // Once again, Sass deviates from the spec and supplies the version as a
	    // string rather than a number, so we use loose equality checking here.
	    if (version != this._version) {
	      throw new Error('Unsupported version: ' + version);
	    }
	
	    sources = sources
	      // Some source maps produce relative source paths like "./foo.js" instead of
	      // "foo.js".  Normalize these first so that future comparisons will succeed.
	      // See bugzil.la/1090768.
	      .map(util.normalize)
	      // Always ensure that absolute sources are internally stored relative to
	      // the source root, if the source root is absolute. Not doing this would
	      // be particularly problematic when the source root is a prefix of the
	      // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	      .map(function (source) {
	        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	          ? util.relative(sourceRoot, source)
	          : source;
	      });
	
	    // Pass `true` below to allow duplicate names and sources. While source maps
	    // are intended to be compressed and deduplicated, the TypeScript compiler
	    // sometimes generates source maps with duplicates in them. See Github issue
	    // #72 and bugzil.la/889492.
	    this._names = ArraySet.fromArray(names, true);
	    this._sources = ArraySet.fromArray(sources, true);
	
	    this.sourceRoot = sourceRoot;
	    this.sourcesContent = sourcesContent;
	    this._mappings = mappings;
	    this.file = file;
	  }
	
	  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
	
	  /**
	   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	   *
	   * @param SourceMapGenerator aSourceMap
	   *        The source map that will be consumed.
	   * @returns BasicSourceMapConsumer
	   */
	  BasicSourceMapConsumer.fromSourceMap =
	    function SourceMapConsumer_fromSourceMap(aSourceMap) {
	      var smc = Object.create(BasicSourceMapConsumer.prototype);
	
	      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	      smc.sourceRoot = aSourceMap._sourceRoot;
	      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                              smc.sourceRoot);
	      smc.file = aSourceMap._file;
	
	      // Because we are modifying the entries (by converting string sources and
	      // names to indices into the sources and names ArraySets), we have to make
	      // a copy of the entry or else bad things happen. Shared mutable state
	      // strikes again! See github issue #191.
	
	      var generatedMappings = aSourceMap._mappings.toArray().slice();
	      var destGeneratedMappings = smc.__generatedMappings = [];
	      var destOriginalMappings = smc.__originalMappings = [];
	
	      for (var i = 0, length = generatedMappings.length; i < length; i++) {
	        var srcMapping = generatedMappings[i];
	        var destMapping = new Mapping;
	        destMapping.generatedLine = srcMapping.generatedLine;
	        destMapping.generatedColumn = srcMapping.generatedColumn;
	
	        if (srcMapping.source) {
	          destMapping.source = sources.indexOf(srcMapping.source);
	          destMapping.originalLine = srcMapping.originalLine;
	          destMapping.originalColumn = srcMapping.originalColumn;
	
	          if (srcMapping.name) {
	            destMapping.name = names.indexOf(srcMapping.name);
	          }
	
	          destOriginalMappings.push(destMapping);
	        }
	
	        destGeneratedMappings.push(destMapping);
	      }
	
	      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
	
	      return smc;
	    };
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  BasicSourceMapConsumer.prototype._version = 3;
	
	  /**
	   * The list of original sources.
	   */
	  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	    get: function () {
	      return this._sources.toArray().map(function (s) {
	        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
	      }, this);
	    }
	  });
	
	  /**
	   * Provide the JIT with a nice shape / hidden class.
	   */
	  function Mapping() {
	    this.generatedLine = 0;
	    this.generatedColumn = 0;
	    this.source = null;
	    this.originalLine = null;
	    this.originalColumn = null;
	    this.name = null;
	  }
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  BasicSourceMapConsumer.prototype._parseMappings =
	    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      var generatedLine = 1;
	      var previousGeneratedColumn = 0;
	      var previousOriginalLine = 0;
	      var previousOriginalColumn = 0;
	      var previousSource = 0;
	      var previousName = 0;
	      var length = aStr.length;
	      var index = 0;
	      var cachedSegments = {};
	      var temp = {};
	      var originalMappings = [];
	      var generatedMappings = [];
	      var mapping, str, segment, end, value;
	
	      while (index < length) {
	        if (aStr.charAt(index) === ';') {
	          generatedLine++;
	          index++;
	          previousGeneratedColumn = 0;
	        }
	        else if (aStr.charAt(index) === ',') {
	          index++;
	        }
	        else {
	          mapping = new Mapping();
	          mapping.generatedLine = generatedLine;
	
	          // Because each offset is encoded relative to the previous one,
	          // many segments often have the same encoding. We can exploit this
	          // fact by caching the parsed variable length fields of each segment,
	          // allowing us to avoid a second parse if we encounter the same
	          // segment again.
	          for (end = index; end < length; end++) {
	            if (this._charIsMappingSeparator(aStr, end)) {
	              break;
	            }
	          }
	          str = aStr.slice(index, end);
	
	          segment = cachedSegments[str];
	          if (segment) {
	            index += str.length;
	          } else {
	            segment = [];
	            while (index < end) {
	              base64VLQ.decode(aStr, index, temp);
	              value = temp.value;
	              index = temp.rest;
	              segment.push(value);
	            }
	
	            if (segment.length === 2) {
	              throw new Error('Found a source, but no line and column');
	            }
	
	            if (segment.length === 3) {
	              throw new Error('Found a source and line, but no column');
	            }
	
	            cachedSegments[str] = segment;
	          }
	
	          // Generated column.
	          mapping.generatedColumn = previousGeneratedColumn + segment[0];
	          previousGeneratedColumn = mapping.generatedColumn;
	
	          if (segment.length > 1) {
	            // Original source.
	            mapping.source = previousSource + segment[1];
	            previousSource += segment[1];
	
	            // Original line.
	            mapping.originalLine = previousOriginalLine + segment[2];
	            previousOriginalLine = mapping.originalLine;
	            // Lines are stored 0-based
	            mapping.originalLine += 1;
	
	            // Original column.
	            mapping.originalColumn = previousOriginalColumn + segment[3];
	            previousOriginalColumn = mapping.originalColumn;
	
	            if (segment.length > 4) {
	              // Original name.
	              mapping.name = previousName + segment[4];
	              previousName += segment[4];
	            }
	          }
	
	          generatedMappings.push(mapping);
	          if (typeof mapping.originalLine === 'number') {
	            originalMappings.push(mapping);
	          }
	        }
	      }
	
	      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
	      this.__generatedMappings = generatedMappings;
	
	      quickSort(originalMappings, util.compareByOriginalPositions);
	      this.__originalMappings = originalMappings;
	    };
	
	  /**
	   * Find the mapping that best matches the hypothetical "needle" mapping that
	   * we are searching for in the given "haystack" of mappings.
	   */
	  BasicSourceMapConsumer.prototype._findMapping =
	    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                           aColumnName, aComparator, aBias) {
	      // To return the position we are searching for, we must first find the
	      // mapping for the given position and then return the opposite position it
	      // points to. Because the mappings are sorted, we can use binary search to
	      // find the best mapping.
	
	      if (aNeedle[aLineName] <= 0) {
	        throw new TypeError('Line must be greater than or equal to 1, got '
	                            + aNeedle[aLineName]);
	      }
	      if (aNeedle[aColumnName] < 0) {
	        throw new TypeError('Column must be greater than or equal to 0, got '
	                            + aNeedle[aColumnName]);
	      }
	
	      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	    };
	
	  /**
	   * Compute the last column for each generated mapping. The last column is
	   * inclusive.
	   */
	  BasicSourceMapConsumer.prototype.computeColumnSpans =
	    function SourceMapConsumer_computeColumnSpans() {
	      for (var index = 0; index < this._generatedMappings.length; ++index) {
	        var mapping = this._generatedMappings[index];
	
	        // Mappings do not contain a field for the last generated columnt. We
	        // can come up with an optimistic estimate, however, by assuming that
	        // mappings are contiguous (i.e. given two consecutive mappings, the
	        // first mapping ends where the second one starts).
	        if (index + 1 < this._generatedMappings.length) {
	          var nextMapping = this._generatedMappings[index + 1];
	
	          if (mapping.generatedLine === nextMapping.generatedLine) {
	            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	            continue;
	          }
	        }
	
	        // The last mapping for each line spans the entire line.
	        mapping.lastGeneratedColumn = Infinity;
	      }
	    };
	
	  /**
	   * Returns the original source, line, and column information for the generated
	   * source's line and column positions provided. The only argument is an object
	   * with the following properties:
	   *
	   *   - line: The line number in the generated source.
	   *   - column: The column number in the generated source.
	   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - source: The original source file, or null.
	   *   - line: The line number in the original source, or null.
	   *   - column: The column number in the original source, or null.
	   *   - name: The original identifier, or null.
	   */
	  BasicSourceMapConsumer.prototype.originalPositionFor =
	    function SourceMapConsumer_originalPositionFor(aArgs) {
	      var needle = {
	        generatedLine: util.getArg(aArgs, 'line'),
	        generatedColumn: util.getArg(aArgs, 'column')
	      };
	
	      var index = this._findMapping(
	        needle,
	        this._generatedMappings,
	        "generatedLine",
	        "generatedColumn",
	        util.compareByGeneratedPositionsDeflated,
	        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	      );
	
	      if (index >= 0) {
	        var mapping = this._generatedMappings[index];
	
	        if (mapping.generatedLine === needle.generatedLine) {
	          var source = util.getArg(mapping, 'source', null);
	          if (source !== null) {
	            source = this._sources.at(source);
	            if (this.sourceRoot != null) {
	              source = util.join(this.sourceRoot, source);
	            }
	          }
	          var name = util.getArg(mapping, 'name', null);
	          if (name !== null) {
	            name = this._names.at(name);
	          }
	          return {
	            source: source,
	            line: util.getArg(mapping, 'originalLine', null),
	            column: util.getArg(mapping, 'originalColumn', null),
	            name: name
	          };
	        }
	      }
	
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    };
	
	  /**
	   * Return true if we have the source content for every source in the source
	   * map, false otherwise.
	   */
	  BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	    function BasicSourceMapConsumer_hasContentsOfAllSources() {
	      if (!this.sourcesContent) {
	        return false;
	      }
	      return this.sourcesContent.length >= this._sources.size() &&
	        !this.sourcesContent.some(function (sc) { return sc == null; });
	    };
	
	  /**
	   * Returns the original source content. The only argument is the url of the
	   * original source file. Returns null if no original source content is
	   * available.
	   */
	  BasicSourceMapConsumer.prototype.sourceContentFor =
	    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	      if (!this.sourcesContent) {
	        return null;
	      }
	
	      if (this.sourceRoot != null) {
	        aSource = util.relative(this.sourceRoot, aSource);
	      }
	
	      if (this._sources.has(aSource)) {
	        return this.sourcesContent[this._sources.indexOf(aSource)];
	      }
	
	      var url;
	      if (this.sourceRoot != null
	          && (url = util.urlParse(this.sourceRoot))) {
	        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	        // many users. We can help them out when they expect file:// URIs to
	        // behave like it would if they were running a local HTTP server. See
	        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
	        if (url.scheme == "file"
	            && this._sources.has(fileUriAbsPath)) {
	          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	        }
	
	        if ((!url.path || url.path == "/")
	            && this._sources.has("/" + aSource)) {
	          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
	        }
	      }
	
	      // This function is used recursively from
	      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	      // don't want to throw if we can't find the source - we just want to
	      // return null, so we provide a flag to exit gracefully.
	      if (nullOnMissing) {
	        return null;
	      }
	      else {
	        throw new Error('"' + aSource + '" is not in the SourceMap.');
	      }
	    };
	
	  /**
	   * Returns the generated line and column information for the original source,
	   * line, and column positions provided. The only argument is an object with
	   * the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: The column number in the original source.
	   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  BasicSourceMapConsumer.prototype.generatedPositionFor =
	    function SourceMapConsumer_generatedPositionFor(aArgs) {
	      var source = util.getArg(aArgs, 'source');
	      if (this.sourceRoot != null) {
	        source = util.relative(this.sourceRoot, source);
	      }
	      if (!this._sources.has(source)) {
	        return {
	          line: null,
	          column: null,
	          lastColumn: null
	        };
	      }
	      source = this._sources.indexOf(source);
	
	      var needle = {
	        source: source,
	        originalLine: util.getArg(aArgs, 'line'),
	        originalColumn: util.getArg(aArgs, 'column')
	      };
	
	      var index = this._findMapping(
	        needle,
	        this._originalMappings,
	        "originalLine",
	        "originalColumn",
	        util.compareByOriginalPositions,
	        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	      );
	
	      if (index >= 0) {
	        var mapping = this._originalMappings[index];
	
	        if (mapping.source === needle.source) {
	          return {
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          };
	        }
	      }
	
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    };
	
	  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
	
	  /**
	   * An IndexedSourceMapConsumer instance represents a parsed source map which
	   * we can query for information. It differs from BasicSourceMapConsumer in
	   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	   * input.
	   *
	   * The only parameter is a raw source map (either as a JSON string, or already
	   * parsed to an object). According to the spec for indexed source maps, they
	   * have the following attributes:
	   *
	   *   - version: Which version of the source map spec this map is following.
	   *   - file: Optional. The generated file this source map is associated with.
	   *   - sections: A list of section definitions.
	   *
	   * Each value under the "sections" field has two fields:
	   *   - offset: The offset into the original specified at which this section
	   *       begins to apply, defined as an object with a "line" and "column"
	   *       field.
	   *   - map: A source map definition. This source map could also be indexed,
	   *       but doesn't have to be.
	   *
	   * Instead of the "map" field, it's also possible to have a "url" field
	   * specifying a URL to retrieve a source map from, but that's currently
	   * unsupported.
	   *
	   * Here's an example source map, taken from the source map spec[0], but
	   * modified to omit a section which uses the "url" field.
	   *
	   *  {
	   *    version : 3,
	   *    file: "app.js",
	   *    sections: [{
	   *      offset: {line:100, column:10},
	   *      map: {
	   *        version : 3,
	   *        file: "section.js",
	   *        sources: ["foo.js", "bar.js"],
	   *        names: ["src", "maps", "are", "fun"],
	   *        mappings: "AAAA,E;;ABCDE;"
	   *      }
	   *    }],
	   *  }
	   *
	   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	   */
	  function IndexedSourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    var version = util.getArg(sourceMap, 'version');
	    var sections = util.getArg(sourceMap, 'sections');
	
	    if (version != this._version) {
	      throw new Error('Unsupported version: ' + version);
	    }
	
	    this._sources = new ArraySet();
	    this._names = new ArraySet();
	
	    var lastOffset = {
	      line: -1,
	      column: 0
	    };
	    this._sections = sections.map(function (s) {
	      if (s.url) {
	        // The url field will require support for asynchronicity.
	        // See https://github.com/mozilla/source-map/issues/16
	        throw new Error('Support for url field in sections not implemented.');
	      }
	      var offset = util.getArg(s, 'offset');
	      var offsetLine = util.getArg(offset, 'line');
	      var offsetColumn = util.getArg(offset, 'column');
	
	      if (offsetLine < lastOffset.line ||
	          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	        throw new Error('Section offsets must be ordered and non-overlapping.');
	      }
	      lastOffset = offset;
	
	      return {
	        generatedOffset: {
	          // The offset fields are 0-based, but we use 1-based indices when
	          // encoding/decoding from VLQ.
	          generatedLine: offsetLine + 1,
	          generatedColumn: offsetColumn + 1
	        },
	        consumer: new SourceMapConsumer(util.getArg(s, 'map'))
	      }
	    });
	  }
	
	  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  IndexedSourceMapConsumer.prototype._version = 3;
	
	  /**
	   * The list of original sources.
	   */
	  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	    get: function () {
	      var sources = [];
	      for (var i = 0; i < this._sections.length; i++) {
	        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	          sources.push(this._sections[i].consumer.sources[j]);
	        }
	      }
	      return sources;
	    }
	  });
	
	  /**
	   * Returns the original source, line, and column information for the generated
	   * source's line and column positions provided. The only argument is an object
	   * with the following properties:
	   *
	   *   - line: The line number in the generated source.
	   *   - column: The column number in the generated source.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - source: The original source file, or null.
	   *   - line: The line number in the original source, or null.
	   *   - column: The column number in the original source, or null.
	   *   - name: The original identifier, or null.
	   */
	  IndexedSourceMapConsumer.prototype.originalPositionFor =
	    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	      var needle = {
	        generatedLine: util.getArg(aArgs, 'line'),
	        generatedColumn: util.getArg(aArgs, 'column')
	      };
	
	      // Find the section containing the generated position we're trying to map
	      // to an original position.
	      var sectionIndex = binarySearch.search(needle, this._sections,
	        function(needle, section) {
	          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	          if (cmp) {
	            return cmp;
	          }
	
	          return (needle.generatedColumn -
	                  section.generatedOffset.generatedColumn);
	        });
	      var section = this._sections[sectionIndex];
	
	      if (!section) {
	        return {
	          source: null,
	          line: null,
	          column: null,
	          name: null
	        };
	      }
	
	      return section.consumer.originalPositionFor({
	        line: needle.generatedLine -
	          (section.generatedOffset.generatedLine - 1),
	        column: needle.generatedColumn -
	          (section.generatedOffset.generatedLine === needle.generatedLine
	           ? section.generatedOffset.generatedColumn - 1
	           : 0),
	        bias: aArgs.bias
	      });
	    };
	
	  /**
	   * Return true if we have the source content for every source in the source
	   * map, false otherwise.
	   */
	  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	    function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	      return this._sections.every(function (s) {
	        return s.consumer.hasContentsOfAllSources();
	      });
	    };
	
	  /**
	   * Returns the original source content. The only argument is the url of the
	   * original source file. Returns null if no original source content is
	   * available.
	   */
	  IndexedSourceMapConsumer.prototype.sourceContentFor =
	    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	      for (var i = 0; i < this._sections.length; i++) {
	        var section = this._sections[i];
	
	        var content = section.consumer.sourceContentFor(aSource, true);
	        if (content) {
	          return content;
	        }
	      }
	      if (nullOnMissing) {
	        return null;
	      }
	      else {
	        throw new Error('"' + aSource + '" is not in the SourceMap.');
	      }
	    };
	
	  /**
	   * Returns the generated line and column information for the original source,
	   * line, and column positions provided. The only argument is an object with
	   * the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: The column number in the original source.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  IndexedSourceMapConsumer.prototype.generatedPositionFor =
	    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	      for (var i = 0; i < this._sections.length; i++) {
	        var section = this._sections[i];
	
	        // Only consider this section if the requested source is in the list of
	        // sources of the consumer.
	        if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
	          continue;
	        }
	        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	        if (generatedPosition) {
	          var ret = {
	            line: generatedPosition.line +
	              (section.generatedOffset.generatedLine - 1),
	            column: generatedPosition.column +
	              (section.generatedOffset.generatedLine === generatedPosition.line
	               ? section.generatedOffset.generatedColumn - 1
	               : 0)
	          };
	          return ret;
	        }
	      }
	
	      return {
	        line: null,
	        column: null
	      };
	    };
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  IndexedSourceMapConsumer.prototype._parseMappings =
	    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      this.__generatedMappings = [];
	      this.__originalMappings = [];
	      for (var i = 0; i < this._sections.length; i++) {
	        var section = this._sections[i];
	        var sectionMappings = section.consumer._generatedMappings;
	        for (var j = 0; j < sectionMappings.length; j++) {
	          var mapping = sectionMappings[j];
	
	          var source = section.consumer._sources.at(mapping.source);
	          if (section.consumer.sourceRoot !== null) {
	            source = util.join(section.consumer.sourceRoot, source);
	          }
	          this._sources.add(source);
	          source = this._sources.indexOf(source);
	
	          var name = section.consumer._names.at(mapping.name);
	          this._names.add(name);
	          name = this._names.indexOf(name);
	
	          // The mappings coming from the consumer for the section have
	          // generated positions relative to the start of the section, so we
	          // need to offset them to be relative to the start of the concatenated
	          // generated file.
	          var adjustedMapping = {
	            source: source,
	            generatedLine: mapping.generatedLine +
	              (section.generatedOffset.generatedLine - 1),
	            generatedColumn: mapping.generatedColumn +
	              (section.generatedOffset.generatedLine === mapping.generatedLine
	              ? section.generatedOffset.generatedColumn - 1
	              : 0),
	            originalLine: mapping.originalLine,
	            originalColumn: mapping.originalColumn,
	            name: name
	          };
	
	          this.__generatedMappings.push(adjustedMapping);
	          if (typeof adjustedMapping.originalLine === 'number') {
	            this.__originalMappings.push(adjustedMapping);
	          }
	        }
	      }
	
	      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	      quickSort(this.__originalMappings, util.compareByOriginalPositions);
	    };
	
	  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
	}


/***/ },
/* 24 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  exports.GREATEST_LOWER_BOUND = 1;
	  exports.LEAST_UPPER_BOUND = 2;
	
	  /**
	   * Recursive implementation of binary search.
	   *
	   * @param aLow Indices here and lower do not contain the needle.
	   * @param aHigh Indices here and higher do not contain the needle.
	   * @param aNeedle The element being searched for.
	   * @param aHaystack The non-empty array being searched.
	   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   */
	  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	    // This function terminates when one of the following is true:
	    //
	    //   1. We find the exact element we are looking for.
	    //
	    //   2. We did not find the exact element, but we can return the index of
	    //      the next-closest element.
	    //
	    //   3. We did not find the exact element, and there is no next-closest
	    //      element than the one we are searching for, so we return -1.
	    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	    var cmp = aCompare(aNeedle, aHaystack[mid], true);
	    if (cmp === 0) {
	      // Found the element we are looking for.
	      return mid;
	    }
	    else if (cmp > 0) {
	      // Our needle is greater than aHaystack[mid].
	      if (aHigh - mid > 1) {
	        // The element is in the upper half.
	        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
	      }
	
	      // The exact needle element was not found in this haystack. Determine if
	      // we are in termination case (3) or (2) and return the appropriate thing.
	      if (aBias == exports.LEAST_UPPER_BOUND) {
	        return aHigh < aHaystack.length ? aHigh : -1;
	      } else {
	        return mid;
	      }
	    }
	    else {
	      // Our needle is less than aHaystack[mid].
	      if (mid - aLow > 1) {
	        // The element is in the lower half.
	        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
	      }
	
	      // we are in termination case (3) or (2) and return the appropriate thing.
	      if (aBias == exports.LEAST_UPPER_BOUND) {
	        return mid;
	      } else {
	        return aLow < 0 ? -1 : aLow;
	      }
	    }
	  }
	
	  /**
	   * This is an implementation of binary search which will always try and return
	   * the index of the closest element if there is no exact hit. This is because
	   * mappings between original and generated line/col pairs are single points,
	   * and there is an implicit region between each of them, so a miss just means
	   * that you aren't on the very start of a region.
	   *
	   * @param aNeedle The element you are looking for.
	   * @param aHaystack The array that is being searched.
	   * @param aCompare A function which takes the needle and an element in the
	   *     array and returns -1, 0, or 1 depending on whether the needle is less
	   *     than, equal to, or greater than the element, respectively.
	   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	   */
	  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	    if (aHaystack.length === 0) {
	      return -1;
	    }
	
	    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
	                                aCompare, aBias || exports.GREATEST_LOWER_BOUND);
	    if (index < 0) {
	      return -1;
	    }
	
	    // We have found either the exact element, or the next-closest element than
	    // the one we are searching for. However, there may be more than one such
	    // element. Make sure we always return the smallest of these.
	    while (index - 1 >= 0) {
	      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
	        break;
	      }
	      --index;
	    }
	
	    return index;
	  };
	}


/***/ },
/* 25 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  // It turns out that some (most?) JavaScript engines don't self-host
	  // `Array.prototype.sort`. This makes sense because C++ will likely remain
	  // faster than JS when doing raw CPU-intensive sorting. However, when using a
	  // custom comparator function, calling back and forth between the VM's C++ and
	  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
	  // worse generated code for the comparator function than would be optimal. In
	  // fact, when sorting with a comparator, these costs outweigh the benefits of
	  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	  // a ~3500ms mean speed-up in `bench/bench.html`.
	
	  /**
	   * Swap the elements indexed by `x` and `y` in the array `ary`.
	   *
	   * @param {Array} ary
	   *        The array.
	   * @param {Number} x
	   *        The index of the first item.
	   * @param {Number} y
	   *        The index of the second item.
	   */
	  function swap(ary, x, y) {
	    var temp = ary[x];
	    ary[x] = ary[y];
	    ary[y] = temp;
	  }
	
	  /**
	   * Returns a random integer within the range `low .. high` inclusive.
	   *
	   * @param {Number} low
	   *        The lower bound on the range.
	   * @param {Number} high
	   *        The upper bound on the range.
	   */
	  function randomIntInRange(low, high) {
	    return Math.round(low + (Math.random() * (high - low)));
	  }
	
	  /**
	   * The Quick Sort algorithm.
	   *
	   * @param {Array} ary
	   *        An array to sort.
	   * @param {function} comparator
	   *        Function to use to compare two items.
	   * @param {Number} p
	   *        Start index of the array
	   * @param {Number} r
	   *        End index of the array
	   */
	  function doQuickSort(ary, comparator, p, r) {
	    // If our lower bound is less than our upper bound, we (1) partition the
	    // array into two pieces and (2) recurse on each half. If it is not, this is
	    // the empty array and our base case.
	
	    if (p < r) {
	      // (1) Partitioning.
	      //
	      // The partitioning chooses a pivot between `p` and `r` and moves all
	      // elements that are less than or equal to the pivot to the before it, and
	      // all the elements that are greater than it after it. The effect is that
	      // once partition is done, the pivot is in the exact place it will be when
	      // the array is put in sorted order, and it will not need to be moved
	      // again. This runs in O(n) time.
	
	      // Always choose a random pivot so that an input array which is reverse
	      // sorted does not cause O(n^2) running time.
	      var pivotIndex = randomIntInRange(p, r);
	      var i = p - 1;
	
	      swap(ary, pivotIndex, r);
	      var pivot = ary[r];
	
	      // Immediately after `j` is incremented in this loop, the following hold
	      // true:
	      //
	      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	      //
	      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	      for (var j = p; j < r; j++) {
	        if (comparator(ary[j], pivot) <= 0) {
	          i += 1;
	          swap(ary, i, j);
	        }
	      }
	
	      swap(ary, i + 1, j);
	      var q = i + 1;
	
	      // (2) Recurse on each half.
	
	      doQuickSort(ary, comparator, p, q - 1);
	      doQuickSort(ary, comparator, q + 1, r);
	    }
	  }
	
	  /**
	   * Sort the given array in-place with the given comparator function.
	   *
	   * @param {Array} ary
	   *        An array to sort.
	   * @param {function} comparator
	   *        Function to use to compare two items.
	   */
	  exports.quickSort = function (ary, comparator) {
	    doQuickSort(ary, comparator, 0, ary.length - 1);
	  };
	}


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	{
	  var SourceMapGenerator = __webpack_require__(17).SourceMapGenerator;
	  var util = __webpack_require__(20);
	
	  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	  // operating systems these days (capturing the result).
	  var REGEX_NEWLINE = /(\r?\n)/;
	
	  // Newline character code for charCodeAt() comparisons
	  var NEWLINE_CODE = 10;
	
	  // Private symbol for identifying `SourceNode`s when multiple versions of
	  // the source-map library are loaded. This MUST NOT CHANGE across
	  // versions!
	  var isSourceNode = "$$$isSourceNode$$$";
	
	  /**
	   * SourceNodes provide a way to abstract over interpolating/concatenating
	   * snippets of generated JavaScript source code while maintaining the line and
	   * column information associated with the original source code.
	   *
	   * @param aLine The original line number.
	   * @param aColumn The original column number.
	   * @param aSource The original source's filename.
	   * @param aChunks Optional. An array of strings which are snippets of
	   *        generated JS, or other SourceNodes.
	   * @param aName The original identifier.
	   */
	  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	    this.children = [];
	    this.sourceContents = {};
	    this.line = aLine == null ? null : aLine;
	    this.column = aColumn == null ? null : aColumn;
	    this.source = aSource == null ? null : aSource;
	    this.name = aName == null ? null : aName;
	    this[isSourceNode] = true;
	    if (aChunks != null) this.add(aChunks);
	  }
	
	  /**
	   * Creates a SourceNode from generated code and a SourceMapConsumer.
	   *
	   * @param aGeneratedCode The generated code
	   * @param aSourceMapConsumer The SourceMap for the generated code
	   * @param aRelativePath Optional. The path that relative sources in the
	   *        SourceMapConsumer should be relative to.
	   */
	  SourceNode.fromStringWithSourceMap =
	    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	      // The SourceNode we want to fill with the generated code
	      // and the SourceMap
	      var node = new SourceNode();
	
	      // All even indices of this array are one line of the generated code,
	      // while all odd indices are the newlines between two adjacent lines
	      // (since `REGEX_NEWLINE` captures its match).
	      // Processed fragments are removed from this array, by calling `shiftNextLine`.
	      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	      var shiftNextLine = function() {
	        var lineContents = remainingLines.shift();
	        // The last line of a file might not have a newline.
	        var newLine = remainingLines.shift() || "";
	        return lineContents + newLine;
	      };
	
	      // We need to remember the position of "remainingLines"
	      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
	
	      // The generate SourceNodes we need a code range.
	      // To extract it current and last mapping is used.
	      // Here we store the last mapping.
	      var lastMapping = null;
	
	      aSourceMapConsumer.eachMapping(function (mapping) {
	        if (lastMapping !== null) {
	          // We add the code from "lastMapping" to "mapping":
	          // First check if there is a new line in between.
	          if (lastGeneratedLine < mapping.generatedLine) {
	            // Associate first line with "lastMapping"
	            addMappingWithCode(lastMapping, shiftNextLine());
	            lastGeneratedLine++;
	            lastGeneratedColumn = 0;
	            // The remaining code is added without mapping
	          } else {
	            // There is no new line in between.
	            // Associate the code between "lastGeneratedColumn" and
	            // "mapping.generatedColumn" with "lastMapping"
	            var nextLine = remainingLines[0];
	            var code = nextLine.substr(0, mapping.generatedColumn -
	                                          lastGeneratedColumn);
	            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
	                                                lastGeneratedColumn);
	            lastGeneratedColumn = mapping.generatedColumn;
	            addMappingWithCode(lastMapping, code);
	            // No more remaining code, continue
	            lastMapping = mapping;
	            return;
	          }
	        }
	        // We add the generated code until the first mapping
	        // to the SourceNode without any mapping.
	        // Each line is added as separate string.
	        while (lastGeneratedLine < mapping.generatedLine) {
	          node.add(shiftNextLine());
	          lastGeneratedLine++;
	        }
	        if (lastGeneratedColumn < mapping.generatedColumn) {
	          var nextLine = remainingLines[0];
	          node.add(nextLine.substr(0, mapping.generatedColumn));
	          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	        }
	        lastMapping = mapping;
	      }, this);
	      // We have processed all mappings.
	      if (remainingLines.length > 0) {
	        if (lastMapping) {
	          // Associate the remaining code in the current line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	        }
	        // and add the remaining lines without any mapping
	        node.add(remainingLines.join(""));
	      }
	
	      // Copy sourcesContent into SourceNode
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content != null) {
	          if (aRelativePath != null) {
	            sourceFile = util.join(aRelativePath, sourceFile);
	          }
	          node.setSourceContent(sourceFile, content);
	        }
	      });
	
	      return node;
	
	      function addMappingWithCode(mapping, code) {
	        if (mapping === null || mapping.source === undefined) {
	          node.add(code);
	        } else {
	          var source = aRelativePath
	            ? util.join(aRelativePath, mapping.source)
	            : mapping.source;
	          node.add(new SourceNode(mapping.originalLine,
	                                  mapping.originalColumn,
	                                  source,
	                                  code,
	                                  mapping.name));
	        }
	      }
	    };
	
	  /**
	   * Add a chunk of generated JS to this source node.
	   *
	   * @param aChunk A string snippet of generated JS code, another instance of
	   *        SourceNode, or an array where each member is one of those things.
	   */
	  SourceNode.prototype.add = function SourceNode_add(aChunk) {
	    if (Array.isArray(aChunk)) {
	      aChunk.forEach(function (chunk) {
	        this.add(chunk);
	      }, this);
	    }
	    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	      if (aChunk) {
	        this.children.push(aChunk);
	      }
	    }
	    else {
	      throw new TypeError(
	        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	      );
	    }
	    return this;
	  };
	
	  /**
	   * Add a chunk of generated JS to the beginning of this source node.
	   *
	   * @param aChunk A string snippet of generated JS code, another instance of
	   *        SourceNode, or an array where each member is one of those things.
	   */
	  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	    if (Array.isArray(aChunk)) {
	      for (var i = aChunk.length-1; i >= 0; i--) {
	        this.prepend(aChunk[i]);
	      }
	    }
	    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	      this.children.unshift(aChunk);
	    }
	    else {
	      throw new TypeError(
	        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	      );
	    }
	    return this;
	  };
	
	  /**
	   * Walk over the tree of JS snippets in this node and its children. The
	   * walking function is called once for each snippet of JS and is passed that
	   * snippet and the its original associated source's line/column location.
	   *
	   * @param aFn The traversal function.
	   */
	  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	    var chunk;
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      chunk = this.children[i];
	      if (chunk[isSourceNode]) {
	        chunk.walk(aFn);
	      }
	      else {
	        if (chunk !== '') {
	          aFn(chunk, { source: this.source,
	                       line: this.line,
	                       column: this.column,
	                       name: this.name });
	        }
	      }
	    }
	  };
	
	  /**
	   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	   * each of `this.children`.
	   *
	   * @param aSep The separator.
	   */
	  SourceNode.prototype.join = function SourceNode_join(aSep) {
	    var newChildren;
	    var i;
	    var len = this.children.length;
	    if (len > 0) {
	      newChildren = [];
	      for (i = 0; i < len-1; i++) {
	        newChildren.push(this.children[i]);
	        newChildren.push(aSep);
	      }
	      newChildren.push(this.children[i]);
	      this.children = newChildren;
	    }
	    return this;
	  };
	
	  /**
	   * Call String.prototype.replace on the very right-most source snippet. Useful
	   * for trimming whitespace from the end of a source node, etc.
	   *
	   * @param aPattern The pattern to replace.
	   * @param aReplacement The thing to replace the pattern with.
	   */
	  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	    var lastChild = this.children[this.children.length - 1];
	    if (lastChild[isSourceNode]) {
	      lastChild.replaceRight(aPattern, aReplacement);
	    }
	    else if (typeof lastChild === 'string') {
	      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	    }
	    else {
	      this.children.push(''.replace(aPattern, aReplacement));
	    }
	    return this;
	  };
	
	  /**
	   * Set the source content for a source file. This will be added to the SourceMapGenerator
	   * in the sourcesContent field.
	   *
	   * @param aSourceFile The filename of the source file
	   * @param aSourceContent The content of the source file
	   */
	  SourceNode.prototype.setSourceContent =
	    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	    };
	
	  /**
	   * Walk over the tree of SourceNodes. The walking function is called for each
	   * source file content and is passed the filename and source content.
	   *
	   * @param aFn The traversal function.
	   */
	  SourceNode.prototype.walkSourceContents =
	    function SourceNode_walkSourceContents(aFn) {
	      for (var i = 0, len = this.children.length; i < len; i++) {
	        if (this.children[i][isSourceNode]) {
	          this.children[i].walkSourceContents(aFn);
	        }
	      }
	
	      var sources = Object.keys(this.sourceContents);
	      for (var i = 0, len = sources.length; i < len; i++) {
	        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	      }
	    };
	
	  /**
	   * Return the string representation of this source node. Walks over the tree
	   * and concatenates all the various snippets together to one string.
	   */
	  SourceNode.prototype.toString = function SourceNode_toString() {
	    var str = "";
	    this.walk(function (chunk) {
	      str += chunk;
	    });
	    return str;
	  };
	
	  /**
	   * Returns the string representation of this source node along with a source
	   * map.
	   */
	  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	    var generated = {
	      code: "",
	      line: 1,
	      column: 0
	    };
	    var map = new SourceMapGenerator(aArgs);
	    var sourceMappingActive = false;
	    var lastOriginalSource = null;
	    var lastOriginalLine = null;
	    var lastOriginalColumn = null;
	    var lastOriginalName = null;
	    this.walk(function (chunk, original) {
	      generated.code += chunk;
	      if (original.source !== null
	          && original.line !== null
	          && original.column !== null) {
	        if(lastOriginalSource !== original.source
	           || lastOriginalLine !== original.line
	           || lastOriginalColumn !== original.column
	           || lastOriginalName !== original.name) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	        lastOriginalSource = original.source;
	        lastOriginalLine = original.line;
	        lastOriginalColumn = original.column;
	        lastOriginalName = original.name;
	        sourceMappingActive = true;
	      } else if (sourceMappingActive) {
	        map.addMapping({
	          generated: {
	            line: generated.line,
	            column: generated.column
	          }
	        });
	        lastOriginalSource = null;
	        sourceMappingActive = false;
	      }
	      for (var idx = 0, length = chunk.length; idx < length; idx++) {
	        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	          generated.line++;
	          generated.column = 0;
	          // Mappings end at eol
	          if (idx + 1 === length) {
	            lastOriginalSource = null;
	            sourceMappingActive = false;
	          } else if (sourceMappingActive) {
	            map.addMapping({
	              source: original.source,
	              original: {
	                line: original.line,
	                column: original.column
	              },
	              generated: {
	                line: generated.line,
	                column: generated.column
	              },
	              name: original.name
	            });
	          }
	        } else {
	          generated.column++;
	        }
	      }
	    });
	    this.walkSourceContents(function (sourceFile, sourceContent) {
	      map.setSourceContent(sourceFile, sourceContent);
	    });
	
	    return { code: generated.code, map: map };
	  };
	
	  exports.SourceNode = SourceNode;
	}


/***/ },
/* 27 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		
		function Region(a,b,root,view){
			this._a = a;
			this._b = b;
			this._root = root;
			this._view = view;
			return this;
		};
		
		exports.Region = Region; // export class 
		
		
		Region.prototype.a = function(v){ return this._a; }
		Region.prototype.setA = function(v){ this._a = v; return this; };
		
		
		Region.prototype.b = function(v){ return this._b; }
		Region.prototype.setB = function(v){ this._b = v; return this; };
		
		
		Region.prototype.view = function(v){ return this._view; }
		Region.prototype.setView = function(v){ this._view = v; return this; };
		
		
		Region.prototype.root = function(v){ return this._root; }
		Region.prototype.setRoot = function(v){ this._root = v; return this; };
		
		// remove root from region
		
		Region.normalize = function (val,view){
			var line_;
			if (val instanceof Region) { return val };
			if (val instanceof Array) { return new Region(val[0],val[1],null,view) };
			if ((typeof val=='number'||val instanceof Number)) { return new Region(val,val,null,view) };
			
			if ((val instanceof Object) && (typeof (line_ = val.line)=='number'||line_ instanceof Number)) {
				var lines = view._buffer.lines();
				var loc = 0;
				for (var i = 0, ary = iter$(lines), len = ary.length; i < len; i++) {
					if (i < (val.line - 1)) {
						loc += ary[i].length + 1;
					} else {
						break;
					};
				};
				
				loc += (val.column || 0);
				return new Region(loc,loc,null,view);
			};
		};
		
		
		Region.prototype.start = function (){
			return Math.min(this._a,this._b);
		};
		
		Region.prototype.end = function (){
			return Math.max(this._a,this._b);
		};
		
		Region.prototype.clone = function (ad,bd){
			if(ad === undefined) ad = 0;
			if(bd === undefined) bd = 0;
			return new Region(this._a + ad,this._b + bd,this._root,this._view);
		};
		
		Region.prototype.contains = function (rel){
			if (rel instanceof Region) {
				return this.start() <= rel.start() && this.end() >= rel.end();
			} else if ((typeof rel=='number'||rel instanceof Number)) {
				return this.start() <= rel && this.end() >= rel;
			};
		};
		
		Region.prototype.adjust = function (rel,add){
			if(add === undefined) add = true;
			if (rel.end() < this.start()) {
				add ? (this.move(rel.size())) : (this.move(-rel.size()));
			};
			return this;
		};
		
		Region.prototype.intersects = function (rel){
			// is this decent?
			rel = Region.normalize(rel);
			var a = Math.max(this.start(),rel.start());
			var b = Math.min(this.end(),rel.end());
			return b >= a;
		};
		
		Region.prototype.relativeTo = function (rel){
			// could use move instead
			return new Region(this._a - rel.start(),this._b - rel.start(),this._root,this._view);
		};
		
		Region.prototype.intersection = function (region){
			return this;
		};
		
		Region.prototype.equals = function (region){
			return this.start() == region.start() && this.end() == region.end();
		};
		
		Region.prototype.same = function (region){
			return region && region.a() == this.a() && region.b() == this.b();
		};
		
		Region.prototype.size = function (){
			return this.end() - this.start();
		};
		
		Region.prototype.move = function (num){
			if(num === undefined) num = 1;
			this._a += num;
			this._b += num;
			return this;
		};
		
		Region.prototype.collapsed = function (){
			return this.size() == 0;
		};
		
		Region.prototype.reverse = function (){
			var a = this._a,b = this._b;
			this._a = b;
			this._b = a;
			return this;
		};
		
		Region.prototype.reversed = function (){
			return this._a > this._b;
		};
		
		Region.prototype.normalize = function (){
			var a = this.start();
			var b = this.end();
			this._a = a;
			this._b = b;
			return this;
		};
		
		Region.prototype.collapse = function (forward){
			if(forward === undefined) forward = true;
			if (forward) {
				this._a = this._b = this.end();
				// @a = @b
			} else {
				this._b = this._a;
				this._a = this._b = this.start();
			};
			return this;
		};
		
		// expand to closest /n
		Region.prototype.expand = function (atStart,atEnd){
			if (this.b() < this.a()) {
				this._b += atStart;
				this._a += atEnd;
			} else {
				this._a += atStart;
				this._b += atEnd;
			};
			return this;
		};
		
		Region.prototype.text = function (){
			return this.view().substr(this);
		};
		
		Region.prototype.toString = function (){
			return ("[" + (this._a) + "," + (this._b) + "]");
		};
		
		Region.prototype.insert = function (node){
			return this;
		};
		
		Region.prototype.nodes = function (includeEnds){
			if(includeEnds === undefined) includeEnds = true;
			return this.view().nodesInRegion(this,includeEnds);
		};
		
		Region.prototype.prevNode = function (query){
			var nodes = this.nodes(false);
			var node = nodes.lft;
			if ((query instanceof Imba.Selector) || (typeof query=='string'||query instanceof String)) {
				var $1;while (node){
					if (node.matches(query)) { return node };
					node = ($1 = node) && $1.isLast  &&  $1.isLast() ? (node.parent()) : (null);
				};
				return null;
			};
			return node;
		};
		
		Region.prototype.nextNode = function (query){
			var nodes = this.nodes(false);
			var node = nodes.rgt;
			if ((query instanceof Imba.Selector) || (typeof query=='string'||query instanceof String)) {
				var $1;while (node){
					if (node.matches(query)) { return node };
					node = ($1 = node) && $1.isFirst  &&  $1.isFirst() ? (node.parent()) : (null);
				};
				return null;
			};
			return node;
		};
		
		Region.prototype.scope = function (query){
			var nodes = this.nodes(false);
			var node;
			if (nodes.lft) {
				node = nodes.lft.up(query);
			} else if (nodes.rgt) {
				node || (node = nodes.rgt.up(query));
			} else if (nodes[0]) {
				node || (node = nodes[0].node.closest(query));
			};
			return node;
		};
		
		Region.prototype.buffer = function (){
			return this._root.code();
		};
		
		Region.prototype.startAtLine = function (){
			this.normalize();
			var buffer = this.buffer();
			var a = this.start();
			
			if (buffer[a] == '\n' && this.size() == 0) {
				a--; // if we are at the end of a line
			};
			
			while (a >= 0 && buffer[a] != '\n'){
				a--;
			};
			this._a = a;
			return this;
		};
		
		Region.prototype.endAtLine = function (){
			this.normalize();
			var buffer = this.buffer();
			var b = (this.end() - 1);
			while (b >= 0 && buffer[b] && buffer[b] != '\n'){
				b++;
			};
			this._b = b;
			return this;
		};
		
		Region.prototype.cell = function (){
			return this.view()._buffer.locToCell(this.a());
		};
		
		Region.prototype.row = function (){
			return this.cell()[0];
		};
		
		Region.prototype.col = function (){
			return this.cell()[1];
		};
		
		Region.prototype.peekbehind = function (len){
			if(len === undefined) len = 1;
			return len == 1 ? (this.buffer()[this.start() - 1]) : (this.buffer().substring(this.start() - len,this.start()));
		};
		
		Region.prototype.peekahead = function (len){
			if(len === undefined) len = 1;
			return len == 1 ? (this.buffer()[this.end()]) : (this.buffer().substr(this.end(),len));
		};
		
		Region.prototype.indent = function (){
			return this.clone().startAtLine().text().match(/^\n?(\t*)/)[1];
		};
		
		Region.prototype.peek = function (before,after){
			if(before === undefined) before = 0;
			if(after === undefined) after = 0;
			return this.clone(before,after).text();
		};
		
		Region.prototype.lloc = function (){
			return {startLine: 0,startCol: 2};
		};
		
		Region.prototype.toJSON = function (){
			return [this.a(),this.b()];
		};
		return Region;
	
	})()

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		
		var KEYWORDS = 'var if elif else for while def in isa while until switch when then return class tag let do and or prop attr in prop'.split(' ');
		var OPS = '+ - * / = ++ -- == === != !== > < >= <= & && | || or . : ?'.split(' ');
		
		var WHITESPACE = /^[ \t\n]+$/;
		
		IM.HL = {
			newline: "<b class='_imnewline'>\n</b>",
			space: function(m) { return ("<b class='_imspace'>" + m + "</b>"); },
			tab: function(m) { return new Array(m.length + 1).join("<b class='_imtab'>\t</b>"); }
		};
		
		
		var Region = __webpack_require__(27).Region;
		var Highlighter = __webpack_require__(29).Highlighter;
		
		var MATCHERS = {
			keyword: function(v) { return KEYWORDS.indexOf(v) >= 0; },
			self: /^(this|self)$/,
			const: function(v) { return (/^[A-Z][\w\_]*$/).test(v); },
			ivar: function(v) { return (/^@[\w\_]+$/).test(v); },
			bool: function(v) { return (/^(true|yes|false|no|null|undefined)$/).test(v); },
			identifier: /^[\$a-z_][\w\_\$]*(\-[\$\w\_]+)*$/,
			float: /^\d+\.\d+$/,
			int: /^\d+$/,
			comment: /^\#([ \t][^\n]*)?$/
		};
		
		var MODES = {
			all: Object.keys(MATCHERS)
		};
		
		
			
			String.prototype.repeat = function (num){
				return new Array(num + 1).join(this);
			};
			
			String.prototype.ins = function (str,region){
				var text = this.toString();
				if (region == 'append') {
					return text + str;
				} else if (region == 'prepend') {
					return "" + str + text;
				} else if (region instanceof Region) {
					return text.substr(0,region.start()) + str + text.slice(region.end());
				};
			};
		
		
		function isWhitespace(str){
			return WHITESPACE.test(str);
		}; exports.isWhitespace = isWhitespace;
		
		IM.num = function (val){
			return tag$.$imnum().flag('number').setText(val).end();
		};
		
		IM.tab = function (){
			return tag$.$imtab().setText('\t').end();
		};
		
		IM.newline = function (){
			return tag$.$imnewline().setText('\n').end();
		};
		
		IM.op = function (val){
			return tag$.$imop().flag('op').setText(val).end();
		};
		
		
		IM.tok = function (val){
			if (val && val._dom) { return val };
			if (val.match(WHITESPACE)) { return IM.parseWhitespace(val) };
			if (OPS.indexOf(val) >= 0) { return IM.op(val) }; // should use token directly
			// return IM.num(val) if val.match(/^\d+(\.\d+)?$/) # should use token directly
			return tag$.$imtok().setText(val).end();
		};
		
		IM.raw = function (val,ctx){
			return tag$.$imraw().setRaw(val).end();
		};
		
		IM.isWhitespace = function (val){
			return WHITESPACE.test(val);
		};
		
		IM.isOp = function (val){
			return OPS.indexOf(val) >= 0;
		};
		
		IM.parseWhitespace = function (text,rich){
			if(rich === undefined) rich = true;
			var hl = IM.HL;
			
			text = text.replace(/(\n|[ ]+|[\t]+)/g,function(m,l) {
				if (l == '\n') {
					return hl.newline || '\n';
				} else if (l[0] == ' ') {
					return hl.space instanceof Function ? (hl.space(l)) : (l);
				} else if (l[0] == '\t') {
					return hl.tab instanceof Function ? (hl.tab(l)) : (l);
				};
			});
			
			if (rich && text.indexOf('<') >= 0) {
				return tag$.$imfragment().setContent(text,0).end();
			};
			
			return text;
		};
		
		IM.identify = function (val,mode){
			if(mode === undefined) mode = 'all';
			var rules = MODES[mode];
			var res;
			for (var i = 0, ary = iter$(rules), len = ary.length, name; i < len; i++) {
				name = ary[i];
				var rule = MATCHERS[name];
				
				if (rule instanceof Function) {
					res = rule(val,mode);
				} else if (rule instanceof RegExp) {
					res = rule.test(val);
				};
				
				if (res) {
					return res === true ? (name) : (res);
				};
			};
			
			return null;
		};
		
		IM.parse = function (code,context){
			// decide if full?
			// console.log "parse code {code:length} {code.substr(0,20)}"
			if (typeof code != 'string') { return code };
			
			if (WHITESPACE.test(code)) {
				return IM.parseWhitespace(code,false);
			};
			
			var ws = code.match(/^([ \t]*)([^]*?)([ \t]*)$/) || ['','',code,''];
			var hl;
			
			if (ws[1] || ws[3]) {
				code = ws[2];
			};
			
			var id = IM.identify(code);
			
			if (id) {
				var typ = 'span';
				var cls = Highlighter.Mapping[id] || id; // this is the issue, no?
				
				if (cls instanceof Array) {
					typ = cls[0];
					cls = cls[1];
				};
				
				if (!cls.match(/\b_[\w]/)) { cls = '_imtok ' + cls };
				// console.log 'parsed as type',id,cls
				hl = '<' + typ + ' class="' + cls + '">' + code + '</' + typ + '>';
			};
			
			if (!hl) {
				hl = Highlighter.highlight(code);
			};
			
			if (ws) {
				hl = IM.parseWhitespace(ws[1],false) + hl + IM.parseWhitespace(ws[3],false);
			};
			if (hl) {
				return hl;
			} else {
				return code;
			};
		};
		
		
		return IM.textNodes = function (root,mark){
			// console.time('textNodes2')
			if(mark === undefined) mark = false;
			root = root._dom || root;
			var el;
			var nodes = [];
			var pos = 0;
			var walk = document.createTreeWalker(root,NodeFilter.SHOW_TEXT,null,false);
			
			while (el = walk.nextNode()){
				if (mark) {
					var len = el.length;
					el._loc = pos;
					pos += len;
				};
				nodes.push(el);
			};
			return nodes;
		};
	
	})()

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		// var imbac = global.Imbac
		var Lexer = __webpack_require__(30).Lexer;
		
		var util = __webpack_require__(34);
		
		var NODETYPE = 'b';
		var KEYWORDS = [
			'null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return',
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import',
			'and','or','is','isnt','not','isa','case','nil'
		];
		
		var classes = {
			'+': '_imop op add math',
			'++': '_imop op incr math',
			'--': '_imop op decr math',
			'-': '_imop op sub math',
			'=': '_imop op eq',
			'/': '_imop op div math',
			'*': '_imop op mult math',
			'?': '_imop op ternary',
			',': '_imop op comma',
			':': '_imop op colon',
			'.': '_imop op dot',
			'.:': '_imop op cdot',
			'!': '_imop op unary',
			'?.': '_imop op qdot',
			'[': '_imopen sb sbl',
			']': '_imclose sb sbr',
			'(': '_imopen rb rbl',
			')': '_imclose rb rbr',
			'{': '_imopen cb cbl',
			'}': '_imclose cb cbr',
			'#': '_imop op hash',
			'call_start': '_imopen call rb rbl',
			'call_end': '_imclose call rb rbr',
			'tag_start': '_imopen tag_open',
			'tag_end': '_imclose tag_close',
			
			'true': '_imbool true',
			'yes': '_imbool true',
			'false': '_imbool false',
			'no': '_imbool false',
			
			'{{': '_imopen',
			'}}': '_imclose',
			
			'"': 'doublequote',
			"'": 'singlequote',
			
			'regex': '_imregex regex',
			'identifier': '_imtok _imidentifier identifier',
			
			'compound_assign': 'op assign compound',
			'str': '_imstr string',
			'num': '_imnum number',
			'string': '_imstr string',
			'number': '_imnum number',
			'math': '_imop op math',
			'unary': '_imop op unary',
			'forin': 'keyword in',
			'forof': 'keyword of',
			'own': 'keyword own',
			'compare': '_imop op compare',
			'herecomment': '_herecomment',
			'relation': 'keyword relation',
			'export': 'keyword export',
			'global': 'keyword global',
			'extern': 'keyword global',
			'extend': 'keyword extend',
			'require': 'keyword require',
			'from': 'keyword from',
			'logic': 'keyword logic',
			'post_if': 'keyword if post_if',
			'post_for': 'keyword for post_for',
			'prop': 'keyword prop',
			'attr': 'keyword attr',
			
			'selector_start': '_imopen _imselopen selector_start',
			'selector_end': '_imclose _imselclose selector_end',
			'index_start': '_imopen index_start',
			'index_end': '_imclose index_end',
			'block_param_start': '_imopen',
			'block_param_end': '_imclose',
			
			'string_start': '_imstrstart string_start',
			'string_end': '_imstrend string_end',
			'neostring': '_imtok _imneostring'
		};
		
		var INTERPOLATING = '_imistring';
		
		var OPEN = {
			'tag_start': '_imtagnode tagnode',
			'call_start': '_imparens call',
			'selector_start': '_imsel selector',
			'string_start': '_imistring',
			'index_start': 'index',
			'block_param_start': '_impair _imblockparams',
			// 'indent': '_indent'
			'(': '_imparens paren',
			'{{': '_imiexpr',
			'{': '_imcurly curly',
			'[': '_imsquare square',
			'("': '_imistring'
		};
		
		
		
		var CLOSE = {
			'tag_end': 'tag',
			'call_end': '_imparens call',
			'string_end': '_imistring',
			'selector_end': 'sel',
			'index_end': 'index',
			'block_param_end': '_impair _imblockparams',
			'}}': '_imiexpr',
			')': 'paren',
			']': 'square',
			'}': 'curly',
			'")': 'string'
		};
		
		var OPS = '+ - * / = ++ -- == === != !== > < >= <= & && | || or . : ?'.split(' ');
		
		var hlo = {
			newline: "<b class='_imnewline'>\n</b>",
			space: function(m) { return ("<b class='_imspace'>" + m + "</b>"); },
			tab: function(m) { return new Array(m.length + 1).join("<b class='_imtab'>\t</b>"); }
		};
		
		function Stack(){
			this._stack = [];
			return this;
		};
		
		Stack.prototype.push = function (val){
			this._stack.push(val);
			this._current = val;
			return this;
		};
		
		Stack.prototype.pop = function (){
			var len = this._stack.pop();
			this._current = this._stack[len - 1];
			return this;
		};
		
		Stack.prototype.toString = function (){
			return this._current;
		};
		
		function Token(type,value,line,loc,len){
			this._type = type;
			this._value = value;
			this._meta = null;
			this._line = line || 0;
			this._col = -1;
			this._loc = loc || 0;
			this._len = len || 0;
			this.generated = false;
			this.newLine = false;
			this.spaced = false;
			return this;
		};
		exports.Token = Token; // export class 
		Token.prototype.type = function (){
			return this._type;
		};
		
		Token.prototype.value = function (){
			return this._value;
		};
		
		Token.prototype.loc = function (){
			return this._loc;
		};
		
		Token.prototype.len = function (){
			return this._len;
		};
		
		
		
		function Highlighter(code,tokens,ast,o){
			var hl_;
			if(o === undefined) o = {};
			this._code = code;
			this._tokens = tokens;
			this._ast = ast;
			
			o.render || (o.render = {});
			o.hl || (o.hl = {});
			(hl_ = o.hl).newline || (hl_.newline = '<b class="_n">\n</b>');
			this._options = o;
			
			this._options.nextVarCounter || (this._options.nextVarCounter = 0);
			this._varRefs = {};
			
			if (o.mode == 'full' && !ast) {
				this._ast = Imbac.parse(this._tokens,{});
			};
			
			return this;
		};
		
		exports.Highlighter = Highlighter; // export class 
		Highlighter.Mapping = classes;
		
		Highlighter.logger = function (){
			return VIEW.logger();
		};
		
		Highlighter.tokenize = function (code,o){
			// console.log 'tokenize using local lexer'
			if(o === undefined) o = {};
			if (global.Imbac) {
				return Imbac.tokenize(code,o);
			};
			
			this._lexer || (this._lexer = new Lexer());
			this._lexer.reset();
			return this._lexer.tokenize(code,o);
		};
		
		Highlighter.reclassify = function (domnode,type,token,newCode,oldCode){
			
			type = type.toLowerCase();
			// console.log 'reclassify node as type',domnode,type,token
			var cls = IM.Types[type] || Imba.TAGS[("im" + type)] || IM.Types.token;
			
			var node = tag$wrap(domnode);
			
			if (node instanceof cls) {
				return node.reuse(token,newCode,oldCode);
			};
			
			if (cls) {
				node = new cls(domnode).setup(token,newCode,oldCode);
			};
			
			return node;
		};
		
		
		Highlighter.nestTokens = function (tokens,offset){
			var pairing = {
				'TAG_START': 'TAG_END',
				'SELECTOR_START': 'SELECTOR_END',
				'CALL_START': 'CALL_END',
				'INDEX_START': 'INDEX_END',
				'STRING_START': 'STRING_END',
				'BLOCK_PARAM_START': 'BLOCK_PARAM_END',
				'{{': '}}',
				'{': '}',
				'[': ']',
				'(': ')'
			};
			
			var naming = {
				'TAG_START': 'tagnode',
				'SELECTOR_START': 'selector',
				'STRING_START': 'istring',
				'CALL_START': 'parens',
				'INDEX_START': 'square',
				'BLOCK_PARAM_START': 'blockparams',
				'{{': 'iexpr',
				'{': 'curly',
				'[': 'square',
				'(': 'parens'
			};
			
			var idx = 0;
			
			var root = {
				_loc: 0,
				_offset: 0,
				_children: []
			};
			
			var stack = [root];
			var ends = [];
			var offset = 0;
			
			var loc,val,typ,ctx,tok;
			
			while (tok = tokens[idx++]){
				loc = tok._loc;
				val = tok._value;
				typ = tok._type;
				
				// normalizing because we dont rewrite tokens (should start with that)
				if (typ == 'IDENTIFIER' && (val == 'prop' || val == 'attr')) { typ = tok._type = 'KEYWORD' }; // not always
				if (typ == 'INDEX_START') { typ = tok._type = '[' };
				if (typ == 'INDEX_END') { typ = tok._type = ']' };
				if (typ == 'CALL_START') { typ = tok._type = '(' };
				if (typ == 'CALL_END') { typ = tok._type = ')' };
				
				ctx = stack[stack.length - 1];
				
				loc -= ctx._offset;
				// offset relative to context
				var closer = pairing[typ];
				
				if (closer) {
					var group = new Token(naming[typ],'',-1,loc);
					group._offset = ctx._offset + loc;
					offset += loc;
					group._children = [];
					ends.push(closer);
					stack.push(group);
					ctx._children.push(group);
					ctx = group;
				};
				
				tok._loc -= ctx._offset;
				
				// update length at all times
				if (tok._len >= 1) {
					ctx._children.push(tok);
					ctx._len = tok._loc + tok._len;
				};
				
				if (ends[ends.length - 1] == typ) {
					ends.pop();
					ctx._len = tok._loc + tok._len;
					stack.pop();
					// offset -= ctx.@offset
				};
			};
			
			// console.log 'children here',root.@children
			return root._children;
		};
		
		Highlighter.normalizeTokens = function (code,tokens,offset){
			if(offset === undefined) offset = 0;
			var idx = 0;
			var caret = 0;
			var new$ = [];
			var tok,next,typ,val;
			var loc = 0;
			
			var stack = new Stack();
			
			var ws = function() {
				var newtok = null;
				
				while (loc > caret){
					var chr = code[caret];
					if (chr == '\t') {
						newtok = new Token('tab',chr,-1,caret,1);
					} else if (chr == '\n') {
						newtok = new Token('newline',chr,-1,caret,1);
					} else if (chr == ';') {
						newtok = new Token('semicolon',chr,-1,caret,1);
					} else if (chr == ' ') {
						if (newtok && newtok._type == 'whitespace') {
							newtok._value += ' ';
							newtok._len += 1;
							caret++;
							continue;
						};
						newtok = new Token('whitespace',chr,-1,caret,1);
					} else if (chr == '#') {
						var startloc = caret;
						var comment = '';
						while (caret < loc && code[caret] != '\n'){
							comment += code[caret];
							caret++;
						};
						new$.push(new Token('comment',comment,-1,startloc,comment.length));
						continue;
					} else {
						newtok = null;
					};
					
					caret++;
					if (newtok) { new$.push(newtok) };
				};
				return;
			};
			
			var skip = ['TERMINATOR','INDENT','OUTDENT',' ',' \t'];
			
			while (tok = tokens[idx++]){
				next = tokens[idx];
				loc = tok._loc;
				val = tok._value;
				typ = tok._type;
				
				if (typ == '#' && next && next._type == 'IDENTIFIER') {
					next._type = 'IDREF';
				};
				
				if (typ == '(' && val == '("') {
					stack.push(val);
				};
				
				if (skip.indexOf(typ) >= 0) { continue; };
				
				if (loc > caret) { ws() };
				caret = tok._loc + tok._len;
				new$.push(tok);
			};
			
			// move to the end to possibly parse more whitespace
			loc = code.length;
			ws();
			// now nest the tokens
			new$ = this.nestTokens(new$);
			return new$;
		};
		
		Highlighter.whitespaceToTokens = function (str){
			var tok;
			var tokens = [];
			var caret = 0;
			var len = str.length;
			
			while (len > caret){
				var loc = caret;
				var chr = str[caret++];
				if (chr == '\t') {
					tokens.push(tok = new Token('tab',chr,-1,loc,1));
				} else if (chr == '\n') {
					tokens.push(tok = new Token('newline',chr,-1,loc,1));
				} else if (chr == ' ') {
					if (tok && tok._type == 'whitespace') {
						tok._value += ' ';
						tok._len += 1;
						continue;
					};
					tokens.push(tok = new Token('whitespace',chr,-1,loc,1));
				};
			};
			
			return tokens;
		};
		
		Highlighter.reparse = function (o){
			
			var $1;
			if (o instanceof Element) {
				var el = tag$wrap(o);
				if (el) { ($1 = el) && $1.mutated  &&  $1.mutated() };
				return;
			};
			
			var nodes = o.nodes;
			var code = o.code;
			var tokens = o.tokens;
			// should use a global logger-instance
			this.logger().groupCollapsed('reparse %s',JSON.stringify(code));
			
			if (util.isWhitespace(code) && !tokens) {
				console.log('using whitespaceToTokens');
				tokens = this.whitespaceToTokens(code);
			};
			// logger.log nodes.slice
			// big hack - adding a space at the end to close up selectors
			// should rather drop inline and let the parser pair up loose ends?
			if (!tokens) {
				tokens = this.tokenize(code + ' ',{inline: true,silent: true,rewrite: false});
				tokens = this.normalizeTokens(code,tokens);
				this.logger().log(tokens.slice());
			};
			
			this.logger().log(nodes.slice());
			this.applyTokens(code,tokens,nodes,o.nested,o.parent);
			this.logger().groupEnd();
			return;
		};
		
		Highlighter.applyTokens = function (code,tokens,nodes,nested,parent){
			// what about len and loc for inner nodes? Should this be set already?
			
			var self = this;
			var node;
			var prevNode;
			
			var addNode = function(nodes,index,after) {
				self.logger().log('addNode',index);
				var el = document.createElement(NODETYPE);
				
				if (after) {
					if (after.nextSibling) {
						after.parentNode.insertBefore(el,after.nextSibling);
					} else if (after.parentNode) {
						after.parentNode.appendChild(el);
					};
				} else if (parent) {
					parent.appendChild(el);
				};
				
				nodes.splice(index,0,el);
				return el;
			};
			
			var removeNode = function(nodes,index) {
				self.logger().log('removeNode',index);
				var el = nodes[index];
				if (el && el.parentNode) {
					el.parentNode.removeChild(el);
				};
				return nodes.splice(index,1);
			};
			
			// loop through to set the locations of the nodes
			var nloc = 0;
			for (var i = 0, ary = iter$(nodes), len = ary.length, node1; i < len; i++) {
				node1 = ary[i];
				node1._loc = nloc;
				nloc += (node1._len = node1.textContent.length);
			};
			
			for (var i = 0, ary = iter$(tokens), len = ary.length, tok; i < len; i++) {
				tok = ary[i];
				node = nodes[i];
				var tloc = tok._loc;
				nloc = node && node._loc;
				
				while (node && node._len == 0){
					self.logger().log('remove node because it is empty',node);
					removeNode(nodes,i);
					node = nodes[i];
				};
				
				if (!node) {
					// need to insert new node here - 
					node = addNode(nodes,i,prevNode);
				} else if (nloc > tloc) {
					node = addNode(nodes,i,prevNode);
				} else if (tloc > nloc) {
					removeNode(nodes,i);
					node = nodes[i];
				};
				
				// need to insert new node here - 
				if (!node) { node = addNode(nodes,i,prevNode) };
				
				if (tok._type == 'STRING' && tok._value.match(/\§{3}/)) {
					if (nested) {
						nested.pop(); // this is the node
						prevNode = node;
						continue;
					};
					
					// want to make sure it is a placeholder for the right thing
				};
				
				var cval = code.substr(tloc,tok._len);
				var cprev = node.textContent;
				var element = self.reclassify(node,tok._type,tok,cval,cprev);
				
				if (tok._children) {
					var cnodes = node.children;
					if (cnodes.length && cnodes.length == node.childNodes.length) {
						self.logger().log('reuse the cnodes(!)',cnodes);
						// otherwise we should remove the textNodes?
						// convert to array
						cnodes = Array.prototype.slice.call(cnodes);
					} else {
						self.logger().log('wrong length');
						for (var j = 0, items = iter$(node.childNodes), len_ = items.length; j < len_; j++) {
							self.logger().log(items[j]);
						};
						// see if previous value is the same?!
						node.innerHTML = '';
						cnodes = [];
					};
					
					// let o =
					// 	code: cval
					// 	nodes: cnodes
					// 	tokens: tok.@children # already parsed
					// 	nested: nested
					// 	parent: node
					
					self.applyTokens(cval,tok._children,cnodes,nested,node);
				} else if (cprev != cval) {
					node.textContent = cval; // tok.@value
					element.reparsed(cval,cprev);
				};
				
				prevNode = node;
				// tok.@len
			};
			
			// loop through tokens? not sure it works due to the issues with whitespace?
			
			// remove excess original nodes
			while (nodes.length > tokens.length){
				node = nodes.pop();
				if (node.parentNode) { node.parentNode.removeChild(node) };
				// node.orphanize
			};
			return self;
		};
		
		// should later be able to rehighlight the text / nodes directly instead
		// probably more efficient
		Highlighter.highlight = function (code,o){
			// first try to parse etc?
			// could highlight single words as well
			if(o === undefined) o = {};
			o.hl || (o.hl = hlo);
			var tokens = o.tokens || null;
			
			if (!tokens) {
				try {
					// sure we dont want to rewrite anything now?
					if (true) { console.time('tokenize') };
					if (o.mode == 'full') {
						tokens = this.tokenize(code,{});
					} else {
						tokens = this.tokenize(code,{inline: true,silent: true,rewrite: false});
					};
					if (true) { console.timeEnd('tokenize') };
				} catch (e) {
					if (e._options) { tokens = e._options.tokens };
				};
			};
			
			var hl = new this(code,tokens,null,o);
			return hl.process();
		};
		
		
		
		Highlighter.prototype.options = function(v){ return this._options; }
		Highlighter.prototype.setOptions = function(v){ this._options = v; return this; };
		
		Highlighter.prototype.varRef = function (variable){
			var $1;
			var i = this._options.nested;
			var pfx = i ? ('i') : ('');
			return this._varRefs[($1 = variable._ref)] || (this._varRefs[$1] = (pfx + this._options.nextVarCounter++));
		};
		
		Highlighter.prototype.parseWhitespace = function (text){
			// parsing comments
			var self = this;
			var hl = this._options.hl;
			var comments = [];
			
			text = text.replace(/(\#)([^\n]*)/g,function(m,s,q) {
				if (self._options.render.comment) {
					m = self._options.render.comment('comment',m);
				};
				var nr = comments.push(("<" + NODETYPE + " class='_im _imcomment'>" + m + "</" + NODETYPE + ">"));
				return ("$" + (nr - 1) + "$");
			});
			
			text = text.replace(/(\n|[ ]+|[\t]+)/g,function(m,l) {
				if (l == '\n') {
					return hl.newline || '\n';
				} else if (l[0] == ' ') {
					return hl.space instanceof Function ? (hl.space(l)) : (l);
				} else if (l[0] == '\t') {
					return hl.tab instanceof Function ? (hl.tab(l)) : (l);
				};
			});
			
			if (comments.length) {
				text = text.replace(/\$(\d+)\$/g,function(m,nr) {
					return comments[parseInt(nr)];
				});
			};
			return text;
		};
		
		Highlighter.prototype.process = function (){
			var tok;
			var o = this.options();
			
			var str = this._code;
			var pos = this._tokens.length;
			
			var stack = [];
			var depth = 0;
			var context = null;
			
			var push = function(ctx) {
				stack.push(ctx);
				depth = stack.length;
				return context = stack[depth - 1];
			};
			
			var pop = function(ctx) {
				stack.pop();
				depth = stack.length;
				return context = stack[depth - 1];
			};
			
			if (this._ast && this._ast.analyze) {
				try {
					this._ast.analyze({});
				} catch (e) {
					null;
				};
			};
			
			var res = "";
			pos = 0;
			var caret = 0;
			
			var open,close;
			
			while (tok = this._tokens[pos++]){
				var next = this._tokens[pos];
				
				if (close) {
					if (!(o.inner && depth == 1)) { res += ("</" + NODETYPE + ">") };
					close = null;
					pop();
				};
				
				var typ = tok._type.toLowerCase();
				var loc = tok._loc;
				var val = tok._value;
				var len = tok._len; // or tok.@value:length
				var meta = tok._meta;
				var attrs = '';
				
				if (loc > caret) {
					var add = str.substring(caret,loc);
					if (context != INTERPOLATING) { add = this.parseWhitespace(add) };
					res += add;
					caret = loc;
				};
				
				close = CLOSE[typ];
				
				if (open = OPEN[typ]) {
					// open = OPEN[val] || open
					push(open);
					if (!(o.inner && depth == 1)) { res += ("<" + NODETYPE + " class='" + open + "'>") };
				};
				
				if (len == 0 || typ == 'terminator' || typ == 'indent' || typ == 'outdent') {
					continue;
				};
				
				if (tok._col == -1 && tok._loc <= 0) {
					continue;
				};
				
				var node = NODETYPE;
				var content = str.substr(loc,len);
				// temporary workaround until we redefine require as an identifier
				if (typ == 'const' && content == 'require') {
					typ = 'require';
				};
				
				
				var cls = classes[typ] || typ;
				
				if (cls instanceof Array) {
					node = cls[0];
					cls = cls[1];
				};
				
				cls = cls.split(" ");
				
				if (KEYWORDS.indexOf(typ) >= 0) {
					cls.unshift('keyword');
				};
				
				caret = loc + len;
				
				if (typ == 'identifier') {
					if (content[0] == '#') {
						cls.push('idref');
					};
					
					if (meta) {
						if (meta.type == 'ACCESS') { cls.push('access') };
					};
					
					if (content == 'log') {
						cls.push('log');
					};
				};
				
				if (tok._variable) {
					
					cls.push('lvar');
					var ref = this.varRef(tok._variable);
					attrs += (" eref='v" + ref + "'");
					// cls.push("ref-"+ref)
				};
				
				if (typ == 'herecomment') {
					var end = ("<" + NODETYPE + ">###</" + NODETYPE + ">");
					content = end + content.slice(3,-3) + end;
				};
				
				if (typ == 'string') {
					if (content.match(/^['"]?\.?\.\//)) { cls.push('pathname') };
				};
				
				var clstr = cls.join(" ");
				if (!clstr.match(/\b\_/)) { clstr = '_imtok ' + clstr };
				res += ("<" + node + " class='" + clstr + "'") + attrs + ">" + content + ("</" + node + ">");
			};
			
			// close after?
			if (close) {
				res += ("</" + NODETYPE + ">");
				close = null;
			};
			
			if (caret < str.length - 1) {
				add = str.slice(caret);
				if (context != INTERPOLATING) { add = this.parseWhitespace(add) };
				res += add;
			};
			
			if (this._tokens.length == 0) {
				res = this._code;
			};
			
			return res;
		};
		return Highlighter;
	
	})()
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		var ALL_KEYWORDS;
		
		var T = __webpack_require__(31);
		var Token = T.Token;
		
		var rw = __webpack_require__(32);
		var Rewriter = rw.Rewriter;
		var INVERSES = rw.INVERSES;
		
		var K = 0;
		
		var ERR = __webpack_require__(33);
		
		// Constants
		// ---------
		
		// Keywords that Imba shares in common with JavaScript.
		var JS_KEYWORDS = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return'
		];
		
		// new can be used as a keyword in imba, since object initing is done through
		// MyObject.new. new is a very useful varname.
		
		// We want to treat return like any regular call for now
		// Must be careful to throw the exceptions in AST, since the parser
		// wont
		
		// Imba-only keywords. var should move to JS_Keywords
		// some words (like tokid) should be context-specific
		var IMBA_KEYWORDS = [
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import'
		];
		
		var IMBA_CONTEXTUAL_KEYWORDS = ['extend','static','local','export','global','prop'];
		
		var IMBA_ALIAS_MAP = {
			'and': '&&',
			'or': '||',
			'is': '==',
			'isnt': '!=',
			'not': '!',
			'yes': 'true',
			'no': 'false',
			'isa': 'instanceof',
			'case': 'switch',
			'nil': 'null'
		};
		
		var IMBA_ALIASES = Object.keys(IMBA_ALIAS_MAP);
		IMBA_KEYWORDS = IMBA_KEYWORDS.concat(IMBA_ALIASES);
		
		// FixedArray for performance
		// var ALL_KEYWORDS = JS_KEYWORDS.concat(IMBA_KEYWORDS)
		module.exports.ALL_KEYWORDS = ALL_KEYWORDS = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return',
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import',
			'and','or','is','isnt','not','yes','no','isa','case','nil'
		];
		
		// The list of keywords that are reserved by JavaScript, but not used, or are
		// used by Imba internally. We throw an error when these are encountered,
		// to avoid having a JavaScript error at runtime.  # 'var', 'let', - not inside here
		var RESERVED = ['case','default','function','void','with','const','enum','native'];
		var STRICT_RESERVED = ['case','function','void','const'];
		
		// The superset of both JavaScript keywords and reserved words, none of which may
		// be used as identifiers or properties.
		var JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED);
		
		var METHOD_IDENTIFIER = /^((([\x23]?[\$A-Za-z_\x7f-\uffff][$\-\w\x7f-\uffff]*)([\=]?))|(<=>|\|(?![\|=])))/;
		// removed ~=|~| |&(?![&=])
		
		// Token matching regexes.
		// added hyphens to identifiers now - to test
		var IDENTIFIER = /^((\$|@@|@|\#)[\wA-Za-z_\-\x7f-\uffff][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*|[$A-Za-z_][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*)([^\n\S]*:(?![\*\=:$\w\x7f-\uffff]))?/;
		
		var OBJECT_KEY = /^((\$|@@|@|)[$A-Za-z_\x7f-\uffff\-][$\w\x7f-\uffff\-]*)([^\n\S\s]*:(?![\*\=:$\w\x7f-\uffff]))/;
		
		var TAG = /^(\<|%)(?=[A-Za-z\#\.\{\@\>])/;
		
		var TAG_TYPE = /^(\w[\w\d]*:)?(\w[\w\d]*)(-[\w\d]+)*/;
		var TAG_ID = /^#((\w[\w\d]*)(-[\w\d]+)*)/;
		
		var TAG_ATTR = /^([\.\:]?[\w\_]+([\-\:][\w]+)*)(\s)*\=/;
		
		var SELECTOR = /^([%\$]{1,2})([\(\w\#\.\[])/;
		var SELECTOR_PART = /^(\#|\.|:|::)?([\w]+(\-[\w]+)*)/;
		var SELECTOR_COMBINATOR = /^ (\+|\>|\~)*\s*(?=[\w\.\#\:\{\*\[])/;
		
		var SELECTOR_PSEUDO_CLASS = /^(::?)([\w]+(\-[\w]+)*)/;
		var SELECTOR_ATTR_OP = /^(\$=|\~=|\^=|\*=|\|=|=|\!=)/;
		var SELECTOR_ATTR = /^\[([\w\_\-]+)(\$=|\~=|\^=|\*=|\|=|=|\!=)/;
		
		var SYMBOL = /^\:((([\*\@$\w\x7f-\uffff]+)+([\-\\/\\\:][\w\x7f-\uffff]+)*)|==|\<=\>|\[\]|\[\]\=|\*|[\\/,\\])/;
		
		
		var NUMBER = /^0x[\da-f]+|^0b[01]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;
		
		var HEREDOC = /^("""|''')([\s\S]*?)(?:\n[^\n\S]*)?\1/;
		
		var OPERATOR = /^(?:[-=]=>|===|->|!==|[-+*\/%<>&|^!?=]=|=<|>>>=?|([-+:])\1|([&|<>])\2=?|\?\.|\?\:|\.{2,3}|\*(?=[a-zA-Z\_]))/;
		
		// FIXME splat should only be allowed when the previous thing is spaced or inside call?
		
		var WHITESPACE = /^[^\n\S]+/;
		
		var COMMENT = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)/;
		// COMMENT    = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)|^(?:\s*(#\s.*|#\s*$))+/
		var INLINE_COMMENT = /^(\s*)(#[ \t\!](.*)|#[ \t]?(?=\n|$))+/;
		
		var CODE = /^[-=]=>/;
		
		var MULTI_DENT = /^(?:\n[^\n\S]*)+/;
		
		var SIMPLESTR = /^'[^\\']*(?:\\.[^\\']*)*'/;
		
		var JSTOKEN = /^`[^\\`]*(?:\\.[^\\`]*)*`/;
		
		// Regex-matching-regexes.
		var REGEX = /^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/;
		
		var HEREGEX = /^\/{3}([\s\S]+?)\/{3}([imgy]{0,4})(?!\w)/;
		
		var HEREGEX_OMIT = /\s+(?:#.*)?/g;
		
		// Token cleaning regexes.
		var MULTILINER = /\n/g;
		
		var HEREDOC_INDENT = /\n+([^\n\S]*)/g;
		
		var HEREDOC_ILLEGAL = /\*\//;
		
		// expensive?
		var LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|::)/;
		
		var TRAILING_SPACES = /\s+$/;
		
		var CONST_IDENTIFIER = /^[A-Z]/;
		
		var ARGVAR = /^\$\d$/;
		
		// Compound assignment tokens.
		var COMPOUND_ASSIGN = ['-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|=','=<'];
		
		// Unary tokens.
		var UNARY = ['!','~','NEW','TYPEOF','DELETE'];
		
		// Logical tokens.
		var LOGIC = ['&&','||','&','|','^'];
		
		// Bit-shifting tokens.
		var SHIFT = ['<<','>>','>>>'];
		
		// Comparison tokens.
		var COMPARE = ['===','!==','==','!=','<','>','<=','>=','===','!=='];
		
		// Overideable methods
		var OP_METHODS = ['<=>','<<','..'];
		
		// Mathematical tokens.
		var MATH = ['*','/','%','∪','∩','√'];
		
		// Relational tokens that are negatable with `not` prefix.
		var RELATION = ['IN','OF','INSTANCEOF','ISA'];
		
		// Boolean tokens.
		var BOOL = ['TRUE','FALSE','NULL','UNDEFINED'];
		
		// Our list is shorter, due to sans-parentheses method calls.
		var NOT_REGEX = ['NUMBER','REGEX','BOOL','TRUE','FALSE','++','--',']'];
		
		// If the previous token is not spaced, there are more preceding tokens that
		// force a division parse:
		var NOT_SPACED_REGEX = ['NUMBER','REGEX','BOOL','TRUE','FALSE','++','--',']',')','}','THIS','SELF','IDENTIFIER','STRING'];
		
		// Tokens which could legitimately be invoked or indexed. An opening
		// parentheses or bracket following these tokens will be recorded as the start
		// of a function invocation or indexing operation.
		// really?!
		
		var UNFINISHED = ['\\','.','?.','?:','UNARY','MATH','+','-','SHIFT','RELATION','COMPARE','LOGIC','COMPOUND_ASSIGN','THROW','EXTENDS'];
		
		// } should not be callable anymore!!! '}', '::',
		var CALLABLE = ['IDENTIFIER','STRING','REGEX',')',']','THIS','SUPER','TAG_END','IVAR','GVAR','SELF','CONST','NEW','ARGVAR','SYMBOL','RETURN'];
		// var INDEXABLE = CALLABLE.concat 'NUMBER', 'BOOL', 'TAG_SELECTOR', 'IDREF', 'ARGUMENTS','}' # are booleans indexable? really?
		// optimize for FixedArray
		var INDEXABLE = [
			'IDENTIFIER','STRING','REGEX',')',']','THIS','SUPER','TAG_END','IVAR','GVAR','SELF','CONST','NEW','ARGVAR','SYMBOL','RETURN',
			'NUMBER','BOOL','TAG_SELECTOR','IDREF','ARGUMENTS','}','TAG_TYPE'
		];
		
		var GLOBAL_IDENTIFIERS = ['global','exports','require'];
		
		// Tokens that, when immediately preceding a `WHEN`, indicate that the `WHEN`
		// occurs at the start of a line. We disambiguate these from trailing whens to
		// avoid an ambiguity in the grammar.
		var LINE_BREAK = ['INDENT','OUTDENT','TERMINATOR'];
		
		
		function LexerError(message,file,line){
			this.message = message;
			this.file = file;
			this.line = line;
			return this;
		};
		subclass$(LexerError,SyntaxError);
		exports.LexerError = LexerError; // export class 
		
		
		
		function last(array,back){
			if(back === undefined) back = 0;
			return array[array.length - back - 1];
		};
		
		function count(str,substr){
			return str.split(substr).length - 1;
		};
		
		function repeatString(str,times){
			var res = '';
			while (times > 0){
				if (times % 2 == 1) {
					res += str;
				};
				str += str;
				times >>= 1;
			};
			return res;
		};
		
		var tT = T.typ;
		var tV = T.val;
		var tTs = T.setTyp;
		var tVs = T.setVal;
		
		// The Lexer class reads a stream of Imba and divvies it up into tokidged
		// tokens. Some potential ambiguity in the grammar has been avoided by
		// pushing some extra smarts into the Lexer.
		
		// Based on the original lexer.coffee from CoffeeScript
		function Lexer(){
			this.reset();
			this;
		};
		
		exports.Lexer = Lexer; // export class 
		Lexer.prototype.reset = function (){
			this._code = null;
			this._chunk = null; // The remainder of the source code.
			this._opts = null;
			
			this._indent = 0; // The current indentation level.
			this._indebt = 0; // The over-indentation at the current level.
			this._outdebt = 0; // The under-outdentation at the current level.
			
			this._indents = []; // The stack of all current indentation levels.
			this._ends = []; // The stack for pairing up tokens.
			this._contexts = []; // suplements @ends
			this._scopes = [];
			this._nextScope = null; // the scope to add on the next indent
			// should rather make it like a statemachine that moves from CLASS_DEF to CLASS_BODY etc
			// Things should compile differently when you are in a CLASS_BODY than when in a DEF_BODY++
			
			this._tokens = []; // Stream of parsed tokens in the form `['TYPE', value, line]`.
			this._seenFor = false;
			this._loc = 0;
			this._locOffset = 0;
			
			this._end = null;
			this._char = null;
			this._bridge = null;
			this._last = null;
			this._lastTyp = '';
			this._lastVal = null;
			return this;
		};
		
		Lexer.prototype.jisonBridge = function (jison){
			return this._bridge = {
				lex: T.lex,
				setInput: function(tokens) {
					this.tokens = tokens;
					return this.pos = 0;
				},
				
				upcomingInput: function() { return ""; }
			};
		};
		
		
		Lexer.prototype.tokenize = function (code,o){
			
			if(o === undefined) o = {};
			if (code.length == 0) {
				return [];
			};
			
			if (!o.inline) {
				if (WHITESPACE.test(code)) {
					code = ("\n" + code);
					if (code.match(/^\s*$/g)) { return [] };
				};
				
				code = code.replace(/\r/g,'').replace(/[\t ]+$/g,'');
			};
			
			this._last = null;
			this._lastTyp = null;
			this._lastVal = null;
			
			this._code = code;
			this._opts = o;
			this._locOffset = o.loc || 0;
			// add a reference to the options object
			o._tokens = this._tokens;
			// what about col here?
			
			// @indent  = 0 # The current indentation level.
			// @indebt  = 0 # The over-indentation at the current level.
			// @outdebt = 0 # The under-outdentation at the current level.
			// @indents = [] # The stack of all current indentation levels.
			// @ends    = [] # The stack for pairing up tokens.
			// @tokens  = [] # Stream of parsed tokens in the form `['TYPE', value, line]`.
			// @char = nil
			
			if (o.profile) { console.time("tokenize:lexer") };
			this.parse(code);
			if (!o.inline) this.closeIndentation();
			if (!o.silent && this._ends.length) {
				this.error(("missing " + (this._ends.pop())));
			};
			
			if (o.profile) { console.timeEnd("tokenize:lexer") };
			if (o.rewrite == false || o.norewrite) { return this._tokens };
			return new Rewriter().rewrite(this._tokens,o);
		};
		
		Lexer.prototype.parse = function (code){
			var i = 0;
			var pi = 0;
			
			while (this._chunk = code.slice(i)){
				this._loc = this._locOffset + i;
				pi = (this._end == 'TAG' && this.tagDefContextToken()) || (this._inTag && this.tagContextToken()) || this.basicContext();
				i += pi;
			};
			
			return;
		};
		
		Lexer.prototype.basicContext = function (){
			return this.selectorToken() || this.symbolToken() || this.methodNameToken() || this.identifierToken() || this.whitespaceToken() || this.lineToken() || this.commentToken() || this.heredocToken() || this.tagToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken() || 0;
		};
		
		Lexer.prototype.moveCaret = function (i){
			return this._loc += i;
		};
		
		Lexer.prototype.context = function (){
			return this._ends[this._ends.length - 1];
		};
		
		Lexer.prototype.inContext = function (key){
			var o = this._contexts[this._contexts.length - 1];
			return o && o[key];
		};
		
		Lexer.prototype.pushEnd = function (val){
			// console.log "pushing end",val
			this._ends.push(val);
			this._contexts.push(null);
			this._end = val;
			this.refreshScope();
			return this;
		};
		
		Lexer.prototype.popEnd = function (val){
			this._ends.pop();
			this._contexts.pop();
			this._end = this._ends[this._ends.length - 1];
			this.refreshScope();
			return this;
		};
		
		Lexer.prototype.refreshScope = function (){
			var ctx0 = this._ends[this._ends.length - 1];
			var ctx1 = this._ends[this._ends.length - 2];
			return this._inTag = ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
		};
		
		
		
		Lexer.prototype.queueScope = function (val){
			// console.log("pushing scope {val} - {@indents} {@indents:length}")
			// @scopes.push(val) # no no
			this._scopes[this._indents.length] = val;
			return this;
		};
		
		Lexer.prototype.popScope = function (val){
			this._scopes.pop();
			return this;
		};
		
		Lexer.prototype.getScope = function (){
			return this._scopes[this._indents.length - 1];
		};
		
		Lexer.prototype.scope = function (sym,opts){
			var len = this._ends.push(this._end = sym);
			this._contexts.push(opts || null);
			return sym;
		};
		
		
		Lexer.prototype.closeSelector = function (){
			if (this._end == '%') {
				this.token('SELECTOR_END','%',0);
				return this.pair('%');
			};
		};
		
		
		Lexer.prototype.openDef = function (){
			return this.pushEnd('DEF');
		};
		
		
		Lexer.prototype.closeDef = function (){
			if (this.context() == 'DEF') {
				var prev = last(this._tokens);
				// console.log "close def {prev}"
				// console.log('closeDef with last>',prev)
				if (tT(prev) == 'DEF_FRAGMENT') {
					true;
				} else if (tT(prev) == 'TERMINATOR') {
					// console.log "here?!??"
					var n = this._tokens.pop();
					// console.log n
					this.token('DEF_BODY','DEF_BODY',0);
					// token('TERMINATOR', '',0) unless n.@value.indexOf('//') >= 0
					this._tokens.push(n);
				} else {
					this.token('DEF_BODY','DEF_BODY',0);
				};
				
				this.pair('DEF');
			};
			return;
		};
		
		Lexer.prototype.tagContextToken = function (){
			var match;
			if (this._chunk[0] == '#') {
				// console.log('found id # in tagContextToken')
				this.token('#','#',1);
				return 1;
			};
			
			if (match = TAG_ATTR.exec(this._chunk)) {
				// console.log 'TAG_SDDSATTR IN tokid',match
				// var prev = last @tokens
				// if the prev is a terminator, we dont really need to care?
				if (this._lastTyp != 'TAG_NAME') {
					if (this._lastTyp == 'TERMINATOR') {
						// console.log('prev was terminator -- drop it?')
						true;
					} else {
						this.token(",",",");
					};
				};
				
				var l = match[0].length;
				
				this.token('TAG_ATTR',match[1],l - 1); // add to loc?
				this._loc += l - 1;
				this.token('=','=',1);
				return l;
			};
			return 0;
		};
		
		Lexer.prototype.tagDefContextToken = function (){
			// console.log "tagContextToken"
			var match;
			if (match = TAG_TYPE.exec(this._chunk)) {
				this.token('TAG_TYPE',match[0],match[0].length);
				return match[0].length;
			};
			
			if (match = TAG_ID.exec(this._chunk)) {
				var input = match[0];
				this.token('TAG_ID',input,input.length);
				return input.length;
			};
			
			return 0;
		};
		
		
		Lexer.prototype.tagToken = function (){
			var match, ary;
			if (!(match = TAG.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var input = ary[0],type = ary[1],identifier = ary[2];
			
			if (type == '<') {
				this.token('TAG_START','<',1);
				this.pushEnd(INVERSES.TAG_START);
				
				if (match = TAG_TYPE.exec(this._chunk.substr(1,40))) {
					// special case should probably be handled in AST
					if (match[0] != 'self') {
						this.token('TAG_TYPE',match[0],match[0].length,1);
						return input.length + match[0].length;
					};
				};
				
				if (identifier) {
					if (identifier.substr(0,1) == '{') {
						return type.length;
					} else {
						this.token('TAG_NAME',input.substr(1),0);
					};
				};
			};
			
			return input.length;
		};
		
		
		Lexer.prototype.selectorToken = function (){
			var ary, string;
			var match;
			
			// special handling if we are in this context
			if (this._end == '%') {
				var chr = this._chunk.charAt(0);
				var open = this.inContext('open');
				
				// should add for +, ~ etc
				// should maybe rather look for the correct type of character?
				
				if (open && (chr == ' ' || chr == '\n' || chr == ',' || chr == '+' || chr == '~' || chr == ')' || chr == ']')) {
					// console.log "close this selector directly"
					this.token('SELECTOR_END','%',0);
					this.pair('%');
					return 0;
				};
				
				if (match = SELECTOR_COMBINATOR.exec(this._chunk)) {
					// spaces between? -- include the whole
					this.token('SELECTOR_COMBINATOR',match[1] || " ",match[0].length);
					return match[0].length;
				} else if (match = SELECTOR_PART.exec(this._chunk)) {
					var type = match[1];
					var id = match[2];
					
					switch (type) {
						case '.':
							tokid = 'SELECTOR_CLASS';break;
						
						case '#':
							tokid = 'SELECTOR_ID';break;
						
						case ':':
							tokid = 'SELECTOR_PSEUDO_CLASS';break;
						
						case '::':
							tokid = 'SELECTOR_PSEUDO_CLASS';break;
						
						default:
						
							var tokid = 'SELECTOR_TAG';
					
					};
					
					this.token(tokid,match[2],match[0].length);
					return match[0].length;
				} else if (chr == '[') {
					this.token('[','[',1);
					this.pushEnd(']');
					if (match = SELECTOR_ATTR.exec(this._chunk)) {
						// fuck this length shit
						var idoffset = match[0].indexOf(match[1]);
						var opoffset = match[0].indexOf(match[2]);
						this.token('IDENTIFIER',match[1],match[1].length,idoffset);
						this.token('SELECTOR_ATTR_OP',match[2],match[2].length,opoffset);
						return match[0].length;
					};
					return 1;
				} else if (chr == '|') {
					var tok = this._tokens[this._tokens.length - 1];
					tTs(tok,'SELECTOR_NS');
					// tok[0] = 'SELECTOR_NS' # FIX
					return 1;
				} else if (chr == ',') {
					this.token('SELECTOR_GROUP',',',1);
					return 1;
				} else if (chr == '*') {
					this.token('UNIVERSAL_SELECTOR','*',1);
					return 1;
				} else if (chr == ')') {
					this.pair('%');
					this.token('SELECTOR_END',')',1);
					return 1;
				} else if (idx$(chr,[')','}',']','']) >= 0) {
					this.pair('%');
					return 0;
				};
			};
			
			if (!(match = SELECTOR.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var input = ary[0],id = ary[1],kind = ary[2];
			
			// this is a closed selector
			if (kind == '(') {
				// token '(','('
				this.token('SELECTOR_START',id,id.length + 1);
				// self.pushEnd(')') # are we so sure about this?
				this.pushEnd('%');
				
				// @ends.push ')'
				// @ends.push '%'
				return id.length + 1;
			} else if (id == '%') {
				// we are already scoped in on a selector
				if (this.context() == '%') { return 1 };
				this.token('SELECTOR_START',id,id.length);
				// this is a separate - scope. Full selector should rather be $, and keep the single selector as %
				
				this.scope('%',{open: true});
				// @ends.push '%'
				// make sure a terminator breaks out
				return id.length;
			} else {
				return 0;
			};
			
			if ((id == '%' || id == '$') && ['%','$','@','(','['].indexOf(chr) >= 0) {
				var idx = 2;
				
				
				// VERY temporary way of solving this
				if ((chr == '%' || chr == '$' || chr == '@')) {
					id += chr;
					idx = 3;
					chr = this._chunk.charAt(2);
				};
				
				
				if (chr == '(') {
					if (!(string = this.balancedSelector(this._chunk,')'))) { return 0 };
					if (0 < string.indexOf('{',1)) {
						this.token('SELECTOR',id);
						// is this even used anymore? If so - we need to fix it
						this.interpolateString(string.slice(idx,-1));
						return string.length;
					} else {
						this.token('SELECTOR',id);
						this.token('(','(');
						this.token('STRING','"' + string.slice(idx,-1) + '"');
						this.token(')',')');
						return string.length;
					};
				} else if (chr == '[') {
					this.token('SELECTOR',id);
					return 1;
					// token '[','['
					// @ends.push ''
				};
			} else {
				return 0;
			};
		};
		
		// is this really needed? Should be possible to
		// parse the identifiers and = etc i jison?
		// what is special about methodNameToken? really?
		Lexer.prototype.methodNameToken = function (){
			// we can optimize this by after a def simply
			// fetching all the way after the def until a space or (
			// and then add this to the def-token itself (as with fragment)
			if (this._chunk.charAt(0) == ' ') { return 0 };
			
			var match;
			
			if (this._end == ')') {
				var outerctx = this._ends[this._ends.length - 2];
				// weird assumption, no?
				// console.log 'context is inside!!!'
				if (outerctx == '%' && (match = TAG_ATTR.exec(this._chunk))) {
					this.token('TAG_ATTR_SET',match[1]);
					return match[0].length;
				};
			};
			
			if (!(match = METHOD_IDENTIFIER.exec(this._chunk))) {
				return 0;
			};
			// var prev = last @tokens
			var length = match[0].length;
			
			var id = match[0];
			var ltyp = this._lastTyp;
			var typ = 'IDENTIFIER';
			var pre = id.charAt(0);
			var space = false;
			
			var m4 = match[4]; // might be out of bounds? should rather check charAt
			// drop match 4??
			
			// should this not quit here in practically all cases?
			if (!((ltyp == '.' || ltyp == 'DEF') || (m4 == '!' || m4 == '?') || match[5])) {
				return 0;
			};
			
			// again, why?
			if (id == 'self' || id == 'this' || id == 'super') { // in ['SELF','THIS']
				return 0;
			};
			
			if (id == 'new') {
				typ = 'NEW';
			};
			
			if (id == '...' && [',','(','CALL_START','BLOCK_PARAM_START','PARAM_START'].indexOf(ltyp) >= 0) {
				return 0;
			};
			
			if (id == '|') {
				// hacky way to implement this
				// with new lexer we'll use { ... } instead, and assume object-context,
				// then go back and correct when we see the context is invalid
				if (ltyp == '(' || ltyp == 'CALL_START') {
					this.token('DO','DO',0);
					this.pushEnd('|');
					// @ends.push '|'
					this.token('BLOCK_PARAM_START',id,1);
					return length;
				} else if (ltyp == 'DO' || ltyp == '{') {
					// @ends.push '|'
					this.pushEnd('|');
					this.token('BLOCK_PARAM_START',id,1);
					return length;
				} else if (this._ends[this._ends.length - 1] == '|') {
					this.token('BLOCK_PARAM_END','|',1);
					this.pair('|');
					return length;
				} else {
					return 0;
				};
			};
			
			// whaat?
			// console.log("method identifier",id)
			if ((['&','^','<<','<<<','>>'].indexOf(id) >= 0 || (id == '|' && this.context() != '|'))) {
				return 0;
			};
			
			if (OP_METHODS.indexOf(id) >= 0) {
				space = true;
			};
			
			// not even anything we should use?!?
			if (pre == '@') {
				typ = 'IVAR';
			} else if (pre == '$') {
				true;
				// typ = 'GVAR'
			} else if (pre == '#') {
				typ = 'TAGID';
			} else if (CONST_IDENTIFIER.test(pre) || id == 'require' || id == 'global' || id == 'exports') {
				// really? seems very strange
				// console.log('global!!',typ,id)
				typ = 'CONST';
			};
			
			// what is this really for?
			if (match[5] && ['IDENTIFIER','CONST','GVAR','CVAR','IVAR','SELF','THIS',']','}',')','NUMBER','STRING','IDREF'].indexOf(ltyp) >= 0) {
				this.token('.','.',0);
			};
			
			this.token(typ,id,length);
			
			if (space) {
				this._last.spaced = true;
			};
			
			return length;
		};
		
		
		Lexer.prototype.inTag = function (){
			var len = this._ends.length;
			if (len > 0) {
				var ctx0 = this._ends[len - 1];
				var ctx1 = len > 1 ? (this._ends[len - 2]) : (ctx0);
				return ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
			};
			return false;
		};
		
		Lexer.prototype.isKeyword = function (id){
			if ((id == 'attr' || id == 'prop')) {
				var scop = this.getScope();
				var incls = scop == 'CLASS' || scop == 'TAG';
				// var scopes = @indents.map(|ind,i| @scopes[i] or 'NONE')
				// console.log "id is prop: {scopes.join(" -> ")} | {@indents.join(" -> ")}"
				if (incls) { return true };
			};
			
			return ALL_KEYWORDS.indexOf(id) >= 0;
		};
		
		// Matches identifying literals: variables, keywords, method names, etc.
		// Check to ensure that JavaScript reserved words aren't being used as
		// identifiers. Because Imba reserves a handful of keywords that are
		// allowed in JavaScript, we're careful not to tokid them as keywords when
		// referenced as property names here, so you can still do `jQuery.is()` even
		// though `is` means `===` otherwise.
		Lexer.prototype.identifierToken = function (){
			var ary;
			var match;
			
			var ctx0 = this._ends[this._ends.length - 1];
			var ctx1 = this._ends[this._ends.length - 2];
			var innerctx = ctx0;
			var typ;
			var reserved = false;
			
			var addLoc = false;
			var inTag = ctx0 == 'TAG_END' || (ctx1 == 'TAG_END' && ctx0 == 'OUTDENT');
			
			// console.log ctx1,ctx0
			
			if (inTag && (match = TAG_ATTR.exec(this._chunk))) {
				// console.log 'TAG_ATTR IN tokid',match
				// var prev = last @tokens
				// if the prev is a terminator, we dont really need to care?
				if (this._lastTyp != 'TAG_NAME') {
					if (this._lastTyp == 'TERMINATOR') {
						// console.log('prev was terminator -- drop it?')
						true;
					} else {
						this.token(",",",");
					};
				};
				
				var l = match[0].length;
				
				this.token('TAG_ATTR',match[1],l - 1); // add to loc?
				this._loc += l - 1;
				this.token('=','=',1);
				return l;
			};
			
			// see if this is a plain object-key
			// way too much logic going on here?
			// the ast should normalize whether keys
			// are accessable as keys or strings etc
			if (match = OBJECT_KEY.exec(this._chunk)) {
				var id = match[1];
				typ = 'IDENTIFIER';
				
				// FIXME loc of key includes colon
				// moveCaret(id:length)
				// console.log "ok"
				if (true) {
					// console.log "got here? {match}"
					this.token(typ,id,id.length);
					this.moveCaret(id.length);
					this.token(':',':',match[3].length);
					this.moveCaret(-id.length);
					// moveCaret(match[3]:length)
					return match[0].length;
				};
				
				// moveCaret(match[2]:length)
				// return 0
				console.log(match[3].length);
				this.token(typ,id,match[0].length);
				this.token(':',':',1);
				return match[0].length;
			};
			
			if (!(match = IDENTIFIER.exec(this._chunk))) {
				return 0;
			};
			
			var ary = iter$(match);var input = ary[0],id = ary[1],typ = ary[2],m3 = ary[3],m4 = ary[4],colon = ary[5];
			var idlen = id.length;
			
			// What is the logic here?
			if (id == 'own' && this.lastTokenType() == 'FOR') {
				this.token('OWN',id,id.length);
				return id.length;
			};
			
			var prev = last(this._tokens);
			var lastTyp = this._lastTyp;
			
			// should we force this to be an identifier even if it is a reserved word?
			// this should only happen for when part of object etc
			// will prev ever be @???
			var forcedIdentifier;
			
			// again
			forcedIdentifier = colon || lastTyp == '.' || lastTyp == '?.'; // in ['.', '?.'
			
			
			// temp hack! need to solve for other keywords etc as well
			// problem appears with ternary conditions.
			
			// well -- it should still be an indentifier if in object?
			// forcedIdentifier = no if id in ['undefined','break']
			
			if (colon && lastTyp == '?') { forcedIdentifier = false }; // for ternary
			
			// if we are not at the top level? -- hacky
			if (id == 'tag' && this._chunk.indexOf("tag(") == 0) { // @chunk.match(/^tokid\(/)
				forcedIdentifier = true;
			};
			
			var isKeyword = false;
			
			// console.log "match",match
			// console.log "typ is {typ}"
			// little reason to check for this right here? but I guess it is only a simple check
			if (typ == '$' && ARGVAR.test(id)) { // id.match(/^\$\d$/)
				// console.log "TYP $"
				if (id == '$0') {
					typ = 'ARGUMENTS';
				} else {
					typ = 'ARGVAR';
					id = id.substr(1);
				};
			} else if (typ == '@') {
				typ = 'IVAR';
				
				// id:reserved = yes if colon
			} else if (typ == '#') {
				// we are trying to move to generic tokens,
				// so we are starting to splitting up the symbols and the items
				// we'll see if that works
				typ = 'IDENTIFIER';
				this.token('#','#');
				id = id.substr(1);
			} else if (typ == '@@') {
				typ = 'CVAR';
			} else if (typ == '$' && !colon) {
				typ = 'IDENTIFIER';
				// typ = 'GVAR'
			} else if (CONST_IDENTIFIER.test(id) || id == 'require' || id == 'global' || id == 'exports') {
				// thous should really be handled by the ast instead
				typ = 'CONST';
			} else if (id == 'elif') {
				this.token('ELSE','elif',id.length);
				this.token('IF','if');
				return id.length;
			} else {
				typ = 'IDENTIFIER';
			};
			
			
			
			// this catches all 
			if (!forcedIdentifier && (isKeyword = this.isKeyword(id))) {
				// (id in JS_KEYWORDS or id in IMBA_KEYWORDS)
				typ = id.toUpperCase();
				addLoc = true;
				
				// clumsy - but testing performance
				if (typ == 'YES') {
					typ = 'TRUE';
				} else if (typ == 'NO') {
					typ = 'FALSE';
				} else if (typ == 'NIL') {
					typ = 'NULL';
				} else if (typ == 'VAR') {
					if (this._lastVal == 'export') {
						tTs(prev,'EXPORT');
					};
				} else if (typ == 'IF' || typ == 'ELSE' || typ == 'TRUE' || typ == 'FALSE' || typ == 'NULL') {
					true;
				} else if (typ == 'TAG') {
					this.pushEnd('TAG');
					// @ends.push('TAG')
				} else if (typ == 'DEF') {
					// should probably shift context and optimize this
					this.openDef();
				} else if (typ == 'DO') {
					if (this.context() == 'DEF') this.closeDef();
				} else if (typ == 'WHEN' && LINE_BREAK.indexOf(this.lastTokenType()) >= 0) {
					typ = 'LEADING_WHEN';
				} else if (typ == 'FOR') {
					this._seenFor = true;
				} else if (typ == 'UNLESS') {
					typ = 'IF'; // WARN
				} else if (UNARY.indexOf(typ) >= 0) {
					typ = 'UNARY';
				} else if (RELATION.indexOf(typ) >= 0) {
					if (typ != 'INSTANCEOF' && typ != 'ISA' && this._seenFor) {
						typ = 'FOR' + typ; // ?
						this._seenFor = false;
					} else {
						typ = 'RELATION';
						if (String(this.value()) == '!') {
							this._tokens.pop(); // is fucked up??!
							// WARN we need to keep the loc, no?
							id = '!' + id;
						};
					};
				};
			};
			
			if (id == 'super') {
				typ = 'SUPER';
			};
			
			// do we really want to check this here
			if (!forcedIdentifier) {
				// should already have dealt with this
				
				if (isKeyword && IMBA_ALIASES.indexOf(id) >= 0) { id = IMBA_ALIAS_MAP[id] };
				// these really should not go here?!?
				switch (id) {
					case '!':
						typ = 'UNARY';break;
					
					case '==':
					case '!=':
					case '===':
					case '!==':
						typ = 'COMPARE';break;
					
					case '&&':
					case '||':
						typ = 'LOGIC';break;
					
					case 'break':
					case 'continue':
					case 'debugger':
					case 'arguments':
						typ = id.toUpperCase();break;
				
				};
			};
			
			// prev = last @tokens
			var len = input.length;
			
			// should be strict about the order, check this manually instead
			if (typ == 'CLASS' || typ == 'DEF' || typ == 'TAG') {
				this.queueScope(typ);
				
				var i = this._tokens.length;
				
				while (i){
					prev = this._tokens[--i];
					var ctrl = "" + tV(prev);
					// console.log("ctrl is {ctrl}")
					// need to coerce to string because of stupid CS ===
					// console.log("prev is",prev[0],prev[1])
					if (idx$(ctrl,IMBA_CONTEXTUAL_KEYWORDS) >= 0) {
						tTs(prev,ctrl.toUpperCase());
						// prev[0] = ctrl.toUpperCase # FIX
					} else {
						break;
					};
				};
			} else if (typ == 'IF') {
				this.queueScope(typ);
			} else if (typ == 'IMPORT') {
				// could manually parse the whole ting here?
				this.pushEnd('IMPORT');
				// @ends.push 'IMPORT'
			} else if (id == 'from' && ctx0 == 'IMPORT') {
				typ = 'FROM';
				this.pair('IMPORT');
			} else if (id == 'as' && ctx0 == 'IMPORT') {
				typ = 'AS';
				this.pair('IMPORT');
			};
			
			if (typ == 'IDENTIFIER') {
				// see if previous was catch -- belongs in rewriter?
				if (lastTyp == 'CATCH') {
					typ = 'CATCH_VAR';
				};
			};
			
			if (colon) {
				this.token(typ,id,idlen);
				this.moveCaret(idlen);
				// console.log "add colon?"
				this.token(':',':',colon.length);
				this.moveCaret(-idlen);
			} else {
				this.token(typ,id,idlen);
			};
			
			return len;
		};
		
		// Matches numbers, including decimals, hex, and exponential notation.
		// Be careful not to interfere with ranges-in-progress.
		Lexer.prototype.numberToken = function (){
			var binaryLiteral;
			var match,number,lexedLength;
			
			if (!(match = NUMBER.exec(this._chunk))) { return 0 };
			
			number = match[0];
			lexedLength = number.length;
			
			if (binaryLiteral = /0b([01]+)/.exec(number)) {
				
				number = "" + parseInt(binaryLiteral[1],2);
			};
			
			var prev = last(this._tokens);
			
			if (match[0][0] == '.' && prev && !prev.spaced && ['IDENTIFIER',')','}',']','NUMBER'].indexOf(tT(prev)) >= 0) {
				// console.log "got here"
				this.token(".",".");
				number = number.substr(1);
			};
			
			
			this.token('NUMBER',number,lexedLength);
			return lexedLength;
		};
		
		Lexer.prototype.symbolToken = function (){
			var match,symbol,prev;
			
			if (!(match = SYMBOL.exec(this._chunk))) { return 0 };
			symbol = match[0].substr(1);
			prev = last(this._tokens);
			
			// is this a property-access?
			// should invert this -- only allow when prev IS .. 
			
			// : should be a token itself, with a specification of spacing (LR,R,L,NONE)
			
			// FIX
			if (prev && !prev.spaced && idx$(tT(prev),['(','{','[','.','CALL_START','INDEX_START',',','=','INDENT','TERMINATOR']) == -1) {
				this.token('.:',':',1);
				var sym = symbol.split(/[\:\\\/]/)[0]; // really?
				// token 'SYMBOL', "'#{symbol}'"
				this.token('IDENTIFIER',sym,sym.length,1);
				return (sym.length + 1);
			} else {
				// token 'SYMBOL', "'#{symbol}'"
				this.token('SYMBOL',symbol,match[0].length);
				return match[0].length;
			};
		};
		
		Lexer.prototype.escapeStr = function (str,heredoc,q){
			str = str.replace(MULTILINER,(heredoc ? ('\\n') : ('')));
			if (q) {
				var r = RegExp(("\\\\[" + q + "]"),"g");
				str = str.replace(r,q);
				str = str.replace(RegExp(("" + q),"g"),'\\$&');
			};
			return str;
			
			// str = str.replace(MULTILINER, '\\n')
			// str = str.replace(/\t/g, '\\t')
		};
		// Matches strings, including multi-line strings. Ensures that quotation marks
		// are balanced within the string's contents, and within nested interpolations.
		Lexer.prototype.stringToken = function (){
			var match,string;
			
			switch (this._chunk.charAt(0)) {
				case "'":
					if (!(match = SIMPLESTR.exec(this._chunk))) { return 0 };
					string = match[0];
					this.token('STRING',this.escapeStr(string),string.length);
					// token 'STRING', (string = match[0]).replace(MULTILINER, '\\\n'), string:length
					break;
				
				case '"':
					if (!(string = this.balancedString(this._chunk,'"'))) { return 0 };
					// what about tripe quoted strings?
					
					if (string.indexOf('{') >= 0) {
						var len = string.length;
						// if this has no interpolation?
						// we are now messing with locations - beware
						this.token('STRING_START',string.charAt(0),1);
						this.interpolateString(string.slice(1,-1));
						this.token('STRING_END',string.charAt(len - 1),1,string.length - 1);
					} else {
						len = string.length;
						// string = string.replace(MULTILINER, '\\\n')
						this.token('STRING',this.escapeStr(string),len);
					};
					break;
				
				default:
				
					return 0;
			
			};
			
			this.moveHead(string);
			return string.length;
		};
		
		// Matches heredocs, adjusting indentation to the correct level, as heredocs
		// preserve whitespace, but ignore indentation to the left.
		Lexer.prototype.heredocToken = function (){
			var match,heredoc,quote,doc;
			
			if (!(match = HEREDOC.exec(this._chunk))) { return 0 };
			
			heredoc = match[0];
			quote = heredoc.charAt(0);
			doc = this.sanitizeHeredoc(match[2],{quote: quote,indent: null});
			// console.log "found heredoc {match[0]:length} {doc:length}"
			
			if (quote == '"' && doc.indexOf('{') >= 0) {
				var open = match[1];
				// console.log doc.substr(0,3),match[1]
				this.token('STRING_START',open,open.length);
				this.interpolateString(doc,{heredoc: true,offset: open.length,quote: quote});
				this.token('STRING_END',open,open.length,heredoc.length - open.length);
			} else {
				this.token('STRING',this.makeString(doc,quote,true),0);
			};
			
			this.moveHead(heredoc);
			return heredoc.length;
		};
		
		// Matches and consumes comments.
		Lexer.prototype.commentToken = function (){
			var match,length,comment,indent,prev;
			
			var typ = 'HERECOMMENT';
			
			if (match = INLINE_COMMENT.exec(this._chunk)) { // .match(INLINE_COMMENT)
				// console.log "match inline comment"
				length = match[0].length;
				indent = match[1];
				comment = match[2];
				
				prev = last(this._tokens);
				var pt = prev && tT(prev);
				var note = '//' + comment.substr(1);
				
				if (this._last && this._last.spaced) {
					note = ' ' + note;
					// console.log "the previous node was SPACED"
				};
				// console.log "comment {note} - indent({indent}) - {length} {comment:length}"
				
				if ((pt && pt != 'INDENT' && pt != 'TERMINATOR') || !pt) {
					// console.log "skip comment"
					// token 'INLINECOMMENT', comment.substr(2)
					// console.log "adding as terminator"
					this.token('TERMINATOR',note,length); // + '\n'
				} else {
					// console.log "add comment ({note})"
					if (pt == 'TERMINATOR') {
						tVs(prev,tV(prev) + note);
						// prev[1] += note
					} else if (pt == 'INDENT') {
						// console.log "adding comment to INDENT: {note}" # why not add directly here?
						this.addLinebreaks(1,note);
					} else {
						// console.log "comment here"
						// should we ever get here?
						this.token(typ,comment.substr(2),length); // are we sure?
					};
				};
				
				return length; // disable now while compiling
			};
			
			// should use exec?
			if (!(match = COMMENT.exec(this._chunk))) { return 0 };
			
			comment = match[0];
			var here = match[1];
			
			if (here) {
				this.token('HERECOMMENT',this.sanitizeHeredoc(here,{herecomment: true,indent: Array(this._indent + 1).join(' ')}),comment.length);
				this.token('TERMINATOR','\n');
			} else {
				this.token('HERECOMMENT',comment,comment.length);
				this.token('TERMINATOR','\n'); // auto? really?
			};
			
			this.moveHead(comment);
			return comment.length;
		};
		
		// Matches JavaScript interpolated directly into the source via backticks.
		Lexer.prototype.jsToken = function (){
			var match,script;
			
			if (!(this._chunk.charAt(0) == '`' && (match = JSTOKEN.exec(this._chunk)))) { return 0 };
			this.token('JS',(script = match[0]).slice(1,-1));
			return script.length;
		};
		
		// Matches regular expression literals. Lexing regular expressions is difficult
		// to distinguish from division, so we borrow some basic heuristics from
		// JavaScript and Ruby.
		Lexer.prototype.regexToken = function (){
			var ary;
			var match,length,prev;
			
			if (this._chunk.charAt(0) != '/') { return 0 };
			if (match = HEREGEX.exec(this._chunk)) {
				length = this.heregexToken(match);
				this.moveHead(match[0]);
				return length;
			};
			
			prev = last(this._tokens);
			// FIX
			if (prev && (idx$(tT(prev),(prev.spaced ? (
				NOT_REGEX
			) : (
				NOT_SPACED_REGEX
			))) >= 0)) { return 0 };
			if (!(match = REGEX.exec(this._chunk))) { return 0 };
			var ary = iter$(match);var m = ary[0],regex = ary[1],flags = ary[2];
			
			// FIXME
			// if regex[..1] is '/*'
			//	error 'regular expressions cannot begin with `*`'
			
			if (regex == '//') {
				regex = '/(?:)/';
			};
			
			this.token('REGEX',("" + regex + flags),m.length);
			return m.length;
		};
		
		// Matches multiline extended regular expressions.
		// The escaping should rather happen in AST - possibly as an additional flag?
		Lexer.prototype.heregexToken = function (match){
			var ary;
			var ary = iter$(match);var heregex = ary[0],body = ary[1],flags = ary[2];
			
			if (0 > body.indexOf('#{')) {
				
				var re = body.replace(HEREGEX_OMIT,'').replace(/\//g,'\\/');
				
				if (re.match(/^\*/)) {
					this.error('regular expressions cannot begin with `*`');
				};
				
				this.token('REGEX',("/" + (re || '(?:)') + "/" + flags),heregex.length);
				return heregex.length;
			};
			
			// use more basic regex type
			
			this.token('CONST','RegExp');
			this._tokens.push(T.token('CALL_START','(',0));
			var tokens = [];
			
			for (var i = 0, items = iter$(this.interpolateString(body,{regex: true})), len = items.length, pair; i < len; i++) {
				
				pair = items[i];
				var tok = tT(pair); // FIX
				var value = tV(pair); // FIX
				
				if (tok == 'TOKENS') {
					// FIXME what is this?
					tokens.push.apply(tokens,value);
				} else {
					if (!value) {
						console.log("what??");
					};
					
					if (!(value = value.replace(HEREGEX_OMIT,''))) { continue; };
					
					value = value.replace(/\\/g,'\\\\');
					tokens.push(T.token('STRING',this.makeString(value,'"',true),0)); // FIX
				};
				
				tokens.push(T.token('+','+',0)); // FIX
			};
			
			tokens.pop();
			
			// FIX
			if (!(tokens[0] && tT(tokens[0]) == 'STRING')) {
				// FIX
				this._tokens.push(T.token('STRING','""'),T.token('+','+'));
			};
			
			this._tokens.push.apply(this._tokens,tokens); // what is this?
			// FIX
			
			if (flags) {
				this._tokens.push(T.token(',',',',0));
				this._tokens.push(T.token('STRING','"' + flags + '"',0));
			};
			
			this.token(')',')',0);
			
			return heregex.length;
		};
		
		// Matches newlines, indents, and outdents, and determines which is which.
		// If we can detect that the current line is continued onto the the next line,
		// then the newline is suppressed:
		//
		//     elements
		//       .each( ... )
		//       .map( ... )
		//
		// Keeps track of the level of indentation, because a single outdent token
		// can close multiple indents, so we need to know how far in we happen to be.
		Lexer.prototype.lineToken = function (){
			var match;
			
			if (!(match = MULTI_DENT.exec(this._chunk))) { return 0 };
			// should it not pair by itself token('SELECTOR_END','%',0)
			// if @end == '%'
			// 	console.log "pairing selector in lineToken {@chunk.substr(0,10)}"
			// 	# should not need to add anything here?
			// 	pair('%')
			
			var indent = match[0];
			// var brCount = count indent, '\n'
			var brCount = this.moveHead(indent);
			this._seenFor = false;
			// reset column as well?
			
			var prev = last(this._tokens,1);
			var size = indent.length - 1 - indent.lastIndexOf('\n');
			var noNewlines = this.unfinished();
			
			// console.log "noNewlines",noNewlines
			// console.log "lineToken -- ",@chunk.substr(0,10),"--"
			if ((/^\n#\s/).test(this._chunk)) {
				this.addLinebreaks(1);
				return 0;
			};
			
			if (size - this._indebt == this._indent) {
				if (noNewlines) {
					this.suppressNewlines();
				} else {
					this.newlineToken(brCount);
				};
				return indent.length;
			};
			
			if (size > this._indent) {
				if (noNewlines) {
					this._indebt = size - this._indent;
					this.suppressNewlines();
					return indent.length;
				};
				
				if (this.inTag()) {
					// console.log "indent inside tokid?!?"
					// @indebt = size - @indent
					// suppressNewlines()
					return indent.length;
				};
				
				
				var diff = size - this._indent + this._outdebt;
				this.closeDef();
				
				var immediate = last(this._tokens);
				
				if (immediate && tT(immediate) == 'TERMINATOR') {
					tTs(immediate,'INDENT');
					immediate._meta || (immediate._meta = {pre: tV(immediate),post: ''});
					
					// should rather add to meta somehow?!?
					// tVs(immediate,tV(immediate) + '%|%') # crazy
				} else {
					this.token('INDENT',"" + diff,0);
				};
				
				// console.log "indenting", prev, last(@tokens,1)
				// if prev and prev[0] == 'TERMINATOR'
				//   console.log "terminator before indent??"
				
				// check for comments as well ?
				
				this._indents.push(diff);
				this.pushEnd('OUTDENT');
				// @ends.push 'OUTDENT'
				this._outdebt = this._indebt = 0;
				this.addLinebreaks(brCount);
			} else {
				this._indebt = 0;
				this.outdentToken(this._indent - size,noNewlines,brCount);
				this.addLinebreaks(brCount - 1);
				// console.log "outdent",noNewlines,tokid()
			};
			
			this._indent = size;
			return indent.length;
		};
		
		// Record an outdent token or multiple tokens, if we happen to be moving back
		// inwards past several recorded indents.
		Lexer.prototype.outdentToken = function (moveOut,noNewlines,newlineCount){
			// here we should also take care to pop / reset the scope-body
			// or context-type for indentation 
			var dent = 0;
			while (moveOut > 0){
				var len = this._indents.length - 1;
				if (this._indents[len] == undefined) {
					moveOut = 0;
				} else if (this._indents[len] == this._outdebt) {
					moveOut -= this._outdebt;
					this._outdebt = 0;
				} else if (this._indents[len] < this._outdebt) {
					this._outdebt -= this._indents[len];
					moveOut -= this._indents[len];
				} else {
					dent = this._indents.pop() - this._outdebt;
					moveOut -= dent;
					this._outdebt = 0;
					
					if (!noNewlines) { this.addLinebreaks(1) };
					
					this.pair('OUTDENT');
					this.token('OUTDENT',"" + dent,0);
				};
			};
			
			if (dent) { this._outdebt -= moveOut };
			
			while (this.lastTokenValue() == ';'){
				this._tokens.pop();
			};
			
			if (!(this.lastTokenType() == 'TERMINATOR' || noNewlines)) { this.token('TERMINATOR','\n',0) };
			
			// capping scopes so they dont hang around 
			this._scopes.length = this._indents.length;
			
			var ctx = this.context();
			if (ctx == '%' || ctx == 'TAG') { this.pair(ctx) }; // really?
			this.closeDef();
			return this;
		};
		
		// Matches and consumes non-meaningful whitespace. tokid the previous token
		// as being "spaced", because there are some cases where it makes a difference.
		Lexer.prototype.whitespaceToken = function (){
			var match,nline,prev;
			if (!((match = WHITESPACE.exec(this._chunk)) || (nline = this._chunk.charAt(0) == '\n'))) { return 0 };
			prev = last(this._tokens);
			
			// FIX - why oh why?
			if (prev) {
				if (match) {
					prev.spaced = true;
					return match[0].length;
				} else {
					prev.newLine = true;
					return 0;
				};
			};
		};
		
		Lexer.prototype.addNewline = function (){
			return this.token('TERMINATOR','\n');
		};
		
		Lexer.prototype.moveHead = function (str){
			var br = count(str,'\n');
			return br;
		};
		
		
		Lexer.prototype.addLinebreaks = function (count,raw){
			var br;
			
			if (!raw && count == 0) { return this }; // no terminators?
			
			var prev = this._last;
			
			if (!raw) {
				if (count == 1) {
					br = '\n';
				} else if (count == 2) {
					br = '\n\n';
				} else if (count == 3) {
					br = '\n\n\n';
				} else {
					br = repeatString('\n',count);
				};
			};
			// FIX
			if (prev) {
				var t = prev._type; // @lastTyp
				var v = tV(prev);
				
				// we really want to add this
				if (t == 'INDENT') {
					// TODO we want to add to the indent
					// console.log "add the comment to the indent -- pre? {raw} {br}"
					
					var meta = prev._meta || (prev._meta = {pre: '',post: ''});
					meta.post += (raw || br);
					// tVs(v + (raw or br))
					return this;
				} else if (t == 'TERMINATOR') {
					// console.log "already exists terminator {br} {raw}"
					tVs(prev,v + (raw || br));
					return this;
				};
			};
			
			this.token('TERMINATOR',br,0);
			return;
		};
		
		// Generate a newline token. Consecutive newlines get merged together.
		Lexer.prototype.newlineToken = function (lines){
			// console.log "newlineToken"
			while (this.lastTokenValue() == ';'){
				console.log("pop token",this._tokens[this._tokens.length - 1]);
				this._tokens.pop();
			};
			
			this.addLinebreaks(lines);
			
			var ctx = this.context();
			// WARN now import cannot go over multiple lines
			if (ctx == 'TAG' || ctx == 'IMPORT') { this.pair(ctx) };
			this.closeDef(); // close def -- really?
			return this;
		};
		
		// Use a `\` at a line-ending to suppress the newline.
		// The slash is removed here once its job is done.
		Lexer.prototype.suppressNewlines = function (){
			if (this.value() == '\\') { this._tokens.pop() };
			return this;
		};
		
		// We treat all other single characters as a token. E.g.: `( ) , . !`
		// Multi-character operators are also literal tokens, so that Jison can assign
		// the proper order of operations. There are some symbols that we tokid specially
		// here. `;` and newlines are both treated as a `TERMINATOR`, we distinguish
		// parentheses that indicate a method call from regular parentheses, and so on.
		Lexer.prototype.literalToken = function (){
			var match,value;
			if (match = OPERATOR.exec(this._chunk)) {
				value = match[0];
				if (CODE.test(value)) this.tagParameters();
			} else {
				value = this._chunk.charAt(0);
			};
			
			var end1 = this._ends[this._ends.length - 1];
			var end2 = this._ends[this._ends.length - 2];
			
			var inTag = end1 == 'TAG_END' || end1 == 'OUTDENT' && end2 == 'TAG_END';
			
			var tokid = value;
			var prev = last(this._tokens);
			var pt = prev && tT(prev);
			var pv = prev && tV(prev);
			var length = value.length;
			
			// is this needed?
			if (value == '=' && prev) {
				
				if (pv == '||' || pv == '&&') { // in ['||', '&&']
					tTs(prev,'COMPOUND_ASSIGN');
					tVs(prev,pv + '=');
					// prev[0] = 'COMPOUND_ASSIGN'
					// prev[1] += '='
					return value.length;
				};
			};
			
			if (value == ';') {
				this._seenFor = false;
				tokid = 'TERMINATOR';
			} else if (value == '(' && inTag && pt != '=' && prev.spaced) { // FIXed
				// console.log 'spaced before ( in tokid'
				// FIXME - should rather add a special token like TAG_PARAMS_START
				this.token(',',',');
			} else if (value == '->' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '/>' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '>' && inTag) {
				tokid = 'TAG_END';
				this.pair('TAG_END');
			} else if (value == '>' && this.context() == 'DEF') {
				// console.log('picked up >!!')
				tokid = 'DEF_FRAGMENT';
				
				// elif value is 'TERMINATOR' and end1 is '%' 
				// 	closeSelector()
			} else if (value == 'TERMINATOR' && end1 == 'DEF') {
				this.closeDef();
			} else if (value == '&' && this.context() == 'DEF') {
				// console.log("okay!")
				tokid = 'BLOCK_ARG';
				// change the next identifier instead?
			} else if (value == '*' && this._chunk.charAt(1).match(/[A-Za-z\_\@\[]/) && (prev.spaced || [',','(','[','{','|','\n','\t'].indexOf(pv) >= 0)) {
				tokid = "SPLAT";
			} else if (value == '√') {
				tokid = 'SQRT';
			} else if (value == 'ƒ') {
				tokid = 'FUNC';
			} else if (idx$(value,MATH) >= 0) {
				tokid = 'MATH';
			} else if (idx$(value,COMPARE) >= 0) {
				tokid = 'COMPARE';
			} else if (idx$(value,COMPOUND_ASSIGN) >= 0) {
				tokid = 'COMPOUND_ASSIGN';
			} else if (idx$(value,UNARY) >= 0) {
				tokid = 'UNARY';
			} else if (idx$(value,SHIFT) >= 0) {
				tokid = 'SHIFT';
			} else if (idx$(value,LOGIC) >= 0) {
				tokid = 'LOGIC'; // or value is '?' and prev?:spaced 
			} else if (prev && !prev.spaced) {
				// need a better way to do these
				if (value == '(' && end1 == '%') {
					tokid = 'TAG_ATTRS_START';
				} else if (value == '(' && idx$(pt,CALLABLE) >= 0) {
					// not using this ???
					// prev[0] = 'FUNC_EXIST' if prev[0] is '?'
					tokid = 'CALL_START';
				} else if (value == '[' && idx$(pt,INDEXABLE) >= 0) {
					tokid = 'INDEX_START';
					if (pt == '?') { tTs(prev,'INDEX_SOAK') };
					// prev[0] = 'INDEX_SOAK' if prev[0] == '?'
				};
			};
			
			switch (value) {
				case '(':
				case '{':
				case '[':
					this.pushEnd(INVERSES[value]);break;
				
				case ')':
				case '}':
				case ']':
					this.pair(value);break;
			
			};
			
			// hacky rule to try to allow for tuple-assignments in blocks
			// if value is ',' and prev[0] is 'IDENTIFIER' and @tokens[@tokens:length - 2][0] in ['TERMINATOR','INDENT']
			//   # token "TUPLE", "tuple" # should rather insert it somewhere else, no?
			//   console.log("found comma")
			
			this.token(tokid,value,value.length);
			return value.length;
		};
		
		// Token Manipulators
		// ------------------
		
		// Sanitize a heredoc or herecomment by
		// erasing all external indentation on the left-hand side.
		Lexer.prototype.sanitizeHeredoc = function (doc,options){
			var match;
			var indent = options.indent;
			var herecomment = options.herecomment;
			
			if (herecomment) {
				if (HEREDOC_ILLEGAL.test(doc)) {
					this.error("block comment cannot contain '*/' starting");
				};
				if (doc.indexOf('\n') <= 0) { return doc };
			} else {
				var length_;while (match = HEREDOC_INDENT.exec(doc)){
					var attempt = match[1];
					if (indent == null || 0 < (length_ = attempt.length) && length_ < indent.length) {
						indent = attempt;
					};
				};
			};
			
			if (indent) { doc = doc.replace(RegExp(("\\n" + indent),"g"),'\n') };
			if (!herecomment) { doc = doc.replace(/^\n/,'') };
			return doc;
		};
		
		// A source of ambiguity in our grammar used to be parameter lists in function
		// definitions versus argument lists in function calls. Walk backwards, tokidging
		// parameters specially in order to make things easier for the parser.
		Lexer.prototype.tagParameters = function (){
			var tok;
			if (this.lastTokenType() != ')') { return this };
			var stack = [];
			var tokens = this._tokens;
			var i = tokens.length;
			
			tTs(tokens[--i],'PARAM_END');
			
			while (tok = tokens[--i]){
				var t = tT(tok);
				switch (t) {
					case ')':
						stack.push(tok);
						break;
					
					case '(':
					case 'CALL_START':
						if (stack.length) {
							stack.pop();
						} else if (t == '(') {
							tTs(tok,'PARAM_START');
							return this;
						} else {
							return this;
						};
						break;
				
				};
			};
			
			return this;
		};
		
		// Close up all remaining open blocks at the end of the file.
		Lexer.prototype.closeIndentation = function (){
			// ctx = context
			// pair(ctx) if ctx in ['%','DEF']
			this.closeDef();
			this.closeSelector();
			return this.outdentToken(this._indent,false,0);
		};
		
		// Matches a balanced group such as a single or double-quoted string. Pass in
		// a series of delimiters, all of which must be nested correctly within the
		// contents of the string. This method allows us to have strings within
		// interpolations within strings, ad infinitum.
		Lexer.prototype.balancedString = function (str,end){
			var match,letter,prev;
			
			// console.log 'balancing string!', str, end
			var stack = [end];
			var i = 0;
			
			// could it not happen here?
			while (i < (str.length - 1)){
				i++;
				letter = str.charAt(i);
				switch (letter) {
					case '\\':
						i++;
						continue;
						break;
					
					case end:
						stack.pop();
						if (!stack.length) {
							var v = str.slice(0,i + 1);
							return v;
						};
						end = stack[stack.length - 1];
						continue;
						break;
				
				};
				
				if (end == '}' && (letter == '"' || letter == "'")) {
					stack.push(end = letter);
				} else if (end == '}' && letter == '/' && (match = (HEREGEX.exec(str.slice(i)) || REGEX.exec(str.slice(i))))) {
					i += match[0].length - 1;
				} else if (end == '}' && letter == '{') {
					stack.push(end = '}');
				} else if (end == '"' && letter == '{') {
					stack.push(end = '}');
				};
				prev = letter;
			};
			
			if (!this._opts.silent) { return this.error(("missing " + (stack.pop()) + ", starting")) };
		};
		
		// Expand variables and expressions inside double-quoted strings using
		// Ruby-like notation for substitution of arbitrary expressions.
		//
		//     "Hello #{name.capitalize()}."
		//
		// If it encounters an interpolation, this method will recursively create a
		// new Lexer, tokenize the interpolated contents, and merge them into the
		// token stream.
		Lexer.prototype.interpolateString = function (str,options){
			// console.log "interpolate string"
			if(options === undefined) options = {};
			var heredoc = options.heredoc;
			var quote = options.quote;
			var regex = options.regex;
			var prefix = options.prefix;
			
			var startLoc = this._loc;
			var tokens = [];
			var pi = 0;
			var i = -1;
			var locOffset = options.offset || 1;
			var strlen = str.length;
			var letter;
			var expr;
			
			var isInterpolated = false;
			// out of bounds
			while (letter = str.charAt(i += 1)){
				if (letter == '\\') {
					i += 1;
					continue;
				};
				
				if (!(str.charAt(i) == '{' && (expr = this.balancedString(str.slice(i),'}')))) {
					continue;
				};
				
				isInterpolated = true;
				
				// these have no real sense of location or anything?
				if (pi < i) {
					// this is the prefix-string - before any item
					var tok = new Token('NEOSTRING',this.escapeStr(str.slice(pi,i),heredoc,quote),this._loc + pi + locOffset,i - pi);
					// tok.@loc = @loc + pi
					// tok.@len = i - pi + 2
					tokens.push(tok);
				};
				
				tokens.push(new Token('{{','{',this._loc + i + locOffset,1));
				
				var inner = expr.slice(1,-1);
				// console.log 'inner is',inner
				// remove leading spaces 
				// need to keep track of how much whitespace we dropped from the start
				inner = inner.replace(/^[^\n\S]+/,'');
				
				if (inner.length) {
					// we need to remember the loc we start at
					// console.log('interpolate from loc',@loc,i)
					// really? why not just add to the stack??
					// what about the added 
					// should share with the selector no?
					// console.log "tokenize inner parts of string",inner
					var spaces = 0;
					var offset = this._loc + i + (expr.length - inner.length) - 1;
					// why create a whole new lexer? Should rather reuse one
					// much better to simply move into interpolation mode where
					// we continue parsing until we meet unpaired }
					var nested = new Lexer().tokenize(inner,{inline: true,rewrite: false,loc: offset + locOffset});
					// console.log nested.pop
					
					if (nested[0] && tT(nested[0]) == 'TERMINATOR') {
						nested.shift();
					};
					
					if (nested.length) {
						tokens.push.apply(tokens,nested); // T.token('TOKENS',nested,0)
					};
				};
				
				// should rather add the amount by which our lexer has moved?
				i += expr.length - 1;
				tokens.push(new Token('}}','}',this._loc + i + locOffset,1));
				pi = i + 1;
			};
			
			// adding the last part of the string here
			if (i >= pi && pi < str.length) {
				// set the length as well - or?
				// the string after?
				// console.log 'push neostring'
				tokens.push(new Token('NEOSTRING',this.escapeStr(str.slice(pi),heredoc,quote),this._loc + pi + locOffset,str.length - pi));
			};
			
			// console.log tokens:length
			if (regex) { return tokens };
			
			if (!tokens.length) { return this.token('NEOSTRING','""') };
			
			for (var j = 0, len = tokens.length; j < len; j++) {
				this._tokens.push(tokens[j]);
			};
			
			return tokens;
		};
		
		// Matches a balanced group such as a single or double-quoted string. Pass in
		// a series of delimiters, all of which must be nested correctly within the
		// contents of the string. This method allows us to have strings within
		// interpolations within strings, ad infinitum.
		Lexer.prototype.balancedSelector = function (str,end){
			var prev;
			var letter;
			var stack = [end];
			// FIXME
			for (var len = str.length, i = 1; i < len; i++) {
				switch (letter = str.charAt(i)) {
					case '\\':
						i++;
						continue;
						break;
					
					case end:
						stack.pop();
						if (!stack.length) {
							return str.slice(0,i + 1);
						};
						
						end = stack[stack.length - 1];
						continue;
						break;
				
				};
				if (end == '}' && letter == [')']) {
					stack.push(end = letter);
				} else if (end == '}' && letter == '{') {
					stack.push(end = '}');
				} else if (end == ')' && letter == '{') {
					stack.push(end = '}');
				};
				prev = letter; // what, why?
			};
			
			return this.error(("missing " + (stack.pop()) + ", starting"));
		};
		
		// Pairs up a closing token, ensuring that all listed pairs of tokens are
		// correctly balanced throughout the course of the token stream.
		Lexer.prototype.pair = function (tok){
			var wanted = last(this._ends);
			if (tok != wanted) {
				if ('OUTDENT' != wanted) { this.error(("unmatched " + tok)) };
				var size = last(this._indents);
				this._indent -= size;
				this.outdentToken(size,true,0);
				return this.pair(tok);
			};
			return this.popEnd();
		};
		
		
		// Helpers
		// -------
		
		// Add a token to the results, taking note of the line number.
		Lexer.prototype.token = function (id,value,len,offset){
			this._lastTyp = id;
			this._lastVal = value;
			var tok = this._last = new Token(id,value,this._loc + (offset || 0),len || 0);
			this._tokens.push(tok);
			return;
		};
		
		Lexer.prototype.lastTokenType = function (){
			var token = this._tokens[this._tokens.length - 1];
			return token ? (tT(token)) : ('NONE');
		};
		
		Lexer.prototype.lastTokenValue = function (){
			var token = this._tokens[this._tokens.length - 1];
			return token ? (token._value) : ('');
		};
		
		// Peek at a tokid in the current token stream.
		Lexer.prototype.tokid = function (index,val){
			var tok;
			if (tok = last(this._tokens,index)) {
				if (val) { tTs(tok,val) };
				return tT(tok);
				// tok.@type = tokid if tokid # why?
				// tok.@type
			} else {
				return null;
			};
		};
		
		// Peek at a value in the current token stream.
		Lexer.prototype.value = function (index,val){
			var tok;
			if (tok = last(this._tokens,index)) {
				if (val) { tVs(tok,val) };
				return tV(tok);
				// tok.@value = val if val # why?
				// tok.@value
			} else {
				return null;
			};
		};
		
		
		// Are we in the midst of an unfinished expression?
		Lexer.prototype.unfinished = function (){
			if (LINE_CONTINUER.test(this._chunk)) { return true };
			return UNFINISHED.indexOf(this._lastTyp) >= 0;
		};
		
		// var tokens = ['\\','.', '?.', 'UNARY', 'MATH', '+', '-', 'SHIFT', 'RELATION', 'COMPARE', 'LOGIC', 'COMPOUND_ASSIGN', 'THROW', 'EXTENDS']
		
		// Converts newlines for string literals.
		Lexer.prototype.escapeLines = function (str,heredoc){
			return str.replace(MULTILINER,(heredoc ? ('\\n') : ('')));
		};
		
		// Constructs a string token by escaping quotes and newlines.
		Lexer.prototype.makeString = function (body,quote,heredoc){
			if (!body) { return quote + quote };
			body = body.replace(/\\([\s\S])/g,function(match,contents) {
				return (contents == '\n' || contents == quote) ? (contents) : (match);
			});
			// Does not work now
			body = body.replace(RegExp(("" + quote),"g"),'\\$&');
			return quote + this.escapeLines(body,heredoc) + quote;
		};
		
		// Throws a syntax error on the current `@line`.
		Lexer.prototype.error = function (message,len){
			if ((typeof this._line=='number'||this._line instanceof Number)) { message = ("" + message + " on line " + (this._line)) };
			
			if (len) {
				message += (" [" + (this._loc) + ":" + (this._loc + len) + "]");
			};
			
			var err = new SyntaxError(message);
			err.line = this._line;
			// err:columnNumber
			err = new ERR.ImbaParseError(err,{tokens: this._tokens,pos: this._tokens.length});
			err.region = [this._loc,this._loc + (len || 0)];
			throw err;
		};
		return Lexer;
	
	})()

/***/ },
/* 31 */
/***/ function(module, exports) {

	(function(){
		var TOK, LBRACKET, RBRACKET, LPAREN, RPAREN, INDENT, OUTDENT;
		
		
		module.exports.TOK = TOK = {};
		var TTERMINATOR = TOK.TERMINATOR = 1;
		var TIDENTIFIER = TOK.IDENTIFIER = 2;
		TIDENTIFIER = TOK.IVAR = 2;
		var CONST = TOK.CONST = 3;
		var VAR = TOK.VAR = 4;
		var IF = TOK.IF = 5;
		var ELSE = TOK.ELSE = 6;
		var DEF = TOK.DEF = 7;
		
		
		
		function Token(type,value,loc,len){
			this._type = type;
			this._value = value;
			this._loc = loc != null ? (loc) : (-1);
			this._len = len || 0;
			this._meta = null;
			this.generated = false;
			this.newLine = false;
			this.spaced = false;
			return this;
		};
		
		exports.Token = Token; // export class 
		Token.prototype.type = function (){
			return this._type;
		};
		
		Token.prototype.value = function (){
			return this._value;
		};
		
		Token.prototype.traverse = function (){
			return;
		};
		
		Token.prototype.c = function (){
			return "" + this._value;
		};
		
		Token.prototype.toString = function (){
			return this._value;
		};
		
		Token.prototype.charAt = function (i){
			return this._value.charAt(i);
		};
		
		Token.prototype.slice = function (i){
			return this._value.slice(i);
		};
		
		Token.prototype.region = function (){
			return [this._loc,this._loc + (this._len || this._value.length)];
		};
		
		Token.prototype.sourceMapMarker = function (){
			return this._loc == -1 ? (':') : (("%$" + (this._loc) + "$%"));
			// @col == -1 ? '' : "%%{@line}${@col}%%"
		};
		
		
		function lex(){
			var token = this.tokens[this.pos++];
			var ttag;
			
			if (token) {
				ttag = token._type;
				this.yytext = token;
			} else {
				ttag = '';
			};
			
			return ttag;
		}; exports.lex = lex;
		
		
		// export def token typ, val, line, col, len do Token.new(typ,val,line, col or 0, len or 0) # [null,typ,val,loc]
		function token(typ,val){
			return new Token(typ,val,-1,0);
		}; exports.token = token;
		
		function typ(tok){
			return tok._type;
		}; exports.typ = typ;
		function val(tok){
			return tok._value;
		}; exports.val = val; // tok[offset + 1]
		function line(tok){
			return tok._line;
		}; exports.line = line; // tok[offset + 2]
		function loc(tok){
			return tok._loc;
		}; exports.loc = loc; // tok[offset + 2]
		
		function setTyp(tok,v){
			return tok._type = v;
		}; exports.setTyp = setTyp;
		function setVal(tok,v){
			return tok._value = v;
		}; exports.setVal = setVal;
		function setLine(tok,v){
			return tok._line = v;
		}; exports.setLine = setLine;
		function setLoc(tok,v){
			return tok._loc = v;
		}; exports.setLoc = setLoc;
		
		
		module.exports.LBRACKET = LBRACKET = new Token('{','{',0,0,0);
		module.exports.RBRACKET = RBRACKET = new Token('}','}',0,0,0);
		
		module.exports.LPAREN = LPAREN = new Token('(','(',0,0,0);
		module.exports.RPAREN = RPAREN = new Token(')',')',0,0,0);
		
		LBRACKET.generated = true;
		RBRACKET.generated = true;
		LPAREN.generated = true;
		RPAREN.generated = true;
		
		module.exports.INDENT = INDENT = new Token('INDENT','2',0,0,0);
		return module.exports.OUTDENT = OUTDENT = new Token('OUTDENT','2',0,0,0);
	
	})()

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var INVERSES, LINEBREAKS;
		
		// The Imba language has a good deal of optional syntax, implicit syntax,
		// and shorthand syntax. This can greatly complicate a grammar and bloat
		// the resulting parse table. Instead of making the parser handle it all, we take
		// a series of passes over the token stream, using this **Rewriter** to convert
		// shorthand into the unambiguous long form, add implicit indentation and
		// parentheses, and generally clean things up.
		
		var T = __webpack_require__(31);
		var Token = T.Token;
		
		// Based on the original rewriter.coffee from CoffeeScript
		function Rewriter(){ };
		
		exports.Rewriter = Rewriter; // export class 
		Rewriter.prototype.tokens = function (){
			return this._tokens;
		};
		
		// Helpful snippet for debugging:
		//     console.log (t[0] + '/' + t[1] for t in @tokens).join ' '
		// Rewrite the token stream in multiple passes, one logical filter at
		// a time. This could certainly be changed into a single pass through the
		// stream, with a big ol' efficient switch, but it's much nicer to work with
		// like this. The order of these passes matters -- indentation must be
		// corrected before implicit parentheses can be wrapped around blocks of code.
		Rewriter.prototype.rewrite = function (tokens,opts){
			var token;
			if(opts === undefined) opts = {};
			this._tokens = tokens;
			this._options = opts;
			
			// console.log "tokens in: " + tokens:length
			if (opts.profile) { console.time("tokenize:rewrite") };
			
			var i = 0;
			// flag empty methods
			while (token = tokens[i]){
				var next = tokens[i + 1];
				if (token._type == 'DEF_BODY' && next && next._type == 'TERMINATOR') {
					token._type = 'DEF_EMPTY';
				};
				i++;
			};
			
			this.step("ensureFirstLine");
			this.step("removeLeadingNewlines");
			this.step("removeMidExpressionNewlines");
			this.step("tagDefArguments");
			this.step("closeOpenCalls");
			this.step("closeOpenIndexes");
			this.step("closeOpenTags");
			this.step("closeOpenTagAttrLists");
			this.step("addImplicitIndentation");
			this.step("tagPostfixConditionals");
			this.step("addImplicitBraces");
			this.step("addImplicitParentheses");
			
			if (opts.profile) { console.timeEnd("tokenize:rewrite") };
			// console.log "tokens out: " + @tokens:length
			return this._tokens;
		};
		
		Rewriter.prototype.step = function (fn){
			if (this._options.profile) {
				console.log(("---- starting " + fn + " ---- "));
				console.time(fn);
			};
			
			this[fn]();
			
			if (this._options.profile) {
				console.timeEnd(fn);
				console.log("\n\n");
			};
			return;
		};
		
		// Rewrite the token stream, looking one token ahead and behind.
		// Allow the return value of the block to tell us how many tokens to move
		// forwards (or backwards) in the stream, to make sure we don't miss anything
		// as tokens are inserted and removed, and the stream changes length under
		// our feet.
		Rewriter.prototype.scanTokens = function (block){
			var token;
			var tokens = this._tokens;
			
			var i = 0;
			while (token = tokens[i]){
				i += block.call(this,token,i,tokens);
			};
			
			return true;
		};
		
		Rewriter.prototype.detectEnd = function (i,condition,action){
			var tokens = this._tokens;
			var levels = 0;
			var starts = [];
			var token;
			var t,v;
			
			while (token = tokens[i]){
				if (levels == 0 && condition.call(this,token,i,starts)) {
					return action.call(this,token,i);
				};
				if (!token || levels < 0) {
					return action.call(this,token,i - 1);
				};
				
				t = T.typ(token);
				
				if (EXPRESSION_START.indexOf(t) >= 0) {
					if (levels == 0) { starts.push(i) };
					levels += 1;
				} else if (EXPRESSION_END.indexOf(t) >= 0) {
					levels -= 1;
				};
				i += 1;
			};
			return i - 1;
		};
		
		Rewriter.prototype.ensureFirstLine = function (){
			var tok = this._tokens[0];
			
			if (T.typ(tok) == 'TERMINATOR') {
				// console.log "adding bodystart"
				this._tokens = [T.token('BODYSTART','BODYSTART')].concat(this._tokens);
				// T.setTyp(tok,'HEADER')
			};
			return;
		};
		
		// Leading newlines would introduce an ambiguity in the grammar, so we
		// dispatch them here.
		Rewriter.prototype.removeLeadingNewlines = function (){
			var at = 0;
			
			for (var i = 0, ary = iter$(this._tokens), len = ary.length; i < len; i++) {
				if (T.typ(ary[i]) != 'TERMINATOR') {
					at = i;break;
				};
			};
			
			if (at) { this._tokens.splice(0,at) };
			
			return;
		};
		
		// Some blocks occur in the middle of expressions -- when we're expecting
		// this, remove their trailing newlines.
		Rewriter.prototype.removeMidExpressionNewlines = function (){
			var self = this;
			return self.scanTokens(function(token,i,tokens) { // do |token,i,tokens|
				var next = self.tokenType(i + 1);
				
				if (!(T.typ(token) == 'TERMINATOR' && EXPRESSION_CLOSE.indexOf(next) >= 0)) { return 1 };
				if (next == 'OUTDENT') { return 1 };
				tokens.splice(i,1);
				return 0;
			});
		};
		
		
		Rewriter.prototype.tagDefArguments = function (){
			return true;
		};
		
		// The lexer has tagged the opening parenthesis of a method call. Match it with
		// its paired close. We have the mis-nested outdent case included here for
		// calls that close on the same line, just before their outdent.
		Rewriter.prototype.closeOpenCalls = function (){
			var self = this;
			var condition = function(token,i) {
				var t = T.typ(token);
				return (t == ')' || t == 'CALL_END') || t == 'OUTDENT' && self.tokenType(i - 1) == ')';
			};
			
			var action = function(token,i) {
				var t = T.typ(token);
				var tok = self._tokens[t == 'OUTDENT' ? (i - 1) : (i)];
				return T.setTyp(tok,'CALL_END');
			};
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'CALL_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		// The lexer has tagged the opening parenthesis of an indexing operation call.
		// Match it with its paired close.
		Rewriter.prototype.closeOpenIndexes = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),[']','INDEX_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'INDEX_END'); };
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'INDEX_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		
		Rewriter.prototype.closeOpenTagAttrLists = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),[')','TAG_ATTRS_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'TAG_ATTRS_END'); }; // 'TAG_ATTRS_END'
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'TAG_ATTRS_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		// The lexer has tagged the opening parenthesis of an indexing operation call.
		// Match it with its paired close. Should be done in lexer directly
		Rewriter.prototype.closeOpenTags = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),['>','TAG_END']) >= 0; };
			var action = function(token,i) { return T.setTyp(token,'TAG_END'); }; // token[0] = 'TAG_END'
			
			return self.scanTokens(function(token,i) {
				if (T.typ(token) == 'TAG_START') { self.detectEnd(i + 1,condition,action) };
				return 1;
			});
		};
		
		Rewriter.prototype.addImplicitCommas = function (){
			return;
		};
		
		Rewriter.prototype.addImplicitBlockCalls = function (){
			var token;
			var i = 1;
			var tokens = this._tokens;
			
			while (token = tokens[i]){
				var t = token._type;
				var v = token._value;
				// hmm
				if (t == 'DO' && (v == 'INDEX_END' || v == 'IDENTIFIER' || v == 'NEW')) {
					tokens.splice(i + 1,0,T.token('CALL_END',')'));
					tokens.splice(i + 1,0,T.token('CALL_START','('));
					i++;
				};
				i++;
			};
			
			return;
		};
		
		// Object literals may be written with implicit braces, for simple cases.
		// Insert the missing braces here, so that the parser doesn't have to.
		Rewriter.prototype.addImplicitBraces = function (){
			var self = this;
			var stack = [];
			var start = null;
			var startIndent = 0;
			var startIdx = null;
			
			var noBraceTag = ['CLASS','IF','UNLESS','TAG','WHILE','FOR','UNTIL','CATCH','FINALLY','MODULE','LEADING_WHEN'];
			var noBraceContext = ['IF','TERNARY','FOR'];
			
			var noBrace = false;
			
			var scope = function() {
				return stack[stack.length - 1] || [];
			};
			
			var action = function(token,i) {
				return self._tokens.splice(i,0,T.RBRACKET);
			};
			
			var open = function(token,i) {
				return self._tokens.splice(i,0,T.LBRACKET);
			};
			
			var close = function(token,i) {
				return self._tokens.splice(i,0,T.RBRACKET);
			};
			
			var stackToken = function(a,b) {
				return [a,b];
			};
			
			return self.scanTokens(function(token,i,tokens) {
				var type = T.typ(token);
				var v = T.val(token);
				var ctx = stack[stack.length - 1] || [];
				var idx;
				
				if (noBraceContext.indexOf(type) >= 0) {
					// console.log "found noBraceTag {type}"
					stack.push(stackToken(type,i));
					return 1;
				};
				
				if (v == '?') {
					// console.log('TERNARY OPERATOR!')
					stack.push(stackToken('TERNARY',i));
					return 1;
				};
				
				// no need to test for this here as well as in
				if (EXPRESSION_START.indexOf(type) >= 0) {
					if (type == 'INDENT' && noBraceContext.indexOf(ctx[0]) >= 0) {
						stack.pop();
					};
					
					// console.log('expression start',type,ctx[0])
					if (type == 'INDENT' && self.tokenType(i - 1) == '{') {
						// stack ?!? no token
						stack.push(stackToken('{',i)); // should not autogenerate another?
					} else {
						stack.push(stackToken(type,i));
					};
					return 1;
				};
				
				if (EXPRESSION_END.indexOf(type) >= 0) {
					// console.log "EXPRESSION_END at {type} - stack is {ctx[0]}"
					if (ctx[0] == 'TERNARY') { // FIX?
						stack.pop();
					};
					
					start = stack.pop();
					if (!start) {
						console.log("NO STACK!!");
					};
					start[2] = i;
					
					// seems like the stack should use tokens, no?)
					if (start[0] == '{' && start.generated) { //  # type != '}' # and start:generated
						close(token,i);
						return 1;
					};
					
					return 1;
				};
				
				// is this correct? same for if/class etc?
				if (ctx[0] == 'TERNARY' && (type == 'TERMINATOR' || type == 'OUTDENT')) {
					stack.pop();
					return 1;
				};
				
				if (noBraceContext.indexOf(ctx[0]) >= 0 && type == 'INDENT') {
					console.log("popping noBraceContext");
					stack.pop();
					return 1;
				};
				
				
				if (type == ',') {
					// automatically add an ending here if inside:generated scope?
					// it is important that this is:generated(!)
					if (ctx[0] == '{' && ctx.generated) {
						tokens.splice(i,0,T.RBRACKET);
						stack.pop();
						return 2;
					} else {
						return 1;
					};
					true;
				};
				
				// found a type
				if (type == ':' && ctx[0] != '{' && ctx[0] != 'TERNARY' && (noBraceContext.indexOf(ctx[0]) == -1)) {
					// could just check if the end was right before this?
					
					if (start && start[2] == i - 1) {
						// console.log('this expression was just ending before colon!')
						idx = start[1] - 1; // these are the stackTokens
					} else {
						// console.log "rewrite here? #{i}"
						idx = i - 2; // if start then start[1] - 1 else i - 2
						// idx = idx - 1 if tokenType(idx) is 'TERMINATOR'
					};
					
					while (self.tokenType(idx - 1) == 'HERECOMMENT'){
						idx -= 2;
					};
					
					var t0 = tokens[idx - 1];
					
					if (t0 && T.typ(t0) == '}' && t0.generated) {
						tokens.splice(idx - 1,1);
						var s = stackToken('{');
						s.generated = true;
						stack.push(s);
						return 0;
					} else if (t0 && T.typ(t0) == ',' && self.tokenType(idx - 2) == '}') {
						tokens.splice(idx - 2,1);
						s = stackToken('{');
						s.generated = true;
						stack.push(s);
						return 0;
					} else {
						s = stackToken('{');
						s.generated = true;
						stack.push(s);
						open(token,idx + 1);
						return 2;
					};
				};
				
				// we probably need to run through autocall first?!
				
				if (type == 'DO') { // and ctx:generated
					var prev = T.typ(tokens[i - 1]); // [0]
					if (['NUMBER','STRING','REGEX','SYMBOL',']','}',')','STRING_END'].indexOf(prev) >= 0) {
						
						var tok = T.token(',',',');
						tok.generated = true;
						tokens.splice(i,0,tok);
						
						if (ctx.generated) {
							close(token,i);
							stack.pop();
							return 2;
						};
					};
				};
				
				if ((type == 'TERMINATOR' || type == 'OUTDENT' || type == 'DEF_BODY') && ctx.generated) {
					close(token,i);
					stack.pop();
					return 2;
				};
				
				return 1;
			});
		};
		
		// Methods may be optionally called without parentheses, for simple cases.
		// Insert the implicit parentheses here, so that the parser doesn't have to
		// deal with them.
		// Practically everything will now be callable this way (every identifier)
		Rewriter.prototype.addImplicitParentheses = function (){
			
			var self = this, token;
			var noCallTag = ['CLASS','IF','UNLESS','TAG','WHILE','FOR','UNTIL','CATCH','FINALLY','MODULE','LEADING_WHEN'];
			
			var action = function(token,i) {
				return self._tokens.splice(i,0,T.token('CALL_END',')'));
			};
			
			// console.log "adding implicit parenthesis" # ,self:scanTokens
			var tokens = self._tokens;
			
			var noCall = false;
			var seenFor = false;
			var endCallAtTerminator = false;
			
			var i = 0;
			while (token = tokens[i]){
				
				// to handle cases like:
				// if a(do yes).test
				// 	yes
				// we need to keep a stack for balanced pairs
				// until then you must explicitly end the call like
				// if a(do yes).test()
				// 	yes
				
				var type = token._type;
				
				var prev = tokens[i - 1];
				var current = tokens[i];
				var next = tokens[i + 1];
				
				var pt = prev && prev._type;
				var nt = next && next._type;
				
				// if pt == 'WHEN'
				// Never make these tags implicitly call
				// should we not just remove these from IMPLICIT_FUNC?
				if ((pt == ')' || pt == ']') && type == 'INDENT') {
					noCall = true;
				};
				
				if (noCallTag.indexOf(pt) >= 0) {
					// console.log("seen nocall tag {pt} ({pt} {type} {nt})")
					endCallAtTerminator = true;
					noCall = true;
					if (pt == 'FOR') { seenFor = true };
				};
				
				
				var callObject = false;
				var callIndent = false;
				
				// [prev, current, next] = tokens[i - 1 .. i + 1]
				
				// check for comments
				// console.log "detect end??"
				if (!noCall && type == 'INDENT' && next) {
					var prevImpFunc = pt && IMPLICIT_FUNC.indexOf(pt) >= 0;
					var nextImpCall = nt && IMPLICIT_CALL.indexOf(nt) >= 0;
					callObject = ((next.generated && nt == '{') || nextImpCall) && prevImpFunc;
					callIndent = nextImpCall && prevImpFunc;
				};
				
				var seenSingle = false;
				var seenControl = false;
				// Hmm ?
				
				// this is not correct if this is inside a block,no?
				if ((type == 'TERMINATOR' || type == 'OUTDENT' || type == 'INDENT')) {
					endCallAtTerminator = false;
					noCall = false;
				};
				
				if (type == '?' && prev && !prev.spaced) { token.call = true };
				
				// where does fromThem come from?
				if (token.fromThen) {
					i += 1;continue;
				};
				// here we deal with :spaced and :newLine
				if (!(callObject || callIndent || (prev && prev.spaced) && (prev.call || IMPLICIT_FUNC.indexOf(pt) >= 0) && (IMPLICIT_CALL.indexOf(type) >= 0 || !(token.spaced || token.newLine) && IMPLICIT_UNSPACED_CALL.indexOf(type) >= 0))) {
					i += 1;continue;
				};
				
				
				tokens.splice(i,0,T.token('CALL_START','('));
				// console.log "added ( {prev}"
				var cond = function(token,i) {
					var type = T.typ(token);
					if (!seenSingle && token.fromThen) { return true };
					var ifelse = type == 'IF' || type == 'UNLESS' || type == 'ELSE';
					if (ifelse || type == 'CATCH') { seenSingle = true };
					if (ifelse || type == 'SWITCH' || type == 'TRY') { seenControl = true };
					var prev = self.tokenType(i - 1);
					
					if ((type == '.' || type == '?.' || type == '::') && prev == 'OUTDENT') { return true };
					if (endCallAtTerminator && (type == 'INDENT' || type == 'TERMINATOR')) { return true };
					if ((type == 'WHEN' || type == 'BY') && !seenFor) {
						// console.log "dont close implicit call outside for"
						return false;
					};
					
					var post = tokens[i + 1];
					var postTyp = post && T.typ(post);
					// WTF
					return !token.generated && prev != ',' && (IMPLICIT_END.indexOf(type) >= 0 || (type == 'INDENT' && !seenControl) || (type == 'DOS' && prev != '=')) && (type != 'INDENT' || (self.tokenType(i - 2) != 'CLASS' && IMPLICIT_BLOCK.indexOf(prev) == -1 && !(post && ((post.generated && postTyp == '{') || IMPLICIT_CALL.indexOf(postTyp) >= 0))));
				};
				
				// The action for detecting when the call should end
				// console.log "detect end??"
				self.detectEnd(i + 1,cond,action);
				if (T.typ(prev) == '?') { T.setTyp(prev,'FUNC_EXIST') };
				i += 2;
				// need to reset after a match
				endCallAtTerminator = false;
				noCall = false;
				seenFor = false;
			};
			
			
			return;
		};
		
		// Because our grammar is LALR(1), it can't handle some single-line
		// expressions that lack ending delimiters. The **Rewriter** adds the implicit
		// blocks, so it doesn't need to. ')' can close a single-line block,
		// but we need to make sure it's balanced.
		Rewriter.prototype.addImplicitIndentation = function (){
			
			
			var self = this, token;
			var i = 0;
			var tokens = self._tokens;
			while (token = tokens[i]){
				var type = T.typ(token);
				var next = self.tokenType(i + 1);
				
				// why are we removing terminators after then? should be able to handle
				if (type == 'TERMINATOR' && next == 'THEN') {
					tokens.splice(i,1);
					continue;
				};
				
				if (type == 'CATCH' && idx$(self.tokenType(i + 2),['OUTDENT','TERMINATOR','FINALLY']) >= 0) {
					tokens.splice.apply(tokens,[].concat([i + 2,0], [].slice.call(self.indentation(token))));
					i += 4;continue;
				};
				
				if (SINGLE_LINERS.indexOf(type) >= 0 && (next != 'INDENT' && next != 'BLOCK_PARAM_START') && !(type == 'ELSE' && next == 'IF') && type != 'ELIF') {
					
					var starter = type;
					
					var indent = T.token('INDENT','2');
					var outdent = T.OUTDENT;
					// var indent, outdent = indentation(token)
					if (starter == 'THEN') { indent.fromThen = true }; // setting special values for these -- cannot really reuse?
					indent.generated = true;
					// outdent:generated = true
					tokens.splice(i + 1,0,indent);
					
					var condition = function(token,i) {
						var t = T.typ(token);
						return T.val(token) != ';' && SINGLE_CLOSERS.indexOf(t) >= 0 && !(t == 'ELSE' && starter != 'IF' && starter != 'THEN');
					};
					
					var action = function(token,i) {
						var idx = self.tokenType(i - 1) == ',' ? (i - 1) : (i);
						return tokens.splice(idx,0,outdent);
					};
					
					self.detectEnd(i + 2,condition,action);
					if (type == 'THEN') { tokens.splice(i,1) };
				};
				
				i++;
			};
			
			return;
		};
		
		// Tag postfix conditionals as such, so that we can parse them with a
		// different precedence.
		Rewriter.prototype.tagPostfixConditionals = function (){
			var self = this;
			var condition = function(token,i) { return idx$(T.typ(token),['TERMINATOR','INDENT']) >= 0; };
			
			return self.scanTokens(function(token,i) {
				var typ = T.typ(token);
				if (!(typ == 'IF' || typ == 'FOR')) { return 1 };
				var original = token;
				self.detectEnd(i + 1,condition,function(token,i) {
					if (T.typ(token) != 'INDENT') { return T.setTyp(original,'POST_' + T.typ(original)) };
				});
				return 1;
			});
		};
		
		// Generate the indentation tokens, based on another token on the same line.
		Rewriter.prototype.indentation = function (token){
			return [T.token('INDENT','2'),T.token('OUTDENT','2')];
		};
		
		// Look up a type by token index.
		Rewriter.prototype.type = function (i){
			// if i < 0 then return null
			var tok = this._tokens[i];
			return tok && T.typ(tok);
			// if tok then tok[0] else null
		};
		
		Rewriter.prototype.tokenType = function (i){
			var tok = this._tokens[i];
			return tok && T.typ(tok);
			// return tok and tok[0]
		};
		
		// Constants
		// ---------
		
		// List of the token pairs that must be balanced.
		var BALANCED_PAIRS = [
			['(',')'],
			['[',']'],
			['{','}'],
			['{{','}}'],
			['INDENT','OUTDENT'],
			['CALL_START','CALL_END'],
			['PARAM_START','PARAM_END'],
			['INDEX_START','INDEX_END'],
			['TAG_START','TAG_END'],
			['TAG_PARAM_START','TAG_PARAM_END'],
			['TAG_ATTRS_START','TAG_ATTRS_END'],
			['BLOCK_PARAM_START','BLOCK_PARAM_END']
		];
		
		// The inverse mappings of `BALANCED_PAIRS` we're trying to fix up, so we can
		// look things up from either end.
		module.exports.INVERSES = INVERSES = {};
		
		// The tokens that signal the start/end of a balanced pair.
		// var EXPRESSION_START = []
		// var EXPRESSION_END   = []
		
		for (var i = 0, ary = iter$(BALANCED_PAIRS), len = ary.length, pair; i < len; i++) {
			pair = ary[i];
			var left = pair[0];
			var rite = pair[1];
			INVERSES[rite] = left;
			INVERSES[left] = rite;
		};
		
		var EXPRESSION_START = ['(','[','{','INDENT','CALL_START','PARAM_START','INDEX_START','TAG_PARAM_START','BLOCK_PARAM_START','STRING_START','{{','TAG_START'];
		var EXPRESSION_END = [')',']','}','OUTDENT','CALL_END','PARAM_END','INDEX_END','TAG_PARAM_END','BLOCK_PARAM_END','STRING_END','}}','TAG_END'];
		
		var IDENTIFIERS = ['IDENTIFIER','GVAR','IVAR','CVAR','CONST','ARGVAR'];
		
		// Tokens that indicate the close of a clause of an expression.
		var EXPRESSION_CLOSE = ['CATCH','WHEN','ELSE','FINALLY'].concat(EXPRESSION_END);
		
		// Tokens that, if followed by an `IMPLICIT_CALL`, indicate a function invocation.
		var IMPLICIT_FUNC = ['IDENTIFIER','SUPER','@','THIS','SELF','EVENT','TRIGGER','TAG_END','IVAR',
		'GVAR','CONST','ARGVAR','NEW','BREAK','CONTINUE','RETURN'];
		
		// If preceded by an `IMPLICIT_FUNC`, indicates a function invocation.
		var IMPLICIT_CALL = [
			'SELECTOR','IDENTIFIER','NUMBER','STRING','SYMBOL','JS','REGEX','NEW','PARAM_START','CLASS',
			'IF','UNLESS','TRY','SWITCH','THIS','BOOL','TRUE','FALSE','NULL','UNDEFINED','UNARY','SUPER','IVAR','GVAR','CONST','ARGVAR','SELF',
			'@','[','(','{','--','++','SELECTOR','TAG_START','TAGID','#','SELECTOR_START','IDREF','SPLAT','DO','BLOCK_ARG',
			'FOR','STRING_START','CONTINUE','BREAK'
		]; // '->', '=>', why does it not work with symbol?
		
		var IMPLICIT_INDENT_CALL = [
			'FOR'
		];
		// is not do an implicit call??
		
		var IMPLICIT_UNSPACED_CALL = ['+','-'];
		
		// Tokens indicating that the implicit call must enclose a block of expressions.
		var IMPLICIT_BLOCK = ['{','[',',','BLOCK_PARAM_END','DO']; // '->', '=>', 
		
		var CONDITIONAL_ASSIGN = ['||=','&&=','?=','&=','|='];
		var COMPOUND_ASSIGN = ['-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|='];
		var UNARY = ['!','~','NEW','TYPEOF','DELETE'];
		var LOGIC = ['&&','||','&','|','^'];
		
		// optimize for fixed arrays
		var NO_IMPLICIT_BLOCK_CALL = [
			'CALL_END','=','DEF_BODY','(','CALL_START',',',':','RETURN',
			'-=','+=','/=','*=','%=','||=','&&=','?=','<<=','>>=','>>>=','&=','^=','|='
		]; // .concat(COMPOUND_ASSIGN)
		
		
		// console.log NO_IMPLICIT_BLOCK_CALL:length
		// NO_IMPLICIT_BLOCK_CALL
		// IMPLICIT_COMMA = ['->', '=>', '{', '[', 'NUMBER', 'STRING', 'SYMBOL', 'IDENTIFIER','DO']
		
		var IMPLICIT_COMMA = ['DO'];
		
		// Tokens that always mark the end of an implicit call for single-liners.
		var IMPLICIT_END = ['POST_IF','POST_UNLESS','POST_FOR','WHILE','UNTIL','WHEN','BY','LOOP','TERMINATOR','DEF_BODY','DEF_FRAGMENT'];
		
		// Single-line flavors of block expressions that have unclosed endings.
		// The grammar can't disambiguate them, so we insert the implicit indentation.
		var SINGLE_LINERS = ['ELSE','TRY','FINALLY','THEN','BLOCK_PARAM_END','DO','BEGIN','CATCH_VAR']; // '->', '=>', really?
		var SINGLE_CLOSERS = ['TERMINATOR','CATCH','FINALLY','ELSE','OUTDENT','LEADING_WHEN'];
		
		// Tokens that end a line.
		return LINEBREAKS = ['TERMINATOR','INDENT','OUTDENT'];
	
	})()

/***/ },
/* 33 */
/***/ function(module, exports) {

	(function(){
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		// create separate error-types with all the logic
		
		function ImbaParseError(e,o){
			this.error = e;
			this.message = e.message;
			this.filename = e.filename;
			this.line = e.line;
			this._options = o || {};
			this;
		};
		
		subclass$(ImbaParseError,Error);
		exports.ImbaParseError = ImbaParseError; // export class 
		ImbaParseError.wrap = function (err){
			// what about the stacktrace?
			return new ImbaParseError(err);
		};
		
		ImbaParseError.prototype.set = function (opts){
			this._options || (this._options = {});
			for (var i = 0, keys = Object.keys(opts), l = keys.length; i < l; i++){
				this._options[keys[i]] = opts[keys[i]];
			};
			return this;
		};
		
		ImbaParseError.prototype.start = function (){
			var o = this._options;
			var idx = o.pos - 1;
			var tok = o.tokens && o.tokens[idx];
			while (tok && tok._loc == -1){
				tok = o.tokens[--idx];
			};
			return tok;
		};
		
		ImbaParseError.prototype.desc = function (){
			var o = this._options;
			var msg = this.message;
			if (o.token && o.token._loc == -1) {
				return 'Syntax Error';
			} else {
				return msg;
			};
		};
		
		ImbaParseError.prototype.loc = function (){
			var start_;
			return (start_ = this.start()) && start_.region  &&  start_.region();
		};
		
		ImbaParseError.prototype.toJSON = function (){
			var o = this._options;
			var tok = this.start();
			// var tok = o:tokens and o:tokens[o:pos - 1]
			// var loc = tok and [tok.@loc,tok.@loc + (tok.@len or tok.@value:length)] or [0,0]
			// , col: tok.@col, line: tok.@line
			// get the token itself?
			return {warn: true,message: this.desc(),loc: this.loc()};
		};
		return ImbaParseError;
	
	})()

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		var Region = __webpack_require__(27).Region;
		
		
		function isWhitespace(str){
			return (/^[\n\t\ ]+$/).test(str);
		}; exports.isWhitespace = isWhitespace;
		
		function commonAncestor(a,b){
			if (a instanceof Array) {
				var arr = a.slice();
				return arr.reduce(function(prev,curr,i) {
					return commonAncestor(prev,curr);
				},arr.shift());
			};
			
			if (!a || !b) { return (a || b) };
			
			a = a._dom || a;
			b = b._dom || b;
			
			while (!a.contains(b)){
				a = a.parentNode;
			};
			while (!b.contains(a)){
				b = b.parentNode;
			};
			
			return tag$wrap(a);
		}; exports.commonAncestor = commonAncestor;
		
		
		var pairs = {
			'"': '"',
			"'": "'",
			'(': ')',
			'<': '>',
			'[': ']',
			'{': '}'
		};
		
		function wrapText(text,open,close){
			close || (close = pairs[open]);
			if (open == "'") { text = text.replace(/\'/g,"\\'") };
			return (open || '') + text + (close || '');
		}; exports.wrapText = wrapText;
		
		
		function stringIsBalanced(str){
			var opens = '[{("\'';
			var closes = ']})"\'';
			var stack = [];
			var i = 0;
			var s,end;
			
			while (s = str[i++]){
				var oid = opens.indexOf(s);
				
				if (s == end) {
					stack.pop();
					end = stack[stack.length - 1];
				} else if (oid >= 0) {
					stack.push(end = closes[oid]);
				};
			};
			
			return stack.length == 0 ? (true) : (false);
		}; exports.stringIsBalanced = stringIsBalanced;
		
		function colToLoc(line,col,tabsize){
			if(tabsize === undefined) tabsize = 4;
			var ci = 0;
			var rci = 0; // real column
			var char$;
			
			if (col == 0) { return 0 };
			
			while (char$ = line[ci++]){
				if (char$ == '\t') {
					var rest = tabsize - rci % tabsize;
					rci += rest;
				} else {
					rci += 1;
				};
				
				if (rci >= col) {
					return ci;
				};
			};
			
			return line.length;
		}; exports.colToLoc = colToLoc;
		
		function colToViewCol(line,col,tabsize){
			if(tabsize === undefined) tabsize = 4;
			var ci = 0;
			var rci = 0; // real column
			var char$;
			
			if (col == 0) { return 0 };
			
			while (char$ = line[ci++]){
				if (char$ == '\t') {
					var rest = tabsize - rci % tabsize;
					if (rest > 3 && col <= rci + 2) { break; };
					rci += rest;
				} else {
					rci += 1;
				};
				
				if (col <= rci) { break; };
			};
			return rci;
		}; exports.colToViewCol = colToViewCol;
		
		function colsForLine(line,tabsize){
			if(tabsize === undefined) tabsize = 4;
			var col = 0;
			var idx = 0;
			var char$;
			while (char$ = line[idx++]){
				if (char$ == '\t') {
					var rest = tabsize - col % tabsize;
					col += rest;
				} else {
					col += 1;
				};
			};
			return col;
		}; exports.colsForLine = colsForLine;
		
		function rowcol(buf,loc,tabsize){
			if(tabsize === undefined) tabsize = 4;
			buf = buf.toString();
			var pos = loc;
			var col = 0;
			var line = 0;
			var char$;
			
			// go back to start of line
			while (char$ = buf[pos - 1]){
				if (char$ == '\n') {
					break;
				};
				pos--;
			};
			
			// get column for slice
			while ((pos < loc) && (char$ = buf[pos])){
				if (char$ == '\t') {
					var rest = tabsize - (col % tabsize);
					col += rest;
				} else {
					col += 1;
				};
				pos++;
			};
			
			while (char$ = buf[pos - 1]){
				if (char$ == '\n') {
					line++;
				};
				pos--;
			};
			
			return [line,col];
		}; exports.rowcol = rowcol;
		
		function increaseIndent(str){
			var reg = /^(\s*(.*\=\s*)?(export |global |extend )?(class|def|tag|unless|if|else|elif|switch|try|catch|finally|for|while|until|do))/;
			var other = /\b(do)\b/;
			return reg.test(str) || other.test(str);
		}; exports.increaseIndent = increaseIndent;
		
		
		function repeatString(str,count){
			return new Array(count + 1).join(str);
		}; exports.repeatString = repeatString;
		
		
		function patchString(orig,str,mode){
			var region;
			var text = orig.toString();
			
			if (mode == 'append') {
				return text + str;
			} else if (mode == 'prepend') {
				return "" + str + text;
			} else {
				if (region = Region.normalize(mode)) {
					// let region = Region.normalize()
					return text.substr(0,region.start()) + str + text.slice(region.end());
				};
			};
		}; exports.patchString = patchString;; return patchString;
		
		
	
	})()

/***/ },
/* 35 */
/***/ function(module, exports) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};
		
		function HistoryState(data){
			if(data === undefined) data = {};
			this._timestamp = new Date();
			this._data = data;
			this;
		};
		
		
		
		HistoryState.prototype.data = function(v){ return this._data; }
		HistoryState.prototype.setData = function(v){ this._data = v; return this; };
		
		
		HistoryState.prototype.timestamp = function(v){ return this._timestamp; }
		HistoryState.prototype.setTimestamp = function(v){ this._timestamp = v; return this; };
		
		HistoryState.prototype.apply = function (view){
			return this;
		};
		
		HistoryState.prototype.update = function (data){
			this._data = data;
			this._timestamp = new Date();
			return this;
		};
		
		
		function FullHistoryState(){ return HistoryState.apply(this,arguments) };
		
		subclass$(FullHistoryState,HistoryState);
		FullHistoryState.prototype.apply = function (view){
			view.loadState(this._data);
			return this;
		};
		
		function DiffHistoryState(){ return HistoryState.apply(this,arguments) };
		
		subclass$(DiffHistoryState,HistoryState);
		
		
		var types = {};
		
		function Command(params){
			this._params = params;
		};
		
		
		
		Command.prototype.prev = function(v){ return this._prev; }
		Command.prototype.setPrev = function(v){ this._prev = v; return this; };
		
		
		Command.prototype.next = function(v){ return this._next; }
		Command.prototype.setNext = function(v){ this._next = v; return this; };
		
		
		Command.prototype.frame = function(v){ return this._frame; }
		Command.prototype.setFrame = function(v){ this._frame = v; return this; };
		
		Command.sym = function (sym){
			var $0 = arguments, i = $0.length;
			var pars = new Array(i>1 ? i-1 : 0);
			while(i>1) pars[--i - 1] = $0[i];
			this.prototype._symbol = sym;
			this.prototype._signature = pars;
			types[sym] = this;
			return this;
		};
		
		Command.load = function (o){
			var typ = types[o[0]];
			var frame = o[1];
			var cmd = typ.build(o[2]);
			cmd.setFrame(frame);
			return cmd;
		};
		
		Command.build = function (params){
			return new this(params);
		};
		
		Command.prototype.data = function (){
			return this._data;
		};
		
		Command.prototype.params = function (){
			return this._params;
		};
		
		Command.prototype.undo = function (view){
			return this.prev();
		};
		
		Command.prototype.redo = function (view){
			return this;
		};
		
		Command.prototype.enter = function (view){
			return this;
		};
		
		Command.prototype.remove = function (){
			var v_;
			if (this.prev()) { (this.prev().setNext(v_ = this.next()),v_) };
			if (this.next()) { (this.next().setPrev(v_ = this.prev()),v_) };
			return this;
		};
		
		Command.prototype.toJSON = function (){
			return [this._symbol,this._frame || 0,this.params() || []];
		};
		
		function Mark(){ return Command.apply(this,arguments) };
		
		subclass$(Mark,Command);
		Mark.sym('M','value');
		
		
		function Snapshot(params){
			this._code = params[0];
		};
		
		subclass$(Snapshot,Mark);
		Snapshot.sym('S','code');
		
		Snapshot.prototype.params = function (){
			return [this._code];
		};
		
		Snapshot.prototype.redo = function (view){
			console.log('load',this._code);
			view.load(this._code);
			// must repair? what about annotations?
			return this;
		};
		
		function Selection(params){
			this._old = params[0];
			this._new = params[1];
		};
		
		subclass$(Selection,Command);
		Selection.sym('|','old','new');
		
		Selection.load = function (val){
			return new this(val);
		};
		
		Selection.prototype.params = function (){
			return [this._old,this._new];
		};
		
		Selection.prototype.redo = function (view){
			view.caret().set(JSON.parse(this._new));
			return this;
		};
		
		Selection.prototype.enter = function (view){
			this.redo(view);
			return this;
		};
		
		Selection.prototype.undo = function (view){
			// we need to know about the previous selection for this?
			// can either store both - or traverse backwards to the previous
			// command like this
			var old = JSON.parse(this._old);
			console.log('move selection back to old',old,this.data());
			view.caret().set(old);
			return this.prev();
		};
		
		
		function Insert(pars){
			this._point = pars[0];
			this._str = pars[1];
		};
		
		subclass$(Insert,Command);
		Insert.sym('+','point','str');
		
		Insert.prototype.params = function (){
			return [this._point,this._str];
		};
		
		Insert.prototype.redo = function (view){
			console.log('redo Insert');
			return view.insert(this._point,this._str);
		};
		
		Insert.prototype.undo = function (view){
			console.log('undo Insert');
			view.erase([this._point,this._point + this._str.length]);
			return this.prev();
		};
		
		function Erase(params){
			this._region = params[0];
			this._str = params[1];
		};
		
		subclass$(Erase,Command);
		Erase.sym('-','region','str');
		
		Erase.prototype.params = function (){
			return [this._region,this._str];
		};
		
		Erase.prototype.redo = function (view){
			console.log('redo Erase');
			return view.erase(this._region);
		};
		
		Erase.prototype.undo = function (view){
			// if we dont know the text to 
			console.log('undo Erase');
			view.insert(this._region.start(),this._str);
			return this.prev();
		};
		
		
		function History(view){
			this._mode = 'normal';
			this._view = view;
			this._enabled = true;
			this._active = false;
			this.setCurrent(this._seed = new Mark());
			this;
		};
		
		exports.History = History; // export class 
		
		
		History.prototype.mode = function(v){ return this._mode; }
		History.prototype.setMode = function(v){ this._mode = v; return this; };
		
		
		History.prototype.view = function(v){ return this._view; }
		History.prototype.setView = function(v){ this._view = v; return this; };
		
		
		History.prototype.enabled = function(v){ return this._enabled; }
		History.prototype.setEnabled = function(v){ this._enabled = v; return this; };
		
		
		History.prototype.current = function(v){ return this._current; }
		History.prototype.setCurrent = function(v){ this._current = v; return this; };
		
		
		History.prototype.seed = function(v){ return this._seed; }
		History.prototype.setSeed = function(v){ this._seed = v; return this; };
		
		
		History.prototype.tail = function(v){ return this._tail; }
		History.prototype.setTail = function(v){ this._tail = v; return this; }; // is this behind or in the very front?
		
		History.prototype.add = function (item,move,frame){
			if(move === undefined) move = true;
			if(frame === undefined) frame = this.view().frames();
			item.setFrame(frame);
			
			if (this.current()) {
				// if current has a next event
				// this should be detached here?
				item.setPrev(this.current());
				this.current().setNext(item);
			};
			
			if (move) { (this.setCurrent(item),item) };
			return this;
		};
		
		History.prototype.next = function (){
			var current_;
			return (current_ = this.current()) && current_.next  &&  current_.next();
		};
		
		History.prototype.prev = function (){
			var current_;
			return (current_ = this.current()) && current_.prev  &&  current_.prev();
		};
		
		History.prototype.update = function (o){
			return this;
		};
		
		History.prototype.move = function (dir){
			if(dir === undefined) dir = 1;
			return this;
		};
		
		History.prototype.redo = function (){
			var self = this;
			self.apply(function() {
				var res = [];while (self.next()){
					self.next().redo(self.view(),self);
					self.setCurrent(self.next());
					if (self.current() instanceof Mark) { break; };
				};return res;
			});
			return self;
		};
		
		History.prototype.undo = function (){
			var self = this;
			self.apply(function() {
				// should be possible to undo 
				var res = [], v_, current_;while (self.current()){
					if (self.prev()) { (self.setCurrent(v_ = self.current().undo(self.view(),self)),v_) };
					(current_ = self.current()) && current_.enter  &&  current_.enter(self.view(),self);
					if (self.current() instanceof Mark) { break; };
				};return res;
			});
			
			return self;
		};
		
		History.prototype.apply = function (cb){
			this._active = true;
			cb && cb();
			this._active = false;
			return this;
		};
		
		History.prototype.batch = function (cb){
			return this;
		};
		
		History.prototype.enter = function (state){
			state.apply(this.view());
			return this;
		};
		
		History.prototype.onerase = function (reg,str,edit){
			if (this._active) { return this };
			return this.add(new Erase([reg,str]));
		};
		
		History.prototype.oninsert = function (loc,str,edit){
			if (this._active) { return this };
			return this.add(new Insert([loc,str]));
		};
		
		History.prototype.oncaret = function (old,new$){
			if (this._active) { return this };
			return this.add(new Selection([old,new$]));
		};
		
		History.prototype.onload = function (code){
			if (this._active) { return this };
			var mark = new Snapshot([code]);
			return this.add(mark);
		};
		
		History.prototype.mark = function (value){
			if (this._active) { return this };
			var mark = new Mark([value]);
			return this.add(mark);
		};
		
		History.prototype.tick = function (){
			
			var self = this;
			if (self._mode == 'play') {
				// console.log 'plyaing'
				var frame = self.view().frames() - self._offset;
				// console.log 'history.tick will play',frame,next,current
				self.apply(function() {
					var res = [], v_;while (self.next() && self.next().frame() <= frame){
						// console.log 'history.tick play',frame,next,current
						// console.log 'replay frame!'
						self.next().redo(self.view(),self);
						res.push(((self.setCurrent(v_ = self.next()),v_)));
					};return res;
				});
				
				if (!(self.next())) {
					self.setMode('live');
				};
			};
			return self;
		};
		
		History.prototype.play = function (){
			// should probably happen in a different manager
			var self = this;
			var snap = self.seed();
			while (!(!snap || (snap instanceof Snapshot))){
				snap = snap.next();
			};
			
			self._offset = self.view().frames() - snap.frame();
			console.log("playing from seed",snap,self._offset);
			// console.log 'found snapshot?!? -- offset frame',@offset
			self.apply(function() { var v_;
			return (self.setCurrent(v_ = snap.redo(self.view(),self)),v_); });
			self.setMode('play');
			return self;
		};
		
		History.prototype.toJSON = function (){
			var data = [];
			var step = this._seed;
			
			while (step){
				data.push(step.toJSON());
				step = step.next();
			};
			
			return {commands: data};
		};
		
		History.prototype.load = function (data){
			var step = this.seed();
			for (var i = 0, ary = iter$(data.commands), len = ary.length; i < len; i++) {
				var item = Command.load(ary[i]);
				item.setPrev(step);
				step.setNext(item);
				step = item;
				// console.log 'load item',item
			};
			// console.log 'loaded'
			return this;
		};
		return History;
		
		
	
	})()

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		
		function Logger(view){
			this._enabled = true;
			this._view = view;
			this;
		};
		
		exports.Logger = Logger; // export class 
		
		
		Logger.prototype.enabled = function(v){ return this._enabled; }
		Logger.prototype.setEnabled = function(v){ this._enabled = v; return this; };
		
		
		Logger.prototype.view = function(v){ return this._view; }
		Logger.prototype.setView = function(v){ this._view = v; return this; };
		
		Logger.prototype.log = function (){
			if (this._enabled || (1)) { console.log.apply(console,arguments) };
			return this;
		};
		
		Logger.prototype.warn = function (){
			if (this._enabled || (1)) { console.log.apply(console,arguments) };
			return this;
		};
		
		Logger.prototype.group = function (name){
			if (this._enabled || (1)) { console.group.apply(console,arguments) };
			return this;
		};
		
		Logger.prototype.groupCollapsed = function (){
			if (this._enabled || (1)) { console.groupCollapsed.apply(console,arguments) };
			return this;
		};
		
		Logger.prototype.groupEnd = function (){
			if (this._enabled || (1)) { console.groupEnd() };
			return this;
		};
		return Logger;
		
		
	
	})()

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		var self = this;
		var util = __webpack_require__(34);
		
		var specialKeys = {
			8: "backspace",
			9: "tab",
			10: "return",
			13: "return",
			16: "shift",
			17: "ctrl",
			18: "alt",
			19: "pause",
			20: "capslock",
			27: "esc",
			32: "space",
			33: "pageup",
			34: "pagedown",
			35: "end",
			36: "home",
			37: "left",
			38: "up",
			39: "right",
			40: "down",
			45: "insert",
			46: "del",
			59: ";",
			61: "=",
			96: "0",
			97: "1",
			98: "2",
			99: "3",
			100: "4",
			101: "5",
			102: "6",
			103: "7",
			104: "8",
			105: "9",
			106: "*",
			107: "+",
			109: "-",
			110: ".",
			111: "/",
			112: "f1",
			113: "f2",
			114: "f3",
			115: "f4",
			116: "f5",
			117: "f6",
			118: "f7",
			119: "f8",
			120: "f9",
			121: "f10",
			122: "f11",
			123: "f12",
			144: "numlock",
			145: "scroll",
			173: "-",
			186: ";",
			187: "=",
			188: ",",
			189: "-",
			190: ".",
			191: "/",
			192: "`",
			219: "[",
			220: "\\",
			221: "]",
			222: "'"
		};
		
		var shiftNums = {
			"`": "~",
			"1": "!",
			"2": "@",
			"3": "#",
			"4": "$",
			"5": "%",
			"6": "^",
			"7": "&",
			"8": "*",
			"9": "(",
			"0": ")",
			"-": "_",
			"=": "+",
			";": ": ",
			"'": '"',
			",": "<",
			".": ">",
			"/": "?",
			"\\": "|"
		};
		
		function trigger(key,o){
			if (o instanceof Function) {
				o = {command: o};
			};
			o.trigger = key;
			return o;
		};
		
		function combo(keys,o){
			if (o instanceof Function) { o = {command: o} };
			o.keys = keys;
			return o;
		};
		
		IM.KeyBindings = [
			
			combo(['super+z'],function(sel) { return sel.view().history().undo(); }),
			combo(["super+shift+z"],function(sel) { return sel.view().history().redo(); }),
			combo(["alt+super+p"],function(sel) { return sel.view().history().play(); }),
			// combo ["alt+shift+r"] do |sel| sel.view.history.play
			
			combo(["super+s"],{command: "save"}),
			combo(["super+b"],{command: "run"}),
			combo(["alt+super+s"],{command: "saveSession"}),
			combo(["alt+shift+l"],{command: "reparse"}),
			combo(["alt+shift+k"],{command: "reparseExtent"}),
			
			combo(["super+a"],function(sel) { return sel.selectAll(); }),
			
			
			combo(['tab'],{context: function(sel) { return sel.text().indexOf('\n') >= 0; },
			command: function(sel) {
				sel.expandToLines();
				var region = sel.region();
				var nodes = sel.view().nodesInRegion(region);
				
				nodes.map(function(match) {
					if (match.node.matches('._imnewline')) {
						console.log('found tab in selection',match);
						if (match.mode != 'start') {
							return match.node.indent();
						};
					};
				});
				return sel.dirty();
			}}),
			
			
			
			combo(["shift+tab"],{context: function(sel) { return sel.text().indexOf('\n') >= 0; },
			command: function(sel) {
				sel.expandToLines();
				var region = sel.region();
				var nodes = sel.view().nodesInRegion(region);
				
				nodes.map(function(match) {
					if (match.node.matches('._imnewline') && match.mode != 'start') {
						return match.node.undent();
					};
				});
				return sel.dirty();
			}}),
			
			combo(["shift+tab"],{context: function(e) {
				return true; // String(e.view.selection).indexOf('\n') >= 0
			},
			command: function(sel) {
				console.log('try undent');
				return true;
			}}),
			
			combo(["alt+shift+return"],function(sel) { return console.log('prettify'); }),
			
			combo(["backspace"],{context: function(e) {
				console.log('deleteLeftRight backspace?!?',e.region(),e.region().peek(-1,1));
				return idx$(e.region().peek(-1,1),['[]','{}','<>','()','""',"''"]) >= 0;
			},
			
			command: function(sel) {
				console.log('moving!!');
				sel.expand(-1,1);
				return sel.erase();
			}}),
			
			combo(["backspace"],{context: function(sel,o) {
				var reg = sel.region();
				if (reg.size() == 0) {
					if (o.node = reg.prevNode('._impair,._imstr')) {
						return true;
					};
				};
			},
			
			command: function(sel,o) { var v_;
			return (sel.setRegion(v_ = o.node.region().clone().reverse()),v_); }}),
			
			combo(["backspace"],{context: function(sel,o) {
				if (sel.text() && !util.stringIsBalanced(sel.text())) {
					return true;
				};
			},
			command: function(sel,o) { return true; }}),
			
			combo(["backspace"],function(sel) { return sel.erase(); }),
			combo(["shift+backspace"],function(sel) { return sel.erase(); }),
			combo(["alt+backspace"],function(sel) { return sel.erase(IM.WORD_START); }),
			combo(["super+backspace"],function(sel) { return sel.erase(IM.LINE_START); }),
			
			combo(["return",'shift+return','super+return'],function(sel) {
				var ind = sel.indent();
				if (util.increaseIndent(sel.head().peekbehind())) { ind += '\t' };
				
				// should not happen in string
				if (idx$(sel.region().peek(-1,1),['[]','{}','()']) >= 0) {
					sel.insert('\n\t' + ind);
					sel.view().insert(sel.head().loc(),'\n' + ind);
				} else {
					sel.insert('\n' + ind);
				};
				
				return true;
			}),
			
			
			combo(['space','shift+space'],function(sel) {
				if (sel.region().peek(-1,1) == '<>') {
					sel.move(1).erase();
				};
				
				return sel.insert(' ');
			}),
			
			combo(['tab'],function(sel) { return sel.insert('\t'); }),
			
			
			combo(['super+up'],function(sel) {
				sel.collapse().head().set(0,0).normalize();
				return sel.dirty();
			}),
			
			combo(['super+down'],function(sel) {
				sel.collapse().head().set(100000,0).normalize();
				return sel.dirty();
			}),
			
			combo(['super+u'],function(sel,o) {
				console.log(sel.target(),"found ut!!!");
				return console.log(sel.target().bubble('unwrap',{}));
			}),
			
			combo(['alt+super+r'],function() { return window.location.reload(); })
		];
		
		IM.Triggers = [
			
			trigger('|',{context: function(sel) { return sel.region().peek(-1,1) == '||'; },
			command: function(sel) { return sel.move(1); }}),
			
			trigger('[',function(sel) { return sel.insert('[$0]'); }),
			trigger('|',function(sel) { return sel.insert('|$0|'); }),
			trigger('(',function(sel) { return sel.insert('($0)'); }),
			trigger('{',function(sel) { return sel.insert('{$0}'); }),
			
			trigger('<',{context: function(sel) { return !sel.peekbehind(/(\b(tag|if|class) |\d\s*$)/); },
			command: function(sel) { return sel.insert('<$0>'); }}),
			
			trigger('"',{context: function(sel,o) {
				if (sel.region().peek(-1,0) == '\\' && (o.node = sel.region().scope(q$('._imstr',self)))) {
					return true;
				};
			},
			command: function(sel) { return sel.insert('"'); }}),
			
			trigger("'",{context: function(sel,o) { return sel.region().peek(-1,1) == "''"; },
			command: function(sel) { return sel.move(1); }}),
			
			trigger("'",{context: function(sel,o) { return o.node = sel.region().scope(q$('._imstr',self)); },
			command: function(sel) { return sel.insert("\\'"); }}),
			
			trigger('"',function(sel) { return sel.insert('"$0"'); }),
			trigger("'",function(sel) { return sel.insert("'$0'"); }),
			
			trigger(']',{context: function(sel) { return sel.region().peek(0,1) == ']'; },
			command: function(sel) { return sel.move(1); }}),
			
			trigger('}',{context: function(sel) { return sel.region().peek(0,1) == '}'; },
			command: function(sel) { return sel.move(1); }}),
			
			trigger(')',{context: function(sel) { return sel.region().peek(0,1) == ')'; },
			command: function(sel) { return sel.move(1); }})
		];
		
		function ShortcutManager(view,bindings){
			this._view = view;
			this._bindings = bindings || IM.KeyBindings;
			this;
		};
		
		global.ShortcutManager = ShortcutManager; // global class 
		ShortcutManager.prototype.view = function (){
			return this._view;
		};
		
		ShortcutManager.prototype.keysForEvent = function (e){
			var combo = [];
			var special = specialKeys[e.which];
			var chr = special || String.fromCharCode(e.which);
			
			chr = chr.toLowerCase(); // unless e:shiftKey
			
			if (e.ctrlKey && special != 'ctrl') { combo.push('ctrl') };
			if (e.altKey && special != 'alt') { combo.push('alt') };
			if (e.metaKey && !e.ctrlKey && special !== 'meta') { combo.push('super') };
			if (e.shiftKey && special != 'shift') { combo.push('shift') };
			if (combo.indexOf(chr) < 0) { combo.push(chr) };
			
			return combo.join('+');
		};
		
		ShortcutManager.prototype.commandsForKeys = function (combo){
			return this._bindings.filter(function(binding) { return binding.keys == combo; });
		};
		
		ShortcutManager.prototype.getShortcut = function (e){
			var combo = this.keysForEvent(e.event());
			console.log(combo);
			
			for (var i = 0, ary = iter$(this._bindings), len = ary.length, cmd; i < len; i++) {
				cmd = ary[i];
				if (cmd.keys.indexOf(combo) >= 0) {
					var o = {};
					// console.log 'found shortcut',combo,cmd:keys
					if (!cmd.context || cmd.context.call(this.view(),this.view().caret(),o,e,this.view())) {
						cmd.data = o;
						return cmd;
					};
				};
			};
			
			return null;
		};
		
		ShortcutManager.prototype.getTrigger = function (view,text){
			for (var i = 0, ary = iter$(IM.Triggers), len = ary.length, cmd; i < len; i++) {
				cmd = ary[i];
				if (cmd.trigger == text) {
					var res = cmd.context ? (cmd.context.call(view,view.caret(),view,text)) : (true);
					if (res) { return cmd };
				};
			};
			return null;
		};
		return ShortcutManager;
		
		
		
		
	
	})()
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 38 */
/***/ function(module, exports) {

	(function(){
		return tag$.defineTag('imcaptor', 'input', function(tag){
			
			tag.prototype.select = function (){
				if (!this.dom().value) {
					this.dom().value = 'x';
				};
				this.dom().select();
				return this;
			};
			
			tag.prototype.build = function (){
				var self = this;
				tag.__super__.build.apply(self,arguments);
				self.dom().onfocus = function(e) {
					console.log('dom onfocus!!!!');
					var event = Imba.Event.wrap({type: 'inputfocus',target: self.dom()});
					return event.process();
				};
				
				self.dom().onblur = function(e) {
					console.log('dom onblur!!!!',e);
					var event = Imba.Event.wrap({type: 'inputblur',target: self.dom(),relatedTarget: e.relatedTarget});
					return event.process();
					// Imba.Events.trigger('inputblur',dom)
				};
				
				return self;
			};
		});
	
	})()

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// disabling logs for now
		// console:log = do true
		// externs;
		
		var OPEN = ['"',"'",'(','[','{','<'];
		var CLOSE = ['"',"'",')',']','}','>'];
		
		if (Imba.Events) {
			Imba.Events.register(['copy','paste','cut','beforecut','beforepaste','beforecopy','keypress']);
		};
		
		var Logger = __webpack_require__(36).Logger;
		var History = __webpack_require__(35).History;
		var Buffer = __webpack_require__(40).Buffer;
		var Observer = __webpack_require__(41).Observer;
		
		var Region = __webpack_require__(27).Region;
		var hints$ = __webpack_require__(42), Hints = hints$.Hints, Hint = hints$.Hint;
		var Highlighter = __webpack_require__(29).Highlighter;
		
		var util = __webpack_require__(34);
		
		__webpack_require__(43);
		
		__webpack_require__(44);
		
		tag$.defineTag('imdims', function(tag){
			
			tag.prototype.ch = function (){
				// uncache
				if (this._ow != this.dom().offsetWidth) {
					this._ow = this.dom().offsetWidth;
					this._ch = null;
				};
				
				return this._ch || (this._ch = this.dom().getBoundingClientRect().width);
			};
		});
		
		tag$.defineTag('imviewbody');
		
		tag$.defineTag('imview', function(tag){
			
			
			
			tag.prototype.filename = function(v){ return this._filename; }
			tag.prototype.setFilename = function(v){ this._filename = v; return this; };
			
			
			
			tag.prototype.observer = function(v){ return this._observer; }
			tag.prototype.setObserver = function(v){ this._observer = v; return this; };
			
			
			tag.prototype.history = function(v){ return this._history; }
			tag.prototype.setHistory = function(v){ this._history = v; return this; };
			
			
			tag.prototype.hints = function(v){ return this._hints; }
			tag.prototype.setHints = function(v){ this._hints = v; return this; };
			
			
			tag.prototype.logger = function(v){ return this._logger; }
			tag.prototype.setLogger = function(v){ this._logger = v; return this; };
			
			
			tag.prototype.shortcuts = function(v){ return this._shortcuts; }
			tag.prototype.setShortcuts = function(v){ this._shortcuts = v; return this; };
			
			tag.prototype.__focusNode = {watch: 'focusNodeDidSet',name: 'focusNode'};
			tag.prototype.focusNode = function(v){ return this._focusNode; }
			tag.prototype.setFocusNode = function(v){
				var a = this.focusNode();
				if(v != a) { this._focusNode = v; }
				if(v != a) { this.focusNodeDidSet && this.focusNodeDidSet(v,a,this.__focusNode) }
				return this;
			};
			
			
			tag.prototype.caret = function(v){ return this._caret; }
			tag.prototype.setCaret = function(v){ this._caret = v; return this; };
			
			
			tag.prototype.frames = function(v){ return this._frames; }
			tag.prototype.setFrames = function(v){ this._frames = v; return this; };
			
			
			tag.prototype.readonly = function(v){ return this._readonly; }
			tag.prototype.setReadonly = function(v){ this._readonly = v; return this; };
			
			tag.prototype.highlighter = function (){
				return Highlighter;
			};
			
			tag.prototype.lineHeight = function (){
				return this._dims.dom().offsetHeight;
			};
			
			tag.prototype.charWidth = function (){
				return this._dims.ch();
			};
			
			tag.prototype.isReadOnly = function (){
				return this.history().mode() == 'play';
			};
			
			tag.prototype.tabSize = function (){
				return 4;
			};
			
			tag.prototype.build = function (){
				// console.log 'build imview'
				VIEW = this;
				this.setTabindex(0);
				
				this._readonly = false;
				this._logger = new Logger(this);
				this._frames = 0;
				this._changes = 0;
				
				this._hints = new Hints(this);
				this._buffer = new Buffer(this);
				this._history = new History(this);
				this._shortcuts = new ShortcutManager(this);
				this.render();
				this._observer = new Observer(this);
				this.caret().setRegion(new Region(0,0,this.root(),this));
				
				// bind to mousemove of dom?
				
				this.dom().addEventListener('mouseover',function(e) { return Imba.Events.delegate(e); });
				this.dom().addEventListener('mouseout',function(e) { return Imba.Events.delegate(e); });
				return this;
			};
			
			tag.prototype.onmouseover = function (e){
				return e.halt();
			};
			
			tag.prototype.onmouseout = function (e){
				return e.halt();
			};
			
			tag.prototype.setInput = function (input){
				
				if (input != this._input) {
					this._input = input;
					// console.log 'set input!!!',@input
					this._input.dom()._responder = this.dom();
				};
				return this;
			};
			
			tag.prototype.input = function (){
				return this._input || this._caret.input();
			};
			
			// called every frame - looking for changed nodes to deal with
			// to deal with mutations.
			tag.prototype.tick = function (){
				this._frames++;
				this.history().tick();
				this.render();
				if (this._dirty) this.repair();
				return this;
			};
			
			tag.prototype.commit = function (){
				return this.tick();
			};
			
			tag.prototype.log = function (){
				var logger_;
				(logger_ = this.logger()).log.apply(logger_,arguments);
				return this;
			};
			
			tag.prototype.edited = function (){
				var self = this;
				self._changes++;
				self._dirty = true;
				self._buffer.refresh();
				
				self.view().hints().rem(function(hint) {
					return hint.group() == 'runtime';
				});
				
				self.hints().cleanup();
				
				self.delay('didchange',50,function() {
					return Imba.Events.trigger('edited:async',self,{data: self});
				});
				
				// we can improve how/when we choose to annotate.
				// currently we do it after every edit - but it should
				// really only be needed when we have changed identifiers.
				// should also only reannotate the closest known scope,
				// but this comes later with refactoring from whole files
				// to scopes.
				self.delay('annotate',500,function() { return self.annotate(); });
				self.delay('recompile',-1); // cancel recompilation
				return self;
			};
			
			tag.prototype.dirty = function (){
				return this;
			};
			
			tag.prototype.activate = function (){
				this.flag('active');
				return this;
			};
			
			tag.prototype.deactivate = function (){
				this.unflag('active');
				return this;
			};
			
			tag.prototype.body = function (){
				var t0;
				return (t0 = this._body=this._body || tag$.$imviewbody().setRef('body',this)).setContent([
					(this._dims = this._dims || tag$.$imdims().setRef('dims',this)).setText("x").end(),
					(this._caret = this._caret || tag$.$imcaret().setRef('caret',this)).setView(this).end(),
					(this._root = this._root || tag$.$imroot().setRef('root',this).flag('imba')).setView(this).end()
				],2).end();
			};
			
			tag.prototype.header = function (){
				return null;
			};
			
			tag.prototype.footer = function (){
				return null;
			};
			
			tag.prototype.overlays = function (){
				return (this._overlays = this._overlays || tag$.$scrimbla_overlays().setRef('overlays',this)).setView(this).end();
			};
			
			tag.prototype.render = function (){
				return this.flag('readonly',this.isReadOnly()).setChildren([
					this.header(),
					this.body(),
					this.footer()
				],1).synced();
			};
			
			tag.prototype.view = function (){
				return this;
			};
			
			tag.prototype.sel = function (){
				return this.caret();
			};
			
			tag.prototype.root = function (){
				return this._root;
			};
			
			tag.prototype.buffer = function (){
				return this._buffer;
				// root.code
			};
			
			tag.prototype.size = function (){
				return this.root().size();
			};
			
			tag.prototype.load = function (code,o){
				var parsed;
				if(o === undefined) o = {};
				this.setFilename(o.filename);
				// console.log 'loading file with filename',o:filename
				// observer.pause do
				if (o.html) {
					this.root().dom().innerHTML = o.html;
					this._buffer.refresh();
					this.history().onload(this.code());
				} else {
					// should use our new parser
					if (parsed = this.parse(code)) {
						if (parsed.highlighted) {
							this.root().dom().innerHTML = parsed.highlighted;
						} else {
							this.root().dom().textContent = code;
						};
					};
					this._buffer.refresh();
					this.history().onload(code);
					this.annotate();
				};
				return this;
			};
			
			tag.prototype.parse = function (code){
				// here we can parse the full code
				return {highlighted: IM.parse(code)};
			};
			
			tag.prototype.refocus = function (){
				if (document.activeElement != this.input().dom()) { this.input().focus() };
				return this;
			};
			
			tag.prototype.oninputfocus = function (e){
				console.log('oninputfocus!!');
				VIEW = this; // hack
				return this.flag('focus');
			};
			
			tag.prototype.oninputblur = function (e){
				return this.unflag('focus');
			};
			
			tag.prototype.onfocusin = function (e){
				VIEW = this; // hack
				this.flag('focus');
				console.log('focus',e);
				return this;
			};
			
			tag.prototype.onfocusout = function (e){
				this.unflag('focus');
				console.log('unfocus',e);
				return this;
			};
			
			tag.prototype.oninput = function (e){
				return this;
			};
			
			tag.prototype.ontextinput = function (e){
				return this;
			};
			
			tag.prototype.execAction = function (action,keydown){
				var command_;
				if (action.command instanceof Function) {
					return action.command.call(this,this.caret(),action.data || {event: keydown},this);
				} else if ((typeof (command_ = action.command)=='string'||command_ instanceof String)) {
					this.log('command is string',action.command);
					var ev = Imba.Events.trigger(action.command,this,{data: action});
					this.log(ev);
					return this;
				};
			};
			
			tag.prototype.tryCommand = function (cmd,target,params){
				if(params === undefined) params = [];
				if (cmd.context) {
					var guard = cmd.context.apply(target || this,params);
					if (!guard) { return false };
				};
				
				if (cmd.command instanceof Function) {
					return cmd.command.apply(target || this,params);
				};
			};
			
			
			
			tag.prototype.onkeydown = function (e){
				var arr;
				VIEW = this; // hack
				e.halt();
				// var combo = e.keycombo
				var combo = this.shortcuts().keysForEvent(e.event());
				var action = this.shortcuts().getShortcut(e);
				var ins = null;
				
				var shift = (/\bshift\b/).test(combo);
				var alt = (/\balt\b/).test(combo);
				var sup = (/\bsuper\b/).test(combo);
				
				// log 'imview keydown',combo
				
				if (action) {
					// console.log 'action here?!',action
					if (this.execAction(action,e)) { e.cancel() };
					return;
				};
				
				// move these into commands as well
				// thisshould move this into commands instead
				if (arr = combo.match(/\b(left|right|up|down)/)) {
					this.hints().activate();
					
					var isCollapsed = this.caret().isCollapsed();
					var ends = this.caret().ends();
					
					shift ? (this.caret().decollapse()) : (this.caret().collapse());
					
					if (arr[0] == 'down') {
						this.caret().moveDown();
						return e.cancel();
					} else if (arr[0] == 'up') {
						this.caret().moveUp();
						return e.cancel();
					};
					
					var mode = IM.CHARACTERS;
					var dir = 0;
					
					if (arr[0] == 'left') {
						dir = -1;
					};
					
					if (arr[0] == 'right') {
						dir = 1;
					};
					
					if (alt) {
						mode = dir > 0 ? (IM.WORD_END) : (IM.WORD_START);
					} else if (sup) {
						mode = dir > 0 ? (IM.LINE_END) : (IM.LINE_START);
					} else if (!shift && !isCollapsed) {
						this.caret().head().set(dir > 0 ? (ends[1]) : (ends[0]));
						this.caret().dirty(); // should not need to call this all the time
						return e.cancel();
					};
					
					this.caret().move(dir,mode);
					
					return e.cancel();
				};
				
				if (e.event().which == 229) {
					return e.halt();
				};
				
				if (combo.match(/^super\+(c|v|x)$/)) {
					// console.log 'matching combo for copy paste'
					e.halt();
					this._awaitCombo = true;
					this.refocus();
					return;
				};
				
				if (ins != null) {
					e.halt().cancel();
					this.caret().insert(ins);
					return this;
				};
				
				return this;
			};
			
			tag.prototype.onkeypress = function (e){
				if (this._awaitCombo) {
					this._awaitCombo = false;
					return e.halt();
				};
				
				e.halt();
				var text = String.fromCharCode(e.event().charCode);
				e._text = text;
				e.cancel();
				this.ontype(e);
				return this;
			};
			
			tag.prototype.ontextinput = function (e){
				e.halt().cancel();
				e._text = e.event().data;
				this.ontype(e);
				return this;
			};
			
			tag.prototype.onkeyup = function (e){
				e.halt();
				return this;
			};
			
			tag.prototype.oninput = function (e){
				e.halt();
				return this;
			};
			
			tag.prototype.ontype = function (e){
				try {
					var ins = e._text;
					// log 'ontype',e,ins
					
					var spans = this.view().nodesInRegion(this.caret().region(),false,true);
					var target = spans[0];
					var cmd;
					
					if (spans.length == 1) {
						// log 'single node for nodesInRegion',target:node
						if (cmd = target.node[("trigger-" + ins)]) {
							// log "found combo for this!??!",cmd
							if (this.tryCommand(cmd,this.caret(),[target.node,target])) {
								return this;
							};
						};
					};
					
					cmd = this.shortcuts().getTrigger(this,ins);
					
					if (cmd && (cmd.command instanceof Function)) {
						// log 'found command!!',cmd
						// should rather run tryCommand?!?
						return cmd.command(this.caret(),this,ins,e);
					} else {
						if (ins) { return this.caret().insert(ins) };
					};
				} catch (e) {
					return this.log('error from ontype');
				};
			};
			
			tag.prototype.onbackspace = function (e){
				e.cancel().halt();
				this.caret().erase();
				return;
			};
			
			tag.prototype.onbeforecopy = function (e){
				if (true) { console.log('onbeforecopy',e) };
				this.input().select();
				var data = e.event().clipboardData;
				data.setData('text/plain',this.caret().text());
				return e.halt();
			};
			
			tag.prototype.oncopy = function (e){
				if (true) { console.log('oncopy',e,this.caret().text()) };
				var data = e.event().clipboardData;
				data.setData('text/plain',this.caret().text());
				e.halt().cancel();
				this.refocus();
				return;
			};
			
			tag.prototype.oncut = function (e){
				if (true) {
					console.log('oncut',e);
				};
				var data = e.event().clipboardData;
				data.setData('text/plain',this.caret().text());
				e.halt().cancel();
				return this.caret().erase();
			};
			
			tag.prototype.onbeforepaste = function (e){
				return console.log('onbeforepaste',e);
			};
			
			tag.prototype.onpaste = function (e){
				console.log('onpaste',e);
				var data = e.event().clipboardData;
				var text = data.getData('text/plain');
				e.halt().cancel();
				this.caret().insert(text);
				this.refocus();
				return this.repair();
				// edit text: data
			};
			
			tag.prototype.refresh = function (){
				// focusNode = sel.node # only if it is inside the scope?
				// caret.region = sel.region
				this.caret().render();
				return this;
			};
			
			tag.prototype.exec = function (o){
				var fn = o.command;
				var args = o.args || [];
				var ev = new Imba.Event({type: 'command',target: this.dom(),data: o});
				ev.setData(o);
				ev.process();
				
				return;
			};
			
			tag.prototype.ontouchstart = function (touch){
				var ary;
				this._rect = this._body.dom().getBoundingClientRect();
				
				if (touch.button() != 0) { return };
				
				if (touch._touch) {
					// is it not redirected?
					return touch.redirect({});
				};
				
				var e = touch.event();
				e.preventDefault();
				// see if shift is down? should change behaviour
				var shift = e.shiftKey;
				// log 'ontouchstart',touch,touch.x,touch.y,e,touch.button
				var ary = iter$(this.rcForTouch(touch));var r = ary[0],c = ary[1];
				
				if (shift) {
					this.caret().selectable();
				} else {
					this.caret().collapse();
				};
				
				this.caret().head().set(r,c).normalize();
				this.caret().dirty();
				// console.log 'touch start refocus?'
				this.refocus();
				return this;
			};
			
			tag.prototype.xyToRowCol = function (x,y){
				var col = Math.max(Math.round(x / this.charWidth()),0);
				var row = Math.max(Math.ceil(y / this.lineHeight()),1);
				return [row - 1,col];
			};
			
			tag.prototype.rcForTouch = function (touch){
				var x = Math.max(touch.x() - this._rect.left,0);
				var y = Math.max(touch.y() - this._rect.top,0);
				return this.xyToRowCol(x,y);
			};
			
			tag.prototype.ontouchupdate = function (touch){
				var ary;
				if (touch.button() != 0) { return };
				var ary = iter$(this.rcForTouch(touch));var r = ary[0],c = ary[1];
				this.caret().selectable();
				this.caret().head().set(r,c).normalize();
				this.caret().dirty();
				return this;
			};
			
			tag.prototype.ontouchend = function (touch){
				var ary;
				if (touch.button() != 0) { return };
				var ary = iter$(this.rcForTouch(touch));var r = ary[0],c = ary[1];
				this.caret().head().set(r,c).normalize();
				this.caret().dirty();
				return this;
			};
			
			tag.prototype.erase = function (reg,edit){
				reg = Region.normalize(reg,this);
				
				var text = reg.text();
				this.history().onerase(reg,text,edit);
				
				var spans = this.nodesInRegion(reg,false,true);
				// gropu the nodes
				this.observer().pause(function() {
					if (spans.length > 1) {
						spans[1].node.setPrev(tag$.$iminsert().flag('dirty').end());
					} else if (spans[0] && spans[0].mode == 'all') {
						console.log('removing single node?!');
						var before = spans[0].node.prev();
						
						spans[0].node.setPrev(tag$.$iminsert().flag('dirty').end());
					};
					
					for (var i = 0, ary = iter$(spans), len = ary.length, sel, res = []; i < len; i++) {
						// buffer need to updated during this?
						sel = ary[i];
						res.push(sel.node.erase(sel.region,sel.mode,edit));
					};
					return res;
				});
				
				// delay('annotate',500) do annotate
				return this.erased(reg);
			};
			
			tag.prototype.inserted = function (loc,str){
				console.log('inserted',loc,str);
				var reg = new Region(loc,loc + str.length,null,this);
				for (var i = 0, ary = iter$(this.hints()), len = ary.length; i < len; i++) {
					ary[i].adjust(reg,true);
				};
				// hints.cleanup
				this.edited();
				if (util.isWhitespace(str)) this.repair();
				return this;
			};
			
			tag.prototype.erased = function (reg){
				for (var i = 0, ary = iter$(this.hints()), len = ary.length; i < len; i++) {
					ary[i].adjust(reg,false);
				};
				this.edited();
				return this.repair(); // repair synchronously
			};
			
			tag.prototype.insert = function (point,str,edit){
				if (point instanceof Region) {
					if (point.size() > 0) {
						this.logger().warn('uncollapsed region in insert is not allowed');
					};
					point = point.start();
				};
				
				this.log('insert',point,str);
				// should maybe create this as a command - and then make it happen?
				
				this.history().oninsert(point,str,edit);
				
				// log 'insert in view'
				var spans = this.nodesInRegion(Region.normalize(point,this),false);
				var mid = spans[0];
				var target = mid || spans.prev || spans.next;
				var lft = spans.lft,rgt = spans.rgt;
				var node;
				var reg;
				
				// log spans,mid,lft,rgt
				this.log('before and after',lft,rgt,str);
				
				if (mid) {
					this.log('insert mid',mid.node);
					mid.node.insert(mid.region,str,edit,mid);
				} else {
					
					while (rgt){
						if (rgt.canPrepend(str)) {
							this.log('prepend',rgt,str);
							rgt.insert('prepend',str,edit);
							return this.inserted(point,str);
						} else if (rgt.isFirst()) {
							rgt = rgt.parent();
							continue;
						};
						
						break;
					};
					
					// find the closest parent
					while (lft){
						if (lft.canAppend(str)) {
							this.log('append',lft,str);
							lft.insert('append',str,edit);
							return this.inserted(point,str);
						} else if (lft.isLast()) {
							lft = lft.parent();
							continue;
						};
						
						break;
					};
					
					node = tag$.$iminsert().end();
					
					if (lft) {
						lft.setNext(node);
					} else if (rgt) {
						rgt.setPrev(node);
					} else {
						// must be empty
						this.root().dom().appendChild(node.dom());
					};
					
					node.insert('append',str,edit);
				};
				
				return this.inserted(point,str);
			};
			
			tag.prototype.onmutations = function (){
				return this;
			};
			
			tag.prototype.repair = function (){
				this._dirty = false;
				var els = this.dom().getElementsByClassName('dirty');
				
				if (els.length) {
					// logger.log "{els:length} dirty nodes to repair"
					
					for (var muts = [], i = 0, ary = iter$(els), len = ary.length; i < len; i++) {
						muts.push(tag$wrap(ary[i]));
					};
					
					for (var i = 0, ary = iter$(muts), len = ary.length, mut; i < len; i++) {
						mut = ary[i];
						mut.unflag('dirty');
						mut.mutated(muts);
					};
				};
				return this;
			};
			
			tag.prototype.code = function (){
				return this._root.dom().textContent;
			};
			
			tag.prototype.focusNodeDidSet = function (new$,old){
				if (!this.root().contains(new$)) { return };
				
				var path = [];
				
				while (new$ && new$ != this.root()){
					path.push(new$);
					new$ = new$.parent();
				};
				
				q$('.focus_',this).map(function(n) {
					if (path.indexOf(n) < 0) { return n.unflag('focus_') };
				});
				
				for (var i = 0, len = path.length; i < len; i++) {
					path[i].flag('focus_');
				};
				return this;
			};
			
			
			tag.prototype.recompile = function (){
				// should happen in a separate thread - and be delayed
				console.log('recompile');
				var res;
				
				try {
					res = Imbac.compile(this.code(),{bare: true});
				} catch (e) { };
				
				if (res) {
					this.compiled(res);
				};
				return this;
			};
			
			tag.prototype.reparse = function (){
				this.log('reparse');
				this.root().rehighlight({inner: true});
				return this;
			};
			
			tag.prototype.compiled = function (res){
				return this;
			};
			
			tag.prototype.onrunerror = function (e){
				console.log('onrunerror',e);
				return this;
			};
			
			tag.prototype.addError = function (msg,loc){
				var node;
				var reg = Region.normalize(loc,this);
				console.log('found warnings',reg,msg,loc);
				if (node = this.nodeAtRegion(reg)) {
					this.log('node at region is?!',node);
					msg = msg.split(/error at (\[[\d\:]*\])\:\s*/).pop();
					node.flag('err');
					node.setAttribute('error',msg);
				};
				this.delay('annotate',-1);
				return this;
			};
			
			
			
			tag.prototype.annotate = function (){
				// console.log 'annotate'
				
				var self = this;
				var state = self.root().codeState();
				var code = state.code;
				
				var apply = function(meta) {
					var vars = [];
					for (var i = 0, ary = iter$(meta.scopes), len = ary.length; i < len; i++) {
						for (var j = 0, items = iter$(ary[i].vars), len_ = items.length; j < len_; j++) {
							vars.push(items[j]);
						};
					};
					
					var warnings = meta.warnings || [];
					var oldWarnings = self.hints().filter(function(hint) { return hint.group() == 'analysis'; });
					
					if (oldWarnings) {
						// could intelligently keep them instead
						self.hints().rem(oldWarnings);
					};
					
					for (var i = 0, ary = iter$(warnings), len = ary.length, warn; i < len; i++) {
						warn = ary[i];
						warn.type || (warn.type = 'error');
						warn.group = 'analysis';
						self.hints().add(warn).activate();
					};
					
					if (warnings.length) { return self };
					
					var nodes = IM.textNodes(self.root().dom(),true);
					// what about removing old warnings?
					
					var map = {};
					for (var i = 0, ary = iter$(nodes), len = ary.length, node; i < len; i++) {
						node = ary[i];
						map[node._loc] = node;
					};
					
					// get textNodes with mapping(!)
					for (var i1 = 0, len = vars.length; i1 < len; i1++) {
						for (var k = 0, ary = iter$(vars[i1].refs), len_ = ary.length, ref; k < len_; k++) {
							ref = ary[k];
							var a = ref.loc[0];
							var b = ref.loc[1];
							var eref = ("v" + i1);
							
							if (map[a]) {
								var dom = map[a].parentNode;
								var oldRef = dom.getAttribute('eref');
								// console.log 'setting the ref for node?',dom,dom.@tag
								tag$wrap(dom).setEref(eref);
								// if dom.@tag
								// 	dom.@tag.eref = eref
								// else
								// 	dom.setAttribute('eref',eref) unless oldRef == eref
								// 	dom:classList.add('lvar')
							};
						};
					};
					
					return;
				};
				
				try {
					
					console.time('analyze');
					IM.worker().analyze(code,{bare: true},function(res) {
						console.log('result from worker analyze');
						console.timeEnd('analyze');
						
						if (res.data) {
							console.time('annotate');
							apply(res.data);
							return console.timeEnd('annotate');
						};
					});
				} catch (e) {
					self.log('error from annotate',e);
				};
				
				return self;
			};
			
			tag.prototype.oncommand = function (e,c){
				if (this[c.command] instanceof Function) {
					this[c.command].call(this,c.args || []);
					e.halt();
				};
				return this;
			};
			
			tag.prototype.dumpState = function (o){
				if(o === undefined) o = {};
				return {
					html: this.root().dom().innerHTML,
					code: this.root().code(),
					selection: this.caret().region(),
					timestamp: new Date()
				};
			};
			
			tag.prototype.loadState = function (o){
				var self = this;
				if(o === undefined) o = {};
				self.observer().pause(function() {
					var v_;
					if (o.html) {
						self.root().dom().innerHTML = o.html;
					} else if (o.code) {
						self.load(o.code);
					};
					if (o.selection) {
						return (self.caret().setRegion(v_ = o.selection),v_);
					};
				});
				return self;
			};
			
			tag.prototype.loadSession = function (session){
				this.history().load(session);
				this.history().play();
				return this;
			};
			
			tag.prototype.textNodes = function (rel){
				if(rel === undefined) rel = this.root();
				return IM.textNodes(rel);
			};
			
			// Should be separate from the viewcode?
			tag.prototype.regionForNode = function (node,rel){
				if(rel === undefined) rel = this.root();
				var el = node._dom || node;
				var len = el.textContent.length;
				var rng = document.createRange();
				rng.setStart(rel._dom || rel,0);
				rng.setEnd(node._dom || node,0);
				var pre = rng.toString();
				return new Region(pre.length,pre.length + len,rel,this);
			};
			
			// Should merge with nodesInRegion
			tag.prototype.nodeAtRegion = function (region,exact){
				if(exact === undefined) exact = false;
				console.time('nodeAtRegion');
				var rel = this.root();
				var a = region.a();
				var b = region.b();
				
				var nodes = this.textNodes(rel);
				// move into region instead?
				var pos = 0;
				var match = null;
				var adist,bdist,str,len;
				
				for (var i = 0, ary = iter$(nodes), len_ = ary.length, node; i < len_; i++) {
					// console.log 'looking through nodes'
					node = ary[i];
					adist = a - pos;
					bdist = b - pos;
					str = node.textContent;
					len = str.length;
					
					if (adist >= 0 && adist < len) {
						// console.log 'found starting point?',node,str,adist
						match = node;
						break;
						// return tag(node:parentNode)
					};
					
					if (bdist >= 0 && bdist < len) {
						// console.log 'found ending point',node,str,bdist
						// range.setEnd(node,bdist)
						break;
					};
					
					
					pos += len;
				};
				
				var el = tag$wrap(match.parentNode);
				// we want to match the one that is full length
				if (exact && len < region.size()) {
					while (el){
						// be careful
						var elreg = el.region();
						if (region.equals(elreg)) { return el };
						el = el.parent();
					};
				};
				
				console.timeEnd('nodeAtRegion');
				return match ? (tag$wrap(match.parentNode)) : (null);
			};
			
			tag.prototype.nodesForEntity = function (ref){
				return q$('[eref="'+("" + ref)+'"]',this);
			};
			
			// does not need to belong to view directly
			tag.prototype.nodesInRegion = function (region,includeEnds,generalize){
				if(includeEnds === undefined) includeEnds = true;
				if(generalize === undefined) generalize = false;
				console.time('nodesInRegion');
				region = Region.normalize(region,this).normalize();
				var a = region.start();
				var b = region.end();
				
				// can be optimized by supplying the regions
				var nodes = IM.textNodes(region.root() || this.root());
				var matches = [];
				var match;
				var el;
				// move into region instead?
				matches.includeEnds = includeEnds;
				matches.region = region;
				
				var pos = 0;
				var ends = [];
				
				for (var i1 = 0, ary = iter$(nodes), len_ = ary.length, node; i1 < len_; i1++) {
					// console.log 'looking through nodes'
					node = ary[i1];
					var adist = a - pos;
					var bdist = b - pos;
					var str = node.textContent;
					var len = str.length;
					
					if ((pos + len) >= a && pos <= b) {
						el = tag$wrap(node.parentNode);
						var start = Math.max(0,a - pos);
						var end = Math.min(len,Math.max(b - pos,0));
						var par;
						
						match = {
							node: el,
							startOffset: start,
							endOffset: end,
							region: new Region(start,end,el,this),
							size: len
						};
						// log "node at {pos} + {len} - looking in range {a} - {b}"
						var mode = 'all';
						
						if (start == len) {
							mode = 'end';
						} else if (end == 0) {
							mode = 'start';
						} else if (start == 0 && end == len) {
							par = el.dom().parentNode;
							var isOpener = par != this._root.dom() && el.dom() == par.firstChild;
							var isCloser = par != this._root.dom() && el.dom() == par.lastChild;
							
							if (isOpener) {
								match.opens = el.parent();
								ends.push(match);
							};
							
							if (isCloser) {
								end = ends[ends.length - 1];
								if (end && end.opens == el.parent()) {
									end.closer = match;
									match.opener = end;
									ends.pop();
								};
								
								match.closes = el.parent();
							};
							
							mode = 'all';
						} else {
							mode = 'partial';
						};
						
						match.mode = mode;
						matches.push(match);
					};
					
					pos += len;
					if (pos > b) { break; };
				};
				
				var first = matches[0];
				var last = matches[matches.length - 1];
				
				if (first && first.mode == 'end') {
					matches.prev = first;
					matches.lft = first.node;
					
					// if first:node isa IM.Types:close
					// 	matches:lft = first:node.parent
					
					if (!includeEnds) { matches.shift() };
				};
				
				if (last && last.mode == 'start') {
					matches.next = last;
					matches.rgt = last.node;
					
					// if last:node isa IM.Types:open
					// 	matches:rgt = last:node.parent
					
					if (!includeEnds) { matches.pop() };
				};
				
				
				// normalize the nodes in groups
				if (generalize) {
					// console.log 'generalize!',matches
					var i = 0;
					var m;
					while (m = matches[i]){
						if (m.closer) {
							var idx = matches.indexOf(m.closer);
							len = m.opens.size();
							var new$ = {
								mode: 'all',
								region: new Region(0,len,m.opens,this),
								startOffset: 0,
								endOffset: len,
								node: m.opens
							};
							var rem = matches.splice(i,idx - i + 1,new$);
							new$.children = rem;
							// console.log 'slice away the items'
						};
						i++;
					};
				};
				
				console.timeEnd('nodesInRegion');
				return matches;
			};
			
			// should move to Buffer class
			tag.prototype.linecount = function (){
				return this.buffer().linecount();
				// buffer.split('\n')[:length]
			};
			
			// Returns the contents of the region as a string.
			// Returns the character to the right of the point.
			tag.prototype.substr = function (region,len){
				return this.buffer().substr(region,len);
			};
			
			// move into Buffer
			tag.prototype.linestr = function (nr){
				return this.buffer().line(nr);
				// if nr isa Number
				// 	buffer.split('\n')[nr] or ''
			};
			
			tag.prototype.expandRegionTo = function (region,match,forward){
				if(forward === undefined) forward = true;
				var buf = this.buffer().toString();
				var pos = region.start();
				var end = region.end();
				
				if (forward) {
					while (buf[end + 1] != match){
						end++;
					};
				} else {
					while (buf[pos - 1] != match){
						pos--;
					};
				};
				
				return new Region(pos,end,this);
			};
		});
		
		
		return VIEW = null;
	
	})()

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		var Region = __webpack_require__(27).Region;
		
		function Buffer(view){
			this._view = view;
			this._buffer = '';
			this._cache = {};
			this;
		};
		
		exports.Buffer = Buffer; // export class 
		
		
		Buffer.prototype.view = function(v){ return this._view; }
		Buffer.prototype.setView = function(v){ this._view = v; return this; };
		
		Buffer.prototype.set = function (buffer){
			if (buffer == this._buffer) {
				return this;
			};
			
			this._buffer = buffer;
			this._cache = {};
			this._lines = null;
			return this;
		};
		
		Buffer.prototype.refresh = function (){
			return this.set(this.view().root().code());
		};
		
		Buffer.prototype.lines = function (){
			return this._lines || (this._lines = (true) && (
				this._buffer.split('\n')
			));
		};
		
		Buffer.prototype.split = function (){
			return this._buffer.split.apply(this._buffer,arguments);
		};
		
		Buffer.prototype.linecount = function (){
			return this.lines().length;
		};
		
		Buffer.prototype.line = function (nr){
			if ((typeof nr=='number'||nr instanceof Number)) {
				return this.lines()[nr] || '';
			} else {
				return '';
			};
		};
		
		Buffer.prototype.len = function (){
			return this._buffer.length;
		};
		
		// location to 
		Buffer.prototype.locToRc = function (){
			return this;
		};
		
		Buffer.prototype.location = function (){
			return this;
		};
		
		Buffer.prototype.locToRow = function (loc){
			var ln = 0;
			var len = 0;
			for (var i = 0, ary = iter$(this.lines()), len_ = ary.length; i < len_; i++) {
				len += ary[i].length + 1;
				if (loc < len) { return i };
			};
			return this.lines().length;
		};
		
		Buffer.prototype.locToCell = function (loc){
			if (this._cache[loc]) {
				return this._cache[loc];
			};
			
			var pos = loc;
			var col = 0;
			var row = 0;
			var char$;
			
			var buf = this._buffer;
			var tabsize = this._view.tabSize();
			
			// go back to start of line
			// goes through the whole
			while (char$ = buf[pos - 1]){
				if (char$ == '\n') {
					break;
				};
				pos--;
			};
			
			// get column for slice
			while ((pos < loc) && (char$ = buf[pos])){
				if (char$ == '\t') {
					var rest = tabsize - (col % tabsize);
					col += rest;
				} else {
					col += 1;
				};
				pos++;
			};
			
			while (char$ = buf[pos - 1]){
				if (char$ == '\n') {
					row++;
				};
				pos--;
			};
			
			return this._cache[loc] = [row,col];
		};
		
		Buffer.prototype.substr = function (region,len){
			if (region instanceof Region) {
				return this._buffer.substr(region.start(),region.size());
			} else if ((typeof region=='number'||region instanceof Number)) {
				return this._buffer.substr(region,len || 1);
			} else {
				throw 'must be region or number';
			};
		};
		
		Buffer.prototype.toString = function (){
			return this._buffer || '';
		};
		return Buffer;
	
	})()

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var util = __webpack_require__(34);
		
		function Observer(view,cfg){
			var self = this;
			self._active = false;
			self._view = view;
			self._config = cfg || {attributes: false,childList: true,characterData: true,subtree: true};
			self._observer = new MutationObserver(function(muts) { return self.onmutations(muts); });
			self;
		};
		
		exports.Observer = Observer; // export class 
		
		
		Observer.prototype.view = function(v){ return this._view; }
		Observer.prototype.setView = function(v){ this._view = v; return this; };
		
		
		Observer.prototype.config = function(v){ return this._config; }
		Observer.prototype.setConfig = function(v){ this._config = v; return this; };
		
		
		Observer.prototype.active = function(v){ return this._active; }
		Observer.prototype.setActive = function(v){ this._active = v; return this; };
		
		Observer.prototype.resume = function (){
			if (!this._active) {
				this._observer.observe(this.view().root().dom(),this.config());
				this._active = true;
			};
			return this;
		};
		
		Observer.prototype.pause = function (blk){
			var wasActive = this._active;
			this._active = false;
			if (wasActive) { this._observer.disconnect() };
			
			if (blk instanceof Function) {
				blk();
				if (wasActive) this.resume();
			};
			
			return this;
		};
		
		Observer.prototype.paused = function (){
			return !this._active;
		};
		
		Observer.prototype.onmutations = function (mutations){
			var el;
			this.view().logger().group('mutations');
			
			var deep = false;
			var nodes = [];
			for (var i = 0, ary = iter$(mutations), len = ary.length, mut; i < len; i++) {
				mut = ary[i];
				this.view().log('mutation',mut);
				var type = mut.type;
				var target = mut.previousSibling || mut.target;
				
				if (type == 'characterData') {
					this.view().log(("updated code to " + (target.textContent)));
					target = target.parentNode;
				} else if (type == 'childList') {
					deep = true;
					var add = mut.addedNodes;
					if (add.length == 1 && (add[0] instanceof Element)) {
						target = add[0];
					};
				};
				
				this.view().log(target,tag$wrap(target));
				// var added = mut:addedNodes
				// for node in mut:addedNodes
				// if target and target:parentNode # and target.@tag
				if (el = tag$wrap(target)) {
					this.view().log('add target?!');
					if (nodes.indexOf(el) < 0) { nodes.push(el) };
				};
				
				// if we have added a node instead
			};
			
			// mutations are not registered on node-level but on extent
			// not really how this should happen
			
			var common = util.commonAncestor(nodes);
			
			this.view().log('common container for mutations is',common,nodes);
			
			var extent;
			
			if (nodes.length == 1) {
				this.view().log('a single node was mutated',nodes[0]);
				nodes[0].mutated({deep: deep,mutations: mutations});
			} else {
				// collect extents for all nodes?
				// rather make a region expand 
				for (var i = 0, len = nodes.length, node; i < len; i++) {
					node = nodes[i];
					if (extent && extent.contains(node.dom())) { // :nodes.indexOf(node.dom) >= 0
						this.view().log('this node is already part of the extent',node.dom());
					} else {
						extent = node.dirtyExtent();
					};
					// node?.mutated
				};
				
				if (extent) {
					// console.log 'found extent(!)',extent
					this.pause(function() { return true; });
				};
			};
			
			this.view().logger().groupEnd();
			this.view().onmutations({nodes: nodes,mutations: mutations,extent: extent});
			return this;
		};
		return Observer;
		
	
	})()

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var Region = __webpack_require__(27).Region;
		
		var labels = {
			"Unexpected 'TAG_END'": 'Tag closed unexpectedly',
			"Unexpected 'TERMINATOR'": 'Unexpected ⏎',
			"Unexpected 'POST_IF'": 'Missing body in <b>IF</b>'
		};
		
		var rules = [
			[/Uncaught Error: tag (\w+) is not defined/,"tag <b>$1</b> does not exist"]
		];
		
		function Hint(opts,view){
			this._view = view;
			this._data = opts;
			this._active = false;
			this._region = opts.loc ? (Region.normalize(opts.loc,view)) : (null);
			// try to find the node immediately
			this._node = opts.node || this.node();
			this;
		};
		
		exports.Hint = Hint; // export class 
		Hint.build = function (o,view){
			return new this(o,view);
		};
		
		
		
		Hint.prototype.view = function(v){ return this._view; }
		Hint.prototype.setView = function(v){ this._view = v; return this; };
		
		
		Hint.prototype.region = function(v){ return this._region; }
		Hint.prototype.setRegion = function(v){ this._region = v; return this; };
		
		
		Hint.prototype.active = function(v){ return this._active; }
		Hint.prototype.setActive = function(v){ this._active = v; return this; };
		
		Hint.prototype.getAttribute = function (key){
			return this._data[key];
		};
		
		Hint.prototype.setAttribute = function (key,val){
			this._data[key] = val;
			return this;
		};
		
		Hint.prototype.type = function (){
			return this._data.type || 'error';
		};
		
		Hint.prototype.group = function (){
			return this._data.group;
		};
		
		Hint.prototype.ref = function (){
			return this._data.ref;
		};
		
		Hint.prototype.node = function (){
			return this._node || (this._node = this._region && this.view().nodeAtRegion(this._region));
		};
		
		Hint.prototype.row = function (){
			return this.region().row();
		};
		
		Hint.prototype.col = function (){
			return this.region().col();
		};
		
		Hint.prototype.label = function (){
			var lbl;
			return this._label || (this._label = (true) && (
				lbl = this._data.label || this._data.message || 'Hint',
				lbl = lbl.split(/error at (\[[\d\:]*\])\:\s*/).pop(),
				lbl = labels[lbl] || lbl
			));
		};
		
		
		Hint.prototype.activate = function (){
			var node_;
			if (!this._active) {
				// node?.setAttribute('hint',ref)
				this._active = true;
				(node_ = this.node()) && node_.setHint  &&  node_.setHint(this);
			};
			return this;
		};
		
		Hint.prototype.deactivate = function (){
			console.log('deactivate hint!!');
			this.setActive(false);
			return this;
			// cleanup
			// remove
		};
		
		Hint.prototype.prune = function (){
			return this.view().hints().prune(this);
		};
		
		// should make this hint ready to be removed
		Hint.prototype.cleanup = function (){
			if (this._node) {
				if (this._node.hint() == this) { this._node.setHint(null) };
			};
			return this;
		};
		
		Hint.prototype.remove = function (){
			this.view().hints().rem(this);
			return this;
		};
		
		Hint.prototype.changed = function (){
			// console.log 'deactivate on changed!'
			// @deactivate = yes
			this.prune();
			return this;
		};
		
		Hint.prototype.adjust = function (reg,ins){
			if(ins === undefined) ins = true;
			if (this.region().intersects(reg)) {
				// deactivate
				this.prune();
				// @deactivate = yes
			};
			
			this.region().adjust(reg,ins);
			return this;
		};
		
		function Hints(view){
			this._prune = [];
			this._array = [];
			this._map = {};
			this._view = view;
		};
		
		exports.Hints = Hints; // export class 
		var nr = 0;
		
		Hints.prototype.toArray = function (){
			return this._array;
		};
		
		Hints.prototype.get = function (ref){
			return this._map[ref];
		};
		
		Hints.prototype.activate = function (){
			for (var i = 0, ary = iter$(this._array), len = ary.length; i < len; i++) {
				ary[i].activate();
			};
			return this;
		};
		
		// this should take care of deallocating the hint no?
		Hints.prototype.rem = function (hint){
			if (hint instanceof Function) {
				hint = this._array.filter(hint);
			};
			
			if (hint instanceof Array) {
				for (var i = 0, ary = iter$(hint), len = ary.length; i < len; i++) {
					this.rem(ary[i]);
				};
				return hint;
			};
			
			if ((typeof hint=='string'||hint instanceof String)) {
				return this.rem(this.get(hint));
			};
			
			if (this._array.indexOf(hint) >= 0) {
				hint.cleanup();
				this._array.splice(this._array.indexOf(hint),1);
			};
			
			return hint;
		};
		
		Hints.prototype.prune = function (hint){
			if (this._prune.indexOf(hint) < 0) { this._prune.push(hint) };
			return this;
		};
		
		Hints.prototype.clear = function (){
			var arr = this._array;
			this._array = [];
			
			for (var i = 0, ary = iter$(arr), len = ary.length; i < len; i++) {
				ary[i].deactivate();
			};
			return this;
		};
		
		Hints.prototype.cleanup = function (){
			
			var self = this;
			self._array.map(function(item) {
				if (self._prune.indexOf(item) >= 0) {
					item.deactivate();
					return self.rem(item);
				};
			});
			self._prune = [];
			return self;
		};
		
		
		Hints.prototype.filter = function (cb){
			return this._array.filter(cb);
		};
		
		Hints.prototype.add = function (o){
			var ref = o.ref = ("hint" + (nr++));
			if (!((o instanceof Hint))) { o = Hint.build(o,this._view) };
			this._map[ref] = o;
			this._array.push(o);
			return o;
		};
		return Hints;
	
	})()

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var util = __webpack_require__(34);
		var Region = __webpack_require__(27).Region;
		
		function RowCol(row,col,caret){
			if(row === undefined) row = 0;
			if(col === undefined) col = 0;
			if(caret === undefined) caret = null;
			this._row = row;
			this._col = col;
			this._caret = caret;
			this;
		};
		
		
		
		RowCol.prototype.row = function(v){ return this._row; }
		RowCol.prototype.setRow = function(v){ this._row = v; return this; };
		
		
		RowCol.prototype.col = function(v){ return this._col; }
		RowCol.prototype.setCol = function(v){ this._col = v; return this; };
		
		
		RowCol.prototype.caret = function(v){ return this._caret; }
		RowCol.prototype.setCaret = function(v){ this._caret = v; return this; };
		
		RowCol.prototype.view = function (){
			return this.caret().view();
		};
		
		RowCol.prototype.normalize = function (){
			this._col = this.realCol();
			return this;
		};
		
		RowCol.prototype.set = function (row,col){
			var ary;
			if (row instanceof RowCol) {
				col = row.col();
				row = row.row();
				
				// return set(row.row,row.col)
			};
			
			if (row instanceof Region) {
				var ary = iter$(util.rowcol(this.view()._buffer,row.start()));row = ary[0];col = ary[1];
			};
			
			var lc = this.view()._buffer.linecount();
			
			if (row >= lc) {
				row = lc - 1;
				col = 1000;
			};
			
			this._row = row;
			this._col = col;
			return this;
		};
		
		
		RowCol.prototype.move = function (offset){
			this.normalize();
			
			var col = this.realCol() + offset;
			var llen = this.linelen();
			
			var lloc = this.lineloc();
			// find the real offset in characters (not columns)
			
			
			// if offset < 0
			// 	# normalize?
			// 	@col = Math.min(@col,llen)
			
			if (col < 0) {
				if (this._row > 0) {
					this.moveUp();
					this._col = this.linelen();
				} else {
					this._row = 0;
					this._col = 0;
				};
				return this;
			} else if (col > llen) {
				if (this._row >= (this.view()._buffer.linecount() - 1)) {
					return this;
				};
				
				this.moveDown();
				var rest = Math.max(0,col - llen - 1);
				var moves = util.colsForLine(this.linestr().substr(0,rest));
				this._col = moves;
				return this;
			};
			
			// this should work
			this._col = util.colsForLine(this.linestr().substr(0,lloc + offset));
			// @col += offset
			return this;
		};
		
		RowCol.prototype.moveUp = function (len){
			this._row = Math.max(0,this._row - 1);
			return this;
		};
		
		RowCol.prototype.moveDown = function (len){
			console.log('moveDown');
			var lc = this.view()._buffer.linecount(); // split('\n')[:length]
			this._row = this._row + 1;
			if (this._row >= lc) {
				console.log('out of bounds');
				this.setLoc(this.view()._buffer.len());
			};
			return this;
		};
		
		RowCol.prototype.clone = function (){
			return new RowCol(this.row(),this.col(),this.caret());
		};
		
		RowCol.prototype.linelen = function (){
			return util.colsForLine(this.linestr());
		};
		
		RowCol.prototype.lineloc = function (){
			return util.colToLoc(this.linestr(),this.realCol());
		};
		
		RowCol.prototype.realCol = function (){
			var rc = util.colToViewCol(this.linestr(),this._col);
			return rc;
		};
		
		RowCol.prototype.linestr = function (){
			return this.view().linestr(this.row());
		};
		
		RowCol.prototype.peekbehind = function (){
			var str = this.linestr();
			return str.substr(0,util.colToLoc(str,this.realCol()));
		};
		
		RowCol.prototype.peekahead = function (){
			var str = this.linestr();
			return str.slice(util.colToLoc(str,this.realCol()));
		};
		
		RowCol.prototype.setLoc = function (loc){
			var ary;
			var ary = iter$(util.rowcol(this.view()._buffer,loc));var row = ary[0],col = ary[1];
			this.set(row,col);
			return this;
		};
		
		RowCol.prototype.loc = function (){
			// should cache(!)
			var lines = this.view()._buffer.lines();
			// var lines = view.buffer.split('\n')
			var loc = 0;
			for (var i = 0, ary = iter$(lines), len = ary.length, line; i < len; i++) {
				line = ary[i];
				var ln = line.length;
				if (i < this._row) {
					loc += ln + 1; // include newline
				} else if (i == this._row) {
					var viewcol = util.colToViewCol(line,this._col);
					var offset = util.colToLoc(line,viewcol);
					loc += Math.min(ln,offset);
				};
			};
			return loc;
		};
		
		RowCol.prototype.tab = function (){
			// wrong - need to round instead?
			
			var lft = this.col() % 4;
			this.setCol(this.col() + (4 - lft)); // Math.floor(col / 4) * 4 + 4
			console.log('marker tab',lft,this.col(),this.realCol());
			return this;
		};
		
		RowCol.prototype.untab = function (){
			console.log('untab',this.col());
			var rest = 4 - this.col() % 4;
			this.setCol(Math.ceil(this.col() / 4) * 4 - 4);
			return this;
		};
		
		RowCol.prototype.alter = function (mode,dir){
			var $1, $2, $3, $4, $5, $6;
			var nodes = this.caret().view().nodesInRegion(this.loc(),false);
			var node = nodes[0];
			var mid = node && node.node;
			var lft = nodes.prev && nodes.prev.node;
			var rgt = nodes.next && nodes.next.node;
			var part;
			
			// log 'move',offset,mode,nodes
			if (mode == IM.WORD_START) {
				var el = mid || lft;
				if (($1 = lft) && $1.matches  &&  $1.matches(q$('._imclose',this))) {
					this.setLoc(lft.parent().region().start());
				} else if (($2 = lft) && $2.matches  &&  $2.matches(q$('._imstr',this))) {
					this.setLoc(lft.region().start());
				} else {
					var loc = this.loc();
					// let buf = view.buffer
					// console.log 'peekbehind',peekbehind,loc,str
					var str = this.peekbehind().split('').reverse().join('');
					loc -= str.match(/^([\s\t\.]*.+?|)(\b|$)/)[1].length;
					this.setLoc(loc);
				};
			} else if (mode == IM.WORD_END) {
				el = mid || rgt;
				if (($3 = rgt) && $3.matches  &&  $3.matches(q$('._imopen',this))) {
					this.setLoc(rgt.parent().region().end());
				} else if (($4 = rgt) && $4.matches  &&  $4.matches(q$('._imstr',this))) {
					this.setLoc(rgt.region().end());
				} else {
					var loc1 = this.loc();
					// let buf = view.buffer
					
					
					// console.log 'peekahead',peekahead,loc
					loc1 += this.peekahead().match(/^([\s\.]*.+?|)(\b|$)/)[1].length;
					// loc++ until buf[loc].match(/[\n\]/)
					this.setLoc(loc1);
				};
			} else if (mode == IM.LINE_END) {
				this.set(this.row(),1000);
			} else if (mode == IM.LINE_START) {
				// FIXME tabs-for-spaces
				var tabs = this.linestr().match(/^\t*/)[0].length;
				var newcol = tabs * this.view().tabSize();
				this.setCol(this.col() > newcol ? (newcol) : (0));
			} else {
				if (dir < 0 && ($5 = lft) && $5.matches  &&  $5.matches('._imtab')) {
					// head.col = head.col - 4
					// caret.view.log 'right is tab',lft.region
					this.setLoc(lft.region().start());
					// head.untab
				} else if (dir > 0 && ($6 = rgt) && $6.matches  &&  $6.matches('._imtab')) {
					
					// use tab instead
					this.tab();
					// head.col = head.col + 4
				} else {
					// ...
					this.move(dir);
				};
			};
			
			return this;
		};
		
		tag$.defineTag('imcarethead');
		
		// should move into Marker (like Atom)
		return tag$.defineTag('imcaret', function(tag){
			
			
			
			tag.prototype.region = function(v){ return this._region; }
			tag.prototype.setRegion = function(v){ this._region = v; return this; };
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			
			tag.prototype.lines = function(v){ return this._lines; }
			tag.prototype.setLines = function(v){ this._lines = v; return this; };
			
			
			tag.prototype.ranges = function(v){ return this._ranges; }
			tag.prototype.setRanges = function(v){ this._ranges = v; return this; };
			
			tag.prototype.__mode = {watch: 'modeDidSet',name: 'mode'};
			tag.prototype.mode = function(v){ return this._mode; }
			tag.prototype.setMode = function(v){
				var a = this.mode();
				if(v != a) { this._mode = v; }
				if(v != a) { this.modeDidSet && this.modeDidSet(v,a,this.__mode) }
				return this;
			};
			
			tag.prototype.__col = {'default': 0,watch: 'dirty',name: 'col'};
			tag.prototype.col = function(v){ return this._col; }
			tag.prototype.setCol = function(v){
				var a = this.col();
				if(v != a) { this._col = v; }
				if(v != a) { this.dirty && this.dirty(v,a,this.__col) }
				return this;
			}
			tag.prototype._col = 0; // the real column of the caret
			
			tag.prototype.__row = {'default': 0,watch: 'dirty',name: 'row'};
			tag.prototype.row = function(v){ return this._row; }
			tag.prototype.setRow = function(v){
				var a = this.row();
				if(v != a) { this._row = v; }
				if(v != a) { this.dirty && this.dirty(v,a,this.__row) }
				return this;
			}
			tag.prototype._row = 0;
			
			
			tag.prototype.input = function(v){ return this._input; }
			tag.prototype.setInput = function(v){ this._input = v; return this; };
			
			
			
			tag.prototype.tail = function(v){ return this._tail; }
			tag.prototype.setTail = function(v){ this._tail = v; return this; }; // rowcol
			
			
			tag.prototype.head = function(v){ return this._head; }
			tag.prototype.setHead = function(v){ this._head = v; return this; };
			
			
			tag.prototype.hash = function(v){ return this._hash; }
			tag.prototype.setHash = function(v){ this._hash = v; return this; };
			
			tag.prototype.expand = function (lft,rgt){
				var ary;
				if(lft === undefined) lft = 0;
				if(rgt === undefined) rgt = 0;
				this.log('imcaret expand',lft,rgt);
				this.decollapse();
				var ary = iter$(this.ends());var a = ary[0],b = ary[1];
				a.move(lft);
				b.move(rgt);
				return this;
			};
			
			tag.prototype.toArray = function (){
				if (this.isCollapsed()) {
					return [this.head().row(),this.head().col()];
				} else {
					return [this.head().row(),this.head().col(),this.tail().row(),this.tail().col()];
				};
			};
			
			tag.prototype.toHash = function (){
				return '[' + this.toArray().join(',') + ']';
			};
			
			tag.prototype.set = function (val){
				if (val instanceof IM.Types.Tok) {
					return this.set(val.region());
				};
				
				if (val instanceof Region) {
					return (this.setRegion(val),val);
				};
				
				if (val instanceof Array) {
					this.head().setRow(val[0]);
					this.head().setCol(val[1]);
					
					if (val.length == 4) {
						this.decollapse();
						this.tail().setRow(val[2]);
						this.tail().setCol(val[3]);
					} else {
						this.setTail(this.head());
					};
				};
				this.dirty();
				return this;
			};
			
			tag.prototype.expandToLines = function (){
				var ary;
				this.selectable();
				var ary = iter$(this.ends());var a = ary[0],b = ary[1];
				a.setCol(0);
				b.setCol(1000);
				return this.dirty();
			};
			
			tag.prototype.selectAll = function (){
				this.decollapse();
				this.tail().setLoc(0);
				this.head().setLoc(this.view()._buffer.len()); // :length
				this.dirty();
				return this;
			};
			
			tag.prototype.selectable = function (){
				this.decollapse();
				return this;
			};
			
			tag.prototype.decollapse = function (){
				var v_;
				if (this.tail() == this.head()) { (this.setTail(v_ = this.head().clone()),v_) };
				return this;
			};
			
			tag.prototype.collapse = function (){
				this.setTail(this.head());
				this.dirty();
				return this;
			};
			
			tag.prototype.collapseToStart = function (){
				if (this.isReversed()) {
					this.setTail(this.head());
				} else {
					this.setHead(this.tail());
				};
				this.dirty();
				return this;
			};
			
			tag.prototype.orientation = function (){
				return this.isReversed() ? ('reversed') : ('normal');
			};
			
			tag.prototype.isCollapsed = function (){
				return this.tail() == this.head();
			};
			
			tag.prototype.isReversed = function (){
				return this.head().row() < this.tail().row() || (this.tail().row() == this.head().row() && this.head().col() < this.tail().col());
			};
			
			tag.prototype.indent = function (){
				var str = this.head().linestr();
				var ind = str.match(/^(\t*)/)[0];
				return ind;
			};
			
			tag.prototype.peekbehind = function (val){
				var str = this.ends()[0].peekbehind();
				if (val instanceof RegExp) { return str.match(val) };
				return str;
			};
			
			tag.prototype.move = function (offset,mode){
				if(offset === undefined) offset = 1;
				if(mode === undefined) mode = 0;
				this.head().alter(mode,offset);
				return this.dirty();
			};
			
			// what if we 
			tag.prototype.moveDown = function (len){
				if(len === undefined) len = 1;
				this.head().moveDown();
				return this.dirty();
			};
			
			tag.prototype.moveUp = function (len){
				if(len === undefined) len = 1;
				this.head().moveUp();
				return this.dirty();
			};
			
			tag.prototype.ends = function (){
				return this.isReversed() ? ([this.head(),this.tail()]) : ([this.tail(),this.head()]);
			};
			
			tag.prototype.text = function (){
				return this.region().text();
			};
			
			tag.prototype.region = function (){
				// get the actual region based on head and tail
				// getting the code might be expensive if done
				// too many times -- but easy to cache
				// send this to util instead
				var ary;
				var code = this.view().code();
				var lines = code.split('\n');
				var ary = iter$(this.ends());var a = ary[0],b = ary[1];
				
				var start = 0;
				var end = 0;
				var ln = 0;
				
				var ar = a.row(),ac = a.col(),br = b.row(),bc = b.col();
				var char$;
				
				for (var i = 0, items = iter$(lines), len = items.length, line; i < len; i++) {
					line = items[i];
					ln = line.length;
					if (i < ar) {
						start += ln + 1; // include newline
					} else if (i == ar) {
						var offset = util.colToLoc(line,ac);
						start += Math.min(ln,offset);
					};
					
					if (i < br) {
						end += ln + 1; // include newline
					} else if (i == br) {
						offset = util.colToLoc(line,bc);
						end += Math.min(ln,offset);
					} else {
						break;
					};
				};
				
				return new Region(start,end,this.view().root(),this.view());
			};
			
			tag.prototype.setRegion = function (reg){
				var buf = this.view().code();
				var a = util.rowcol(buf,reg.a());
				var b = util.rowcol(buf,reg.b());
				
				this.setHead(new RowCol(b[0],b[1],this));
				
				if (reg.size() == 0) {
					this.setTail(this.head());
				} else {
					this.setTail(new RowCol(a[0],a[1],this));
				};
				return this.dirty();
			};
			
			tag.prototype.nodes = function (reg){
				if(reg === undefined) reg = this.region();
				return this.view().nodesInRegion(reg,this.isCollapsed());
			};
			
			// should rather move this to region itself
			tag.prototype.target = function (reg){
				if(reg === undefined) reg = this.region();
				var nodes = this.nodes(reg);
				if (nodes.length > 2) {
					return util.commonAncestor(nodes.map(function(n) { return n.node; }));
				};
				return nodes[0].node;
			};
			
			tag.prototype.insert = function (text,edit){
				
				var sub = '';
				this.view().history().mark('action');
				
				if (!(this.isCollapsed())) {
					var reg = this.region();
					sub = reg.text();
					this.view().erase(reg);
					this.collapseToStart();
				};
				
				var move = 0;
				var sel;
				
				// need a different syntax for $0 -- can be in regular pasted code
				// should have a separate command for insertSnippet probably.
				if (text.indexOf('$0') >= 0) {
					sel = this.region().clone(0,sub.length).move(text.indexOf('$0'));
					text = text.replace('$0',sub);
				};
				
				edit || (edit = {size: text.length});
				
				this.head().normalize();
				var res = this.view().insert(this.region().start(),text,edit);
				this.view().log('inserted -- now move',edit.size);
				
				if (sel) {
					this.setRegion(sel);
				} else {
					// move locations
					this.head().setLoc(this.head().loc() + edit.size);
					// head.move(edit:size)
				};
				
				this.dirty();
				
				return this;
			};
			
			
			tag.prototype.erase = function (mode){
				this.view().history().mark('action');
				
				if (this.isCollapsed()) {
					this.log('isCollapsed',mode);
					this.decollapse();
					this.head().alter(mode,-1); // 
					
					// dirty
					// return erase # call again now
				};
				console.log('erasing region',this.region());
				this.view().erase(this.region());
				// log 'now collapse region to start',region
				this.collapseToStart();
				// log region
				return this;
				
				var target = this.target(this.reg());
				this.setRegion(this.reg());
				
				return this.view().edit(
					{text: '',
					target: target,
					region: this.reg(),
					caret: this.reg().clone().collapse(false)}
				);
			};
			
			tag.prototype.dirty = function (){
				var $1, $2;
				this._timestamp = new Date();
				// var hash = toArray.join("")
				
				if (this._hash != this.toHash()) {
					// the realCol values could have changed though?
					this.view().history().oncaret(this._hash,this.toHash(),this);
					this._hash = this.toHash();
					// console.log 'caret has actually changed',@hash
				};
				
				var rev = this.isReversed();
				var a = this.tail();
				var b = this.head();
				
				if (rev) { $1 = b,$2 = a,a = $1,b = $2 };
				
				var lc = b.row() - a.row();
				var row = a.row();
				
				var ac = a.realCol(); // Math.min( a.col, util.colsForLine(view.linestr(a.row) ) )
				var bc = b.realCol(); // Math.min( b.col, util.colsForLine(view.linestr(b.row) ) )
				var hc,tc;
				
				if (this.isReversed()) {
					hc = ac;
					tc = bc;
				} else {
					hc = bc;
					tc = ac;
				};
				
				// log 'dirty',region,a.row,a.col,b.row,b.col,hc,tc,head,tail,rev
				
				this.css({transform: ("translate(0px," + (a.row() * 100) + "%)")});
				// convert the row and column to a region (should go both ways)
				this._caret.css({transform: ("translate(" + hc + "ch," + ((this.head().row() - row) * 100) + "%)")});
				this._start.css({marginLeft: ("" + ac + "ch"),width: "auto"});
				this._end.css({width: ("" + bc + "ch")});
				
				if (this.isCollapsed()) {
					this.setMode('collapsed');
				} else if (lc == 0) {
					this.setMode('single');
					this._start.css({width: (bc - ac) + "ch"});
				} else {
					this._mid.setText(lc > 1 ? (('\n').repeat(lc - 1)) : (''));
					this.setMode('multi');
				};
				return this;
			};
			
			tag.prototype.render = function (){
				var elapsed = (new Date() - this._timestamp);
				var flip = Math.round(elapsed / 500) % 2;
				
				if (flip != this._flip) {
					this._caret.flag('blink',flip);
					this._flip = flip;
				};
				
				return this;
			};
			
			tag.prototype.build = function (){
				var v_, t0;
				this.setTail((this.setHead(v_ = new RowCol(0,0,this)),v_));
				
				return this.setChildren([
					// <imcaptor@input value='x'>
					(this.$a = this.$a || tag$.$span().flag('dim')).setText('x').end(),
					(this._caret = this._caret || tag$.$imcarethead().setRef('caret',this)).end(),
					(t0 = this._lines=this._lines || tag$.$div().setRef('lines',this)).setContent([
						(this._start = this._start || tag$.$div().setRef('start',this)).setText(" ").end(),
						(this._mid = this._mid || tag$.$div().setRef('mid',this)).end(),
						(this._end = this._end || tag$.$div().setRef('end',this)).setText(" ").end()
					],2).end()
				],2).synced();
			};
			
			tag.prototype.normalize = function (){
				this.head().normalize();
				return this;
			};
			
			tag.prototype.modeDidSet = function (new$,old){
				this.unflag(old);
				return this.flag(new$);
			};
		});
	
	})()

/***/ },
/* 44 */
/***/ function(module, exports) {

	(function(){
		
		tag$.defineTag('scrimbla-overlay', function(tag){
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.render = function (){
				return this.setChildren(JSON.stringify(this.object()),3).synced();
			};
		});
		
		return tag$.defineTag('scrimbla-overlays', function(tag){
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.add = function (type,data){
				if(data === undefined) data = {};
				console.log('add overlay!');
				this.append(tag$.$scrimbla_overlay().setView(this.view()).setObject(data).end());
				return this;
			};
			
			tag.prototype.reposition = function (){
				return this;
			};
		});
	
	})()

/***/ },
/* 45 */
/***/ function(module, exports) {

	(function(){
		
		return tag$.defineTag('imeditor', function(tag){
			
			tag.prototype.build = function (){
				this.render();
				return this;
			};
			
			tag.prototype.render = function (){
				return this.setChildren(
					(this._view = this._view || tag$.$imview().setRef('view',this)).end()
				,2).synced();
			};
			
			tag.prototype.view = function (){
				return this._view;
			};
			
			tag.prototype.activate = function (){
				this.view().activate();
				return this;
			};
			
			tag.prototype.deactivate = function (){
				this.view().deactivate();
				return this;
			};
			
			tag.prototype.load = function (code,opts){
				this.view().load(code,opts);
				return this;
			};
			
			tag.prototype.fs = function (){
				return IM.FS;
			};
			
			tag.prototype.oncommand = function (e,c){
				if (this[c.command] instanceof Function) {
					this[c.command].call(this,c.args || []);
					e.halt();
				};
				return this;
			};
			
			tag.prototype.onsavesession = function (){
				console.log("imeditor.saveSession",this);
				var path = this.view().filename().replace(/\.imba$/,'.imbasession');
				var body = JSON.stringify(this.view().history());
				
				return IM.FS.save(path,body,function() {
					return console.log('returned from saving!',path);
				});
			};
		});
	
	})()

/***/ },
/* 46 */
/***/ function(module, exports) {

	(function(){
		
		/*
		Bridge for communicating with the Imba compiler in a worker
		*/
		
		function ImbacWorker(path){
			if(path === undefined) path = "/vendor/imba/imbac.worker.min.js";
			this._path = path;
			this._callbacks = [];
			this;
		};
		
		exports.ImbacWorker = ImbacWorker; // export class 
		ImbacWorker.prototype.worker = function (){
			var self = this, process1;
			return self._worker || (self._worker = (true) && (
				process1 = new Worker(self._path),
				process1.onmessage = function(e) { return self.onmessage(e); },
				process1
			));
		};
		
		ImbacWorker.prototype.onmessage = function (e){
			var fn;
			if (fn = this._callbacks.shift()) {
				return fn(e.data,e);
			};
		};
		
		ImbacWorker.prototype.compile = function (code,o,cb){
			this._callbacks.push(cb);
			this.worker().postMessage(['compile',code,o]);
			return this;
		};
		
		ImbacWorker.prototype.analyze = function (code,o,cb){
			this._callbacks.push(cb);
			this.worker().postMessage(['analyze',code,o]);
			return this;
		};
		return ImbacWorker;
	
	})()

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		__webpack_require__(48);
		__webpack_require__(49);
		__webpack_require__(50);
		__webpack_require__(51);
		__webpack_require__(52);
		__webpack_require__(53);
		__webpack_require__(54);
		__webpack_require__(55);
		return __webpack_require__(56);
	
	})()

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		var Highlighter = __webpack_require__(29).Highlighter;
		var util = __webpack_require__(34);
		
		// dangerous to extend all htmlelement tags globally
		tag$.extendTag('htmlelement', function(tag){
			
			tag.prototype.bubble = function (name,data){
				// log "bubble event",name,data
				var ev = Imba.Events.trigger(name,this,{data: data,bubble: true});
				return ev;
			};
			
			tag.prototype.delay = function (name,time,blk){
				this._timeouts || (this._timeouts = {});
				clearTimeout(this._timeouts[name]);
				if (time != -1) { this._timeouts[name] = setTimeout(blk,time) };
				return this;
			};
			
			tag.prototype.setNext = function (el){
				if (el instanceof IMFragment) {
					el = Array.prototype.slice.call(el.dom().childNodes);
				};
				
				if (el instanceof Array) {
					for (var i = 0, ary = iter$(el.reverse()), len = ary.length; i < len; i++) {
						this.setNext(ary[i]);
					};
					return this;
				};
				
				var curr = this.dom().nextSibling;
				if ((typeof el=='string'||el instanceof String)) {
					el = document.createTextNode(el);
				};
				
				if (curr) {
					this.parent().insertBefore(el,curr);
				} else {
					this.parent().appendChild(el);
				};
				
				return el;
			};
			
			tag.prototype.setPrev = function (el){
				if (el instanceof IMFragment) {
					el = Array.prototype.slice.call(el.dom().childNodes);
					// el = [].concat(el.dom:childNodes)
				};
				
				if (el instanceof Array) {
					for (var i = 0, ary = iter$(el), len = ary.length; i < len; i++) {
						this.setPrev(ary[i]);
					};
					return this;
				};
				
				var curr = this.dom().prevSibling;
				if ((typeof el=='string'||el instanceof String)) {
					el = document.createTextNode(el);
				};
				this.parent().insertBefore(el,this);
				// parent.insert(el, before: self)
				return el;
			};
			
			tag.prototype.nextNode = function (){
				return this.dom().nextSibling;
			};
			
			tag.prototype.prevNode = function (){
				return this.dom().prevSibling;
			};
		});
		
		IM.Types = {};
		
		tag$.defineTag('im', 'b', function(tag){
			
			tag.key = function (key,handler){
				this.prototype[("handle" + key)] = handler;
				return this;
			};
			
			tag.native = function (typ){
				this._nativeType = typ;
				return this;
			};
			
			tag.type = function (typ){
				IM.Types[typ] = this;
				this._type = typ;
				this.prototype._type = typ;
				// @domFlags.push(typ) if @domFlags
				return this;
			};
			
			tag.type('Tok');
			
			tag.alias = function (typ){
				IM.Types[typ] = this;
				return this;
			};
			
			tag.trigger = function (match,cmd){
				if (cmd instanceof Function) {
					cmd = {command: cmd};
				};
				
				cmd.trigger = match;
				return this.prototype[("trigger-" + match)] = cmd;
			};
			
			tag.prototype.setHint = function (hint){
				if (hint && hint != this._hint) {
					this.setAttribute('hint',hint.ref());
					this.setAttribute("hint-type",hint.type());
				} else {
					this.removeAttribute('hint');
					this.removeAttribute('hint-type');
				};
				return this._hint = hint;
			};
			
			tag.prototype.hint = function (){
				// strange no?		
				return this._hint || this.view().hints().get(this.getAttribute('hint'));
			};
			
			// go over to using this 
			tag.prototype.walkTextNodes = function (mark){
				if(mark === undefined) mark = false;
				this.setRoot(this.dom());
				var el;
				var nodes = [];
				var pos = 0;
				var walk = document.createTreeWalker(this.root(),NodeFilter.SHOW_TEXT,null,false);
				
				while (el = walk.nextNode()){
					if (mark) {
						var len = el.length;
						el._loc = pos;
						pos += len;
					};
					nodes.push(el);
				};
				
				return nodes;
			};
			
			
			tag.prototype.util = function (){
				return util;
			};
			
			tag.prototype.select = function (){
				return this.view().caret().set(this.region());
			};
			
			tag.prototype.canPrepend = function (text){
				return false;
			};
			
			tag.prototype.canAppend = function (text){
				return false;
			};
			
			tag.prototype.log = function (){
				var logger_;
				(logger_ = this.view().logger()).log.apply(logger_,arguments);
				return this;
			};
			
			tag.prototype.toString = function (){
				return this.dom().outerHTML;
			};
			
			tag.prototype.spaced = function (){
				if (this.dom().nextSibling instanceof Text) {
					return (/[\t ]/).test(this.dom().nextSibling.textContent[0]);
				};
				return false;
			};
			
			tag.prototype.unspaced = function (){
				return !(this.spaced());
			};
			
			tag.prototype.nextImmediate = function (){
				// could be text as well?
				return this.dom().nextSibling instanceof Text ? (null) : (this.next());
			};
			
			tag.prototype.prevImmediate = function (){
				// could be text as well?
				return this.dom().previousSibling instanceof Text ? (null) : (this.prev());
			};
			
			tag.prototype.repair = function (){
				return this;
			};
			
			tag.prototype.text = function (){
				return this.dom().textContent;
			};
			
			tag.prototype.setText = function (text){
				this.dom().textContent = text;
				return this;
			};
			
			tag.prototype.code = function (){
				return this.dom().textContent;
			};
			
			tag.prototype.setCode = function (code,silent){
				var hint_;
				if(silent === undefined) silent = false;
				var prev = this.code();
				
				if (this._dom.firstChild == this._dom.lastChild && (this._dom.firstChild instanceof Text)) {
					// still set if it has not changed?
					this._dom.firstChild.textContent = code;
				} else {
					this._dom.textContent = code;
				};
				
				if (code != prev) {
					(hint_ = this.hint()) && hint_.changed  &&  hint_.changed();
					if (!silent) { this.onchanged(code,prev) };
				};
				return this;
			};
			
			tag.prototype.onchanged = function (code,prev){
				return this.flag('dirty');
			};
			
			tag.prototype.size = function (){
				return this.code().length;
			};
			
			tag.prototype.view = function (){
				var parent_;
				return this._view || ((parent_ = this.parent()) && parent_.view  &&  parent_.view()) || VIEW;
			};
			
			tag.prototype.sel = function (){
				return this.view().caret();
			};
			
			tag.prototype.region = function (){
				return this.view().regionForNode(this);
			};
			
			tag.prototype.loc = function (){
				return this.region().loc();
			};
			
			tag.prototype.load = function (){
				return this;
			};
			
			tag.prototype.decreaseIndent = function (pre,state){
				return false;
			};
			
			tag.prototype.increaseIndent = function (pre,state){
				var reg = /^(\s*(.*\=\s*)?(class|def|tag|unless|if|else|elif|switch|try|catch|finally|for|while|until|do))/;
				return reg.test(pre);
			};
			
			tag.prototype.erase = function (region,mode){
				if (mode == 'all') {
					this.orphanize();
				} else {
					this.setCode(util.patchString(this.code(),'',region)); // code.ins('',region)
				};
				return this;
			};
			
			tag.prototype.insert = function (region,str,edit,pars){
				if(!pars||pars.constructor !== Object) pars = {};
				var mode = pars.mode !== undefined ? pars.mode : null;
				this.setCode(util.patchString(this.code(),str,region));
				return this;
			};
			
			tag.prototype.oninserted = function (e){
				return this;
			};
			
			tag.prototype.oncommand = function (e,cmd){
				var name = cmd.command;
				var fn = this[name];
				this.log('run oncommand',name,cmd);
				
				if (fn instanceof Function) {
					fn.call(this,e,cmd);
				};
				return this;
			};
			
			tag.prototype.indentBlock = function (e){
				this.log('im.indentBlock',arguments,this);
				return this;
			};
			
			tag.prototype.clone = function (val){
				return IM.tok(val).classify();
			};
			
			tag.prototype.validate = function (code){
				return false;
			};
			
			tag.prototype.isFirst = function (){
				var par = this.parent();
				return (par instanceof IM.Types.Tok) && par.dom().firstChild == this.dom();
			};
			
			tag.prototype.isLast = function (){
				var par = this.parent();
				return (par instanceof IM.Types.Tok) && par.dom().lastChild == this.dom();
			};
			
			tag.prototype.isValid = function (code){
				if(code === undefined) code = this.text();
				return this.validate(code);
			};
			
			tag.prototype.markInvalid = function (){
				this.flag('invalid');
				return this;
			};
			
			tag.prototype.markValid = function (){
				this.unflag('invalid');
				return this;
			};
			
			tag.prototype.isInvalid = function (){
				return this.hasFlag('invalid');
			};
			
			tag.prototype.classify = function (){
				return this;
			};
			
			// unwrap / remove this node from parent
			tag.prototype.unwrap = function (){
				var el = this.dom();
				var par = el.parentNode;
				
				while (el.firstChild){
					par.insertBefore(el.firstChild,el);
				};
				return this;
			};
			
			tag.prototype.replaceWith = function (other){
				this.setPrev(other);
				return this.orphanize();
			};
			
			tag.prototype.scope = function (){
				return this.closest(q$('._indent',this));
			};
			
			tag.prototype.mutated = function (muts){
				// remove node if it is orphanized
				var self = this;
				if (self.code() == '') {
					self.log('remove whole node');
					// should possibly
					return self.orphanize();
				} else {
					self.log('mutated -- reparse');
					return self.view().observer().pause(function() {
						return self.view().highlighter().reparse(self.dirtyExtent());
					});
				};
			};
			
			
			tag.prototype.reclassify = function (type){
				// reclassify should happen through the highlighter
				// log 'reclassify node as type',type
				var cls = IM.Types[type] || Imba.TAGS[("im" + type)];
				
				if (cls) {
					// log 'found class to reclassify as',cls,self:constructor
					if (cls == this.constructor) {
						return this;
					};
					
					// log 'found class to reclassify as',cls
					var node = new cls(this.dom()).setup();
					return node;
				};
				return this;
			};
			
			tag.prototype.reparsed = function (){
				return this;
			};
			
			tag.prototype.baseClasses = function (){
				var cls = this.constructor.dom().className;
				if (this._type) { cls += ' ' + this._type };
				return cls;
			};
			
			tag.prototype.setup = function (){
				this._dom.className = this.baseClasses();
				return this;
			};
			
			tag.prototype.reuse = function (){
				return this.setup.apply(this,arguments);
			};
			
			tag.prototype.isAtomic = function (){
				return false;
			};
			
			// find the nodes / region that should be reparsed if this element has changed
			// this is currently quote 
			
			tag.prototype.dirtyExtent = function (){
				// 3log "get dirty extent for",dom
				var self = this, sel, sel1, sel2, $1;
				if (sel = self.up(q$('.selector',self))) {
					return sel.dirtyExtent();
				} else if (sel1 = self.up(q$('._imtagnode',self))) {
					return sel1.dirtyExtent();
				} else if (sel2 = self.up(q$('._imistring',self))) {
					return sel2.dirtyExtent();
				};
				
				if (self.isAtomic()) { // hmm
					return {
						nodes: [self.dom()],
						code: self.code(),
						contains: function(el) { return self.dom().contains(el._dom || el); }
					};
				};
				
				var start = self.dom();
				var end = self.dom();
				
				var prev,next;
				var nodes = [self.dom()];
				var opener,closer;
				
				while (prev = start.previousSibling){
					if (prev instanceof Text) {
						break;
					} else if (prev.matches('._imnewline,._imtab')) { // ,._imopen,._imclose
						break;
					};
					
					if (prev.matches('._imopen')) {
						opener = prev;
					};
					
					start = prev;
					nodes.unshift(start);
				};
				
				while (next = end.nextSibling){
					if (next instanceof Text) {
						break;
					} else if (next.matches('._imnewline')) { // ._imopen,._imclose
						break;
					};
					
					if (next.matches('._imclose')) {
						closer = next;
					};
					
					end = next;
					nodes.push(end);
				};
				
				// see if we include an open or close-tag
				
				var result = {
					nodes: nodes,
					code: "",
					target: self.dom(),
					nested: [],
					contains: function(node) { return this.nodes.indexOf(node) >= 0; }
				};
				
				if (opener || closer) {
					// log "includes opener and / or closer",opener,closer
					var par = tag$wrap((opener || closer).parentNode);
					if (($1 = par) && $1.isAtomic  &&  $1.isAtomic()) {
						// log 'return the parent dirty extent',par
						return par.dirtyExtent();
					};
					
					for (var nodes = [], i = 0, ary = iter$((opener || closer).parentNode.children), len_ = ary.length; i < len_; i++) {
						nodes.push(ary[i]);
					};
				};
				
				var loc = 0;
				
				// should use the tags directly
				for (var i = 0, ary = iter$(nodes), len_ = ary.length, node; i < len_; i++) {
					node = ary[i];
					var rich = tag$wrap(node);
					var text = node.textContent;
					var len = text.length;
					
					if (false) {
						text = "'§§§'";
						len = 5;
						self.log("added node as nested reference",rich.dom());
						// this is fucked up
						// this really does mess up the rich nodes here(?!)
						result.nested.push(rich);
					};
					
					result.code += text;
					loc += len;
				};
				
				result.nodes = nodes;
				return result;
			};
			
			tag.prototype.reparseExtent = function (e){
				var self = this;
				return self.view().observer().pause(function() {
					var dirty = self.dirtyExtent();
					if (e) { e.handled() };
					return Highlighter.reparse(dirty);
				});
			};
		});
		
		
		// piece of unparsed code
		tag$.defineTag('imraw', 'im', function(tag){
			tag.type('raw');
			tag.alias('@');
			
			tag.prototype.setRaw = function (raw){
				this._raw = raw;
				this._dom.textContent = raw;
				return this;
			};
			
			tag.prototype.onedit = function (e){
				this.setCode(e.patch(this));
				return e.handled();
			};
		});
		
		tag$.defineTag('imfragment', 'imraw', function(tag){
			tag.type('fragment');
			
			tag.prototype.setContent = function (content){
				if (typeof content == 'string') {
					this.dom().innerHTML = content;
				} else {
					tag.__super__.setContent.apply(this,arguments);
				};
				return this;
			};
			
			tag.prototype.repair = function (){
				this.unwrap();
				this.orphanize();
				return this;
			};
		});
		
		IMFragment = Imba.TAGS.imfragment;
		
		tag$.defineTag('imopen', 'im', function(tag){
			
			// @nodeType = 's'
			tag.type('open');
			
			tag.alias('[');
			tag.alias('(');
			tag.alias('{');
			tag.alias('{{');
			tag.alias('index_start');
			tag.alias('block_param_start');
		});
		
		tag$.defineTag('imclose', 'im', function(tag){
			
			tag.type('close');
			// @nodeType = 's'
			
			tag.alias(']');
			tag.alias(')');
			tag.alias('}');
			tag.alias('}}');
			tag.alias('index_end');
			tag.alias('block_param_end');
		});
		
		tag$.defineTag('imrparen', 'imclose', function(tag){
			tag.type('rparen');
			tag.alias(')');
		});
		
		tag$.defineTag('imtagopen', 'imopen', function(tag){
			tag.type('tag_start');
		});
		
		tag$.defineTag('imtagclose', 'imclose', function(tag){
			tag.type('tag_end');
		});
		
		tag$.defineTag('imselopen', 'imopen', function(tag){
			tag.type('selector_start');
		});
		
		tag$.defineTag('imselclose', 'imclose', function(tag){
			tag.type('selector_end');
		});
		
		tag$.defineTag('imquote', 'im');
		
		tag$.defineTag('imsinglequote', 'imquote', function(tag){
			tag.type("'");
		});
		
		tag$.defineTag('imdoublequote', 'imquote', function(tag){
			tag.type('"');
		});
		
		tag$.defineTag('imstrstart', 'imopen', function(tag){
			tag.type('string_start');
		});
		
		return tag$.defineTag('imstrend', 'imclose', function(tag){
			tag.type('string_end');
		});
	
	})()

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		
		var Region = __webpack_require__(27).Region;
		var Highlighter = __webpack_require__(29).Highlighter;
		
		
		var keywords = [
			'true','false','null','this',
			'delete','typeof','in','instanceof',
			'throw','break','continue','debugger',
			'if','else','switch','for','while','do','try','catch','finally',
			'class','extends','super','return',
			'undefined','then','unless','until','loop','of','by',
			'when','def','tag','do','elif','begin','var','let','self','await','import',
			'and','or','is','isnt','not','yes','no','isa','case','nil','extend','export','own'
		];
		
		// this is really the general token
		tag$.defineTag('imtok', 'im', function(tag){
			tag.alias('token');
			
			
			tag.prototype.__eref = {watch: 'erefDidSet',name: 'eref'};
			tag.prototype.eref = function(v){ return this.getAttribute('eref'); }
			tag.prototype.setEref = function(v){
				var a = this.eref();
				if(v != a) { this.setAttribute('eref',v); }
				if(v != a) { this.erefDidSet && this.erefDidSet(v,a,this.__eref) }
				return this;
			};
			
			tag.prototype.erefDidSet = function (new$,old){
				// experimental
				// console.log 'erefDidSet',new,old
				if (!(new$ && old)) { this.flag('lvar',!(!(new$))) };
				return this;
			};
			
			tag.prototype.isVarRef = function (){
				return this.hasFlag('lvar');
			};
			
			tag.prototype.clearVarRef = function (){
				this.setEref(null);
				return this;
			};
			
			tag.prototype.clone = function (val){
				return IM.tok(val);
			};
			
			tag.prototype.setText = function (text){
				tag.__super__.setText.call(this,text);
				this.classify();
				
				var typ = IM.identify(text);
				
				if (typ) {
					this.log('reclassifying imtok immediately');
					this.setCode(text);
					return this.reclassify(typ);
				};
				
				// return raw token if not classified?
				return this._typ ? (this) : (tag$.$imraw().setRaw(text).end());
			};
			
			tag.prototype.canPrepend = function (text){
				return true;
			};
			
			tag.prototype.canAppend = function (text){
				return true;
			};
			
			tag.prototype.classify = function (map){
				map || (map = IM.identify(this.code()));
				if (map) {
					if (!map.match(/\b_[\w]/)) { map = '_imtok ' + map };
					this.dom().className = map;
					this._typ = map;
				} else {
					this._typ = null;
				};
				return this;
			};
			
			tag.prototype.validate = function (code){
				return false;
			};
			
			tag.prototype.repair = function (){
				this.log('repair');
				this.classify();
				return this;
			};
			
			tag.prototype.split = function (region){
				region = Region.normalize(region);
				var lft = this.code().substring(0,region.start());
				var rgt = this.code().slice(region.end());
				
				this.setCode(lft);
				this.setNext(IM.tok(rgt));
				return this;
			};
			
			tag.prototype.mutated = function (o){
				if(o === undefined) o = {};
				var dirty = this.dirtyExtent();
				this.view().observer().pause(function() { return Highlighter.reparse(dirty); });
				return this;
			};
			
			tag.prototype.reuse = function (tok,new$,old){
				if (new$ == old) { return this };
				return tag.__super__.reuse.apply(this,arguments);
			};
			
			tag.prototype.mutated = function (o){
				if(o === undefined) o = {};
				if (!o.deep && this.validate(this.code())) { return this };
				return tag.__super__.mutated.apply(this,arguments);
			};
			
			tag.prototype.ondblclick = function (e){
				e.halt();
				return this.select();
			};
			
			tag.prototype.onmouseover = function (e){
				e.halt();
				
				if (this.eref()) {
					return this.view().nodesForEntity(this.eref()).map(function(el) { return el.flag('hl'); });
				};
			};
			
			tag.prototype.onmouseout = function (e){
				e.halt();
				if (this.eref()) {
					return this.view().nodesForEntity(this.eref()).map(function(el) { return el.unflag('hl'); });
				};
			};
		});
		
		
		tag$.defineTag('imidentifier', 'imtok', function(tag){
			tag.type('identifier');
			
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			tag.prototype.validate = function (code){
				// regex for identifier
				return (/^[a-z](-?[\wA-Za-z_\-\x7f-\uffff\$]+)*$/).test(code) && keywords.indexOf(code) == -1;
			};
			
			tag.prototype.setup = function (tok,new$,old){
				// console.log 'identifier setup',baseClasses
				var v_;
				if (tok && tok._value) { (this.setName(v_ = tok._value),v_) };
				this._dom.className = this.baseClasses();
				return this;
			};
			
			tag.prototype.mutated = function (){
				// console.log 'imidentifier mutated'
				this.setName(this.code());
				if (this.isVarRef()) {
					this.clearVarRef();
				};
				return tag.__super__.mutated.apply(this,arguments);
			};
		});
		
		tag$.defineTag('imtagtype', 'imtok', function(tag){
			tag.type('tag_type');
		});
		
		tag$.defineTag('imtagid', 'imtok', function(tag){
			tag.type('tag_id');
			tag.alias('idref');
		});
		
		tag$.defineTag('imconst', 'imtok', function(tag){
			tag.type('const');
			
			tag.prototype.validate = function (code){
				return (/^[A-Z](-?[\wA-Za-z_\-\x7f-\uffff\$]+)*$/).test(code);
			};
			
			// def onchanged code, prev
			// 	# console.log 'imconst onchanged',code,prev
			// 	flag('dirty') unless validate(code)
		});
		
		
		tag$.defineTag('imivar', 'imtok', function(tag){
			tag.type('ivar');
		});
		
		tag$.defineTag('imcvar', 'imtok', function(tag){
			tag.type('cvar');
		});
		
		tag$.defineTag('imkeyword', 'imtok', function(tag){
			tag.type('keyword');
			tag.alias('new');
			
			tag.prototype.setup = function (tok,new$,old){
				// console.log 'setup imkeyword',tok, new, old
				var cls = this.baseClasses();
				if (tok && tok._value) { cls += ' ' + tok._value };
				this._dom.className = cls;
				return this;
			};
		});
		
		keywords.map(function(keyword) { return IM.Types[keyword] = IM.Types.keyword; });
		
		IM.Types.forin = IM.Types.keyword;
		IM.Types.forof = IM.Types.keyword;
		IM.Types.post_if = IM.Types.keyword;
		IM.Types.post_unless = IM.Types.keyword;
		IM.Types.post_for = IM.Types.keyword;
		IM.Types.post_while = IM.Types.keyword;
		
		tag$.defineTag('imnum', 'imtok', function(tag){
			tag.type('number');
			
			tag.prototype.validate = function (code){
				return (/^\d+(\.\d+)?$/).test(code);
			};
			
			tag.prototype.reuse = function (){
				return this;
			};
		});
		
		tag$.defineTag('imint', 'imnum', function(tag){
			tag.type('int');
		});
		
		tag$.defineTag('imfloat', 'imnum', function(tag){
			tag.type('float');
		});
		
		tag$.defineTag('imbool', 'imtok', function(tag){
			tag.type('bool');
			tag.alias('true');
			tag.alias('false');
		});
		
		// this should be more advanced - no
		tag$.defineTag('imstr', 'imtok', function(tag){
			tag.type('string');
			
			tag.prototype.quote = function (){
				return this.code()[0];
			};
			
			tag.prototype.setQuote = function (quote){
				this.setCode(quote + this.code().slice(1,-1) + quote);
				return this;
			};
			
			tag.prototype.setup = function (tok,new$,old){
				// console.log 'setup string',tok, new, old
				this._dom.className = this.baseClasses();
				this.setCode(new$);
				return this;
			};
			
			tag.prototype.onunwrap = function (e){
				var v_;
				this.log('imstring onunwrap!!!',e);
				e.halt();
				// look at prev and next as well?
				// should do this through the view
				return (this.setCode(v_ = this.code().slice(1,-1)),v_);
			};
			
			tag.prototype.ondblclick = function (e){
				e.halt();
				return this.select();
			};
			
			tag.prototype.validate = function (code){
				if (code[0] == '"') {
					return (/^\"([^"\{]*)\"$/).test(code);
				} else if (code[0] == "'") {
					return (/^\'([^'\{]*)\'$/).test(code);
				};
			};
			
			tag.trigger('"',function(token,o) {
				if (token.quote() == '"') {
					this.insert('\\"');
					return true;
				} else if (token.quote() == "'" && o.mode == 'all') {
					token.setQuote('"');
					return this;
				};
			});
			
			tag.trigger("'",function(token,o) {
				var v_;
				if (token.quote() == '"') {
					return (token.setQuote(v_ = "'"),v_);
				} else if (token.quote() == "'" && o.mode == 'all') {
					return this.insert("\\'");
				};
			});
		});
		
		
		
		tag$.defineTag('imneostring', 'imtok', function(tag){
			tag.type('neostring');
			
			tag.prototype.mutated = function (o){
				if(o === undefined) o = {};
				if (!o.deep && !this.code().match(/[\{\"\']/)) { return this };
				return tag.__super__.mutated.apply(this,arguments);
			};
		});
		
		tag$.defineTag('imsym', 'imtok', function(tag){
			tag.type('symbol');
		});
		
		return tag$.defineTag('imtagattr', 'imtok', function(tag){
			tag.type('tag_attr');
		});
	
	})()

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		
		var Highlighter = __webpack_require__(29).Highlighter;
		var util = __webpack_require__(34);
		
		tag$.defineTag('imblock', 'im', function(tag){
			
			tag.prototype.deleteLeftRight = function (e){
				this.log('imblock deleteLeftRight',e.region().peek(-1,1));
				
				if (e.region().peek(-1,1) == this.code()) {
					this.orphanize();
					return e.handled();
				};
				
				return this;
			};
			
			tag.prototype.indentBlock = function (e){
				var self = this;
				e.handled();
				
				self.view().caret().expandToLines();
				var region = self.view().caret().region();
				var nodes = self.view().nodesInRegion(region);
				
				nodes.map(function(match) {
					if (match.node.matches('._imnewline')) {
						self.log('found tab in selection',match);
						if (match.mode != 'start') {
							return match.node.indent();
						};
					};
				});
				
				self.view().caret().dirty();
				return self;
			};
			
			tag.prototype.undent = function (e){
				this.log('imblock.undent',arguments);
				var nodes = e.view().nodesInRegion(e.region().clone().startAtLine());
				nodes.map(function(match) {
					if (match.node.matches('._imnewline') && match.mode != 'start') {
						return match.node.undent();
						// e.caret.expand(0,-1)
					};
				});
				this.view().caret().expandToLines();
				return e.handled();
			};
			
			tag.prototype.pairable = function (str,e){
				return true;
			};
			
			tag.prototype.wrap = function (node){
				this.setChildren([node]);
				return this;
			};
			
			tag.prototype.repair = function (){
				// log "repair block"
				q$('._imraw',this).map(function(raw) { return raw.repair(); });
				return this;
			};
			
			tag.prototype.rehighlight = function (){
				// var reg = view.sel.region
				var self = this;
				var state = self.codeState();
				var hl = IM.parse(state.code);
				// could send this through load instead
				// what about annotations here?
				throw 'dont rehighlight';
				
				if (hl) {
					self.view().observer().pause(function() {
						self.dom().innerHTML = hl + '\n';
						return state.invalids.map(function(inv) {
							// we could go local instead
							var node;
							if (node = self.view().nodeAtRegion(inv.region,true)) {
								self.log('found node at invalid position',node);
								return node.replaceWith(inv.node);
							};
						});
					});
				};
				return self;
			};
			
			// bad naming
			tag.prototype.codeState = function (){
				var self = this;
				var real = self.code();
				var valid = real;
				var invalids = q$('.invalid',self);
				var ownreg = self.region();
				var selreg = self.view().sel().region();
				
				var remember = invalids.map(function(inv) {
					// multilevel nesting?
					var region = inv.region();
					var relreg = region.relativeTo(ownreg);
					self.log('invalid region',ownreg,'self',region,relreg);
					valid = valid.ins(inv.placeholder(),relreg);
					return {region: region,placeholder: inv.placeholder(),raw: inv.code(),node: inv,root: self,relRegion: relreg};
				});
				
				return {
					region: ownreg,
					marker: (selreg.intersects(ownreg) ? (selreg) : (null)),
					raw: real,
					code: valid,
					invalids: remember
				};
			};
		});
		
		
		tag$.defineTag('iminterpolated', 'imblock');
		
		tag$.defineTag('indent', 'imblock', function(tag){
			
			tag.prototype.variables = function (){
				var map = {};
				var vars = [];
				q$('._lvar',this).map(function(lvar) {
					var name = lvar.text();
					if (!map[name]) {
						map[name] = true;
						return vars.push(name);
					};
				});
				return vars;
			};
		});
		
		tag$.defineTag('impair', 'imblock', function(tag){
			tag.type('pair');
			
			tag.pair = function (open,close){
				this.prototype._open = open;
				this.prototype._close = close;
				return this;
			};
			
			tag.prototype.open = function (){
				return this._open || '';
			};
			tag.prototype.close = function (){
				return this._close || '';
			};
			
			tag.prototype.build = function (){
				this.gen();
				return this;
			};
			
			tag.prototype.setContent = function (content){
				throw 'should not get here';
				this.dom().innerHTML = this.open() + IM.parse(content) + this.close();
				return this;
			};
			
			tag.prototype.isEmpty = function (){
				return this.code().replace(/[\s\t \n]/,'') == (this.open() + this.close());
			};
			
			tag.prototype.isPaired = function (){
				var code = this.code();
				return code[0] == this.open() && code[code.length - 1] == this.close();
			};
			
			tag.prototype.isOpened = function (){
				return this.code()[0] == this.open();
			};
			
			tag.prototype.isClosed = function (){
				return this.code()[this.code().length - 1] == this.close();
			};
			
			tag.prototype.unwrap = function (){
				if (this.isEmpty()) {
					this.log('remove the whole thing');
					this.orphanize();
				} else {
					var el;
					var par = this.parent();
					while (el = this._dom.firstChild){
						par.dom().insertBefore(el,this._dom);
					};
					// remove self as well
				};
				return this;
			};
			
			tag.prototype.onunwrap = function (e){
				this.log('impair onunwrap!!!',e);
				return e.halt();
			};
			
			tag.prototype.gen = function (){
				this.setChildren([
					tag$.$imopen().setContent(this.open(),0).end(),
					tag$.$imclose().setContent(this.close(),0).end()
				]);
				return this;
			};
			
			tag.prototype.oninserted = function (e){
				e.setCaret(this.region().collapse(false).move(1));
				return this;
			};
			
			tag.prototype.select = function (){
				return this;
			};
			
			tag.prototype.onlinebreak = function (e){
				var pre = e.linestr('pre');
				var indent = e.indent();
				var new$ = this.text().ins('',e.relRegion());
				
				// this is a special case - no?
				if (new$ == (this.open() + this.close())) {
					var prefix = '\n' + indent + '\t';
					var post = '\n' + indent;
					this.onwhitespace(e,prefix + post);
					e.caret().collapse(false).move(-post.length);
					return e.handled();
				};
				
				// need to first consider the splitting, no?
				if (this.increaseIndent(pre)) { indent += '\t' };
				if (this.decreaseIndent(pre)) { indent = indent.slice(1) };
				this.onwhitespace(e,'\n' + indent);
				return e.handled();
			};
			
			tag.prototype.repair = function (){
				this.log('repair imtag');
				if (!(this.isPaired())) { this.revalidate(true) };
				return this;
			};
			
			tag.prototype.mutated = function (){
				this.log('impair mutated');
				return this.revalidate();
			};
			
			tag.prototype.defaultValidationMode = function (){
				return 'tokenize';
			};
			
			tag.prototype.rehighlight = function (){
				return this;
			};
			
			tag.prototype.revalidate = function (mode,write){
				// tricky motherfucker -- mostly useful for validations
				// I suppose we can do this a simpler way -- by turning
				// off observers -- temporarily replacing inner code etc
				
				// when a block checks validity it should probably
				// substitute inner invalid parts - so that the block
				// thing is still valid
				var self = this, hl;
				if(mode === undefined) mode = self.defaultValidationMode();
				if(write === undefined) write = false;
				var wasInvalid = self.hasFlag('invalid');
				var oldState = self.hasFlag('invalid');
				var state = self.codeState();
				var code = state.code;
				
				if (!(self.isPaired())) {
					return self.markInvalid();
				};
				
				console.log('will revalidate with code',code);
				console.time('revalidate');
				
				try {
					if (mode == 'compile') {
						self._output = Imbac.compile(code,{bare: true});
						self._tokens = self._output.options._tokens;
					} else {
						self._tokens = Imbac.tokenize(code,{bare: true});
					};
					self.markValid();
				} catch (e) {
					self._tokens = null;
					self.markInvalid();
				};
				
				console.timeEnd('revalidate');
				
				if (wasInvalid && self._tokens) {
					// need to fix inner for root
					if (hl = Highlighter.highlight(code,{tokens: self._tokens,inner: true})) {
						// this should be refactored out into a separate method
						// possibly do loadState / dumpState
						self.view().observer().pause(function() {
							self.dom().innerHTML = hl;
							state.invalids.map(function(inv) {
								var node;
								if (node = self.view().nodeAtRegion(inv.region,true)) {
									return node.replaceWith(inv.node);
								};
							});
							if (state.marker) { return self.view().sel().set(state.marker) };
						});
					};
				};
				
				return self;
			};
			
			tag.prototype.placeholder = function (){
				return this.open() + (' ').repeat(this.size() - 2) + this.close();
			};
			
			tag.prototype.isAtomic = function (){
				return true;
			};
			
			tag.prototype.mutated = function (){
				this.log('muated imcurly');
				this.view().highlighter().reparse(this.dirtyExtent());
				return this;
			};
		});
		
		tag$.defineTag('imcurly', 'impair', function(tag){
			tag.type('curly');
			tag.pair('{','}');
		});
		
		tag$.defineTag('imsquare', 'impair', function(tag){
			tag.type('square');
			tag.pair('[',']');
			
			tag.prototype.prettify = function (e){
				var self = this;
				self.log('prettify!');
				e.handled();
				var ind = e.region().indent();
				self.log('with indentation',ind,ind.length);
				
				self.view().observer().pause(function() {
					for (var i = 0, ary = iter$(self.children()), len = ary.length, child, res = []; i < len; i++) {
						child = ary[i];
						res.push(child.matches('.comma,._imopen') ? (
							child.setNext('\n' + ind + '\t')
						) : ((child.matches('._imclose')) && (
							child.setPrev('\n' + ind)
						)));
					};
					return res;
				});
				
				return true;
			};
		});
		
		tag$.defineTag('imparens', 'impair', function(tag){
			tag.type('parens');
			tag.pair('(',')');
			
			tag.prototype.onunwrap = function (e){
				this.log('impair onunwrap!!!',e);
				e.halt();
				// look at prev and next as well?
				// should do this through the view
				this.setCode(' ' + this.code().slice(1,-1));
				return this.view().repair();
			};
		});
		
		tag$.defineTag('imistring', 'impair', function(tag){
			tag.type('istring');
			tag.pair('"','"');
		});
		
		tag$.defineTag('imiexpr', 'impair', function(tag){
			tag.type('iexpr');
			tag.pair('{','}');
		});
		
		tag$.defineTag('imblockparams', 'impair', function(tag){
			tag.type('blockparams');
			tag.pair('|','|');
		});
		
		return tag$.defineTag('imtagnode', 'impair', function(tag){
			tag.type('tagnode');
			tag.pair('<','>');
			
			tag.prototype.pairable = function (str,e){
				return idx$(str,['{','[','(','"',"'"]) >= 0;
			};
			
			tag.prototype.placeholder = function (){
				return this.open() + ('x').repeat(this.size() - 2) + this.close();
			};
			
			tag.prototype.defaultValidationMode = function (){
				return 'compile';
			};
		});
	
	})()

/***/ },
/* 51 */
/***/ function(module, exports) {

	(function(){
		
		return tag$.defineTag('imroot', 'imblock', function(tag){
			
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag._nodeType = 'code';
			// def self.dom
			//	@dom ||= document.createElement('code')
			
			tag.prototype.tryUndent = function (e){
				var self = this;
				self.log('tryUndent');
				var nodes = e.view().nodesInRegion(e.region().clone().startAtLine());
				nodes.map(function(match) {
					if (match.node.matches('._imnewline') && match.mode != 'start') {
						match.node.undent();
						return self.view().caret().move(-1);
						// e.caret.move(-1)
						// e.caret.expand(0,-1)
					};
				});
				
				// e.moveCaret = 0
				e.handled();
				return self;
			};
			
			tag.prototype.build = function (){
				tag.__super__.build.apply(this,arguments);
				
				this.dom().addEventListener('');
				return this;
			};
			
			tag.prototype.commit = function (){
				return this;
			};
			
			tag.prototype.setNext = function (node){
				this.appendChild(node);
				return node;
			};
			
			tag.prototype.setPrev = function (node){
				var first = this.dom().firstChild;
				first ? (this.insertBefore(node,first)) : (this.appendChild(node));
				return node;
			};
			
			tag.prototype.onlinebreak = function (e){
				var pre = e.linestr('pre');
				var indent = e.indent();
				var new$ = this.text().ins('',e.relRegion());
				// need to first consider the splitting, no?
				if (this.increaseIndent(pre)) { indent += '\t' };
				if (this.decreaseIndent(pre)) { indent = indent.slice(1) };
				this.onwhitespace(e,'\n' + indent);
				return e.handled();
			};
			
			tag.prototype.mutated = function (){
				this.log('imroot mutated');
				return this;
			};
			
			tag.prototype.dirtyExtent = function (){
				var self = this;
				self.log('imroot dirtyExtent');
				// super
				var nodes = self.children().map(function(n) { return n.dom(); });
				
				return {
					code: self.code(),
					nodes: nodes,
					parent: self.dom(),
					contains: function(el) { return self.dom().contains(el._dom || el); }
				};
			};
		});
	
	})()

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		// externs;
		
		var util = __webpack_require__(34);
		
		var SINGLE_STR = /^'[^']*'$/;
		var DOUBLE_STR = /^"[^"\{]*"$/;
		var COMMENT = /^\#[ \t][^\n]*$/;
		
		DOUBLE_STR = /^"([^\\"\{]|\\\\|\\")*"$/;
		
		tag$.defineTag('imlit', 'im', function(tag){
			
			tag.prototype.validate = function (code){
				return false;
			};
		});
		
		return tag$.defineTag('imregex', 'imlit', function(tag){
			
			tag.type('regex');
			
			tag.prototype.validate = function (value){
				return true;
			};
			
			tag.prototype.pairing = function (chr){
				return this;
			};
			
			tag.prototype.revalidate = function (){
				var reg = this.code();
				try {
					var obj = eval(reg);
				} catch (e) { };
				this.log('regex is',reg,obj);
				this.flag('invalid',!obj);
				return this;
			};
			
			tag.prototype.mutated = function (){
				this.log('regex mutated');
				return this.revalidate();
			};
			
			tag.prototype.placeholder = function (){
				return '/' + 'R'.repeat(this.size() - 2) + '/';
			};
			
			tag.prototype.isAtomic = function (){
				return true;
			};
		});
		
	
	})()

/***/ },
/* 53 */
/***/ function(module, exports) {

	(function(){
		
		// should rather reconcile into token - or something like it
		var names = {
			'.': 'dot',
			'=': 'eq',
			'?': 'q',
			'!': 'unary',
			':': 'colon',
			',': 'comma',
			'#': 'hash',
			'*': 'mult',
			'>>': 'bitshift'
		};
		
		tag$.defineTag('imop', 'im', function(tag){
			
			tag.type('op');
			tag.alias('relation');
			tag.alias('compare');
			tag.alias('compound_assign');
			tag.alias('assign');
			tag.alias('block_arg');
			tag.alias('splat');
			tag.alias('logic');
			tag.alias('math');
			tag.alias('shift');
			tag.alias('unary');
			
			tag.prototype.validate = function (code){
				return IM.isOp(code);
			};
			
			tag.prototype.baseClasses = function (){
				return tag.__super__.baseClasses.apply(this,arguments) + ' ' + (names[this.code()] || '');
			};
			
			tag.prototype.setup = function (token){
				var val = token && token._value || this.code();
				this.dom().className = ("_im _imop op " + (names[val] || ''));
				return this;
			};
			
			// should merge with a more generic version for token in general
			// same goes for text etc
			tag.prototype.insert = function (){
				tag.__super__.insert.apply(this,arguments);
				
				if (this.code() == '//') {
					this.log('is a regex!!');
					return this.reclassify('regex');
				};
			};
		});
		
		// link regular ops to op-node
		return '+ - * / = ++ -- == === != !== > < >= <= & && | || or . : ? &= ||= &&= ?. ?: , ! .. ... .: >> << #'.split(' ').map(function(op) {
			return IM.Types[op] = IM.Types.op;
		});
		
		
		// IM.Types:logic = IM.Types:op
		// IM.Types:compare = IM.Types:op
		// IM.Types:math = IM.Types:op
		// IM.Types:shift = IM.Types:op
		
	
	})()

/***/ },
/* 54 */
/***/ function(module, exports) {

	(function(){
		
		// this should be more advanced than this, no?
		tag$.defineTag('imsel', 'imtok', function(tag){
			tag.type('selector');
			
			tag.prototype.isAtomic = function (){
				return true;
			};
			
			tag.prototype.reparsed = function (code,old){
				this.log("imsel reparsed",code,old);
				return this;
			};
		});
		
		tag$.defineTag('imseltag', 'imtok', function(tag){
			tag.type('selector_tag');
		});
		
		tag$.defineTag('imselclass', 'imtok', function(tag){
			tag.type('selector_class');
		});
		
		tag$.defineTag('imselcomb', 'imtok', function(tag){
			tag.type('selector_combinator');
		});
		
		tag$.defineTag('imselattrop', 'imtok', function(tag){
			tag.type('selector_attr_op');
		});
		
		return tag$.defineTag('imselattrop', 'imtok', function(tag){
			tag.type('selector_attr_op');
		});
	
	})()

/***/ },
/* 55 */
/***/ function(module, exports) {

	(function(){
		tag$.defineTag('iminsert', 'im', function(tag){
			
			tag.prototype.canAppend = function (){
				return true;
			};
			
			tag.prototype.canPrepend = function (){
				return true;
			};
			
			tag.prototype.insert = function (reg,ins){
				console.log('insert code into iminsert!!',ins,reg);
				
				if (ins instanceof IM.Types.fragment) {
					ins = ins.code();
				} else if (ins instanceof IM.Types.raw) {
					ins = ins._raw;
				} else if ((typeof ins=='string'||ins instanceof String)) {
					ins = (this.code() || "").ins(ins,reg);
				};
				
				this.setCode(ins);
				return this;
			};
			
			tag.prototype.isWhitespace = function (){
				return this.code().match(/^[\n\t\ ]+$/);
			};
			
			tag.prototype.mutated = function (){
				this.log('iminsert mutated');
				
				var dirty = this.dirtyExtent();
				this.view().highlighter().reparse(dirty);
				return this;
			};
		});
		
		tag$.defineTag('imwhitespace', 'im', function(tag){
			
			tag.prototype.canPrepend = function (str){
				return this.validate(str + this.code());
			};
			
			tag.prototype.canAppend = function (str){
				return this.validate(this.code() + str);
			};
			
			tag.prototype.validate = function (){
				return false;
			};
		});
		
		tag$.defineTag('imnewline', 'imwhitespace', function(tag){
			
			tag.type('newline');
			tag.alias('\n');
			
			tag.prototype.canPrepend = function (str){
				if (str.match(/^[\n\t\ ]+$/)) {
					// should not really be able to prepend here
					// it shold rather insert a new newline in
					// an iminsert, and that should be able to
					// decide that no reparse is needed
					return true;
				};
				return false;
			};
			
			tag.prototype.validate = function (val){
				if(val === undefined) val = this.code();
				return val == '\n';
			};
			
			tag.prototype.indent = function (){
				this.view().insert(this.region().end(),'\t');
				return this;
			};
			
			tag.prototype.undent = function (){
				this.log('undent newline');
				var reg = this.region().clone().collapse(true).clone(0,1);
				if (reg.text() == '\t') {
					this.log('can undent!!');
					this.view().erase(reg);
				};
				
				// view.observer.pause do
				//	next.orphanize if next?.matches('._imtab')
				return this;
			};
			
			tag.prototype.mutated = function (){
				// log 'imnewline mutated!!'
				// remove node if it is orphanized
				if (this.code() == '') {
					this.log('remove whole node');
					return this.orphanize();
				} else {
					this.log('reparse newline');
					return this.view().highlighter().reparse({nodes: [this.dom()],code: this.code()});
				};
			};
		});
		
		
		
		tag$.defineTag('imspace', 'imwhitespace', function(tag){
			
			tag.type('whitespace');
			
			tag.prototype.validate = function (val){
				if(val === undefined) val = this.code();
				return (/^[ ]+$/).test(val);
			};
			
			// this should be the default for all nodes, no?
			tag.prototype.mutated = function (o){
				if(o === undefined) o = {};
				if (!o.deep && this.validate(this.code())) { return this };
				return tag.__super__.mutated.apply(this,arguments);
			};
		});
		
		tag$.defineTag('imsemicolon', 'imwhitespace', function(tag){
			tag.type('semicolon');
			tag.alias(';');
		});
		
		tag$.defineTag('imtab', 'imwhitespace', function(tag){
			
			tag.type('tab');
			tag.alias('\t');
			
			tag.prototype.onedit = function (e){
				if (e.isSurrounded()) {
					this.log('delete tab?!?');
					if (e.text()) { // otherwise we really are done
						e.redirect(this.prev() || this.next() || this.parent());
					} else {
						e.handled();
					};
					
					e.region().collapse(false);
					this.orphanize();
					return;
				};
			};
			
			tag.prototype.validate = function (val){
				if(val === undefined) val = this.code();
				return val == '\t';
			};
		});
		
		tag$.defineTag('imcomment', 'im', function(tag){
			
			tag.type('comment');
			
			tag.prototype.validate = function (code){
				return COMMENT.test(code);
			};
			
			tag.prototype.mutated = function (){
				this.log('imcomment mutated');
				return tag.__super__.mutated.apply(this,arguments);
			};
			
			tag.prototype.repair = function (){
				this;
				this.log('repair comment');
				var region = this.region().endAtLine();
				var full = region.text(); // should not include the last line?
				var nodes = region.nodes(false);
				this.log('whole region should be',region,full,nodes);
				this.log('all nodes',nodes);
				
				// VERY temporary
				if (nodes.length > 1) {
					this.setCode(full);
					while (nodes.length > 1){
						var el = nodes.pop();
						el.node.orphanize();
					};
				};
				return this;
			};
			
			tag.prototype.oninserted = function (e){
				return this.repair();
			};
			
			tag.prototype.canPrepend = function (text){
				return false;
			};
			
			tag.prototype.canAppend = function (text){
				if (!text.match(/[\n]/)) { return true };
			};
		});
		
		
		// allow inserting additional tabs directly here?
		
		return tag$.defineTag('eof');
	
	})()

/***/ },
/* 56 */
/***/ function(module, exports) {

	(function(){
		
		
		tag$.defineTag('imwarn', 'im', function(tag){
			
			
			
			tag.prototype.message = function(v){ return this.getAttribute('message'); }
			tag.prototype.setMessage = function(v){ this.setAttribute('message',v); return this; };
			
			tag.prototype.build = function (){
				this.log('built error with error',this.object());
				return this;
			};
		});
		
		return tag$.defineTag('imerr', 'imwarn');
	
	})()

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		var Router = __webpack_require__(58).Router;
		
		function App(){
			this.setCache({});
			this.setDeps({});
			this.reset();
			this.tick();
			this;
		};
		
		exports.App = App; // export class 
		
		
		App.prototype.req = function(v){ return this._req; }
		App.prototype.setReq = function(v){ this._req = v; return this; };
		
		
		App.prototype.res = function(v){ return this._res; }
		App.prototype.setRes = function(v){ this._res = v; return this; };
		
		
		App.prototype.deps = function(v){ return this._deps; }
		App.prototype.setDeps = function(v){ this._deps = v; return this; };
		
		
		App.prototype.site = function(v){ return this._site; }
		App.prototype.setSite = function(v){ this._site = v; return this; };
		
		
		App.prototype.cache = function(v){ return this._cache; }
		App.prototype.setCache = function(v){ this._cache = v; return this; };
		
		App.prototype.reset = function (){
			this.setCache({});
			return this;
		};
		
		App.prototype.router = function (){
			return this._router || (this._router = new Router(this));
		};
		
		App.prototype.path = function (){
			return  false ? (this.req().path) : (this._path);
		};
		
		App.prototype.hash = function (){
			return '';
		};
		
		App.prototype.hash = function (){
			return  false ? ('') : (document.location.hash.substr(1));
		};
		
		App.prototype.tick = function (){
			if (true) {
				this._path = document.location.pathname;
			};
			
			return this;
		};
		
		App.prototype.schedule = function (){
			Imba.schedule(this);
			return this;
		};
		
		App.prototype.unschedule = function (){
			Imba.unschedule(this);
			return this;
		};
		
		App.prototype.fetchDocument = function (src,cb){
			
			var deps_, $1, $3, $2;
			if (false) {
				console.log('fetch document',src);
				
				var fs = require('fs');
				var path = require('path');
				
				var filepath = ("" + __dirname + "/../docs/" + src).replace(/\/\//g,'/');
				
				var res = this.deps()[src];
				
				if (!res) {
					var body = fs.readFileSync(filepath,'utf-8');
					
					if (src.match(/\.md$/)) {
						res = this.Markdown.render(body);
					} else if (src.match(/\.json$/)) {
						res = JSON.parse(body);
					} else if (src.match(/\.imba$/)) {
						var html = this.Highlighter.highlight(body,{mode: 'full'});
						res = {body: body,html: html};
					};
				};
				
				(deps_ = this.deps())[($1 = src)] || (deps_[$1] = res);
				
				if (this.site()) {
					($3 = this.site().deps())[($2 = src)] || ($3[$2] = res);
				};
				cb && cb(res);
			} else {
				if (DEPS[src]) {
					cb && cb(DEPS[src]);
					return {then: function(v) { return v(res); }}; // fake promise hack
				};
				
				var xhr = new XMLHttpRequest();
				xhr.addEventListener('load',function(res) {
					DEPS[src] = JSON.parse(xhr.responseText);
					return cb && cb(DEPS[src]);
					// XHR = xhr
					// console.log 'response here',xhr:responseText
				});
				xhr.open("GET",src);
				xhr.send();
			};
			
			return this;
		};
		
		
		function Doc(path){
			this._path = path;
			this._ready = false;
			this.fetch();
			this;
		};
		
		exports.Doc = Doc; // export class 
		var cache = {};
		
		Doc.get = function (path){
			var $1;
			var cache = APP.cache();
			return cache[($1 = 'doc-' + path)] || (cache[$1] = new this(path));
		};
		
		
		
		Doc.prototype.path = function(v){ return this._path; }
		Doc.prototype.setPath = function(v){ this._path = v; return this; };
		
		Doc.prototype.ready = function (){
			return this._ready;
		};
		
		Doc.prototype.fetch = function (){
			var self = this;
			if (false) {
				// console.log 'fetch Guide on server',path
				return APP.fetchDocument(self._path + '.md',function(res) {
					// console.log 'fetch Guide on server done',path
					return self.load(res);
				});
			};
			
			return self._promise || (self._promise = APP.fetchDocument(self._path + '.md',function(res) {
				return self.load(res);
			}));
		};
		
		Doc.prototype.load = function (doc){
			this._object = doc;
			this._meta = doc.meta || {};
			this._ready = true;
			Imba.emit(this,'ready');
			return this;
		};
		
		Doc.prototype.title = function (){
			return this._object.title || 'path';
		};
		
		Doc.prototype.toc = function (){
			return this._object && this._object.toc[0];
		};
		
		Doc.prototype.body = function (){
			return this._object && this._object.body;
		};
		return Doc;
	
	})()

/***/ },
/* 58 */
/***/ function(module, exports) {

	(function(){
		// externs;
		
		function Router(app){
			var self = this;
			self._app = app;
			
			if (Imba.isClient()) {
				window.onpopstate = function(e) {
					self.refresh();
					console.log('popstate');
					return Imba.setTimeout(0,function() { return true; });
				};
			};
			self;
		};
		
		exports.Router = Router; // export class 
		
		
		Router.prototype.path = function(v){ return this._path; }
		Router.prototype.setPath = function(v){ this._path = v; return this; };
		
		Router.slug = function (str){
			str = str.replace(/^\s+|\s+$/g,'').toLowerCase(); // trim
			// remove accents, swap ñ for n, etc
			var from = "àáäâåèéëêìíïîòóöôùúüûñç·/_,:;";
			var to = "aaaaaeeeeiiiioooouuuunc------";
			
			// for (var i=0, l=from.length ; i<l ; i++)
			// 	str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i))
			
			str = str.replace(/[^a-z0-9 -]/g,''); // remove invalid chars
			str = str.replace(/\s+/g,'-'); // collapse whitespace and replace by -
			str = str.replace(/-+/g,'-'); // collapse dashes
			
			return str;
		};
		
		Router.prototype.refresh = function (){
			return this;
		};
		
		Router.prototype.path = function (){
			return this._app.path();
		};
		
		Router.prototype.hash = function (){
			return this._app.hash();
		};
		
		Router.prototype.ext = function (){
			var path = this.path();
			var m = path.match(/\.([^\/]+)$/);
			return m && m[1] || '';
		};
		
		Router.prototype.go = function (href,state,replace){
			if(state === undefined) state = {};
			if(replace === undefined) replace = false;
			if (href == '/install') {
				// redirects here
				href = '/guides#toc-getting-started-installation';
			};
			
			if (replace) {
				history.replaceState(state,null,href);
			} else {
				history.pushState(state,null,href);
			};
			
			if (!href.match(/\#/)) {
				window.scrollTo(0,0);
			};
			
			return this;
		};
		
		Router.prototype.scoped = function (reg,part){
			var path = this.path() + '#' + this.hash();
			if ((typeof reg=='string'||reg instanceof String)) {
				var nxt = path[reg.length];
				return path.substr(0,reg.length) == reg && (!nxt || nxt == '-' || nxt == '/' || nxt == '#' || nxt == '?' || nxt == '_');
			} else if (reg instanceof RegExp) {
				var m = path.match(reg);
				return part && m ? (m[part]) : (m);
			} else {
				return false;
			};
		};
		
		Router.prototype.match = function (reg,part){
			var path = this.path() + '#' + this.hash();
			
			if ((typeof reg=='string'||reg instanceof String)) {
				return path == reg;
			} else if (reg instanceof RegExp) {
				var m = path.match(reg);
				return part && m ? (m[part]) : (m);
			} else {
				return false;
			};
		};
		return Router;
		
	
	})()

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		
		__webpack_require__(60);
		__webpack_require__(61);
		
		__webpack_require__(63);
		__webpack_require__(64);
		__webpack_require__(65);
		__webpack_require__(66);
		__webpack_require__(67);
		__webpack_require__(68);
		__webpack_require__(69);
		return __webpack_require__(70);
	
	})()

/***/ },
/* 60 */
/***/ function(module, exports) {

	(function(){
		tag$.extendTag('element', function(tag){
			
			
			tag.prototype.route = function(v){ return this.getAttribute('route'); }
			tag.prototype.setRoute = function(v){ this.setAttribute('route',v); return this; };
			
			tag.prototype.setHtml = function (html){
				this._dom.innerHTML = html;
				return this;
			};
			
			tag.prototype.go = function (route){
				return this;
			};
			
			tag.prototype.router = function (){
				return APP.router();
			};
			
			tag.prototype.reroute = function (){
				this.flag('scoped',this.router().scoped(this.route(),this));
				return this.flag('selected',this.router().match(this.route(),this));
			};
			
			tag.prototype.setTransform = function (value){
				this.css('transform',value);
				return this;
			};
			
			tag.prototype.transform = function (){
				return this.css('transform');
			};
		});
		
		tag$.extendTag('script', function(tag){
			
			tag.prototype.setChildren = function (value){
				this._children = value;
				this.dom().innerHTML = value;
				return this;
			};
		});
		
		tag$.extendTag('canvas', function(tag){
			
			tag.prototype.dpr = function (){
				return this._dpr || (this._dpr = window.devicePixelRatio || 1);
			};
			
			tag.prototype.setWidth = function (width){
				if (width != this._width) {
					this.dom().width = width * this.dpr();
					this.css({width: width});
					this._width = width;
				};
				return this;
			};
			
			tag.prototype.setHeight = function (height){
				if (height != this._height) {
					this.dom().height = height * this.dpr();
					this.css({height: height});
					this._height = height;
				};
				return this;
			};
		});
		
		return tag$.extendTag('a', function(tag){
			
			tag.prototype.route = function (){
				return this._route || this.href();
			};
			
			tag.prototype.ontap = function (e){
				if (e.event().metaKey || e.event().altKey) {
					e._responder = null;
					return e.halt();
				};
				
				if (this.href()[0] == '#' || this.href()[0] == '/') {
					e.cancel().halt();
					this.router().go(this.href(),{});
					Imba.Events.trigger('route',this);
				} else {
					e._responder = null;
					return e.halt();
				};
				return this;
			};
			
			tag.prototype.render = function (){
				return this.reroute();
			};
		});
	
	})()

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// for markdown rendering
		tag$.defineTag('md', function(tag){
			
			
			tag.prototype.__src = {watch: 'reload',name: 'src'};
			tag.prototype.src = function(v){ return this.getAttribute('src'); }
			tag.prototype.setSrc = function(v){
				var a = this.src();
				if(v != a) { this.setAttribute('src',v); }
				if(v != a) { this.reload && this.reload(v,a,this.__src) }
				return this;
			};
			
			tag.prototype.__html = {watch: 'htmlDidSet',name: 'html'};
			tag.prototype.html = function(v){ return this._html; }
			tag.prototype.setHtml = function(v){
				var a = this.html();
				if(v != a) { this._html = v; }
				if(v != a) { this.htmlDidSet && this.htmlDidSet(v,a,this.__html) }
				return this;
			};
			
			
			tag.prototype.doc = function(v){ return this._doc; }
			tag.prototype.setDoc = function(v){ this._doc = v; return this; };
			
			tag.prototype.body = function (){
				return this;
			};
			
			tag.prototype.setup = function (){
				return this;
			};
			
			tag.prototype.ghsrc = function (){
				return ("https://github.com/somebee/imba.io/blob/master/docs" + this.src());
			};
			
			tag.prototype.htmlDidSet = function (html){
				this.body().dom().innerHTML = html;
				this.setup();
				return this;
			};
			
			tag.prototype.render = function (){
				var self = this;
				if (false) {
					APP.fetchDocument(self.src() + '.md',function(doc) {
						return self.assemble(doc);
					});
				} else if (self._snippets) {
					for (var i = 0, ary = iter$(self._snippets), len = ary.length; i < len; i++) {
						ary[i].end(); // simulate real rendering here?
					};
				};
				return self;
			};
			
			// not on frontpage?!
			tag.prototype.assemble = function (doc){
				return this.flag('md').setHtml(doc.body).synced();
			};
			
			tag.prototype.build = function (){
				tag.__super__.build.apply(this,arguments);
				if (Imba.isClient() && this.src()) { return this.reload() };
			};
			
			tag.prototype.awaken = function (){
				// log "awakened md from client(!)"
				this._snippets = q$('._snippet',this).toArray();
				return this;
			};
			
			tag.prototype.preload = function (html){
				this._dom.innerHTML = html;
				this._snippets = q$('._snippet',this).toArray();
				return this;
			};
			
			tag.prototype.reload = function (){
				var self = this;
				if (Imba.isClient()) {
					// console.log 'reloading markdown'
					self._snippets = [];
					APP.fetchDocument(self.src() + '.md',function(res) {
						// console.log 'returned from markdown here?!',res
						self.assemble((self.setDoc(res),res));
						self._snippets = q$('._snippet',self).toArray();
						self.parent().dom().scrollTop = 0;
						return self;
					});
				};
				return self;
			};
		});
		
		// define renderer
		var marked = __webpack_require__(62);
		var mdr = new (marked.Renderer)();
		
		mdr.heading = function (text,lvl){
			return ("<h" + lvl + ">" + text + "</h" + lvl + ">");
		};
		
		return tag$.defineTag('marked', function(tag){
			
			tag.prototype.renderer = function (){
				return this;
			};
			
			tag.prototype.setText = function (text){
				return this.setContent(text,0);
			};
			
			tag.prototype.setContent = function (val,typ){
				if (val != this._content) {
					this._content = val;
					this.dom().innerHTML = marked(val,{renderer: mdr});
				};
				return this;
			};
		});
	
	})()

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * marked - a markdown parser
	 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
	 * https://github.com/chjj/marked
	 */
	
	;(function() {
	
	/**
	 * Block-Level Grammar
	 */
	
	var block = {
	  newline: /^\n+/,
	  code: /^( {4}[^\n]+\n*)+/,
	  fences: noop,
	  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
	  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
	  nptable: noop,
	  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
	  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
	  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
	  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
	  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
	  table: noop,
	  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
	  text: /^[^\n]+/
	};
	
	block.bullet = /(?:[*+-]|\d+\.)/;
	block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
	block.item = replace(block.item, 'gm')
	  (/bull/g, block.bullet)
	  ();
	
	block.list = replace(block.list)
	  (/bull/g, block.bullet)
	  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
	  ('def', '\\n+(?=' + block.def.source + ')')
	  ();
	
	block.blockquote = replace(block.blockquote)
	  ('def', block.def)
	  ();
	
	block._tag = '(?!(?:'
	  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
	  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
	  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';
	
	block.html = replace(block.html)
	  ('comment', /<!--[\s\S]*?-->/)
	  ('closed', /<(tag)[\s\S]+?<\/\1>/)
	  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
	  (/tag/g, block._tag)
	  ();
	
	block.paragraph = replace(block.paragraph)
	  ('hr', block.hr)
	  ('heading', block.heading)
	  ('lheading', block.lheading)
	  ('blockquote', block.blockquote)
	  ('tag', '<' + block._tag)
	  ('def', block.def)
	  ();
	
	/**
	 * Normal Block Grammar
	 */
	
	block.normal = merge({}, block);
	
	/**
	 * GFM Block Grammar
	 */
	
	block.gfm = merge({}, block.normal, {
	  fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
	  paragraph: /^/,
	  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
	});
	
	block.gfm.paragraph = replace(block.paragraph)
	  ('(?!', '(?!'
	    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
	    + block.list.source.replace('\\1', '\\3') + '|')
	  ();
	
	/**
	 * GFM + Tables Block Grammar
	 */
	
	block.tables = merge({}, block.gfm, {
	  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
	  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
	});
	
	/**
	 * Block Lexer
	 */
	
	function Lexer(options) {
	  this.tokens = [];
	  this.tokens.links = {};
	  this.options = options || marked.defaults;
	  this.rules = block.normal;
	
	  if (this.options.gfm) {
	    if (this.options.tables) {
	      this.rules = block.tables;
	    } else {
	      this.rules = block.gfm;
	    }
	  }
	}
	
	/**
	 * Expose Block Rules
	 */
	
	Lexer.rules = block;
	
	/**
	 * Static Lex Method
	 */
	
	Lexer.lex = function(src, options) {
	  var lexer = new Lexer(options);
	  return lexer.lex(src);
	};
	
	/**
	 * Preprocessing
	 */
	
	Lexer.prototype.lex = function(src) {
	  src = src
	    .replace(/\r\n|\r/g, '\n')
	    .replace(/\t/g, '    ')
	    .replace(/\u00a0/g, ' ')
	    .replace(/\u2424/g, '\n');
	
	  return this.token(src, true);
	};
	
	/**
	 * Lexing
	 */
	
	Lexer.prototype.token = function(src, top, bq) {
	  var src = src.replace(/^ +$/gm, '')
	    , next
	    , loose
	    , cap
	    , bull
	    , b
	    , item
	    , space
	    , i
	    , l;
	
	  while (src) {
	    // newline
	    if (cap = this.rules.newline.exec(src)) {
	      src = src.substring(cap[0].length);
	      if (cap[0].length > 1) {
	        this.tokens.push({
	          type: 'space'
	        });
	      }
	    }
	
	    // code
	    if (cap = this.rules.code.exec(src)) {
	      src = src.substring(cap[0].length);
	      cap = cap[0].replace(/^ {4}/gm, '');
	      this.tokens.push({
	        type: 'code',
	        text: !this.options.pedantic
	          ? cap.replace(/\n+$/, '')
	          : cap
	      });
	      continue;
	    }
	
	    // fences (gfm)
	    if (cap = this.rules.fences.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'code',
	        lang: cap[2],
	        text: cap[3] || ''
	      });
	      continue;
	    }
	
	    // heading
	    if (cap = this.rules.heading.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'heading',
	        depth: cap[1].length,
	        text: cap[2]
	      });
	      continue;
	    }
	
	    // table no leading pipe (gfm)
	    if (top && (cap = this.rules.nptable.exec(src))) {
	      src = src.substring(cap[0].length);
	
	      item = {
	        type: 'table',
	        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
	        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	        cells: cap[3].replace(/\n$/, '').split('\n')
	      };
	
	      for (i = 0; i < item.align.length; i++) {
	        if (/^ *-+: *$/.test(item.align[i])) {
	          item.align[i] = 'right';
	        } else if (/^ *:-+: *$/.test(item.align[i])) {
	          item.align[i] = 'center';
	        } else if (/^ *:-+ *$/.test(item.align[i])) {
	          item.align[i] = 'left';
	        } else {
	          item.align[i] = null;
	        }
	      }
	
	      for (i = 0; i < item.cells.length; i++) {
	        item.cells[i] = item.cells[i].split(/ *\| */);
	      }
	
	      this.tokens.push(item);
	
	      continue;
	    }
	
	    // lheading
	    if (cap = this.rules.lheading.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'heading',
	        depth: cap[2] === '=' ? 1 : 2,
	        text: cap[1]
	      });
	      continue;
	    }
	
	    // hr
	    if (cap = this.rules.hr.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'hr'
	      });
	      continue;
	    }
	
	    // blockquote
	    if (cap = this.rules.blockquote.exec(src)) {
	      src = src.substring(cap[0].length);
	
	      this.tokens.push({
	        type: 'blockquote_start'
	      });
	
	      cap = cap[0].replace(/^ *> ?/gm, '');
	
	      // Pass `top` to keep the current
	      // "toplevel" state. This is exactly
	      // how markdown.pl works.
	      this.token(cap, top, true);
	
	      this.tokens.push({
	        type: 'blockquote_end'
	      });
	
	      continue;
	    }
	
	    // list
	    if (cap = this.rules.list.exec(src)) {
	      src = src.substring(cap[0].length);
	      bull = cap[2];
	
	      this.tokens.push({
	        type: 'list_start',
	        ordered: bull.length > 1
	      });
	
	      // Get each top-level item.
	      cap = cap[0].match(this.rules.item);
	
	      next = false;
	      l = cap.length;
	      i = 0;
	
	      for (; i < l; i++) {
	        item = cap[i];
	
	        // Remove the list item's bullet
	        // so it is seen as the next token.
	        space = item.length;
	        item = item.replace(/^ *([*+-]|\d+\.) +/, '');
	
	        // Outdent whatever the
	        // list item contains. Hacky.
	        if (~item.indexOf('\n ')) {
	          space -= item.length;
	          item = !this.options.pedantic
	            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
	            : item.replace(/^ {1,4}/gm, '');
	        }
	
	        // Determine whether the next list item belongs here.
	        // Backpedal if it does not belong in this list.
	        if (this.options.smartLists && i !== l - 1) {
	          b = block.bullet.exec(cap[i + 1])[0];
	          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
	            src = cap.slice(i + 1).join('\n') + src;
	            i = l - 1;
	          }
	        }
	
	        // Determine whether item is loose or not.
	        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
	        // for discount behavior.
	        loose = next || /\n\n(?!\s*$)/.test(item);
	        if (i !== l - 1) {
	          next = item.charAt(item.length - 1) === '\n';
	          if (!loose) loose = next;
	        }
	
	        this.tokens.push({
	          type: loose
	            ? 'loose_item_start'
	            : 'list_item_start'
	        });
	
	        // Recurse.
	        this.token(item, false, bq);
	
	        this.tokens.push({
	          type: 'list_item_end'
	        });
	      }
	
	      this.tokens.push({
	        type: 'list_end'
	      });
	
	      continue;
	    }
	
	    // html
	    if (cap = this.rules.html.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: this.options.sanitize
	          ? 'paragraph'
	          : 'html',
	        pre: !this.options.sanitizer
	          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
	        text: cap[0]
	      });
	      continue;
	    }
	
	    // def
	    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
	      src = src.substring(cap[0].length);
	      this.tokens.links[cap[1].toLowerCase()] = {
	        href: cap[2],
	        title: cap[3]
	      };
	      continue;
	    }
	
	    // table (gfm)
	    if (top && (cap = this.rules.table.exec(src))) {
	      src = src.substring(cap[0].length);
	
	      item = {
	        type: 'table',
	        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
	        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
	      };
	
	      for (i = 0; i < item.align.length; i++) {
	        if (/^ *-+: *$/.test(item.align[i])) {
	          item.align[i] = 'right';
	        } else if (/^ *:-+: *$/.test(item.align[i])) {
	          item.align[i] = 'center';
	        } else if (/^ *:-+ *$/.test(item.align[i])) {
	          item.align[i] = 'left';
	        } else {
	          item.align[i] = null;
	        }
	      }
	
	      for (i = 0; i < item.cells.length; i++) {
	        item.cells[i] = item.cells[i]
	          .replace(/^ *\| *| *\| *$/g, '')
	          .split(/ *\| */);
	      }
	
	      this.tokens.push(item);
	
	      continue;
	    }
	
	    // top-level paragraph
	    if (top && (cap = this.rules.paragraph.exec(src))) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'paragraph',
	        text: cap[1].charAt(cap[1].length - 1) === '\n'
	          ? cap[1].slice(0, -1)
	          : cap[1]
	      });
	      continue;
	    }
	
	    // text
	    if (cap = this.rules.text.exec(src)) {
	      // Top-level should never reach here.
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'text',
	        text: cap[0]
	      });
	      continue;
	    }
	
	    if (src) {
	      throw new
	        Error('Infinite loop on byte: ' + src.charCodeAt(0));
	    }
	  }
	
	  return this.tokens;
	};
	
	/**
	 * Inline-Level Grammar
	 */
	
	var inline = {
	  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
	  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
	  url: noop,
	  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
	  link: /^!?\[(inside)\]\(href\)/,
	  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
	  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
	  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
	  em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
	  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
	  br: /^ {2,}\n(?!\s*$)/,
	  del: noop,
	  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
	};
	
	inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
	inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;
	
	inline.link = replace(inline.link)
	  ('inside', inline._inside)
	  ('href', inline._href)
	  ();
	
	inline.reflink = replace(inline.reflink)
	  ('inside', inline._inside)
	  ();
	
	/**
	 * Normal Inline Grammar
	 */
	
	inline.normal = merge({}, inline);
	
	/**
	 * Pedantic Inline Grammar
	 */
	
	inline.pedantic = merge({}, inline.normal, {
	  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
	  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
	});
	
	/**
	 * GFM Inline Grammar
	 */
	
	inline.gfm = merge({}, inline.normal, {
	  escape: replace(inline.escape)('])', '~|])')(),
	  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
	  del: /^~~(?=\S)([\s\S]*?\S)~~/,
	  text: replace(inline.text)
	    (']|', '~]|')
	    ('|', '|https?://|')
	    ()
	});
	
	/**
	 * GFM + Line Breaks Inline Grammar
	 */
	
	inline.breaks = merge({}, inline.gfm, {
	  br: replace(inline.br)('{2,}', '*')(),
	  text: replace(inline.gfm.text)('{2,}', '*')()
	});
	
	/**
	 * Inline Lexer & Compiler
	 */
	
	function InlineLexer(links, options) {
	  this.options = options || marked.defaults;
	  this.links = links;
	  this.rules = inline.normal;
	  this.renderer = this.options.renderer || new Renderer;
	  this.renderer.options = this.options;
	
	  if (!this.links) {
	    throw new
	      Error('Tokens array requires a `links` property.');
	  }
	
	  if (this.options.gfm) {
	    if (this.options.breaks) {
	      this.rules = inline.breaks;
	    } else {
	      this.rules = inline.gfm;
	    }
	  } else if (this.options.pedantic) {
	    this.rules = inline.pedantic;
	  }
	}
	
	/**
	 * Expose Inline Rules
	 */
	
	InlineLexer.rules = inline;
	
	/**
	 * Static Lexing/Compiling Method
	 */
	
	InlineLexer.output = function(src, links, options) {
	  var inline = new InlineLexer(links, options);
	  return inline.output(src);
	};
	
	/**
	 * Lexing/Compiling
	 */
	
	InlineLexer.prototype.output = function(src) {
	  var out = ''
	    , link
	    , text
	    , href
	    , cap;
	
	  while (src) {
	    // escape
	    if (cap = this.rules.escape.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += cap[1];
	      continue;
	    }
	
	    // autolink
	    if (cap = this.rules.autolink.exec(src)) {
	      src = src.substring(cap[0].length);
	      if (cap[2] === '@') {
	        text = cap[1].charAt(6) === ':'
	          ? this.mangle(cap[1].substring(7))
	          : this.mangle(cap[1]);
	        href = this.mangle('mailto:') + text;
	      } else {
	        text = escape(cap[1]);
	        href = text;
	      }
	      out += this.renderer.link(href, null, text);
	      continue;
	    }
	
	    // url (gfm)
	    if (!this.inLink && (cap = this.rules.url.exec(src))) {
	      src = src.substring(cap[0].length);
	      text = escape(cap[1]);
	      href = text;
	      out += this.renderer.link(href, null, text);
	      continue;
	    }
	
	    // tag
	    if (cap = this.rules.tag.exec(src)) {
	      if (!this.inLink && /^<a /i.test(cap[0])) {
	        this.inLink = true;
	      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
	        this.inLink = false;
	      }
	      src = src.substring(cap[0].length);
	      out += this.options.sanitize
	        ? this.options.sanitizer
	          ? this.options.sanitizer(cap[0])
	          : escape(cap[0])
	        : cap[0]
	      continue;
	    }
	
	    // link
	    if (cap = this.rules.link.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.inLink = true;
	      out += this.outputLink(cap, {
	        href: cap[2],
	        title: cap[3]
	      });
	      this.inLink = false;
	      continue;
	    }
	
	    // reflink, nolink
	    if ((cap = this.rules.reflink.exec(src))
	        || (cap = this.rules.nolink.exec(src))) {
	      src = src.substring(cap[0].length);
	      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
	      link = this.links[link.toLowerCase()];
	      if (!link || !link.href) {
	        out += cap[0].charAt(0);
	        src = cap[0].substring(1) + src;
	        continue;
	      }
	      this.inLink = true;
	      out += this.outputLink(cap, link);
	      this.inLink = false;
	      continue;
	    }
	
	    // strong
	    if (cap = this.rules.strong.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.strong(this.output(cap[2] || cap[1]));
	      continue;
	    }
	
	    // em
	    if (cap = this.rules.em.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.em(this.output(cap[2] || cap[1]));
	      continue;
	    }
	
	    // code
	    if (cap = this.rules.code.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.codespan(escape(cap[2], true));
	      continue;
	    }
	
	    // br
	    if (cap = this.rules.br.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.br();
	      continue;
	    }
	
	    // del (gfm)
	    if (cap = this.rules.del.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.del(this.output(cap[1]));
	      continue;
	    }
	
	    // text
	    if (cap = this.rules.text.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.text(escape(this.smartypants(cap[0])));
	      continue;
	    }
	
	    if (src) {
	      throw new
	        Error('Infinite loop on byte: ' + src.charCodeAt(0));
	    }
	  }
	
	  return out;
	};
	
	/**
	 * Compile Link
	 */
	
	InlineLexer.prototype.outputLink = function(cap, link) {
	  var href = escape(link.href)
	    , title = link.title ? escape(link.title) : null;
	
	  return cap[0].charAt(0) !== '!'
	    ? this.renderer.link(href, title, this.output(cap[1]))
	    : this.renderer.image(href, title, escape(cap[1]));
	};
	
	/**
	 * Smartypants Transformations
	 */
	
	InlineLexer.prototype.smartypants = function(text) {
	  if (!this.options.smartypants) return text;
	  return text
	    // em-dashes
	    .replace(/---/g, '\u2014')
	    // en-dashes
	    .replace(/--/g, '\u2013')
	    // opening singles
	    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
	    // closing singles & apostrophes
	    .replace(/'/g, '\u2019')
	    // opening doubles
	    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
	    // closing doubles
	    .replace(/"/g, '\u201d')
	    // ellipses
	    .replace(/\.{3}/g, '\u2026');
	};
	
	/**
	 * Mangle Links
	 */
	
	InlineLexer.prototype.mangle = function(text) {
	  if (!this.options.mangle) return text;
	  var out = ''
	    , l = text.length
	    , i = 0
	    , ch;
	
	  for (; i < l; i++) {
	    ch = text.charCodeAt(i);
	    if (Math.random() > 0.5) {
	      ch = 'x' + ch.toString(16);
	    }
	    out += '&#' + ch + ';';
	  }
	
	  return out;
	};
	
	/**
	 * Renderer
	 */
	
	function Renderer(options) {
	  this.options = options || {};
	}
	
	Renderer.prototype.code = function(code, lang, escaped) {
	  if (this.options.highlight) {
	    var out = this.options.highlight(code, lang);
	    if (out != null && out !== code) {
	      escaped = true;
	      code = out;
	    }
	  }
	
	  if (!lang) {
	    return '<pre><code>'
	      + (escaped ? code : escape(code, true))
	      + '\n</code></pre>';
	  }
	
	  return '<pre><code class="'
	    + this.options.langPrefix
	    + escape(lang, true)
	    + '">'
	    + (escaped ? code : escape(code, true))
	    + '\n</code></pre>\n';
	};
	
	Renderer.prototype.blockquote = function(quote) {
	  return '<blockquote>\n' + quote + '</blockquote>\n';
	};
	
	Renderer.prototype.html = function(html) {
	  return html;
	};
	
	Renderer.prototype.heading = function(text, level, raw) {
	  return '<h'
	    + level
	    + ' id="'
	    + this.options.headerPrefix
	    + raw.toLowerCase().replace(/[^\w]+/g, '-')
	    + '">'
	    + text
	    + '</h'
	    + level
	    + '>\n';
	};
	
	Renderer.prototype.hr = function() {
	  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
	};
	
	Renderer.prototype.list = function(body, ordered) {
	  var type = ordered ? 'ol' : 'ul';
	  return '<' + type + '>\n' + body + '</' + type + '>\n';
	};
	
	Renderer.prototype.listitem = function(text) {
	  return '<li>' + text + '</li>\n';
	};
	
	Renderer.prototype.paragraph = function(text) {
	  return '<p>' + text + '</p>\n';
	};
	
	Renderer.prototype.table = function(header, body) {
	  return '<table>\n'
	    + '<thead>\n'
	    + header
	    + '</thead>\n'
	    + '<tbody>\n'
	    + body
	    + '</tbody>\n'
	    + '</table>\n';
	};
	
	Renderer.prototype.tablerow = function(content) {
	  return '<tr>\n' + content + '</tr>\n';
	};
	
	Renderer.prototype.tablecell = function(content, flags) {
	  var type = flags.header ? 'th' : 'td';
	  var tag = flags.align
	    ? '<' + type + ' style="text-align:' + flags.align + '">'
	    : '<' + type + '>';
	  return tag + content + '</' + type + '>\n';
	};
	
	// span level renderer
	Renderer.prototype.strong = function(text) {
	  return '<strong>' + text + '</strong>';
	};
	
	Renderer.prototype.em = function(text) {
	  return '<em>' + text + '</em>';
	};
	
	Renderer.prototype.codespan = function(text) {
	  return '<code>' + text + '</code>';
	};
	
	Renderer.prototype.br = function() {
	  return this.options.xhtml ? '<br/>' : '<br>';
	};
	
	Renderer.prototype.del = function(text) {
	  return '<del>' + text + '</del>';
	};
	
	Renderer.prototype.link = function(href, title, text) {
	  if (this.options.sanitize) {
	    try {
	      var prot = decodeURIComponent(unescape(href))
	        .replace(/[^\w:]/g, '')
	        .toLowerCase();
	    } catch (e) {
	      return '';
	    }
	    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
	      return '';
	    }
	  }
	  var out = '<a href="' + href + '"';
	  if (title) {
	    out += ' title="' + title + '"';
	  }
	  out += '>' + text + '</a>';
	  return out;
	};
	
	Renderer.prototype.image = function(href, title, text) {
	  var out = '<img src="' + href + '" alt="' + text + '"';
	  if (title) {
	    out += ' title="' + title + '"';
	  }
	  out += this.options.xhtml ? '/>' : '>';
	  return out;
	};
	
	Renderer.prototype.text = function(text) {
	  return text;
	};
	
	/**
	 * Parsing & Compiling
	 */
	
	function Parser(options) {
	  this.tokens = [];
	  this.token = null;
	  this.options = options || marked.defaults;
	  this.options.renderer = this.options.renderer || new Renderer;
	  this.renderer = this.options.renderer;
	  this.renderer.options = this.options;
	}
	
	/**
	 * Static Parse Method
	 */
	
	Parser.parse = function(src, options, renderer) {
	  var parser = new Parser(options, renderer);
	  return parser.parse(src);
	};
	
	/**
	 * Parse Loop
	 */
	
	Parser.prototype.parse = function(src) {
	  this.inline = new InlineLexer(src.links, this.options, this.renderer);
	  this.tokens = src.reverse();
	
	  var out = '';
	  while (this.next()) {
	    out += this.tok();
	  }
	
	  return out;
	};
	
	/**
	 * Next Token
	 */
	
	Parser.prototype.next = function() {
	  return this.token = this.tokens.pop();
	};
	
	/**
	 * Preview Next Token
	 */
	
	Parser.prototype.peek = function() {
	  return this.tokens[this.tokens.length - 1] || 0;
	};
	
	/**
	 * Parse Text Tokens
	 */
	
	Parser.prototype.parseText = function() {
	  var body = this.token.text;
	
	  while (this.peek().type === 'text') {
	    body += '\n' + this.next().text;
	  }
	
	  return this.inline.output(body);
	};
	
	/**
	 * Parse Current Token
	 */
	
	Parser.prototype.tok = function() {
	  switch (this.token.type) {
	    case 'space': {
	      return '';
	    }
	    case 'hr': {
	      return this.renderer.hr();
	    }
	    case 'heading': {
	      return this.renderer.heading(
	        this.inline.output(this.token.text),
	        this.token.depth,
	        this.token.text);
	    }
	    case 'code': {
	      return this.renderer.code(this.token.text,
	        this.token.lang,
	        this.token.escaped);
	    }
	    case 'table': {
	      var header = ''
	        , body = ''
	        , i
	        , row
	        , cell
	        , flags
	        , j;
	
	      // header
	      cell = '';
	      for (i = 0; i < this.token.header.length; i++) {
	        flags = { header: true, align: this.token.align[i] };
	        cell += this.renderer.tablecell(
	          this.inline.output(this.token.header[i]),
	          { header: true, align: this.token.align[i] }
	        );
	      }
	      header += this.renderer.tablerow(cell);
	
	      for (i = 0; i < this.token.cells.length; i++) {
	        row = this.token.cells[i];
	
	        cell = '';
	        for (j = 0; j < row.length; j++) {
	          cell += this.renderer.tablecell(
	            this.inline.output(row[j]),
	            { header: false, align: this.token.align[j] }
	          );
	        }
	
	        body += this.renderer.tablerow(cell);
	      }
	      return this.renderer.table(header, body);
	    }
	    case 'blockquote_start': {
	      var body = '';
	
	      while (this.next().type !== 'blockquote_end') {
	        body += this.tok();
	      }
	
	      return this.renderer.blockquote(body);
	    }
	    case 'list_start': {
	      var body = ''
	        , ordered = this.token.ordered;
	
	      while (this.next().type !== 'list_end') {
	        body += this.tok();
	      }
	
	      return this.renderer.list(body, ordered);
	    }
	    case 'list_item_start': {
	      var body = '';
	
	      while (this.next().type !== 'list_item_end') {
	        body += this.token.type === 'text'
	          ? this.parseText()
	          : this.tok();
	      }
	
	      return this.renderer.listitem(body);
	    }
	    case 'loose_item_start': {
	      var body = '';
	
	      while (this.next().type !== 'list_item_end') {
	        body += this.tok();
	      }
	
	      return this.renderer.listitem(body);
	    }
	    case 'html': {
	      var html = !this.token.pre && !this.options.pedantic
	        ? this.inline.output(this.token.text)
	        : this.token.text;
	      return this.renderer.html(html);
	    }
	    case 'paragraph': {
	      return this.renderer.paragraph(this.inline.output(this.token.text));
	    }
	    case 'text': {
	      return this.renderer.paragraph(this.parseText());
	    }
	  }
	};
	
	/**
	 * Helpers
	 */
	
	function escape(html, encode) {
	  return html
	    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	    .replace(/"/g, '&quot;')
	    .replace(/'/g, '&#39;');
	}
	
	function unescape(html) {
	  return html.replace(/&([#\w]+);/g, function(_, n) {
	    n = n.toLowerCase();
	    if (n === 'colon') return ':';
	    if (n.charAt(0) === '#') {
	      return n.charAt(1) === 'x'
	        ? String.fromCharCode(parseInt(n.substring(2), 16))
	        : String.fromCharCode(+n.substring(1));
	    }
	    return '';
	  });
	}
	
	function replace(regex, opt) {
	  regex = regex.source;
	  opt = opt || '';
	  return function self(name, val) {
	    if (!name) return new RegExp(regex, opt);
	    val = val.source || val;
	    val = val.replace(/(^|[^\[])\^/g, '$1');
	    regex = regex.replace(name, val);
	    return self;
	  };
	}
	
	function noop() {}
	noop.exec = noop;
	
	function merge(obj) {
	  var i = 1
	    , target
	    , key;
	
	  for (; i < arguments.length; i++) {
	    target = arguments[i];
	    for (key in target) {
	      if (Object.prototype.hasOwnProperty.call(target, key)) {
	        obj[key] = target[key];
	      }
	    }
	  }
	
	  return obj;
	}
	
	
	/**
	 * Marked
	 */
	
	function marked(src, opt, callback) {
	  if (callback || typeof opt === 'function') {
	    if (!callback) {
	      callback = opt;
	      opt = null;
	    }
	
	    opt = merge({}, marked.defaults, opt || {});
	
	    var highlight = opt.highlight
	      , tokens
	      , pending
	      , i = 0;
	
	    try {
	      tokens = Lexer.lex(src, opt)
	    } catch (e) {
	      return callback(e);
	    }
	
	    pending = tokens.length;
	
	    var done = function(err) {
	      if (err) {
	        opt.highlight = highlight;
	        return callback(err);
	      }
	
	      var out;
	
	      try {
	        out = Parser.parse(tokens, opt);
	      } catch (e) {
	        err = e;
	      }
	
	      opt.highlight = highlight;
	
	      return err
	        ? callback(err)
	        : callback(null, out);
	    };
	
	    if (!highlight || highlight.length < 3) {
	      return done();
	    }
	
	    delete opt.highlight;
	
	    if (!pending) return done();
	
	    for (; i < tokens.length; i++) {
	      (function(token) {
	        if (token.type !== 'code') {
	          return --pending || done();
	        }
	        return highlight(token.text, token.lang, function(err, code) {
	          if (err) return done(err);
	          if (code == null || code === token.text) {
	            return --pending || done();
	          }
	          token.text = code;
	          token.escaped = true;
	          --pending || done();
	        });
	      })(tokens[i]);
	    }
	
	    return;
	  }
	  try {
	    if (opt) opt = merge({}, marked.defaults, opt);
	    return Parser.parse(Lexer.lex(src, opt), opt);
	  } catch (e) {
	    e.message += '\nPlease report this to https://github.com/chjj/marked.';
	    if ((opt || marked.defaults).silent) {
	      return '<p>An error occured:</p><pre>'
	        + escape(e.message + '', true)
	        + '</pre>';
	    }
	    throw e;
	  }
	}
	
	/**
	 * Options
	 */
	
	marked.options =
	marked.setOptions = function(opt) {
	  merge(marked.defaults, opt);
	  return marked;
	};
	
	marked.defaults = {
	  gfm: true,
	  tables: true,
	  breaks: false,
	  pedantic: false,
	  sanitize: false,
	  sanitizer: null,
	  mangle: true,
	  smartLists: false,
	  silent: false,
	  highlight: null,
	  langPrefix: 'lang-',
	  smartypants: false,
	  headerPrefix: '',
	  renderer: new Renderer,
	  xhtml: false
	};
	
	/**
	 * Expose
	 */
	
	marked.Parser = Parser;
	marked.parser = Parser.parse;
	
	marked.Renderer = Renderer;
	
	marked.Lexer = Lexer;
	marked.lexer = Lexer.lex;
	
	marked.InlineLexer = InlineLexer;
	marked.inlineLexer = InlineLexer.output;
	
	marked.parse = marked;
	
	if (true) {
	  module.exports = marked;
	} else if (typeof define === 'function' && define.amd) {
	  define(function() { return marked; });
	} else {
	  this.marked = marked;
	}
	
	}).call(function() {
	  return this || ( true ? window : global);
	}());


/***/ },
/* 63 */
/***/ function(module, exports) {

	(function(){
		tag$.defineTag('site', 'html', function(tag){
			
			
			
			tag.prototype.deps = function(v){ return this._deps; }
			tag.prototype.setDeps = function(v){ this._deps = v; return this; };
			
			tag.prototype.head = function (){
				return tag$.$head().setContent([
					tag$.$title().setText("imba").end(),
					tag$.$meta().setCharset("utf-8").end(),
					tag$.$meta().setName("viewport").setContent("width=device-width, initial-scale=1, maximum-scale=1,minimum-scale=1").end(),
					tag$.$meta().setName("Description").setContent("Imba is a rich programming language for the web.").end(),
					tag$.$meta().setName("keywords").setContent("imba javascript language js").end(),
					tag$.$link().setHref('http://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600').setRel('stylesheet').setType('text/css').end(),
					tag$.$link().setRel("stylesheet").setHref("/css/site.css").setMedia("screen").end(),
					tag$.$script().setText('DEPS = {};').end(),
					tag$.$script().setSrc("/vendor/ga.js").end()
				],2).end();
			};
			
			tag.prototype.body = function (){
				return tag$.$body().setId('site').setContent([
					tag$.$site_nav().setId('header').flag('awaken').end(),
					tag$.$home().setRoute('/home').end(),
					tag$.$guides().setRoute('/guides').end(),
					tag$.$docs().setRoute('/docs').end(),
					tag$.$blog().setRoute('/blog').end()
				],2).end();
			};
			
			tag.prototype.scripts = function (){
				var self = this, t0;
				return tag$.$div().flag('scripts').setContent([
					(function(t0) {
						for (var o = self.deps(), i = 0, keys = Object.keys(o), l = keys.length, res = []; i < l; i++){
							res.push(tag$.$script().setType("text/javascript").setSrc((keys[i] + '.dep')).end());
						};
						return res;
					})(t0),
					tag$.$script().setSrc("/vendor/hl.js").end(),
					tag$.$script().setSrc("/client.js").end()
				],0).end();
			};
			
			tag.prototype.render = function (){
				// dirty workarounds
				APP.setSite(this);
				this.setDeps({});
				APP.fetchDocument('/guides.md');
				var body = this.body();
				body.append(this.scripts());
				
				this.flag('light').setChildren([
					this.head(),
					body
				],1).synced();
				APP.setSite(null);
				return this;
			};
		});
		
		
		return tag$.defineTag('site-nav', function(tag){
			
			tag.prototype.toggleMenu = function (){
				return q$$('body').toggleFlag('menu');
			};
			
			tag.prototype.render = function (){
				var t0, t1, t2, t3, t4, t5, t6, t7;
				return this.setChildren(
					(t0 = this.$a=this.$a || tag$.$nav().flag('content')).setContent([
						(t1 = t0.$$a=t0.$$a || tag$.$a().flag('menu').setHandler('tap','toggleMenu',this)).setContent((t1.$$a = t1.$$a || tag$.$b()).end(),2).end(),
						(t2 = t0.$$b=t0.$$b || tag$.$a().flag('tab').flag('logo').setHref('/home')).setContent((t2.$$a = t2.$$a || tag$.$i()).setText('imba').end(),2).end(),
						(t0.$$c = t0.$$c || tag$.$span().flag('greedy')).end(),
						(t3 = t0.$$d=t0.$$d || tag$.$a().flag('tab').flag('home').setHref('/home')).setContent((t3.$$a = t3.$$a || tag$.$i()).setText('home').end(),2).end(),
						(t4 = t0.$$e=t0.$$e || tag$.$a().flag('tab').flag('guides').setHref('/guides')).setContent((t4.$$a = t4.$$a || tag$.$i()).setText('guides').end(),2).end(),
						(t5 = t0.$$f=t0.$$f || tag$.$a().flag('tab').flag('docs').setHref('/docs')).setContent((t5.$$a = t5.$$a || tag$.$i()).setText('docs').end(),2).end(),
						(t6 = t0.$$g=t0.$$g || tag$.$a().flag('tab').flag('blog').setHref('/blog')).setContent((t6.$$a = t6.$$a || tag$.$i()).setText('blog').end(),2).end(),
						
						(t7 = t0.$$h=t0.$$h || tag$.$a().flag('github').setHref('https://github.com/somebee/imba')).setContent((t7.$$a = t7.$$a || tag$.$i()).setText('github').end(),2).end()
					],2).end()
				,2).synced();
			};
			
			tag.prototype.awaken = function (){
				return this.schedule({fps: 0});
			};
		});
	
	})()

/***/ },
/* 64 */
/***/ function(module, exports) {

	(function(){
		
		
		tag$.defineTag('navmenu', function(tag){
			
			tag.prototype.onroute = function (e){
				document.body.classList.remove('menu');
				return this;
			};
		});
		
		tag$.defineTag('nav-list');
		
		tag$.defineTag('nav-link', function(tag){
			
			
			
			tag.prototype.href = function(v){ return this.getAttribute('href'); }
			tag.prototype.setHref = function(v){ this.setAttribute('href',v); return this; };
			
			tag.prototype.render = function (){
				var t0;
				return this.setChildren((t0 = this.$a=this.$a || tag$.$a()).setHref(this.href()).setContent(this._content,3).end(),2).synced();
			};
		});
		
		return tag$.defineTag('toc', function(tag){
			
			tag.prototype.toggle = function (){
				return this.toggleFlag('collapsed');
			};
		});
	
	})()

/***/ },
/* 65 */
/***/ function(module, exports) {

	(function(){
		
		return tag$.defineTag('page', function(tag){
			tag.prototype.body = function (){
				return (this._body = this._body || tag$.$div().setRef('body',this)).setText("Content here").end();
			};
			
			tag.prototype.nav = function (){
				return (this._nav = this._nav || tag$.$div().setRef('nav',this)).setText("Navigation here").end();
			};
			
			tag.prototype.assemble = function (){
				return this.setChildren([
					this.nav(),
					this.body()
				],1).synced();
			};
			
			tag.prototype.ready = function (){
				return true;
			};
			
			tag.prototype.render = function (){
				// log 'render page',route
				var scoped = this.router().scoped(this.route(),this);
				this.flag('scoped',scoped);
				this.flag('selected',this.router().match(this.route(),this));
				
				if (!(scoped && this.ready())) { return this };
				return this.assemble();
			};
			
			tag.prototype.awaken = function (){
				return this.schedule({fps: 1});
			};
		});
	
	})()

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		function shuffle(array){
			var counter = array.length,temp,index;
			
			// While there are elements in the array
			while (counter > 0){
				// Pick a random index
				index = Math.floor(Math.random() * counter);
				counter--; // Decrease counter by 1
				
				// And swap the last element with it
				temp = array[counter];
				array[counter] = array[index];
				array[index] = temp;
			};
			
			return array;
		};
		
		tag$.defineTag('pattern', function(tag){
			
			tag.prototype.build = function (){
				if (false) { return this };
				
				var parts = {tags: [],keywords: [],methods: []};
				var items = [];
				var lines = [];
				
				for (var o = Imba.Tag.prototype, i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
					k = keys[i];items.push(("<em>" + k + "</em>"));
					parts.methods.push(("<em>" + k + "</em>"));
				};
				
				for (var i = 0, ary = iter$(HTML_TAGS), len_ = ary.length, k1; i < len_; i++) {
					// for own k,v of Imba.TAGS
					// if v and v:prototype isa Imba.Tag
					k1 = ary[i];
					items.push(("<u>&lt;" + k1 + "&gt;</u>"));
					parts.tags.push(("<u>&lt;" + k1 + "&gt;</u>"));
				};
				
				var words = "def if else elif while until for in of var let class extend export import tag global";
				
				for (var i = 0, ary = iter$(words.split(" ")), len_ = ary.length, k2; i < len_; i++) {
					k2 = ary[i];
					items.push(("<i>" + k2 + "</i>"));
					parts.keywords.push(("<i>" + k2 + "</i>"));
				};
				
				var shuffled = shuffle(items);
				var all = [].concat(shuffled);
				var count = items.length - 1;
				
				for (var len = 12, ln = 0; ln <= len; ln++) {
					var chars = 0;
					lines[ln] = [];
					while (chars < 300){
						var item = (shuffled.pop() || all[Math.floor(count * Math.random())]);
						if (item) {
							chars += item.length;
							lines[ln].push(item);
						} else {
							chars = 400;
						};
					};
				};
				
				this.dom().innerHTML = '<div>' + lines.map(function(ln) {
					return '<div class="line">' + ln.join(" ") + '</div>';
				}).join('') + '</div>';
				return this;
			};
			
			tag.prototype.awaken = function (){
				this.log('awakening pattern!!');
				return this;
				
				for (var i = 0, ary = iter$(q$('.line',this)), len = ary.length; i < len; i++) {
					var z = 20 + i * 10;
					// z = parseInt(-z + Math.random * z * 2)
					ary[i].css('transform',("translateZ(" + z + "px)"));
				};
				return this;
			};
		});
		
		return tag$.defineTag('home', 'page', function(tag){
			
			var todos = {demo: true,autorun: true};
			var clock = {demo: true,autorun: true};
			var reminders = {demo: true,autorun: true};
			var hero = {autorun: true};
			var canvas = {demo: true,autorun: true};
			
			tag.prototype.awaken = function (){
				var snippets = document.querySelectorAll('code[data-src]');
				for (var i = 0, ary = iter$(snippets), len = ary.length, snippet; i < len; i++) {
					snippet = ary[i];
					var src = snippet.getAttribute('data-src');
					// console.log 'fetching snippet for ',src
					DEPS[src] = {html: snippet.innerHTML};
				};
				
				return tag.__super__.awaken.apply(this,arguments);
			};
			
			tag.prototype.nav = function (){
				return null;
			};
			
			tag.prototype.body = function (){
				var t0, t1, t2, t3, t4;
				return (t0 = this._body=this._body || tag$.$div().setRef('body',this)).setContent([
					(t1 = t0.$$a=t0.$$a || tag$.$div().setId('hero').flag('dark')).setContent([
						(this._pattern = this._pattern || tag$.$pattern().setRef('pattern',this).flag('awaken')).end(),
						(t1.$$b = t1.$$b || tag$.$example().flag('hero').flag('dark').setSrc('/home/examples/hero.imba')).end()
					],2).end(),
					
					(t2 = this._content=this._content || tag$.$div().setRef('content',this)).setContent([
						(t2.$$a = t2.$$a || tag$.$marked().flag('section').flag('md').flag('welcome').flag('huge').flag('light')).setText("# Ruby, Python and React got together. Nine months later, Imba was born.\n\nImba is a new programming language for the web that compiles to highly \nperformant and readable JavaScript. It has language level support for defining, \nextending, subclassing, instantiating and rendering dom nodes. For a semi-complex \napplication like TodoMVC, it is more than \n[10 times faster than React](http://somebee.github.io/todomvc-render-benchmark/index.html) \nwith less code, and a much smaller library.\n\n---\n\n- ## Imba.inspiration\n  Imba brings the best from Ruby, Python, and React (+ JSX) together in a clean language and runtime.\n\n- ## Imba.interoperability\n  Imba compiles down to clean and readable JavaScript. Use any JS library in Imba and vica-versa.\n\n- ## Imba.performance\n  Build your application views using Imba's native tags for unprecedented performance.\n").end(),
						
						(t2.$$b = t2.$$b || tag$.$example().flag('dark').setHeading("Simple reminders").setSrc('/home/examples/reminders.imba')).end(),
						
						(t2.$$c = t2.$$c || tag$.$marked().flag('section').flag('md')).setText("## Reusable components\n\nA custom tag / component can maintain internal state and control how to render itself.\nWith the performance of DOM reconciliation in Imba, you can use one-way declarative binding,\neven for animations. Write all your views in a straight-forward linear fashion as if you could\nrerender your whole application on **every single** data/state change.").end(),
						
						(t2.$$d = t2.$$d || tag$.$example().flag('dark').setHeading("World clock").setSrc('/home/examples/clock.imba')).end(),
						
						(t2.$$e = t2.$$e || tag$.$marked().flag('section').flag('md')).setText("## Extend native tags\n\nIn addition to defining custom tags, you can also extend native tags, or inherit from them.\nBinding to dom events is as simple as defining methods on your tags; all events will be\nefficiently delegated and handled by Imba. Let's define a simple sketchpad...").end(),
						
						(t2.$$f = t2.$$f || tag$.$example().flag('dark').setHeading("Custom canvas").setSrc('/home/examples/canvas.imba')).end(),
						
						(t3 = t2.$$g=t2.$$g || tag$.$footer()).setContent(
							(t4 = t3.$$a=t3.$$a || tag$.$nav()).setContent([
								(t4.$$a = t4.$$a || tag$.$a().flag('button').flag('huge').flag('main').setHref('/install')).setText("Install").end(),
								(t4.$$b = t4.$$b || tag$.$a().flag('button').flag('huge').setHref('/guides')).setText("Learn more").end()
							],2).end()
						,2).end()
					],2).end()
				],2).end();
			};
			
			// def awaken
			// 	# awaken the snippets
			// 	schedule
			// 	for el in %(snippet)
			// 		el
			// 	self
			
			// def tick
			// 	log 'home.tick'
			// 	self
			
			// def assemble
			// 	return self if Imba.isClient
			// 	super
			// 	# flag('scoped',router.scoped(route,self))
			// 	# flag('selected',router.match(route,self))
		});
	
	})()

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		__webpack_require__(65);
		
		var Doc = __webpack_require__(57).Doc;
		
		tag$.defineTag('blog', 'page', function(tag){
			
			tag.prototype.doc = function (){
				if (this.router().scoped('/blog')) {
					return Doc.get(this.router().path());
				};
			};
			
			tag.prototype.nav = function (){
				var t0, t1;
				return (t0 = this._nav=this._nav || tag$.$navmenu().setRef('nav',this)).setContent(
					(t1 = t0.$$a=t0.$$a || tag$.$div().flag('content')).setContent(
						(t1.$$a = t1.$$a || tag$.$h1()).setText("No items?").end()
					,2).end()
				,2).end();
			};
			tag.prototype.body = function (){
				var t0;
				return (t0 = this._body=this._body || tag$.$div().setRef('body',this).flag('light')).setContent([
					(this.doc()) ? (Imba.static([
						(t0.$$a = t0.$$a || tag$.$h1()).setText("Blogpost?").end(),
						(t0.$$b = t0.$$b || tag$.$blogpost()).setObject(this.doc()).end()
					],2)) : void(0),
					(t0.$$c = t0.$$c || tag$.$h4()).setText("No posts").end()
				],1).end();
			};
		});
		
		return tag$.defineTag('blogpost', function(tag){
			
			tag.prototype.render = function (){
				var object_;
				if (!(object_ = this.object()) && object_.ready  &&  object_.ready()) { return this };
				return this.flag('md').setBody((this.object().body())).synced();
			};
			
			tag.prototype.setBody = function (body){
				if (body != this._body) {
					this._body = body;
					this.dom().innerHTML = body;
					if (Imba.isClient()) this.reawaken();
				};
				return this;
			};
			
			tag.prototype.reawaken = function (){
				for (var i = 0, ary = iter$(q$('._snippet',this)), len = ary.length; i < len; i++) {
					ary[i];
				};
				return this;
			};
		});
	
	})()

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		__webpack_require__(65);
		
		function Guide(path){
			this._path = path;
			this._ready = false;
			this.fetch();
			this;
		};
		
		var cache = {};
		
		Guide.get = function (path){
			var $1;
			var cache = APP.cache();
			return cache[($1 = 'guide-' + path)] || (cache[$1] = new this(path));
		};
		
		
		
		Guide.prototype.path = function(v){ return this._path; }
		Guide.prototype.setPath = function(v){ this._path = v; return this; };
		
		Guide.prototype.ready = function (){
			return this._ready;
		};
		
		Guide.prototype.fetch = function (){
			var self = this;
			if (false) {
				// console.log 'fetch Guide on server',path
				return APP.fetchDocument(self._path + '.md',function(res) {
					// console.log 'fetch Guide on server done',path
					return self.load(res);
				});
			};
			
			return self._promise || (self._promise = APP.fetchDocument(self._path + '.md',function(res) {
				return self.load(res);
			}));
		};
		
		Guide.prototype.load = function (doc){
			this._object = doc;
			this._meta = doc.meta || {};
			this._ready = true;
			Imba.emit(this,'ready');
			return this;
		};
		
		Guide.prototype.title = function (){
			return this._object.title || 'path';
		};
		
		Guide.prototype.toc = function (){
			return this._object && this._object.toc[0];
		};
		
		Guide.prototype.body = function (){
			return this._object && this._object.body;
		};
		
		
		tag$.defineTag('guide-toc', 'toc', function(tag){
			
			
			
			tag.prototype.toc = function(v){ return this._toc; }
			tag.prototype.setToc = function(v){ this._toc = v; return this; };
			
			
			tag.prototype.level = function(v){ return this.getAttribute('level'); }
			tag.prototype.setLevel = function(v){ this.setAttribute('level',v); return this; };
			
			
			tag.prototype.route = function(v){ return this.getAttribute('route'); }
			tag.prototype.setRoute = function(v){ this.setAttribute('route',v); return this; };
			
			tag.prototype.toc = function (){
				return this._toc || this.object().toc();
			};
			
			tag.prototype.route = function (){
				return ("" + (this.object().path()) + "#" + (this.toc().slug));
			};
			
			tag.prototype.toggle = function (){
				return this.toggleFlag('collapsed');
			};
			
			tag.prototype.render = function (){
				var t0, t1, self = this, t2, t3;
				if (!this.object().ready()) { return this };
				
				this.reroute();
				
				return this.flag('entry').setLevel((this.toc().level)).setChildren([
					this.toc().children.length && this.toc().level < 2 ? (Imba.static([
						(t0 = this.$a=this.$a || tag$.$div().flag('header').setHandler('tap','toggle',this)).setContent(
							(t1 = t0.$$a=t0.$$a || tag$.$a()).setHref(this.route()).setContent(this.toc().title,3).end()
						,2).end(),
						(t2 = self.$b=self.$b || tag$.$div().flag('content')).setContent(
							(function(t2) {
								for (var i = 0, ary = iter$(self.toc().children), len = ary.length, res = []; i < len; i++) {
									res.push((t2['$$a' + i] = t2['$$a' + i] || tag$.$guide_toc()).setToc(ary[i]).setObject(self.object()).end());
								};
								return res;
							})(t2)
						,3).end()
					],2)) : (
						(t3 = self.$c=self.$c || tag$.$a()).setHref(self.route()).setContent(self.toc().title,3).end()
					)
				],1).synced();
			};
		});
		
		
		tag$.defineTag('guide', function(tag){
			
			tag.prototype.render = function (){
				var object_;
				if (!(object_ = this.object()) && object_.ready  &&  object_.ready()) { return this };
				return this.flag('md').setBody((this.object().body())).synced();
			};
			
			tag.prototype.setBody = function (body){
				if (body != this._body) {
					this._body = body;
					this.dom().innerHTML = body;
					if (Imba.isClient()) this.reawaken();
				};
				return this;
			};
			
			tag.prototype.reawaken = function (){
				for (var i = 0, ary = iter$(q$('._snippet',this)), len = ary.length; i < len; i++) {
					ary[i];
				};
				return this;
			};
		});
		
		
		return tag$.defineTag('guides', 'page', function(tag){
			
			tag.prototype.nav = function (){
				var t0, t1;
				return (t0 = this._nav=this._nav || tag$.$navmenu().setRef('nav',this)).setContent(
					(t1 = t0.$$a=t0.$$a || tag$.$div().flag('content')).setContent([
						(t1.$$a = t1.$$a || tag$.$guide_toc()).setObject(Guide.get('/guides')).end(),
						(t1.$$b = t1.$$b || tag$.$guide_toc()).setObject(Guide.get('/guides/language')).end()
					// <guide-toc[Guide.get('/guides/tips')]>
					],2).end()
				,2).end();
			};
			
			tag.prototype.body = function (){
				var t0;
				return (t0 = this._body=this._body || tag$.$div().setRef('body',this).flag('light')).setContent([
					(this.guide()) ? ((t0.$$a = t0.$$a || tag$.$guide()).setObject(this.guide()).end()) : void(0)
				// <guide@doc.md.l src="{router.path}">
				],1).end();
			};
			
			tag.prototype.onroute = function (e){
				// log 'onroute guides',router.hash
				var self = this;
				e.halt();
				
				var scroll = function() {
					var el;
					if (el = self.first('#' + self.router().hash())) {
						el.dom().scrollIntoView(true);
						self._scrollFreeze = window.scrollY;
						return el;
					};
					return false;
				};
				
				if (self.router().hash()) {
					self.render();
					scroll() || setTimeout(scroll,20,function() {  });
				};
				
				
				return self;
			};
			
			tag.prototype.guide = function (){
				if (this.router().scoped('/guides')) {
					return Guide.get(this.router().path());
				};
			};
			
			
			tag.prototype.awaken = function (){
				var self = this;
				if (Imba.isClient()) {
					// @doc = %%(guide)
					self.schedule({fps: 1});
					window.addEventListener('scroll',function() {
						// console.log 'check scrolling'
						return self.scrolled();
					});
				};
				return self;
			};
			
			tag.prototype.scrolled = function (){
				if (!this.hasFlag('scoped')) { return };
				
				var items = q$('[id]',this);
				var match;
				
				// should probably cache these periodically
				var scrollTop = window.scrollY;
				var wh = window.innerHeight;
				var dh = document.body.scrollHeight;
				
				if (this._scrollFreeze >= 0) {
					var diff = Math.abs(scrollTop - this._scrollFreeze);
					if (diff < 50) { return this };
					this._scrollFreeze = -1;
				};
				
				var scrollBottom = dh - (scrollTop + wh);
				
				// console.log scrollTop,wh,dh,scrollBottom
				
				if (scrollBottom == 0) {
					match = items.last();
				} else {
					for (var i = 0, ary = iter$(items), len = ary.length, item; i < len; i++) {
						item = ary[i];
						var t = (item.dom().offsetTop + 30 + 60); // hack
						var dist = scrollTop - t;
						// console.log "{item.id} {t} {dist}"
						
						if (dist < 0) {
							match = item;break;
						};
					};
				};
				
				if (match) {
					// console.log "match is {match.id}"
					if (this._hash != match.id()) {
						this._hash = match.id();
						this.router().go('#' + this._hash,{},true);
						this.render();
					};
				};
				return this;
			};
			
			tag.prototype.tick = function (){
				this.render();
				return this;
			};
		});
	
	})()

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		function pathToAnchor(path){
			return 'api-' + path.replace(/\./g,'_').replace(/\#/g,'__');
		};
		
		tag$.defineTag('api-desc', function(tag){
			
			tag.prototype.setHtml = function (html){
				if (html != this._html) {
					this.dom().innerHTML = this._html = html;
				};
				return this;
			};
		});
		
		tag$.defineTag('api-ref', function(tag){
			
			tag.prototype.render = function (){
				return this.synced();
			};
		});
		
		tag$.defineTag('api-item');
		
		tag$.defineTag('api-path', 'span', function(tag){
			
			tag.prototype.build = function (){
				var object_;
				var items = [];
				if ((typeof (object_ = this.object())=='string'||object_ instanceof String)) {
					this.setHtml(this.object().replace(/\b([\w]+|\.|\#)\b/g,function(m,i) {
						if (i == '.' || i == '#') {
							return ("<i>" + i + "</i>");
						} else if (i[0] == i[0].toUpperCase()) {
							return ("<b class='const'>" + i + "</b>");
						} else {
							return ("<b class='id'>" + i + "</b>");
						};
					}));
				};
				return this;
			};
		});
		
		
		tag$.defineTag('api-link', function(tag){
			
			
			tag.prototype.name = function(v){ return this.getAttribute('name'); }
			tag.prototype.setName = function(v){ this.setAttribute('name',v); return this; };
			
			tag.prototype.render = function (){
				var t0;
				return this.setChildren([
					(this.$a = this.$a || tag$.$api_path().flag('value')).setObject(this.object().value).end(),
					(t0 = this.$b=this.$b || tag$.$span().flag('desc')).setContent(this.object().desc,3).end()
				],2).synced();
			};
		});
		
		tag$.defineTag('api-return', 'api-link');
		
		tag$.defineTag('api-class', 'api-item', function(tag){
			
			
			tag.prototype.__object = {watch: 'parse',name: 'object'};
			tag.prototype.object = function(v){ return this._object; }
			tag.prototype.setObject = function(v){
				var a = this.object();
				if(v != a) { this._object = v; }
				if(v != a) { this.parse && this.parse(v,a,this.__object) }
				return this;
			};
			
			tag.prototype.parse = function (){
				for (var i = 0, ary = iter$(this.object()['.']), len = ary.length, m, res = []; i < len; i++) {
					m = ary[i];
					if (!m.desc) { continue; };
					res.push(m);
				};
				this._statics = res;
				for (var i = 0, ary = iter$(this.object()['#']), len = ary.length, m1, res = []; i < len; i++) {
					m1 = ary[i];
					if (!m1.desc) { continue; };
					res.push(m1);
				};
				this._methods = res;
				this._properties = [];
				return this;
			};
			
			tag.prototype.render = function (){
				var t0, t1, t2, t3, t4, self = this, t5, t6, t7;
				return this.setChildren([
					(this.$a = this.$a || tag$.$span().flag('toc-anchor')).setId(pathToAnchor(this.object().namepath)).end(),
					(t0 = this.$b=this.$b || tag$.$div().flag('header')).setContent((t1 = t0.$$a=t0.$$a || tag$.$div().flag('title')).setContent((t1.$$a = t1.$$a || tag$.$api_path()).setObject(this.object().namepath).end(),2).end(),2).end(),
					(this.$c = this.$c || tag$.$api_desc()).setHtml(this.object().html).end(),
					(this.object().ctor) ? (
						(t2 = this.$d=this.$d || tag$.$div().flag('content').flag('ctor')).setContent(
							(t2.$$a = t2.$$a || tag$.$api_method()).setPath((this.object().namepath + '.new')).setObject(this.object().ctor).end()
						,2).end()
					) : void(0),
					
					(t3 = self.$e=self.$e || tag$.$div().flag('content')).setContent([
						(this._statics.length > 0) ? (
							(t4 = t3.$$a=t3.$$a || tag$.$div().flag('section')).setContent([
								(t4.$$a = t4.$$a || tag$.$h2().flag('header')).setText('Static Methods').end(),
								(t5 = t4.$$b=t4.$$b || tag$.$div().flag('content').flag('list')).setContent((function(t5) {
									for (var i = 0, ary = iter$(self._statics), len = ary.length, res = []; i < len; i++) {
										res.push((t5['$$a' + i] = t5['$$a' + i] || tag$.$api_method().flag('doc')).setIname(self.object().namepath).setObject(ary[i]).end());
									};
									return res;
								})(t5),3).end()
							],2).end()
						) : void(0),
						
						(self._methods.length > 0) ? (
							(t6 = t3.$$b=t3.$$b || tag$.$div().flag('section')).setContent([
								(t6.$$a = t6.$$a || tag$.$h2().flag('header')).setText('Instance Methods').end(),
								(t7 = t6.$$b=t6.$$b || tag$.$div().flag('content').flag('list')).setContent((function(t7) {
									for (var i = 0, ary = iter$(self._methods), len = ary.length, res = []; i < len; i++) {
										res.push((t7['$$a' + i] = t7['$$a' + i] || tag$.$api_method().flag('doc')).setIname(self.object().iname).setObject(ary[i]).end());
									};
									return res;
								})(t7),3).end()
							],2).end()
						) : void(0)
					],1).end()
				],1).synced();
			};
		});
		
		tag$.defineTag('api-value', function(tag){
			
			tag.prototype.render = function (){
				var object_, $1;
				if (this.object().type) {
					this.flag(this.object().type).setChildren(
						this.object().value
					,3).synced();
				} else if ((typeof (object_ = this.object())=='string'||object_ instanceof String)) {
					this.flag('str').setText(this.object()).synced();
				} else if ((typeof ($1 = this.object())=='number'||$1 instanceof Number)) {
					this.flag('num').setText(this.object()).synced();
				};
				return this;
			};
		});
		
		
		tag$.defineTag('api-param', function(tag){
			
			tag.prototype.type = function (){
				return this.object().type;
			};
			
			tag.prototype.render = function (){
				var self = this, t0, t1;
				return this.flag(self.type()).setChildren([
					self.type() == 'NamedParams' ? (
						(function(self) {
							for (var i = 0, ary = iter$(self.object().nodes), len = ary.length, res = []; i < len; i++) {
								res.push((self['$a' + i] = self['$a' + i] || tag$.$api_param()).setObject(ary[i]).end());
							};
							return res;
						})(self)
					) : (Imba.static([
						(t0 = self.$b=self.$b || tag$.$div().flag('name')).setContent(self.object().name,3).end(),
						(self.object().defaults) ? (Imba.static([
							(t1 = self.$c=self.$c || tag$.$i()).setContent([self.type() == 'NamedParam' ? (': ') : (' = ')],1).end(),
							(self.$d = self.$d || tag$.$api_value()).setObject(self.object().defaults).end()
						],2)) : void(0)
					],3))
				],1).synced();
			};
		});
		
		tag$.defineTag('api-method', 'api-item', function(tag){
			
			
			
			tag.prototype.iname = function(v){ return this._iname; }
			tag.prototype.setIname = function(v){ this._iname = v; return this; };
			
			
			tag.prototype.path = function(v){ return this._path; }
			tag.prototype.setPath = function(v){ this._path = v; return this; };
			
			tag.prototype.tags = function (){
				var t0;
				return (t0 = this._tags=this._tags || tag$.$div().setRef('tags',this)).setContent([
					(this.object().deprecated) ? (
						(t0.$$a = t0.$$a || tag$.$div().flag('deprecated').flag('red')).setText('Method is deprecated').end()
					) : void(0),
					(this.object().return) ? ((t0.$$b = t0.$$b || tag$.$api_return().setName('returns')).setObject(this.object().return).end()) : void(0)
				],1).end();
			};
			
			tag.prototype.path = function (){
				return this._path || (this.iname() + '.' + this.object().name);
			};
			
			tag.prototype.slug = function (){
				return pathToAnchor(this.object().namepath);
			};
			
			tag.prototype.render = function (){
				var t0, self = this, t1;
				return this.flag('deprecated',this.object().deprecated).setChildren([
					(this.$a = this.$a || tag$.$span().flag('toc-anchor')).setId(this.slug()).end(),
					(t0 = self.$b=self.$b || tag$.$div().flag('header')).setContent([
						(t0.$$a = t0.$$a || tag$.$api_path()).setObject(this.path()).end(),
						(t1 = t0.$$b=t0.$$b || tag$.$div().flag('params')).setContent((function(t1) {
							for (var i = 0, ary = iter$(self.object().params), len = ary.length, res = []; i < len; i++) {
								res.push((t1['$$a' + i] = t1['$$a' + i] || tag$.$api_param()).setObject(ary[i]).end());
							};
							return res;
						})(t1),3).end(),
						(t0.$$c = t0.$$c || tag$.$div().flag('grow')).end()
					],2).end(),
					(self.$c = self.$c || tag$.$api_desc().flag('md')).setHtml(self.object().html).end(),
					self.tags()
				],1).synced();
			};
		});
		
		tag$.defineTag('doc-link', 'a', function(tag){
			
			tag.prototype.render = function (){
				this.setHref(("/docs#" + pathToAnchor(this.object().namepath))).setChildren((this.$a = this.$a || tag$.$api_path()).setObject(this.object().namepath).end(),2).synced();
				return tag.__super__.render.apply(this,arguments);
			};
			
			tag.prototype.ontap = function (){
				tag.__super__.ontap.apply(this,arguments);
				return this.up(q$('._docs',this)).refocus();
			};
		});
		
		tag$.defineTag('doc-group', 'toc', function(tag){
			
			tag.prototype.ontap = function (){
				return this.toggleFlag('collapsed');
			};
		});
		
		
		return tag$.defineTag('docs', 'page', function(tag){
			
			
			tag.prototype.__version = {'default': '0.14.1',name: 'version'};
			tag.prototype.version = function(v){ return this._version; }
			tag.prototype.setVersion = function(v){ this._version = v; return this; }
			tag.prototype._version = '0.14.1';
			
			
			tag.prototype.roots = function(v){ return this._roots; }
			tag.prototype.setRoots = function(v){ this._roots = v; return this; };
			
			tag.prototype.src = function (){
				return ("/api/" + this.version() + ".json");
			};
			
			tag.prototype.docs = function (){
				return this._docs;
			};
			
			tag.prototype.awaken = function (){
				this.load();
				this.schedule();
				return this;
			};
			
			tag.prototype.build = function (){
				this.load();
				return tag.__super__.build.apply(this,arguments);
			};
			
			tag.prototype.load = function (){
				var self = this;
				if (false) {
					// return self
					APP.fetchDocument(self.src(),function(res) {
						self._docs = JSON.parse(JSON.stringify(res));
						return self.generate();
					});
					return self;
				};
				
				return self._request || (self._request = APP.fetchDocument(self.src(),function(res) {
					DOCS = self._docs = res;
					DOCMAP = self._docs.entities;
					self.generate();
					return self.loaded();
				}));
			};
			
			tag.prototype.loaded = function (){
				var el;
				this.render();
				// really?
				if (document.location.hash) {
					if (el = this.first(document.location.hash)) {
						// console.log 'should scroll here?!?!?!',el
						el.dom().scrollIntoView();
					};
				};
				return this;
			};
			
			tag.prototype.refocus = function (){
				var el;
				if (el = this.first(document.location.hash)) {
					el.dom().scrollIntoView();
				};
				return this;
			};
			
			tag.prototype.lookup = function (path){
				return this.docs().entities[path];
			};
			
			tag.prototype.generate = function (){
				this._roots = [];
				var ents = this._docs.entities;
				
				for (var o = this.docs().entities, item, i = 0, keys = Object.keys(o), l = keys.length; i < l; i++){
					item = o[keys[i]];if (item.type == 'class' || keys[i] == 'Imba') {
						item['.'] = (item['.'] || []).sort().map(function(path) { return ents[path]; }).filter(function(v) { return v.type == 'method' && v.desc; });
						item['#'] = (item['#'] || []).sort().map(function(path) { return ents[path]; }).filter(function(v) { return v.type == 'method' && v.desc; });
						
						if (item.desc) { this._roots.push(item) };
					};
				};
				return this;
			};
			
			tag.prototype.render = function (){
				if (!(this.docs())) { return this };
				return tag.__super__.render.apply(this,arguments);
			};
			
			tag.prototype.body = function (){
				var self = this, t0;
				return (t0 = self._body=self._body || tag$.$div().setRef('body',this).flag('light')).setContent(
					(function(t0) {
						for (var i = 0, ary = iter$(self.roots()), len = ary.length, res = []; i < len; i++) {
							res.push((t0['$$a' + i] = t0['$$a' + i] || tag$.$api_class().flag('doc').flag('l')).setObject(ary[i]).end());
						};
						return res;
					})(t0)
				,3).end();
			};
			tag.prototype.nav = function (){
				var t0, self = this, t1;
				return (t0 = self._nav=self._nav || tag$.$navmenu().setRef('nav',this)).setContent(
					(t1 = t0.$$a=t0.$$a || tag$.$div().flag('content')).setContent(
						(function(t1) {
							var t2, t3, t4, t5, t6;
							for (var i = 0, ary = iter$(self.roots()), len = ary.length, root, res = []; i < len; i++) {
								root = ary[i];
								res.push((t2 = t1['$$a' + i]=t1['$$a' + i] || tag$.$doc_group().flag('class').flag('section').flag('compact')).setContent([
									(t3 = t2.$$a=t2.$$a || tag$.$div().flag('header')).setContent((t3.$$a = t3.$$a || tag$.$doc_link().flag('class')).setObject(root).end(),2).end(),
									(t4 = t2.$$b=t2.$$b || tag$.$div().flag('content')).setContent([
										(t5 = t4.$$a=t4.$$a || tag$.$div().flag('static')).setContent(
											(function(t5) {
												var t6;
												for (var j = 0, items = iter$(root['.']), len_ = items.length, meth, res1 = []; j < len_; j++) {
													meth = items[j];
													if (!meth.desc) { continue; };
													res1.push((t6 = t5['$$a' + j]=t5['$$a' + j] || tag$.$div().flag('entry')).setContent((t6.$$a = t6.$$a || tag$.$doc_link()).setObject(meth).end(),2).end());
												};
												return res1;
											})(t5)
										,3).end(),
										(t6 = t4.$$b=t4.$$b || tag$.$div().flag('instance')).setContent(
											(function(t6) {
												var t7;
												for (var j = 0, items = iter$(root['#']), len_ = items.length, meth, res1 = []; j < len_; j++) {
													meth = items[j];
													if (!meth.desc) { continue; };
													res1.push((t7 = t6['$$a' + j]=t6['$$a' + j] || tag$.$div().flag('entry')).setContent((t7.$$a = t7.$$a || tag$.$doc_link()).setObject(meth).end(),2).end());
												};
												return res1;
											})(t6)
										,3).end()
									],2).end()
								],2).end());
							};
							return res;
						})(t1)
					,3).end()
				,2).end();
			};
		});
		
		
	
	})()

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
		function iter$(a){ return a ? (a.toArray ? a.toArray() : a) : []; };
		// externs;
		
		// var hljs = require 'highlight.js'
		
		tag$.defineTag('tool', 'button', function(tag){
			
			
			tag.prototype.action = function(v){ return this._action; }
			tag.prototype.setAction = function(v){ this._action = v; return this; };
			
			tag.prototype.render = function (){
				return this.flag('sym').synced();
			};
			
			tag.prototype.onclick = function (e){
				this.log('button click',e);
				return e.halt();
			};
			
			tag.prototype.ontouchstart = function (e){
				this.log('touchstart');
				true;
				return e.event().preventDefault();
			};
		});
		
		tag$.defineTag('snippet-hint', function(tag){
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.render = function (){
				return this.setText("I am a hint!!").synced();
			};
		});
		
		tag$.defineTag('overlays', function(tag){
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.render = function (){
				var root;
				if (root = this.view()._root) {
					var left = 0,top = 0,el = root.dom();
					
					while (el && !el.contains(this._dom)){
						left += el.offsetLeft;
						top += el.offsetTop - el.scrollTop;
						el = el.parentNode;
					};
					
					this._dom.style.left = left + 'px';
					this._dom.style.top = top + 'px';
				};
				
				return this;
			};
		});
		
		tag$.defineTag('hint-label', function(tag){
			
			tag.prototype.setLabel = function (text){
				if (text != this._label) {
					this._label = text;
					this.dom().innerHTML = text;
				};
				return this;
			};
		});
		
		tag$.defineTag('overlay-hint', function(tag){
			
			
			tag.prototype.type = function(v){ return this.getAttribute('type'); }
			tag.prototype.setType = function(v){ this.setAttribute('type',v); return this; };
			
			
			
			tag.prototype.view = function(v){ return this._view; }
			tag.prototype.setView = function(v){ this._view = v; return this; };
			
			tag.prototype.__row = {watch: 'rowDidSet',name: 'row'};
			tag.prototype.row = function(v){ return this._row; }
			tag.prototype.setRow = function(v){
				var a = this.row();
				if(v != a) { this._row = v; }
				if(v != a) { this.rowDidSet && this.rowDidSet(v,a,this.__row) }
				return this;
			};
			
			tag.prototype.__col = {watch: 'colDidSet',name: 'col'};
			tag.prototype.col = function(v){ return this._col; }
			tag.prototype.setCol = function(v){
				var a = this.col();
				if(v != a) { this._col = v; }
				if(v != a) { this.colDidSet && this.colDidSet(v,a,this.__col) }
				return this;
			};
			
			tag.prototype.__len = {watch: 'lenDidSet',name: 'len'};
			tag.prototype.len = function(v){ return this._len; }
			tag.prototype.setLen = function(v){
				var a = this.len();
				if(v != a) { this._len = v; }
				if(v != a) { this.lenDidSet && this.lenDidSet(v,a,this.__len) }
				return this;
			};
			
			tag.prototype.rowDidSet = function (new$,old){
				var val = ("" + (this.object().row() * this.view().lineHeight()) + "px");
				return this._dom.style.top = val;
			};
			
			tag.prototype.colDidSet = function (new$,old){
				var val = ("" + (this.object().col() * this.view().charWidth()) + "px");
				return this._dom.style.left = val;
			};
			
			tag.prototype.lenDidSet = function (new$,old){
				var width = ("" + (new$ * this.view().charWidth()) + "px");
				return this._dom.style.width = width;
			};
			
			tag.prototype.render = function (){
				// console.log 'hint at',object.row
				var reg = this.object().region();
				
				if (reg) {
					this.setRow(this.object().row());
					this.setCol(this.object().col());
					this.setLen(reg.size());
				};
				
				return this.flag('warn').flag('global',(!reg)).setType((this.object().type())).setChildren(
					(this.$a = this.$a || tag$.$hint_label().flag('label')).setLabel(this.object().label()).end()
				,2).synced();
			};
		});
		
		tag$.defineTag('jsview', function(tag){
			
			tag.prototype.render = function (){
				return this.setChildren((this._code = this._code || tag$.$code().setRef('code',this)).end(),2).synced();
			};
			
			tag.prototype.load = function (code,cb){
				// should compile bare
				var self = this;
				code = code.replace(/\/\/\# sourceMapping(.*)$/,'');
				code = code.replace(/^\(function\(\)\{\n/,'');
				code = code.replace(/\n?\}\)\(\)\n?$/,'');
				// code = code.replace(/^\t/mg,'')
				this._code.textContent = code;
				
				this.flag('huge',code.length > 1000);
				
				setTimeout(function() {
					hljs.configure({classPrefix: ''});
					var hl = hljs.highlight('javascript',code);
					self._code.setHtml(hl.value);
					return cb && cb(self);
				},0);
				
				return self;
			};
		});
		
		tag$.defineTag('console', function(tag){
			
			
			tag.prototype.editor = function(v){ return this._editor; }
			tag.prototype.setEditor = function(v){ this._editor = v; return this; };
			
			tag.prototype.reset = function (){
				this.empty();
				return this;
			};
			
			tag.prototype.log = function (val){
				console.log.apply(console,arguments);
				
				if (this.editor()) {
					this.editor().flag('console');
				};
				// console.log 'logging val',val
				
				if (val == this) {
					return;
				};
				
				if (val && val.dom) {
					val = val.dom().outerHTML;
				} else if (val instanceof Object) {
					val = JSON.stringify(val);
				};
				
				if (val != undefined) {
					this.append(tag$.$div().flag('json').setContent(val,0).end());
				};
				
				return;
			};
		});
		
		
		// this is basically like an editor
		tag$.defineTag('snippet', function(tag){
			
			var counter = 0;
			
			
			
			tag.prototype.imba = function(v){ return this._imba; }
			tag.prototype.setImba = function(v){ this._imba = v; return this; };
			
			
			tag.prototype.config = function(v){ return this._config; }
			tag.prototype.setConfig = function(v){ this._config = v; return this; };
			
			tag.prototype.__src = {watch: 'reload',name: 'src'};
			tag.prototype.src = function(v){ return this._src; }
			tag.prototype.setSrc = function(v){
				var a = this.src();
				if(v != a) { this._src = v; }
				if(v != a) { this.reload && this.reload(v,a,this.__src) }
				return this;
			};
			
			
			
			tag.prototype.heading = function(v){ return this.getAttribute('heading'); }
			tag.prototype.setHeading = function(v){ this.setAttribute('heading',v); return this; };
			
			
			tag.prototype.layout = function(v){ return this.getAttribute('layout'); }
			tag.prototype.setLayout = function(v){ this.setAttribute('layout',v); return this; };
			
			
			tag.prototype.tab = function(v){ return this.getAttribute('tab'); }
			tag.prototype.setTab = function(v){ this.setAttribute('tab',v); return this; };
			
			
			tag.prototype.__active = {watch: 'activeDidSet',name: 'active'};
			tag.prototype.active = function(v){ return this._active; }
			tag.prototype.setActive = function(v){
				var a = this.active();
				if(v != a) { this._active = v; }
				if(v != a) { this.activeDidSet && this.activeDidSet(v,a,this.__active) }
				return this;
			};
			
			tag.prototype.id = function (){
				var dom_;
				return (dom_ = this.dom()).id || (dom_.id = ("snippet" + (counter++)));
			};
			
			tag.prototype.activeDidSet = function (bool){
				return bool ? (this.schedule({fps: 60})) : (this.unschedule());
			};
			
			tag.prototype.input = function (){
				return (this._input = this._input || tag$.$imcaptor().setRef('input',this)).end();
			};
			
			tag.prototype.view = function (){
				return this._view || (this._view = (this._view = this._view || tag$.$imview().setRef('view',this)).setInput(this.input()).end());
			};
			
			tag.prototype.build = function (){
				
				var self = this, t0, t1, t2, t3, t4, t5;
				if (false) {
					if (self.src() && self.src().match(/\.imba$/)) {
						APP.fetchDocument(self.src(),function(res) {
							var v_;
							return (self.setImba(v_ = res.html),v_);
						});
					};
					// prerender shell
					self.setChildren([
						(t0 = self._main=self._main || tag$.$section().setRef('main',self)).setContent([
							(t1 = self._header=self._header || tag$.$header().setRef('header',self)).setContent([
								(t2 = t1.$$a=t1.$$a || tag$.$div().flag('title').flag('path')).setContent(self.heading(),3).end(),
								(t3 = t1.$$b=t1.$$b || tag$.$div().flag('tools')).setContent([
									(t3.$$a = t3.$$a || tag$.$tool().flag('reset').setTitle('reset').setHandler('tap','reset',self)).setText('reset').end(),
									(t3.$$b = t3.$$b || tag$.$tool().flag('js').setTitle('show js').setHandler('tap','toggleJS',self)).setText('show js').end(),
									(t3.$$c = t3.$$c || tag$.$tool().flag('run').setTitle('run').setHandler('tap','run',self)).setText('run').end()
								],2).end()
							],2).end(),
							(t4 = self._view=self._view || tag$.$div().setRef('view',self)).setContent((t5 = t4.$$a=t4.$$a || tag$.$code().flag('imbacode')).dataset('src',(self.src())).setContent(self.imba(),3).end(),2).end()
						],2).end(),
						(self._inspector = self._inspector || tag$.$div().setRef('inspector',self)).end()
					],2).synced();
					return self;
				};
				
				tag.__super__.build.apply(self,arguments);
				if (self.src()) { return self.reload() };
			};
			
			tag.prototype.setConfig = function (cfg){
				var v_;
				if (cfg != this._options) {
					this._options = cfg;
					if (cfg.title) { (this.setHeading(v_ = cfg.title),v_) };
				};
				return this;
			};
			
			tag.prototype.copts = function (){
				return this._copts || (this._copts = {
					bare: false,
					standalone: false,
					sourceMapInline: true,
					filename: ("" + this.id() + ".imba"),
					targetPath: ("" + this.id() + ".js"),
					sourcePath: ("" + this.id() + ".imba")
				});
			};
			
			tag.prototype.option = function (key){
				return this._options ? (this._options[key]) : (null);
			};
			
			tag.prototype.configure = function (o){
				this._options = o;
				return this.render();
			};
			
			tag.prototype.awaken = function (){
				var config = {};
				try {
					var code = q$$('.imbacode',this).dom().innerHTML;
				} catch (e) { };
				
				if (code) {
					config.html = code;
					this.view().load(null,{html: code});
					this.configure(config);
				};
				
				return this;
			};
			
			tag.prototype.load = function (code,o){
				if(o === undefined) o = {};
				if (code || o.html) { this.view().load(code,o) };
				return this;
			};
			
			tag.prototype.code = function (){
				return this.view().code();
			};
			
			tag.prototype.compile = function (code,o,blk){
				// cache latest compilation - return?
				if(blk==undefined && typeof o == 'function') blk = o,o = this.copts();
				if(o==undefined) o = this.copts();
				return Scrimbla.worker().compile(code,o,blk);
			};
			
			tag.prototype.overlays = function (){
				for (var i = 0, ary = iter$(this.view().hints()), len = ary.length, hint, res = []; i < len; i++) {
					hint = ary[i];
					if (!hint.active()) { continue; };
					res.push((this['_' + 'hint' + i] = this['_' + 'hint' + i] || tag$.$overlay_hint()).setView(this.view()).setObject(hint).end());
				};
				return res;
			};
			
			tag.prototype.toggleJS = function (){
				if (this.tab() != 'js') {
					this.showjs();
				} else {
					this.setTab('imba');
				};
				return this;
			};
			
			tag.prototype.oninputfocus = function (e){
				VIEW = this; // hack
				this.flag('focus');
				return (this.setActive(true),true);
			};
			
			tag.prototype.oninputblur = function (e){
				this.unflag('focus');
				var rel = e.event().relatedTarget;
				if (!(rel && this.dom().contains(rel))) {
					this.unflag('focus');
					this.setActive(false);
				};
				return this;
			};
			
			tag.prototype.render = function (){
				var t0, t1, t2, t3, t4, t5;
				if (false) { return this };
				
				return this.setChildren([
					this._input,
					(t0 = this._main=this._main || tag$.$section().setRef('main',this)).setContent([
						(t1 = this._header=this._header || tag$.$header().setRef('header',this)).setContent([
							(t2 = t1.$$a=t1.$$a || tag$.$div().flag('title').flag('path')).setContent(this.heading(),3).end(),
							(t3 = t1.$$b=t1.$$b || tag$.$div().flag('tools')).setContent([
								(t3.$$a = t3.$$a || tag$.$tool().flag('reset').setTitle('reset').setHandler('tap','reset',this)).setText('reset').end(),
								(t3.$$b = t3.$$b || tag$.$tool().flag('js').setTitle('show js').setHandler('tap','toggleJS',this)).setText('show js').end(),
								(t3.$$c = t3.$$c || tag$.$tool().flag('run').setTitle('run').setHandler('tap','run',this)).setText('run').end()
							],2).end()
						],2).end(),
						(t4 = this._overlays=this._overlays || tag$.$overlays().setRef('overlays',this)).setView(this.view()).setContent(this.overlays(),3).end(),
						(this._jsview = this._jsview || tag$.$jsview().setRef('jsview',this)).end(),
						this._view.end(),
						(this._console = this._console || tag$.$console().setRef('console',this).flag('dark')).setEditor(this).end()
					],1).end(),
					(t5 = this._inspector=this._inspector || tag$.$div().setRef('inspector',this)).setContent(this.playground(),3).end()
				],1).synced();
			};
			
			tag.prototype.sandbox = function (){
				return (this._sandbox = this._sandbox || tag$.$sandbox().setRef('sandbox',this).flag('playground')).setEditor(this).end();
			};
			
			tag.prototype.playground = function (){
				return this.sandbox();
			};
			
			tag.prototype.reload = function (){
				var self = this;
				if (!self._built) { return };
				
				if (DEPS[self.src()]) {
					var res = DEPS[self.src()];
					self.view().load(null,{html: res.html,filename: self.src()});
					if (self.autorun()) {
						setTimeout(function() { return self.run(); },50);
					};
					return self;
				};
				
				// get imba document?!?
				APP.fetchDocument(self.src(),function(res) {
					self.view().load(res.body,{filename: self.src()});
					if (self.autorun()) {
						return setTimeout(function() { return self.run(); },50);
					};
				});
				return self;
			};
			
			tag.prototype.onrun = function (){
				return this.run();
			};
			
			tag.prototype.autorun = function (){
				return false;
			};
			
			tag.prototype.oneditedasync = function (){
				this.flag('dirty');
				return this;
			};
			
			tag.prototype.onsave = function (){
				this.view().hints().clear();
				return this.run();
			};
			
			tag.prototype.reset = function (e){
				this._console.reset();
				if (this._options.html) {
					this.view().load(null,{html: this._options.html});
				};
				if (e) {
					e.cancel();
				};
				this.unflag('dirty');
				this.view().caret().normalize().dirty();
				return this;
			};
			
			tag.prototype.run = function (){
				var self = this;
				self.flag('running');
				self.compile(self.code(),self.copts(),function(res) {
					self.view().hints().rem(function(hint) { return hint.group() == 'runtime'; });
					
					if (res.data && res.data.code) {
						// @jsview.load(res:data:code) if res:data
						try {
							return self._sandbox.run(res.data);
						} catch (e) {
							return console.log('error');
						};
					};
				});
				return self;
			};
			
			tag.prototype.showjs = function (){
				var self = this;
				var o = {bare: true,standalone: false,filename: 'a.imba'};
				
				return self.compile(self.code(),o,function(res) {
					if (res.data && res.data.code) {
						return self._jsview.load(res.data.code,function() { var v_;
						return (self.setTab(v_ = 'js'),v_); });
					} else if (res.data && res.data.error) {
						return console.log('has error');
					};
				});
			};
			
			tag.prototype.runError = function (o){
				o.type = 'error';
				o.group = 'runtime';
				// console.log 'runError',o
				// only show error if we have a line and column
				return this.view().hints().add(o).activate();
			};
			
			tag.prototype.runLog = function (o){
				o.type = 'log';
				o.group = 'runtime';
				o.message || (o.message = JSON.stringify(o.params[0]));
				// console.log 'runLog',o
				
				if (o.nr != null && !o.loc) {
					var logs = this.view().find('.identifier.log,.identifier[name="log"]').toArray();
					var node = logs[o.nr];
					
					o.node = node;
					
					if (node) {
						var reg = node.region(); // node.next ? node.next.region : 
						console.log('found loc!!',node,reg);
						// let col = view.buffer.line(reg.row)[:length]
						o.loc = reg.endAtLine().collapse(); // {line: reg.row, column: col} #  reg.toJSON # {line: reg.row, column: 100}
						
						// o:loc = logs[o:nr].region.toJSON
					};
				};
				return this.view().hints().add(o).activate();
			};
			
			tag.prototype.runResult = function (o){
				// console.log 'runResult',o
				this.flag('repl',!!o);
				this._console.log(o);
				return this;
			};
		});
		
		tag$.defineTag('example', 'snippet', function(tag){
			
			tag.prototype.autorun = function (){
				return true;
			};
		});
		
		if (true) {
			Imba.Event.PROCESSING;
			
			
				
				var prev = Imba.Event.prototype.process;
				
				Imba.Event.prototype.process = function (){
					Imba.Event.PROCESSING = this;
					return prev.call(this);
				};
			
		};
		
		
		return tag$.defineTag('sandbox', function(tag){
			
			
			
			tag.prototype.editor = function(v){ return this._editor; }
			tag.prototype.setEditor = function(v){ this._editor = v; return this; };
			
			tag.prototype.render = function (){
				return this;
			};
			
			tag.prototype.console = function (){
				return this.editor()._console;
			};
			
			tag.prototype.onerror = function (msg,url,line,col,err){
				
				var stack_;
				if (url.match(/snippet(\d+)\.(imba|js)/)) {
					
					var id = url.split('.').shift();
					var snippet = tag$wrap(document.getElementById(id));
					
					if (snippet) {
						snippet.playground().onerror(msg,'',line,col,err);
						return;
					};
				} else if (url == 'undefined') {
					// safari?
					var ev = Imba.Event.PROCESSING;
					console.log('last event target',ev && ev.target());
					if (ev && ev.target()) {
						snippet = ev.target().closest(q$('._snippet',this));
						if (snippet) {
							return snippet.playground().onerror(msg,'',line,col,err);
						};
					};
				};
				
				console.log('caught the error here!!!',arguments,this);
				var locs = [];
				
				err && (stack_ = err.stack) && stack_.replace  &&  stack_.replace(/(\<anonymous\>|snippet\d+\.imba)\:(\d+):(\d+)/g,function(m,source,line,col) {
					locs.push({line: parseInt(line),column: parseInt(col)});
					return "";
				});
				
				locs.push({line: line,column: col});
				
				if (locs[0]) {
					var map = this.object().sourcemap;
					var consumer = Scrimbla.SourceMap.SourceMapConsumer(map);
					var loc = consumer.originalPositionFor(locs[0]);
					console.log('original location is',loc);
					this.editor().runError({message: msg,loc: loc});
				};
				
				return true;
			};
			
			tag.prototype.onlog = function (nr,pars){
				this.editor().runLog({nr: nr,params: pars});
				return this;
			};
			
			tag.prototype.empty = function (){
				for (var i = 0, ary = iter$(q$('.scheduled_',this)), len = ary.length; i < len; i++) {
					ary[i].unschedule();
				};
				return tag.__super__.empty.apply(this,arguments);
			};
			
			tag.prototype.present = function (res){
				var node;
				if (res && (res.prototype instanceof Imba.Tag)) {
					node = new res(res.createNode());
				} else if (res instanceof Imba.Tag) {
					node = res;
				};
				
				if (node) {
					this.empty().append(node);
					node.end();
				};
				
				return this.console().log(node || res);
			};
			
			tag.prototype.run = function (src){
				var self = this;
				var code = src.code;
				if (!code) { return self };
				
				self._object = src;
				
				try {
					window.onerror = function(msg,url,line,col,err) {
						console.log('caught error',msg,url,line,col,err,this);
						return self.onerror(msg,url,line,col,err);
					};
					
					code = code + '\n//# sourceURL=' + self.editor().id() + '.imba';
					var tag$ = Imba.TAGS.__clone();
					var console = self.console();
					var res = eval(code);
					self.present(res);
				} catch (e) {
					self.log('immediate error in eval-inline',e);
					self.onerror(e.message,'',e.lineNr || e.line || 0,e.column,e);
				};
				
				return self;
			};
		});
	
	})()

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMzI3MmVlY2EzYjRhYTI5OTZlYzciLCJ3ZWJwYWNrOi8vLy4vc3JjL2NsaWVudC5pbWJhIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvbGliL2ltYmEvaW1iYS5qcyIsIndlYnBhY2s6Ly8vLi4vaW1iYS9saWIvaW1iYS9jb3JlLmV2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vaW1iYS9saWIvaW1iYS9zY2hlZHVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvbGliL2ltYmEvdGFnLmpzIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2RvbS5qcyIsIndlYnBhY2s6Ly8vLi4vaW1iYS9saWIvaW1iYS9kb20uY2xpZW50LmpzIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2RvbS5odG1sLmpzIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2RvbS5zdmcuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvbGliL2ltYmEvZG9tLmxlZ2FjeS5qcyIsIndlYnBhY2s6Ly8vLi4vaW1iYS9saWIvaW1iYS9kb20uZXZlbnRzLmpzIiwid2VicGFjazovLy8uLi9pbWJhL2xpYi9pbWJhL2RvbS5zdGF0aWMuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltYmEvbGliL2ltYmEvc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9pbmRleC5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvY29yZS9mcy5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvc291cmNlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9iYXNlNjQtdmxxLmpzIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL2Jhc2U2NC5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL2FycmF5LXNldC5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9tYXBwaW5nLWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9iaW5hcnktc2VhcmNoLmpzIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL3F1aWNrLXNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvc291cmNlLW5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9yZWdpb24uaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2hlbHBlcnMuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvaGlnaGxpZ2h0ZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9pbWJhL3NyYy9jb21waWxlci9sZXhlci5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9+L2ltYmEvc3JjL2NvbXBpbGVyL3Rva2VuLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL34vaW1iYS9zcmMvY29tcGlsZXIvcmV3cml0ZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvfi9pbWJhL3NyYy9jb21waWxlci9lcnJvcnMuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvdXRpbC5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvY29yZS9oaXN0b3J5LmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9jb3JlL2xvZ2dlci5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvY29yZS9zaG9ydGN1dHMuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL3ZpZXdzL2NhcHRvci5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvdmlldy5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvY29yZS9idWZmZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvb2JzZXJ2ZXIuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvaGludHMuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvY2FyZXQuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL3ZpZXdzL292ZXJsYXlzLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9lZGl0b3IuaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL2NvcmUvd29ya2VyLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9ub2Rlcy9pbmRleC5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvbm9kZXMvYmFzZS5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvbm9kZXMvdG9rZW4uaW1iYSIsIndlYnBhY2s6Ly8vLi4vc2NyaW1ibGEvc3JjL25vZGVzL2Jsb2NrLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9ub2Rlcy9yb290LmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9ub2Rlcy9saXRlcmFscy5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvbm9kZXMvb3BlcmF0b3JzLmltYmEiLCJ3ZWJwYWNrOi8vLy4uL3NjcmltYmxhL3NyYy9ub2Rlcy9zZWxlY3Rvci5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvbm9kZXMvd2hpdGVzcGFjZS5pbWJhIiwid2VicGFjazovLy8uLi9zY3JpbWJsYS9zcmMvbm9kZXMvYW5ub3RhdGlvbnMuaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwLmltYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JvdXRlci5pbWJhIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9pbmRleC5pbWJhIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9iYXNlLmltYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL21hcmtkb3duLmltYmEiLCJ3ZWJwYWNrOi8vLy4vfi9tYXJrZWQvbGliL21hcmtlZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3Mvc2l0ZS5pbWJhIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9uYXYuaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvcGFnZS5pbWJhIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9ob21lLmltYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2Jsb2cuaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvZ3VpZGVzLmltYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2RvY3MuaW1iYSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3Mvc25pcHBldC5pbWJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdENBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBZ0MsV0FBVyxFQUFFO0FBQzdDLHlDQUF3QyxXQUFXLEVBQUU7O0FBRXJELEVBQUMsRzs7Ozs7O0FDaEJEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBLEVBQUMsRzs7Ozs7O0FDdEJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXNDLGtDQUFrQyxFQUFFO0FBQzFFOztBQUVBO0FBQ0EsdUNBQXNDLGtDQUFrQyxFQUFFO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFDLEc7Ozs7Ozs7QUNuSUQ7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFvRDtBQUNwRCw0Q0FBMkM7QUFDM0MsbURB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Q0E7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFXLFM7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNEMsU0FBUztBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQzNZQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBMkQ7QUFDM0QscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDNUlBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEIsbUJBQWtCOztBQUVsQixzQkFBcUI7QUFDckIsdUJBQXNCOztBQUV0QixtQkFBa0I7QUFDbEIsbUJBQWtCOztBQUVsQixtQkFBa0I7QUFDbEIsb0JBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbkVBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoWEEsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUN2R0EsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUMvRUEsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF3RDtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF3RDtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlEQUF3RCxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCLHdDQUF3QztBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWlELG1CQUFtQixFQUFFO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQSx5Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLCtDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLOztBQUVMLGFBQVk7QUFDWjs7QUFFQTtBQUNBOzs7Ozs7O0FDdlpBO0FBQ0Esb0JBQW1CLCtDQUErQzs7O0FBR2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUF5Qjs7O0FBR3pCLG1DQUFrQyxnQkFBZ0I7QUFDbEQsc0NBQXFDLGFBQWEsYUFBYTs7O0FBRy9ELG1DQUFrQyxnQkFBZ0I7QUFDbEQsc0NBQXFDLGFBQWEsYUFBYTs7O0FBRy9ELHNDQUFxQyxtQkFBbUI7QUFDeEQseUNBQXdDLGdCQUFnQixhQUFhOzs7QUFHckUsc0NBQXFDLG1CQUFtQjtBQUN4RCx5Q0FBd0MsZ0JBQWdCLGFBQWE7O0FBRXJFOztBQUVBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUIsOEJBQTZCO0FBQzdCLHVEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0EseURBQXdELFNBQVM7QUFDakU7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDViwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWLCtCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFPO0FB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLGdCQUFlO0FBQ2Y7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLDJDQUEyQztBQUN2RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBLDZCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDOztBQUUzQztBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0IsNENBQTJDO0FBQzND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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUksWUFBWTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7O0FBR0YsRUFBQyxHOzs7Ozs7QUN2REQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxFQUFDLEc7Ozs7OztBQ25FRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRixFQUFDLEc7Ozs7OztBQ3BDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsK0JBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixFQUFFO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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YTs7QUFFdkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFlLDJDQUEyQztBQUMxRDtBQUNBLEtBQUk7O0FBRUosZUFBYyx1QkFBdUI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsc0JBQXNCO0FBQ2xEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQSwwRUFBeUUsU0FBUztBQUNsRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7O0FBRWY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRixFQUFDLEciLCJmaWxlIjoiLi93d3cvY2xpZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCAzMjcyZWVjYTNiNGFhMjk5NmVjN1xuICoqLyIsIihmdW5jdGlvbigpe1xuXHRyZXF1aXJlKCdpbWJhL2xpYi9pbWJhL2Jyb3dzZXInKTtcblx0XG5cdC8vIG5lZWQgdG8gdXNlIHdlYnBhY2sgZm9yIHRoaXMgaW5jbHVkZSB0byB3b3JrIGFzIGludGVuZGVkXG5cdFNjcmltYmxhID0gcmVxdWlyZSgnc2NyaW1ibGEvc3JjL2luZGV4Jyk7XG5cdFxuXHR2YXIgQXBwID0gcmVxdWlyZSgnLi9hcHAnKS5BcHA7XG5cdEFQUCA9IG5ldyBBcHAoKTtcblx0QVBQLnNjaGVkdWxlKCk7XG5cdFxuXHRyZXF1aXJlKCcuL3ZpZXdzJyk7XG5cdFxuXHQvLyBhd2FrZW4gcGFnZXMgZXRjXG5cdHEkKCcuX3BhZ2UnKS5tYXAoZnVuY3Rpb24oZWwpIHsgcmV0dXJuIGVsOyB9KTtcblx0cmV0dXJuIHEkKCcuYXdha2VuJykubWFwKGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbDsgfSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NsaWVudC5pbWJhXG4gKiogbW9kdWxlIGlkID0gMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHRpZiAodHlwZW9mIEltYmEgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmVxdWlyZSgnLi9pbWJhJyk7XG5cdFx0XG5cdFx0SW1iYS5DTElFTlQgPSB0cnVlO1xuXHRcdFxuXHRcdHJlcXVpcmUoJy4vY29yZS5ldmVudHMnKTtcblx0XHRyZXF1aXJlKCcuL3NjaGVkdWxlcicpO1xuXHRcdHJlcXVpcmUoJy4vdGFnJyk7XG5cdFx0cmVxdWlyZSgnLi9kb20nKTtcblx0XHRyZXF1aXJlKCcuL2RvbS5jbGllbnQnKTtcblx0XHRyZXF1aXJlKCcuL2RvbS5odG1sJyk7XG5cdFx0cmVxdWlyZSgnLi9kb20uc3ZnJyk7XG5cdFx0cmVxdWlyZSgnLi9kb20ubGVnYWN5Jyk7XG5cdFx0cmVxdWlyZSgnLi9kb20uZXZlbnRzJyk7XG5cdFx0cmVxdWlyZSgnLi9kb20uc3RhdGljJyk7XG5cdFx0cmV0dXJuIHJlcXVpcmUoJy4vc2VsZWN0b3InKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gY29uc29sZS53YXJuKFwiSW1iYSBpcyBhbHJlYWR5IGxvYWRlZFwiKTtcblx0fTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9saWIvaW1iYS9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdC8vIGV4dGVybnM7XG5cdFxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRnbG9iYWwgPSB3aW5kb3c7XG5cdH07XG5cdFxuXHQvKlxuXHRJbWJhIGlzIHRoZSBuYW1lc3BhY2UgZm9yIGFsbCBydW50aW1lIHJlbGF0ZWQgdXRpbGl0aWVzXG5cdEBuYW1lc3BhY2Vcblx0Ki9cblx0XG5cdEltYmEgPSB7XG5cdFx0VkVSU0lPTjogJzAuMTQuMScsXG5cdFx0REVCVUc6IGZhbHNlXG5cdH07XG5cdFxuXHR2YXIgcmVnID0gLy0uL2c7XG5cdFxuXHQvKlxuXHRUcnVlIGlmIHJ1bm5pbmcgaW4gY2xpZW50IGVudmlyb25tZW50LlxuXHRAcmV0dXJuIHtib29sfVxuXHQqL1xuXHRcblx0SW1iYS5pc0NsaWVudCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBJbWJhLkNMSUVOVCA9PT0gdHJ1ZTtcblx0fTtcblx0XG5cdC8qXG5cdFRydWUgaWYgcnVubmluZyBpbiBzZXJ2ZXIgZW52aXJvbm1lbnQuXG5cdEByZXR1cm4ge2Jvb2x9XG5cdCovXG5cdFxuXHRJbWJhLmlzU2VydmVyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIEltYmEuU0VSVkVSID09PSB0cnVlO1xuXHR9O1xuXHRcblx0SW1iYS5zdWJjbGFzcyA9IGZ1bmN0aW9uIChvYmosc3VwKXtcblx0XHQ7XG5cdFx0Zm9yICh2YXIgayBpbiBzdXApe1xuXHRcdFx0aWYgKHN1cC5oYXNPd25Qcm9wZXJ0eShrKSkgeyBvYmpba10gPSBzdXBba10gfTtcblx0XHR9O1xuXHRcdFxuXHRcdG9iai5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cC5wcm90b3R5cGUpO1xuXHRcdG9iai5fX3N1cGVyX18gPSBvYmoucHJvdG90eXBlLl9fc3VwZXJfXyA9IHN1cC5wcm90b3R5cGU7XG5cdFx0b2JqLnByb3RvdHlwZS5pbml0aWFsaXplID0gb2JqLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG9iajtcblx0XHRyZXR1cm4gb2JqO1xuXHR9O1xuXHRcblx0Lypcblx0TGlnaHR3ZWlnaHQgbWV0aG9kIGZvciBtYWtpbmcgYW4gb2JqZWN0IGl0ZXJhYmxlIGluIGltYmFzIGZvci9pbiBsb29wcy5cblx0SWYgdGhlIGNvbXBpbGVyIGNhbm5vdCBzYXkgZm9yIGNlcnRhaW4gdGhhdCBhIHRhcmdldCBpbiBhIGZvciBsb29wIGlzIGFuXG5cdGFycmF5LCBpdCB3aWxsIGNhY2hlIHRoZSBpdGVyYWJsZSB2ZXJzaW9uIGJlZm9yZSBsb29waW5nLlxuXHRcblx0YGBgaW1iYVxuXHQjIHRoaXMgaXMgdGhlIHdob2xlIG1ldGhvZFxuXHRkZWYgSW1iYS5pdGVyYWJsZSBvXG5cdFx0cmV0dXJuIG8gPyAobzp0b0FycmF5ID8gby50b0FycmF5IDogbykgOiBbXVxuXHRcblx0Y2xhc3MgQ3VzdG9tSXRlcmFibGVcblx0XHRkZWYgdG9BcnJheVxuXHRcdFx0WzEsMiwzXVxuXHRcblx0IyB3aWxsIHJldHVybiBbMiw0LDZdXG5cdGZvciB4IGluIEN1c3RvbUl0ZXJhYmxlLm5ld1xuXHRcdHggKiAyXG5cdFxuXHRgYGBcblx0Ki9cblx0XG5cdEltYmEuaXRlcmFibGUgPSBmdW5jdGlvbiAobyl7XG5cdFx0cmV0dXJuIG8gPyAoKG8udG9BcnJheSA/IChvLnRvQXJyYXkoKSkgOiAobykpKSA6IChbXSk7XG5cdH07XG5cdFxuXHQvKlxuXHRDb2VyY2VzIGEgdmFsdWUgaW50byBhIHByb21pc2UuIElmIHZhbHVlIGlzIGFycmF5IGl0IHdpbGxcblx0Y2FsbCBgUHJvbWlzZS5hbGwodmFsdWUpYCwgb3IgaWYgaXQgaXMgbm90IGEgcHJvbWlzZSBpdCB3aWxsXG5cdHdyYXAgdGhlIHZhbHVlIGluIGBQcm9taXNlLnJlc29sdmUodmFsdWUpYC4gVXNlZCBmb3IgZXhwZXJpbWVudGFsXG5cdGF3YWl0IHN5bnRheC5cblx0QHJldHVybiB7UHJvbWlzZX1cblx0Ki9cblx0XG5cdEltYmEuYXdhaXQgPSBmdW5jdGlvbiAodmFsdWUpe1xuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwodmFsdWUpO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUudGhlbikge1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcblx0XHR9O1xuXHR9O1xuXHRcblx0SW1iYS50b0NhbWVsQ2FzZSA9IGZ1bmN0aW9uIChzdHIpe1xuXHRcdHJldHVybiBzdHIucmVwbGFjZShyZWcsZnVuY3Rpb24obSkgeyByZXR1cm4gbS5jaGFyQXQoMSkudG9VcHBlckNhc2UoKTsgfSk7XG5cdH07XG5cdFxuXHRJbWJhLnRvQ2FtZWxDYXNlID0gZnVuY3Rpb24gKHN0cil7XG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKHJlZyxmdW5jdGlvbihtKSB7IHJldHVybiBtLmNoYXJBdCgxKS50b1VwcGVyQ2FzZSgpOyB9KTtcblx0fTtcblx0XG5cdEltYmEuaW5kZXhPZiA9IGZ1bmN0aW9uIChhLGIpe1xuXHRcdHJldHVybiAoYiAmJiBiLmluZGV4T2YpID8gKGIuaW5kZXhPZihhKSkgOiAoW10uaW5kZXhPZi5jYWxsKGEsYikpO1xuXHR9O1xuXHRcblx0SW1iYS5wcm9wID0gZnVuY3Rpb24gKHNjb3BlLG5hbWUsb3B0cyl7XG5cdFx0aWYgKHNjb3BlLmRlZmluZVByb3BlcnR5KSB7XG5cdFx0XHRyZXR1cm4gc2NvcGUuZGVmaW5lUHJvcGVydHkobmFtZSxvcHRzKTtcblx0XHR9O1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdHJldHVybiBJbWJhLmF0dHIgPSBmdW5jdGlvbiAoc2NvcGUsbmFtZSxvcHRzKXtcblx0XHRpZiAoc2NvcGUuZGVmaW5lQXR0cmlidXRlKSB7XG5cdFx0XHRyZXR1cm4gc2NvcGUuZGVmaW5lQXR0cmlidXRlKG5hbWUsb3B0cyk7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgZ2V0TmFtZSA9IEltYmEudG9DYW1lbENhc2UobmFtZSk7XG5cdFx0dmFyIHNldE5hbWUgPSBJbWJhLnRvQ2FtZWxDYXNlKCdzZXQtJyArIG5hbWUpO1xuXHRcdFxuXHRcdHNjb3BlLnByb3RvdHlwZVtnZXROYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuXHRcdH07XG5cdFx0XG5cdFx0c2NvcGUucHJvdG90eXBlW3NldE5hbWVdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsdmFsdWUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm47XG5cdH07XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvaW1iYS5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0XG5cdGZ1bmN0aW9uIGVtaXRfXyhldmVudCxhcmdzLG5vZGUpe1xuXHRcdC8vIHZhciBub2RlID0gY2JzW2V2ZW50XVxuXHRcdHZhciBwcmV2LGNiLHJldDtcblx0XHRcblx0XHR3aGlsZSAoKHByZXYgPSBub2RlKSAmJiAobm9kZSA9IG5vZGUubmV4dCkpe1xuXHRcdFx0aWYgKGNiID0gbm9kZS5saXN0ZW5lcikge1xuXHRcdFx0XHRpZiAobm9kZS5wYXRoICYmIGNiW25vZGUucGF0aF0pIHtcblx0XHRcdFx0XHRyZXQgPSBhcmdzID8gKGNiW25vZGUucGF0aF0uYXBwbHkoY2IsYXJncykpIDogKGNiW25vZGUucGF0aF0oKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgaXQgaXMgYSBtZXRob2Q/XG5cdFx0XHRcdFx0cmV0ID0gYXJncyA/IChjYi5hcHBseShub2RlLGFyZ3MpKSA6IChjYi5jYWxsKG5vZGUpKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChub2RlLnRpbWVzICYmIC0tbm9kZS50aW1lcyA8PSAwKSB7XG5cdFx0XHRcdHByZXYubmV4dCA9IG5vZGUubmV4dDtcblx0XHRcdFx0bm9kZS5saXN0ZW5lciA9IG51bGw7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0Ly8gbWV0aG9kIGZvciByZWdpc3RlcmluZyBhIGxpc3RlbmVyIG9uIG9iamVjdFxuXHRJbWJhLmxpc3RlbiA9IGZ1bmN0aW9uIChvYmosZXZlbnQsbGlzdGVuZXIscGF0aCl7XG5cdFx0dmFyICQxO1xuXHRcdHZhciBjYnMsbGlzdCx0YWlsO1xuXHRcdGNicyA9IG9iai5fX2xpc3RlbmVyc19fIHx8IChvYmouX19saXN0ZW5lcnNfXyA9IHt9KTtcblx0XHRsaXN0ID0gY2JzWygkMSA9IGV2ZW50KV0gfHwgKGNic1skMV0gPSB7fSk7XG5cdFx0dGFpbCA9IGxpc3QudGFpbCB8fCAobGlzdC50YWlsID0gKGxpc3QubmV4dCA9IHt9KSk7XG5cdFx0dGFpbC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuXHRcdHRhaWwucGF0aCA9IHBhdGg7XG5cdFx0bGlzdC50YWlsID0gdGFpbC5uZXh0ID0ge307XG5cdFx0cmV0dXJuIHRhaWw7XG5cdH07XG5cdFxuXHRJbWJhLm9uY2UgPSBmdW5jdGlvbiAob2JqLGV2ZW50LGxpc3RlbmVyKXtcblx0XHR2YXIgdGFpbCA9IEltYmEubGlzdGVuKG9iaixldmVudCxsaXN0ZW5lcik7XG5cdFx0dGFpbC50aW1lcyA9IDE7XG5cdFx0cmV0dXJuIHRhaWw7XG5cdH07XG5cdFxuXHRJbWJhLnVubGlzdGVuID0gZnVuY3Rpb24gKG9iaixldmVudCxjYixtZXRoKXtcblx0XHR2YXIgbm9kZSxwcmV2O1xuXHRcdHZhciBtZXRhID0gb2JqLl9fbGlzdGVuZXJzX187XG5cdFx0aWYgKCFtZXRhKSB7IHJldHVybiB9O1xuXHRcdFxuXHRcdGlmIChub2RlID0gbWV0YVtldmVudF0pIHtcblx0XHRcdHdoaWxlICgocHJldiA9IG5vZGUpICYmIChub2RlID0gbm9kZS5uZXh0KSl7XG5cdFx0XHRcdGlmIChub2RlID09IGNiIHx8IG5vZGUubGlzdGVuZXIgPT0gY2IpIHtcblx0XHRcdFx0XHRwcmV2Lm5leHQgPSBub2RlLm5leHQ7XG5cdFx0XHRcdFx0Ly8gY2hlY2sgZm9yIGNvcnJlY3QgcGF0aCBhcyB3ZWxsP1xuXHRcdFx0XHRcdG5vZGUubGlzdGVuZXIgPSBudWxsO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdEltYmEuZW1pdCA9IGZ1bmN0aW9uIChvYmosZXZlbnQscGFyYW1zKXtcblx0XHR2YXIgY2I7XG5cdFx0aWYgKGNiID0gb2JqLl9fbGlzdGVuZXJzX18pIHtcblx0XHRcdGlmIChjYltldmVudF0pIHsgZW1pdF9fKGV2ZW50LHBhcmFtcyxjYltldmVudF0pIH07XG5cdFx0XHRpZiAoY2IuYWxsKSB7IGVtaXRfXyhldmVudCxbZXZlbnQscGFyYW1zXSxjYi5hbGwpIH07IC8vIGFuZCBldmVudCAhPSAnYWxsJ1xuXHRcdH07XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0cmV0dXJuIEltYmEub2JzZXJ2ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9ic2VydmVyLGtleSx0cmlnZ2VyLHRhcmdldCxwcmV2KXtcblx0XHRpZiAocHJldiAmJiB0eXBlb2YgcHJldiA9PSAnb2JqZWN0Jykge1xuXHRcdFx0SW1iYS51bmxpc3RlbihwcmV2LCdhbGwnLG9ic2VydmVyLHRyaWdnZXIpO1xuXHRcdH07XG5cdFx0aWYgKHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ID09ICdvYmplY3QnKSB7XG5cdFx0XHRJbWJhLmxpc3Rlbih0YXJnZXQsJ2FsbCcsb2JzZXJ2ZXIsdHJpZ2dlcik7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9saWIvaW1iYS9jb3JlLmV2ZW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpZHgkKGEsYil7XG5cdFx0cmV0dXJuIChiICYmIGIuaW5kZXhPZikgPyBiLmluZGV4T2YoYSkgOiBbXS5pbmRleE9mLmNhbGwoYSxiKTtcblx0fTtcblx0XG5cdFxuXHR2YXIgcmFmOyAvLyB2ZXJ5IHNpbXBsZSByYWYgcG9seWZpbGxcblx0cmFmIHx8IChyYWYgPSBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKTtcblx0cmFmIHx8IChyYWYgPSBnbG9iYWwud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKTtcblx0cmFmIHx8IChyYWYgPSBnbG9iYWwubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lKTtcblx0cmFmIHx8IChyYWYgPSBmdW5jdGlvbihibGspIHsgcmV0dXJuIHNldFRpbWVvdXQoYmxrLDEwMDAgLyA2MCk7IH0pO1xuXHRcblx0SW1iYS50aWNrID0gZnVuY3Rpb24gKGQpe1xuXHRcdGlmICh0aGlzLl9zY2hlZHVsZWQpIHsgcmFmKEltYmEudGlja2VyKCkpIH07XG5cdFx0dGhpcy5lbWl0KHRoaXMsJ3RpY2snLFtkXSk7XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0SW1iYS50aWNrZXIgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0cmV0dXJuIHNlbGYuX3RpY2tlciB8fCAoc2VsZi5fdGlja2VyID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gc2VsZi50aWNrKGUpOyB9KTtcblx0fTtcblx0XG5cdC8qXG5cdFxuXHRHbG9iYWwgYWx0ZXJuYXRpdmUgdG8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBTY2hlZHVsZSBhIHRhcmdldFxuXHR0byB0aWNrIGV2ZXJ5IGZyYW1lLiBZb3UgY2FuIHNwZWNpZnkgd2hpY2ggbWV0aG9kIHRvIGNhbGwgb24gdGhlXG5cdHRhcmdldCAoZGVmYXVsdHMgdG8gdGljaykuXG5cdFxuXHQqL1xuXHRcblx0SW1iYS5zY2hlZHVsZSA9IGZ1bmN0aW9uICh0YXJnZXQsbWV0aG9kKXtcblx0XHRpZihtZXRob2QgPT09IHVuZGVmaW5lZCkgbWV0aG9kID0gJ3RpY2snO1xuXHRcdHRoaXMubGlzdGVuKHRoaXMsJ3RpY2snLHRhcmdldCxtZXRob2QpO1xuXHRcdC8vIHN0YXJ0IHNjaGVkdWxpbmcgbm93IGlmIHRoaXMgd2FzIHRoZSBmaXJzdCBvbmVcblx0XHRpZiAoIXRoaXMuX3NjaGVkdWxlZCkge1xuXHRcdFx0dGhpcy5fc2NoZWR1bGVkID0gdHJ1ZTtcblx0XHRcdHJhZihJbWJhLnRpY2tlcigpKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XG5cdFVuc2NoZWR1bGUgYSBwcmV2aW91c2x5IHNjaGVkdWxlZCB0YXJnZXRcblx0XG5cdCovXG5cdFxuXHRJbWJhLnVuc2NoZWR1bGUgPSBmdW5jdGlvbiAodGFyZ2V0LG1ldGhvZCl7XG5cdFx0dGhpcy51bmxpc3Rlbih0aGlzLCd0aWNrJyx0YXJnZXQsbWV0aG9kKTtcblx0XHR2YXIgY2JzID0gdGhpcy5fX2xpc3RlbmVyc19fIHx8ICh0aGlzLl9fbGlzdGVuZXJzX18gPSB7fSk7XG5cdFx0aWYgKCFjYnMudGljayB8fCAhY2JzLnRpY2submV4dCB8fCAhY2JzLnRpY2submV4dC5saXN0ZW5lcikge1xuXHRcdFx0dGhpcy5fc2NoZWR1bGVkID0gZmFsc2U7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFxuXHRMaWdodCB3cmFwcGVyIGFyb3VuZCBuYXRpdmUgc2V0VGltZW91dCB0aGF0IGV4cGVjdHMgdGhlIGJsb2NrIC8gZnVuY3Rpb25cblx0YXMgbGFzdCBhcmd1bWVudCAoaW5zdGVhZCBvZiBmaXJzdCkuIEl0IGFsc28gdHJpZ2dlcnMgYW4gZXZlbnQgdG8gSW1iYVxuXHRhZnRlciB0aGUgdGltZW91dCB0byBsZXQgc2NoZWR1bGVycyB1cGRhdGUgKHRvIHJlcmVuZGVyIGV0YykgYWZ0ZXJ3YXJkcy5cblx0XG5cdCovXG5cdFxuXHRJbWJhLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAoZGVsYXksYmxvY2spe1xuXHRcdHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0YmxvY2soKTtcblx0XHRcdHJldHVybiBJbWJhLmVtaXQoSW1iYSwndGltZW91dCcsW2Jsb2NrXSk7XG5cdFx0fSxkZWxheSk7XG5cdH07XG5cdFxuXHQvKlxuXHRcblx0TGlnaHQgd3JhcHBlciBhcm91bmQgbmF0aXZlIHNldEludGVydmFsIHRoYXQgZXhwZWN0cyB0aGUgYmxvY2sgLyBmdW5jdGlvblxuXHRhcyBsYXN0IGFyZ3VtZW50IChpbnN0ZWFkIG9mIGZpcnN0KS4gSXQgYWxzbyB0cmlnZ2VycyBhbiBldmVudCB0byBJbWJhXG5cdGFmdGVyIGV2ZXJ5IGludGVydmFsIHRvIGxldCBzY2hlZHVsZXJzIHVwZGF0ZSAodG8gcmVyZW5kZXIgZXRjKSBhZnRlcndhcmRzLlxuXHRcblx0Ki9cblx0XG5cdEltYmEuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAoaW50ZXJ2YWwsYmxvY2spe1xuXHRcdHJldHVybiBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcblx0XHRcdGJsb2NrKCk7XG5cdFx0XHRyZXR1cm4gSW1iYS5lbWl0KEltYmEsJ2ludGVydmFsJyxbYmxvY2tdKTtcblx0XHR9LGludGVydmFsKTtcblx0fTtcblx0XG5cdC8qXG5cdENsZWFyIGludGVydmFsIHdpdGggc3BlY2lmaWVkIGlkXG5cdCovXG5cdFxuXHRJbWJhLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbiAoaW50ZXJ2YWwpe1xuXHRcdHJldHVybiBjbGVhckludGVydmFsKGludGVydmFsKTtcblx0fTtcblx0XG5cdC8qXG5cdENsZWFyIHRpbWVvdXQgd2l0aCBzcGVjaWZpZWQgaWRcblx0Ki9cblx0XG5cdEltYmEuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKHRpbWVvdXQpe1xuXHRcdHJldHVybiBjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdH07XG5cdFxuXHQvLyBzaG91bGQgYWRkIGFuIEltYmEucnVuIC8gc2V0SW1tZWRpYXRlIHRoYXRcblx0Ly8gcHVzaGVzIGxpc3RlbmVyIG9udG8gdGhlIHRpY2stcXVldWUgd2l0aCB0aW1lcyAtIG9uY2Vcblx0XG5cdFxuXHQvKlxuXHRcblx0SW5zdGFuY2VzIG9mIEltYmEuU2NoZWR1bGVyIG1hbmFnZXMgd2hlbiB0byBjYWxsIGB0aWNrKClgIG9uIHRoZWlyIHRhcmdldCxcblx0YXQgYSBzcGVjaWZpZWQgZnJhbWVyYXRlIG9yIHdoZW4gY2VydGFpbiBldmVudHMgb2NjdXIuIFJvb3Qtbm9kZXMgaW4geW91clxuXHRhcHBsaWNhdGlvbnMgd2lsbCB1c3VhbGx5IGhhdmUgYSBzY2hlZHVsZXIgdG8gbWFrZSBzdXJlIHRoZXkgcmVyZW5kZXIgd2hlblxuXHRzb21ldGhpbmcgY2hhbmdlcy4gSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBtYWtlIGlubmVyIGNvbXBvbmVudHMgdXNlIHRoZWlyXG5cdG93biBzY2hlZHVsZXJzIHRvIGNvbnRyb2wgd2hlbiB0aGV5IHJlbmRlci5cblx0XG5cdEBpbmFtZSBzY2hlZHVsZXJcblx0XG5cdCovXG5cdFxuXHRJbWJhLlNjaGVkdWxlciA9IGZ1bmN0aW9uIFNjaGVkdWxlcih0YXJnZXQpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzZWxmLl90YXJnZXQgPSB0YXJnZXQ7XG5cdFx0c2VsZi5fbWFya2VkID0gZmFsc2U7XG5cdFx0c2VsZi5fYWN0aXZlID0gZmFsc2U7XG5cdFx0c2VsZi5fbWFya2VyID0gZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLm1hcmsoKTsgfTtcblx0XHRzZWxmLl90aWNrZXIgPSBmdW5jdGlvbihlKSB7IHJldHVybiBzZWxmLnRpY2soZSk7IH07XG5cdFx0XG5cdFx0c2VsZi5fZXZlbnRzID0gdHJ1ZTtcblx0XHRzZWxmLl9mcHMgPSAxO1xuXHRcdFxuXHRcdHNlbGYuX2R0ID0gMDtcblx0XHRzZWxmLl90aW1lc3RhbXAgPSAwO1xuXHRcdHNlbGYuX3RpY2tzID0gMDtcblx0XHRzZWxmLl9mbHVzaGVzID0gMDtcblx0fTtcblx0XG5cdC8qXG5cdFx0Q3JlYXRlIGEgbmV3IEltYmEuU2NoZWR1bGVyIGZvciBzcGVjaWZpZWQgdGFyZ2V0XG5cdFx0QHJldHVybiB7SW1iYS5TY2hlZHVsZXJ9XG5cdFx0Ki9cblx0XG5cdC8qXG5cdFx0Q2hlY2sgd2hldGhlciB0aGUgY3VycmVudCBzY2hlZHVsZXIgaXMgYWN0aXZlIG9yIG5vdFxuXHRcdEByZXR1cm4ge2Jvb2x9XG5cdFx0Ki9cblx0XG5cdEltYmEuU2NoZWR1bGVyLnByb3RvdHlwZS5hY3RpdmUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fYWN0aXZlO1xuXHR9O1xuXHRcblx0Lypcblx0XHREZWx0YSB0aW1lIGJldHdlZW4gdGhlIHR3byBsYXN0IHRpY2tzXG5cdFx0QHJldHVybiB7TnVtYmVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLlNjaGVkdWxlci5wcm90b3R5cGUuZHQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fZHQ7XG5cdH07XG5cdFxuXHQvKlxuXHRcdERlbHRhIHRpbWUgYmV0d2VlbiB0aGUgdHdvIGxhc3QgdGlja3Ncblx0XHRAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuU2NoZWR1bGVyLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAocGFycyl7XG5cdFx0aWYoIXBhcnN8fHBhcnMuY29uc3RydWN0b3IgIT09IE9iamVjdCkgcGFycyA9IHt9O1xuXHRcdHZhciBmcHMgPSBwYXJzLmZwcyAhPT0gdW5kZWZpbmVkID8gcGFycy5mcHMgOiAxO1xuXHRcdHZhciBldmVudHMgPSBwYXJzLmV2ZW50cyAhPT0gdW5kZWZpbmVkID8gcGFycy5ldmVudHMgOiB0cnVlO1xuXHRcdGlmIChldmVudHMgIT0gbnVsbCkgeyB0aGlzLl9ldmVudHMgPSBldmVudHMgfTtcblx0XHRpZiAoZnBzICE9IG51bGwpIHsgdGhpcy5fZnBzID0gZnBzIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBkZWYgcmVzY2hlZHVsZVxuXHQvLyBcdHJhZihAdGlja2VyKVxuXHQvLyBcdHNlbGZcblx0XG5cdC8qXG5cdFx0TWFyayB0aGUgc2NoZWR1bGVyIGFzIGRpcnR5LiBUaGlzIHdpbGwgbWFrZSBzdXJlIHRoYXRcblx0XHR0aGUgc2NoZWR1bGVyIGNhbGxzIGB0YXJnZXQudGlja2Agb24gdGhlIG5leHQgZnJhbWVcblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlNjaGVkdWxlci5wcm90b3R5cGUubWFyayA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMuX21hcmtlZCA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEluc3RhbnRseSB0cmlnZ2VyIHRhcmdldC50aWNrIGFuZCBtYXJrIHNjaGVkdWxlciBhcyBjbGVhbiAobm90IGRpcnR5L21hcmtlZCkuXG5cdFx0VGhpcyBpcyBjYWxsZWQgaW1wbGljaXRseSBmcm9tIHRpY2ssIGJ1dCBjYW4gYWxzbyBiZSBjYWxsZWQgbWFudWFsbHkgaWYgeW91XG5cdFx0cmVhbGx5IHdhbnQgdG8gZm9yY2UgYSB0aWNrIHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIG5leHQgZnJhbWUuXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5TY2hlZHVsZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5fbWFya2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fZmx1c2hlcysrO1xuXHRcdHRoaXMuX3RhcmdldC50aWNrKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEBmaXhtZSB0aGlzIGV4cGVjdHMgcmFmIHRvIHJ1biBhdCA2MCBmcHMgXG5cdFxuXHRcdENhbGxlZCBhdXRvbWF0aWNhbGx5IG9uIGV2ZXJ5IGZyYW1lIHdoaWxlIHRoZSBzY2hlZHVsZXIgaXMgYWN0aXZlLlxuXHRcdEl0IHdpbGwgb25seSBjYWxsIGB0YXJnZXQudGlja2AgaWYgdGhlIHNjaGVkdWxlciBpcyBtYXJrZWQgZGlydHksXG5cdFx0b3Igd2hlbiBhY2NvcmRpbmcgdG8gQGZwcyBzZXR0aW5nLlxuXHRcblx0XHRJZiB5b3UgaGF2ZSBzZXQgdXAgYSBzY2hlZHVsZXIgd2l0aCBhbiBmcHMgb2YgMSwgdGljayB3aWxsIHN0aWxsIGJlXG5cdFx0Y2FsbGVkIGV2ZXJ5IGZyYW1lLCBidXQgYHRhcmdldC50aWNrYCB3aWxsIG9ubHkgYmUgY2FsbGVkIG9uY2UgZXZlcnlcblx0XHRzZWNvbmQsIGFuZCBpdCB3aWxsICptYWtlIHN1cmUqIGVhY2ggYHRhcmdldC50aWNrYCBoYXBwZW5zIGluIHNlcGFyYXRlXG5cdFx0c2Vjb25kcyBhY2NvcmRpbmcgdG8gRGF0ZS4gU28gaWYgeW91IGhhdmUgYSBub2RlIHRoYXQgcmVuZGVycyBhIGNsb2NrXG5cdFx0YmFzZWQgb24gRGF0ZS5ub3cgKG9yIHNvbWV0aGluZyBzaW1pbGFyKSwgeW91IGNhbiBzY2hlZHVsZSBpdCB3aXRoIDFmcHMsXG5cdFx0bmV2ZXIgbmVlZGluZyB0byB3b3JyeSBhYm91dCB0d28gdGlja3MgaGFwcGVuaW5nIHdpdGhpbiB0aGUgc2FtZSBzZWNvbmQuXG5cdFx0VGhlIHNhbWUgZ29lcyBmb3IgNGZwcywgMTBmcHMgZXRjLlxuXHRcblx0XHRAcHJvdGVjdGVkXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5TY2hlZHVsZXIucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoZGVsdGEpe1xuXHRcdHRoaXMuX3RpY2tzKys7XG5cdFx0dGhpcy5fZHQgPSBkZWx0YTtcblx0XHRcblx0XHR2YXIgZnBzID0gdGhpcy5fZnBzO1xuXHRcdFxuXHRcdGlmIChmcHMgPT0gNjApIHtcblx0XHRcdHRoaXMuX21hcmtlZCA9IHRydWU7XG5cdFx0fSBlbHNlIGlmIChmcHMgPT0gMzApIHtcblx0XHRcdGlmICh0aGlzLl90aWNrcyAlIDIpIHsgdGhpcy5fbWFya2VkID0gdHJ1ZSB9O1xuXHRcdH0gZWxzZSBpZiAoZnBzKSB7XG5cdFx0XHQvLyBpZiBpdCBpcyBsZXNzIHJvdW5kIC0gd2UgdHJpZ2dlciBiYXNlZFxuXHRcdFx0Ly8gb24gZGF0ZSwgZm9yIGNvbnNpc3RlbnQgcmVuZGVyaW5nLlxuXHRcdFx0Ly8gaWUsIGlmIHlvdSB3YW50IHRvIHJlbmRlciBldmVyeSBzZWNvbmRcblx0XHRcdC8vIGl0IGlzIGltcG9ydGFudCB0aGF0IG5vIHR3byByZW5kZXJzXG5cdFx0XHQvLyBoYXBwZW4gZHVyaW5nIHRoZSBzYW1lIHNlY29uZCAoYWNjb3JkaW5nIHRvIERhdGUpXG5cdFx0XHR2YXIgcGVyaW9kID0gKCg2MCAvIGZwcykgLyA2MCkgKiAxMDAwO1xuXHRcdFx0dmFyIGJlYXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyBwZXJpb2QpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5fYmVhdCAhPSBiZWF0KSB7XG5cdFx0XHRcdHRoaXMuX2JlYXQgPSBiZWF0O1xuXHRcdFx0XHR0aGlzLl9tYXJrZWQgPSB0cnVlO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh0aGlzLl9tYXJrZWQpIHRoaXMuZmx1c2goKTtcblx0XHQvLyByZXNjaGVkdWxlIGlmIEBhY3RpdmVcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0U3RhcnQgdGhlIHNjaGVkdWxlciBpZiBpdCBpcyBub3QgYWxyZWFkeSBhY3RpdmUuXG5cdFx0KipXaGlsZSBhY3RpdmUqKiwgdGhlIHNjaGVkdWxlciB3aWxsIG92ZXJyaWRlIGB0YXJnZXQuY29tbWl0YFxuXHRcdHRvIGRvIG5vdGhpbmcuIEJ5IGRlZmF1bHQgSW1iYS50YWcjY29tbWl0IGNhbGxzIHJlbmRlciwgc29cblx0XHR0aGF0IHJlbmRlcmluZyBpcyBjYXNjYWRlZCB0aHJvdWdoIHRvIGNoaWxkcmVuIHdoZW4gcmVuZGVyaW5nXG5cdFx0YSBub2RlLiBXaGVuIGEgc2NoZWR1bGVyIGlzIGFjdGl2ZSAoZm9yIGEgbm9kZSksIEltYmEgZGlzYWJsZXNcblx0XHR0aGlzIGF1dG9tYXRpYyByZW5kZXJpbmcuXG5cdFx0Ki9cblx0XG5cdEltYmEuU2NoZWR1bGVyLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICghdGhpcy5fYWN0aXZlKSB7XG5cdFx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlO1xuXHRcdFx0Ly8gb3ZlcnJpZGUgdGFyZ2V0I2NvbW1pdCB3aGlsZSB0aGlzIGlzIGFjdGl2ZVxuXHRcdFx0dGhpcy5fY29tbWl0ID0gdGhpcy5fdGFyZ2V0LmNvbW1pdDtcblx0XHRcdHRoaXMuX3RhcmdldC5jb21taXQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XHRJbWJhLnNjaGVkdWxlKHRoaXMpO1xuXHRcdFx0aWYgKHRoaXMuX2V2ZW50cykgeyBJbWJhLmxpc3RlbihJbWJhLCdldmVudCcsdGhpcywnb25ldmVudCcpIH07XG5cdFx0XHR0aGlzLl90YXJnZXQgJiYgdGhpcy5fdGFyZ2V0LmZsYWcgICYmICB0aGlzLl90YXJnZXQuZmxhZygnc2NoZWR1bGVkXycpO1xuXHRcdFx0dGhpcy50aWNrKDApOyAvLyBzdGFydCB0aWNraW5nXG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0U3RvcCB0aGUgc2NoZWR1bGVyIGlmIGl0IGlzIGFjdGl2ZS5cblx0XHQqL1xuXHRcblx0SW1iYS5TY2hlZHVsZXIucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fYWN0aXZlKSB7XG5cdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3RhcmdldC5jb21taXQgPSB0aGlzLl9jb21taXQ7XG5cdFx0XHRJbWJhLnVuc2NoZWR1bGUodGhpcyk7XG5cdFx0XHRJbWJhLnVubGlzdGVuKEltYmEsJ2V2ZW50Jyx0aGlzKTtcblx0XHRcdHRoaXMuX3RhcmdldCAmJiB0aGlzLl90YXJnZXQudW5mbGFnICAmJiAgdGhpcy5fdGFyZ2V0LnVuZmxhZygnc2NoZWR1bGVkXycpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlNjaGVkdWxlci5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fbWFya2VyO1xuXHR9O1xuXHRcblx0SW1iYS5TY2hlZHVsZXIucHJvdG90eXBlLm9uZXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpe1xuXHRcdHZhciAkMTtcblx0XHRpZiAodGhpcy5fbWFya2VkKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XG5cdFx0aWYgKHRoaXMuX2V2ZW50cyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRpZiAodGhpcy5fZXZlbnRzKGV2ZW50KSkgdGhpcy5tYXJrKCk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLl9ldmVudHMgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0aWYgKGlkeCQoKCQxID0gZXZlbnQpICYmICQxLnR5cGUgICYmICAkMS50eXBlKCksdGhpcy5fZXZlbnRzKSA+PSAwKSB0aGlzLm1hcmsoKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuX2V2ZW50cykge1xuXHRcdFx0aWYgKGV2ZW50Ll9yZXNwb25kZXIpIHRoaXMubWFyaygpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdHJldHVybiBJbWJhLlNjaGVkdWxlcjtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9saWIvaW1iYS9zY2hlZHVsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaWR4JChhLGIpe1xuXHRcdHJldHVybiAoYiAmJiBiLmluZGV4T2YpID8gYi5pbmRleE9mKGEpIDogW10uaW5kZXhPZi5jYWxsKGEsYik7XG5cdH07XG5cdFxuXHRJbWJhLnN0YXRpYyA9IGZ1bmN0aW9uIChpdGVtcyxucil7XG5cdFx0aXRlbXMuc3RhdGljID0gbnI7XG5cdFx0cmV0dXJuIGl0ZW1zO1xuXHR9O1xuXHRcblx0Lypcblx0VGhpcyBpcyB0aGUgYmFzZWNsYXNzIHRoYXQgYWxsIHRhZ3MgaW4gaW1iYSBpbmhlcml0IGZyb20uXG5cdEBpbmFtZSBub2RlXG5cdCovXG5cdFxuXHRJbWJhLlRhZyA9IGZ1bmN0aW9uIFRhZyhkb20pe1xuXHRcdHRoaXMuc2V0RG9tKGRvbSk7XG5cdH07XG5cdFxuXHRJbWJhLlRhZy5jcmVhdGVOb2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhyb3cgXCJOb3QgaW1wbGVtZW50ZWRcIjtcblx0fTtcblx0XG5cdEltYmEuVGFnLmJ1aWxkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIG5ldyB0aGlzKHRoaXMuY3JlYXRlTm9kZSgpKTtcblx0fTtcblx0XG5cdFxuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLm9iamVjdCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fb2JqZWN0OyB9XG5cdEltYmEuVGFnLnByb3RvdHlwZS5zZXRPYmplY3QgPSBmdW5jdGlvbih2KXsgdGhpcy5fb2JqZWN0ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuZG9tID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2RvbTtcblx0fTtcblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5zZXREb20gPSBmdW5jdGlvbiAoZG9tKXtcblx0XHRkb20uX3RhZyA9IHRoaXM7XG5cdFx0dGhpcy5fZG9tID0gZG9tO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRTZXR0aW5nIHJlZmVyZW5jZXMgZm9yIHRhZ3MgbGlrZVxuXHRcdGA8ZGl2QGhlYWRlcj5gIHdpbGwgY29tcGlsZSB0byBgdGFnKCdkaXYnKS5zZXRSZWYoJ2hlYWRlcicsdGhpcykuZW5kKClgXG5cdFx0QnkgZGVmYXVsdCBpdCBhZGRzIHRoZSByZWZlcmVuY2UgYXMgYSBjbGFzc05hbWUgdG8gdGhlIHRhZy5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2V0UmVmID0gZnVuY3Rpb24gKHJlZixjdHgpe1xuXHRcdHRoaXMuZmxhZyh0aGlzLl9yZWYgPSByZWYpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRNZXRob2QgdGhhdCBpcyBjYWxsZWQgYnkgdGhlIGNvbXBpbGVkIHRhZy1jaGFpbnMsIGZvclxuXHRcdGJpbmRpbmcgZXZlbnRzIG9uIHRhZ3MgdG8gbWV0aG9kcyBldGMuXG5cdFx0YDxhIDp0YXA9Zm4+YCBjb21waWxlcyB0byBgdGFnKCdhJykuc2V0SGFuZGxlcigndGFwJyxmbix0aGlzKS5lbmQoKWBcblx0XHR3aGVyZSB0aGlzIHJlZmVycyB0byB0aGUgY29udGV4dCBpbiB3aGljaCB0aGUgdGFnIGlzIGNyZWF0ZWQuXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnNldEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQsaGFuZGxlcixjdHgpe1xuXHRcdHZhciBrZXkgPSAnb24nICsgZXZlbnQ7XG5cdFx0XG5cdFx0aWYgKGhhbmRsZXIgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0dGhpc1trZXldID0gaGFuZGxlcjtcblx0XHR9IGVsc2UgaWYgKGhhbmRsZXIgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0dmFyIGZuID0gaGFuZGxlci5zaGlmdCgpO1xuXHRcdFx0dGhpc1trZXldID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gY3R4W2ZuXS5hcHBseShjdHgsaGFuZGxlci5jb25jYXQoZSkpOyB9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzW2tleV0gPSBmdW5jdGlvbihlKSB7IHJldHVybiBjdHhbaGFuZGxlcl0oZSk7IH07XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5zZXRJZCA9IGZ1bmN0aW9uIChpZCl7XG5cdFx0dGhpcy5kb20oKS5pZCA9IGlkO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuZG9tKCkuaWQ7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEFkZHMgYSBuZXcgYXR0cmlidXRlIG9yIGNoYW5nZXMgdGhlIHZhbHVlIG9mIGFuIGV4aXN0aW5nIGF0dHJpYnV0ZVxuXHRcdG9uIHRoZSBzcGVjaWZpZWQgdGFnLiBJZiB0aGUgdmFsdWUgaXMgbnVsbCBvciBmYWxzZSwgdGhlIGF0dHJpYnV0ZVxuXHRcdHdpbGwgYmUgcmVtb3ZlZC5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUsdmFsdWUpe1xuXHRcdC8vIHNob3VsZCB0aGlzIG5vdCByZXR1cm4gc2VsZj9cblx0XHR2YXIgb2xkID0gdGhpcy5kb20oKS5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cdFx0XG5cdFx0aWYgKG9sZCA9PSB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UpIHtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnNldEF0dHJpYnV0ZShuYW1lLHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdH07XG5cdH07XG5cdFxuXHQvKlxuXHRcdHJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gdGhlIHNwZWNpZmllZCB0YWdcblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lKXtcblx0XHRyZXR1cm4gdGhpcy5kb20oKS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdH07XG5cdFxuXHQvKlxuXHRcdHJldHVybnMgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvbiB0aGUgdGFnLlxuXHRcdElmIHRoZSBnaXZlbiBhdHRyaWJ1dGUgZG9lcyBub3QgZXhpc3QsIHRoZSB2YWx1ZSByZXR1cm5lZFxuXHRcdHdpbGwgZWl0aGVyIGJlIG51bGwgb3IgXCJcIiAodGhlIGVtcHR5IHN0cmluZylcblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lKXtcblx0XHRyZXR1cm4gdGhpcy5kb20oKS5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cdH07XG5cdFxuXHQvKlxuXHRcdE92ZXJyaWRlIHRoaXMgdG8gcHJvdmlkZSBzcGVjaWFsIHdyYXBwaW5nIGV0Yy5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50LHR5cGUpe1xuXHRcdHRoaXMuc2V0Q2hpbGRyZW4oY29udGVudCx0eXBlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0U2V0IHRoZSBjaGlsZHJlbiBvZiBub2RlLiB0eXBlIHBhcmFtIGlzIG9wdGlvbmFsLFxuXHRcdGFuZCBzaG91bGQgb25seSBiZSB1c2VkIGJ5IEltYmEgd2hlbiBjb21waWxpbmcgdGFnIHRyZWVzLiBcblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAobm9kZXMsdHlwZSl7XG5cdFx0dGhyb3cgXCJOb3QgaW1wbGVtZW50ZWRcIjtcblx0fTtcblx0XG5cdC8qXG5cdFx0R2V0IHRleHQgb2Ygbm9kZS4gVXNlcyB0ZXh0Q29udGVudCBiZWhpbmQgdGhlIHNjZW5lcyAobm90IGlubmVyVGV4dClcblx0XHRbaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUvdGV4dENvbnRlbnRdKClcblx0XHRAcmV0dXJuIHtzdHJpbmd9IGlubmVyIHRleHQgb2Ygbm9kZVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uICh2KXtcblx0XHRyZXR1cm4gdGhpcy5fZG9tLnRleHRDb250ZW50O1xuXHR9O1xuXHRcblx0Lypcblx0XHRTZXQgdGV4dCBvZiBub2RlLiBVc2VzIHRleHRDb250ZW50IGJlaGluZCB0aGUgc2NlbmVzIChub3QgaW5uZXJUZXh0KVxuXHRcdFtodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS90ZXh0Q29udGVudF0oKVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uICh0eHQpe1xuXHRcdHRoaXMuX2VtcHR5ID0gZmFsc2U7XG5cdFx0dGhpcy5fZG9tLnRleHRDb250ZW50ID0gdHh0ID09IG51bGwgPyAodHh0ID0gXCJcIikgOiAodHh0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHQvKlxuXHRcdE1ldGhvZCBmb3IgZ2V0dGluZyBhbmQgc2V0dGluZyBkYXRhLWF0dHJpYnV0ZXMuIFdoZW4gY2FsbGVkIHdpdGggemVyb1xuXHRcdGFyZ3VtZW50cyBpdCB3aWxsIHJldHVybiB0aGUgYWN0dWFsIGRhdGFzZXQgZm9yIHRoZSB0YWcuXG5cdFxuXHRcdFx0dmFyIG5vZGUgPSA8ZGl2IGRhdGEtbmFtZT0naGVsbG8nPlxuXHRcdFx0IyBnZXQgdGhlIHdob2xlIGRhdGFzZXRcblx0XHRcdG5vZGUuZGF0YXNldCAjIHtuYW1lOiAnaGVsbG8nfVxuXHRcdFx0IyBnZXQgYSBzaW5nbGUgdmFsdWVcblx0XHRcdG5vZGUuZGF0YXNldCgnbmFtZScpICMgJ2hlbGxvJ1xuXHRcdFx0IyBzZXQgYSBzaW5nbGUgdmFsdWVcblx0XHRcdG5vZGUuZGF0YXNldCgnbmFtZScsJ25ld25hbWUnKSAjIHNlbGZcblx0XG5cdFxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuZGF0YXNldCA9IGZ1bmN0aW9uIChrZXksdmFsKXtcblx0XHR0aHJvdyBcIk5vdCBpbXBsZW1lbnRlZFwiO1xuXHR9O1xuXHRcblx0Lypcblx0XHRFbXB0eSBwbGFjZWhvbGRlci4gT3ZlcnJpZGUgdG8gaW1wbGVtZW50IGN1c3RvbSByZW5kZXIgYmVoYXZpb3VyLlxuXHRcdFdvcmtzIG11Y2ggbGlrZSB0aGUgZmFtaWxpYXIgcmVuZGVyLW1ldGhvZCBpbiBSZWFjdC5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdENhbGxlZCBpbXBsaWNpdGx5IHRocm91Z2ggSW1iYS5UYWcjZW5kLCB1cG9uIGNyZWF0aW5nIGEgdGFnLiBBbGxcblx0XHRwcm9wZXJ0aWVzIHdpbGwgaGF2ZSBiZWVuIHNldCBiZWZvcmUgYnVpbGQgaXMgY2FsbGVkLCBpbmNsdWRpbmdcblx0XHRzZXRDb250ZW50LlxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdENhbGxlZCBpbXBsaWNpdGx5IHRocm91Z2ggSW1iYS5UYWcjZW5kLCBmb3IgdGFncyB0aGF0IGFyZSBwYXJ0IG9mXG5cdFx0YSB0YWcgdHJlZSAodGhhdCBhcmUgcmVuZGVyZWQgc2V2ZXJhbCB0aW1lcykuXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLmNvbW1pdCA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcblx0XHRDYWxsZWQgYnkgdGhlIHRhZy1zY2hlZHVsZXIgKGlmIHRoaXMgdGFnIGlzIHNjaGVkdWxlZClcblx0XHRCeSBkZWZhdWx0IGl0IHdpbGwgY2FsbCB0aGlzLnJlbmRlci4gRG8gbm90IG92ZXJyaWRlIHVubGVzc1xuXHRcdHlvdSByZWFsbHkgdW5kZXJzdGFuZCBpdC5cblx0XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5yZW5kZXIoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0XG5cdFx0QSB2ZXJ5IGltcG9ydGFudCBtZXRob2QgdGhhdCB5b3Ugd2lsbCBwcmFjdGljYWxseSBuZXZlciBtYW51YWxseS5cblx0XHRUaGUgdGFnIHN5bnRheCBvZiBJbWJhIGNvbXBpbGVzIHRvIGEgY2hhaW4gb2Ygc2V0dGVycywgd2hpY2ggYWx3YXlzXG5cdFx0ZW5kcyB3aXRoIC5lbmQuIGA8YS5sYXJnZT5gIGNvbXBpbGVzIHRvIGB0YWcoJ2EnKS5mbGFnKCdsYXJnZScpLmVuZCgpYFxuXHRcdFxuXHRcdFlvdSBhcmUgaGlnaGx5IGFkdmljZWQgdG8gbm90IG92ZXJyaWRlIGl0cyBiZWhhdmlvdXIuIFRoZSBmaXJzdCB0aW1lXG5cdFx0ZW5kIGlzIGNhbGxlZCBpdCB3aWxsIG1hcmsgdGhlIHRhZyBhcyBidWlsdCBhbmQgY2FsbCBJbWJhLlRhZyNidWlsZCxcblx0XHRhbmQgY2FsbCBJbWJhLlRhZyNjb21taXQgb24gc3Vic2VxdWVudCBjYWxscy5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX2J1aWx0KSB7XG5cdFx0XHR0aGlzLmNvbW1pdCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9idWlsdCA9IHRydWU7XG5cdFx0XHR0aGlzLmJ1aWxkKCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0VGhpcyBpcyBjYWxsZWQgaW5zdGVhZCBvZiBJbWJhLlRhZyNlbmQgZm9yIGA8c2VsZj5gIHRhZyBjaGFpbnMuXG5cdFx0RGVmYXVsdHMgdG8gbm9vcFxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5zeW5jZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIGNhbGxlZCB3aGVuIHRoZSBub2RlIGlzIGF3YWtlbmVkIGluIHRoZSBkb20gLSBlaXRoZXIgYXV0b21hdGljYWxseVxuXHQvLyB1cG9uIGF0dGFjaG1lbnQgdG8gdGhlIGRvbS10cmVlLCBvciB0aGUgZmlyc3QgdGltZSBpbWJhIG5lZWRzIHRoZVxuXHQvLyB0YWcgZm9yIGEgZG9tbm9kZSB0aGF0IGhhcyBiZWVuIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXJcblx0SW1iYS5UYWcucHJvdG90eXBlLmF3YWtlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRMaXN0IG9mIGZsYWdzIGZvciB0aGlzIG5vZGUuIFxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuZmxhZ3MgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fZG9tLmNsYXNzTGlzdDtcblx0fTtcblx0XG5cdC8qXG5cdFx0QWRkIHNwZWZpY2llZCBmbGFnIHRvIGN1cnJlbnQgbm9kZS5cblx0XHRJZiBhIHNlY29uZCBhcmd1bWVudCBpcyBzdXBwbGllZCwgaXQgd2lsbCBiZSBjb2VyY2VkIGludG8gYSBCb29sZWFuLFxuXHRcdGFuZCB1c2VkIHRvIGluZGljYXRlIHdoZXRoZXIgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgZmxhZyBpbnN0ZWFkLlxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5mbGFnID0gZnVuY3Rpb24gKG5hbWUsdG9nZ2xlcil7XG5cdFx0Ly8gaXQgaXMgbW9zdCBuYXR1cmFsIHRvIHRyZWF0IGEgc2Vjb25kIHVuZGVmaW5lZCBhcmd1bWVudCBhcyBhIG5vLXN3aXRjaFxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgdGhlIGFyZ3VtZW50cy1sZW5ndGhcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyICYmICF0b2dnbGVyKSB7XG5cdFx0XHR0aGlzLl9kb20uY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZG9tLmNsYXNzTGlzdC5hZGQobmFtZSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0UmVtb3ZlIHNwZWNpZmllZCBmbGFnIGZyb20gbm9kZVxuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS51bmZsYWcgPSBmdW5jdGlvbiAobmFtZSl7XG5cdFx0dGhpcy5fZG9tLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFRvZ2dsZSBzcGVjaWZpZWQgZmxhZyBvbiBub2RlXG5cdFx0QHJldHVybiB7c2VsZn1cblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnRvZ2dsZUZsYWcgPSBmdW5jdGlvbiAobmFtZSl7XG5cdFx0dGhpcy5fZG9tLmNsYXNzTGlzdC50b2dnbGUobmFtZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdENoZWNrIHdoZXRoZXIgY3VycmVudCBub2RlIGhhcyBzcGVjaWZpZWQgZmxhZ1xuXHRcdEByZXR1cm4ge2Jvb2x9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5oYXNGbGFnID0gZnVuY3Rpb24gKG5hbWUpe1xuXHRcdHJldHVybiB0aGlzLl9kb20uY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xuXHR9O1xuXHRcblx0Lypcblx0XHRHZXQgdGhlIHNjaGVkdWxlciBmb3IgdGhpcyBub2RlLiBBIG5ldyBzY2hlZHVsZXIgd2lsbCBiZSBjcmVhdGVkXG5cdFx0aWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cblx0XG5cdFx0QHJldHVybiB7SW1iYS5TY2hlZHVsZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5zY2hlZHVsZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fc2NoZWR1bGVyID09IG51bGwgPyAodGhpcy5fc2NoZWR1bGVyID0gbmV3IEltYmEuU2NoZWR1bGVyKHRoaXMpKSA6ICh0aGlzLl9zY2hlZHVsZXIpO1xuXHR9O1xuXHRcblx0Lypcblx0XG5cdFx0U2hvcnRoYW5kIHRvIHN0YXJ0IHNjaGVkdWxpbmcgYSBub2RlLiBUaGUgbWV0aG9kIHdpbGwgYmFzaWNhbGx5XG5cdFx0cHJveHkgdGhlIGFyZ3VtZW50cyB0aHJvdWdoIHRvIHNjaGVkdWxlci5jb25maWd1cmUsIGFuZCB0aGVuXG5cdFx0YWN0aXZhdGUgdGhlIHNjaGVkdWxlci5cblx0XHRcblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRhZy5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAob3B0aW9ucyl7XG5cdFx0aWYob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSBvcHRpb25zID0ge307XG5cdFx0dGhpcy5zY2hlZHVsZXIoKS5jb25maWd1cmUob3B0aW9ucykuYWN0aXZhdGUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0U2hvcnRoYW5kIGZvciBkZWFjdGl2YXRpbmcgc2NoZWR1bGVyIChpZiB0YWcgaGFzIG9uZSkuXG5cdFx0QGRlcHJlY2F0ZWRcblx0XHQqL1xuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLnVuc2NoZWR1bGUgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fc2NoZWR1bGVyKSB7IHRoaXMuc2NoZWR1bGVyKCkuZGVhY3RpdmF0ZSgpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0Lypcblx0XHRHZXQgdGhlIHBhcmVudCBvZiBjdXJyZW50IG5vZGVcblx0XHRAcmV0dXJuIHtJbWJhLlRhZ30gXG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGFnJHdyYXAodGhpcy5kb20oKS5wYXJlbnROb2RlKTtcblx0fTtcblx0XG5cdC8qXG5cdFx0U2hvcnRoYW5kIGZvciBjb25zb2xlLmxvZyBvbiBlbGVtZW50c1xuXHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVGFnLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgJDAgPSBhcmd1bWVudHMsIGkgPSAkMC5sZW5ndGg7XG5cdFx0dmFyIGFyZ3MgPSBuZXcgQXJyYXkoaT4wID8gaSA6IDApO1xuXHRcdHdoaWxlKGk+MCkgYXJnc1tpLTFdID0gJDBbLS1pXTtcblx0XHRhcmdzLnVuc2hpZnQoY29uc29sZSk7XG5cdFx0RnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYXBwbHkoY29uc29sZS5sb2csYXJncyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0SW1iYS5UYWcucHJvdG90eXBlLmluaXRpYWxpemUgPSBJbWJhLlRhZztcblx0XG5cdEhUTUxfVEFHUyA9IFwiYSBhYmJyIGFkZHJlc3MgYXJlYSBhcnRpY2xlIGFzaWRlIGF1ZGlvIGIgYmFzZSBiZGkgYmRvIGJpZyBibG9ja3F1b3RlIGJvZHkgYnIgYnV0dG9uIGNhbnZhcyBjYXB0aW9uIGNpdGUgY29kZSBjb2wgY29sZ3JvdXAgZGF0YSBkYXRhbGlzdCBkZCBkZWwgZGV0YWlscyBkZm4gZGl2IGRsIGR0IGVtIGVtYmVkIGZpZWxkc2V0IGZpZ2NhcHRpb24gZmlndXJlIGZvb3RlciBmb3JtIGgxIGgyIGgzIGg0IGg1IGg2IGhlYWQgaGVhZGVyIGhyIGh0bWwgaSBpZnJhbWUgaW1nIGlucHV0IGlucyBrYmQga2V5Z2VuIGxhYmVsIGxlZ2VuZCBsaSBsaW5rIG1haW4gbWFwIG1hcmsgbWVudSBtZW51aXRlbSBtZXRhIG1ldGVyIG5hdiBub3NjcmlwdCBvYmplY3Qgb2wgb3B0Z3JvdXAgb3B0aW9uIG91dHB1dCBwIHBhcmFtIHByZSBwcm9ncmVzcyBxIHJwIHJ0IHJ1YnkgcyBzYW1wIHNjcmlwdCBzZWN0aW9uIHNlbGVjdCBzbWFsbCBzb3VyY2Ugc3BhbiBzdHJvbmcgc3R5bGUgc3ViIHN1bW1hcnkgc3VwIHRhYmxlIHRib2R5IHRkIHRleHRhcmVhIHRmb290IHRoIHRoZWFkIHRpbWUgdGl0bGUgdHIgdHJhY2sgdSB1bCB2YXIgdmlkZW8gd2JyXCIuc3BsaXQoXCIgXCIpO1xuXHRIVE1MX1RBR1NfVU5TQUZFID0gXCJhcnRpY2xlIGFzaWRlIGhlYWRlciBzZWN0aW9uXCIuc3BsaXQoXCIgXCIpO1xuXHRTVkdfVEFHUyA9IFwiY2lyY2xlIGRlZnMgZWxsaXBzZSBnIGxpbmUgbGluZWFyR3JhZGllbnQgbWFzayBwYXRoIHBhdHRlcm4gcG9seWdvbiBwb2x5bGluZSByYWRpYWxHcmFkaWVudCByZWN0IHN0b3Agc3ZnIHRleHQgdHNwYW5cIi5zcGxpdChcIiBcIik7XG5cdFxuXHRcblx0ZnVuY3Rpb24gZXh0ZW5kZXIob2JqLHN1cCl7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhzdXApLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspe1xuXHRcdFx0b2JqWygkMSA9IGtleXNbaV0pXSA9PSBudWxsID8gKG9ialskMV0gPSBzdXBba2V5c1tpXV0pIDogKG9ialskMV0pO1xuXHRcdH07XG5cdFx0XG5cdFx0b2JqLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwLnByb3RvdHlwZSk7XG5cdFx0b2JqLl9fc3VwZXJfXyA9IG9iai5wcm90b3R5cGUuX19zdXBlcl9fID0gc3VwLnByb3RvdHlwZTtcblx0XHRvYmoucHJvdG90eXBlLmluaXRpYWxpemUgPSBvYmoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gb2JqO1xuXHRcdGlmIChzdXAuaW5oZXJpdCkgeyBzdXAuaW5oZXJpdChvYmopIH07XG5cdFx0cmV0dXJuIG9iajtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIFRhZygpe1xuXHRcdHJldHVybiBmdW5jdGlvbihkb20pIHtcblx0XHRcdHRoaXMuc2V0RG9tKGRvbSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gVGFnU3Bhd25lcih0eXBlKXtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiB0eXBlLmJ1aWxkKCk7IH07XG5cdH07XG5cdFxuXHRJbWJhLlRhZ3MgPSBmdW5jdGlvbiBUYWdzKCl7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdEltYmEuVGFncy5wcm90b3R5cGUuX19jbG9uZSA9IGZ1bmN0aW9uIChucyl7XG5cdFx0dmFyIGNsb25lID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcblx0XHRjbG9uZS5fcGFyZW50ID0gdGhpcztcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH07XG5cdFxuXHRJbWJhLlRhZ3MucHJvdG90eXBlLmRlZmluZU5hbWVzcGFjZSA9IGZ1bmN0aW9uIChuYW1lKXtcblx0XHR2YXIgY2xvbmUgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuXHRcdGNsb25lLl9wYXJlbnQgPSB0aGlzO1xuXHRcdGNsb25lLl9ucyA9IG5hbWU7XG5cdFx0dGhpc1tuYW1lLnRvVXBwZXJDYXNlKCldID0gY2xvbmU7XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9O1xuXHRcblx0SW1iYS5UYWdzLnByb3RvdHlwZS5iYXNlVHlwZSA9IGZ1bmN0aW9uIChuYW1lKXtcblx0XHRyZXR1cm4gaWR4JChuYW1lLEhUTUxfVEFHUykgPj0gMCA/ICgnaHRtbGVsZW1lbnQnKSA6ICgnZGl2Jyk7XG5cdH07XG5cdFxuXHRJbWJhLlRhZ3MucHJvdG90eXBlLmRlZmluZVRhZyA9IGZ1bmN0aW9uIChuYW1lLHN1cHIsYm9keSl7XG5cdFx0aWYoYm9keT09dW5kZWZpbmVkICYmIHR5cGVvZiBzdXByID09ICdmdW5jdGlvbicpIGJvZHkgPSBzdXByLHN1cHIgPSAnJztcblx0XHRpZihzdXByPT11bmRlZmluZWQpIHN1cHIgPSAnJztcblx0XHRzdXByIHx8IChzdXByID0gdGhpcy5iYXNlVHlwZShuYW1lKSk7XG5cdFx0dmFyIHN1cGVydHlwZSA9IHRoaXNbc3Vwcl07XG5cdFx0dmFyIHRhZ3R5cGUgPSBUYWcoKTtcblx0XHR2YXIgbm9ybSA9IG5hbWUucmVwbGFjZSgvXFwtL2csJ18nKTtcblx0XHRcblx0XHRcblx0XHR0YWd0eXBlLl9uYW1lID0gbmFtZTtcblx0XHRleHRlbmRlcih0YWd0eXBlLHN1cGVydHlwZSk7XG5cdFx0XG5cdFx0aWYgKG5hbWVbMF0gPT0gJyMnKSB7XG5cdFx0XHR0aGlzW25hbWVdID0gdGFndHlwZTtcblx0XHRcdEltYmEuU0lOR0xFVE9OU1tuYW1lLnNsaWNlKDEpXSA9IHRhZ3R5cGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXNbbmFtZV0gPSB0YWd0eXBlO1xuXHRcdFx0dGhpc1snJCcgKyBub3JtXSA9IFRhZ1NwYXduZXIodGFndHlwZSk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoYm9keSkge1xuXHRcdFx0aWYgKGJvZHkubGVuZ3RoID09IDIpIHtcblx0XHRcdFx0Ly8gY3JlYXRlIGNsb25lXG5cdFx0XHRcdGlmICghdGFndHlwZS5oYXNPd25Qcm9wZXJ0eSgnVEFHUycpKSB7XG5cdFx0XHRcdFx0dGFndHlwZS5UQUdTID0gKHN1cGVydHlwZS5UQUdTIHx8IHRoaXMpLl9fY2xvbmUoKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGJvZHkuY2FsbCh0YWd0eXBlLHRhZ3R5cGUsdGFndHlwZS5UQUdTIHx8IHRoaXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRhZ3R5cGU7XG5cdH07XG5cdFxuXHRJbWJhLlRhZ3MucHJvdG90eXBlLmRlZmluZVNpbmdsZXRvbiA9IGZ1bmN0aW9uIChuYW1lLHN1cHIsYm9keSl7XG5cdFx0cmV0dXJuIHRoaXMuZGVmaW5lVGFnKG5hbWUsc3Vwcixib2R5KTtcblx0fTtcblx0XG5cdEltYmEuVGFncy5wcm90b3R5cGUuZXh0ZW5kVGFnID0gZnVuY3Rpb24gKG5hbWUsc3Vwcixib2R5KXtcblx0XHRpZihib2R5PT11bmRlZmluZWQgJiYgdHlwZW9mIHN1cHIgPT0gJ2Z1bmN0aW9uJykgYm9keSA9IHN1cHIsc3VwciA9ICcnO1xuXHRcdGlmKHN1cHI9PXVuZGVmaW5lZCkgc3VwciA9ICcnO1xuXHRcdHZhciBrbGFzcyA9ICgodHlwZW9mIG5hbWU9PSdzdHJpbmcnfHxuYW1lIGluc3RhbmNlb2YgU3RyaW5nKSA/ICh0aGlzW25hbWVdKSA6IChuYW1lKSk7XG5cdFx0Ly8gYWxsb3cgZm9yIHByaXZhdGUgdGFncyBoZXJlIGFzIHdlbGw/XG5cdFx0aWYgKGJvZHkpIHsgYm9keSAmJiBib2R5LmNhbGwoa2xhc3Msa2xhc3Msa2xhc3MucHJvdG90eXBlKSB9O1xuXHRcdHJldHVybiBrbGFzcztcblx0fTtcblx0XG5cdFxuXHRJbWJhLlRBR1MgPSBuZXcgSW1iYS5UYWdzKCk7XG5cdEltYmEuVEFHUy5lbGVtZW50ID0gSW1iYS5UYWc7XG5cdFxuXHR2YXIgc3ZnID0gSW1iYS5UQUdTLmRlZmluZU5hbWVzcGFjZSgnc3ZnJyk7XG5cdFxuXHRzdmcuYmFzZVR5cGUgPSBmdW5jdGlvbiAobmFtZSl7XG5cdFx0cmV0dXJuICdzdmdlbGVtZW50Jztcblx0fTtcblx0XG5cdFxuXHRJbWJhLlNJTkdMRVRPTlMgPSB7fTtcblx0XG5cdFxuXHRJbWJhLmRlZmluZVRhZyA9IGZ1bmN0aW9uIChuYW1lLHN1cHIsYm9keSl7XG5cdFx0aWYoYm9keT09dW5kZWZpbmVkICYmIHR5cGVvZiBzdXByID09ICdmdW5jdGlvbicpIGJvZHkgPSBzdXByLHN1cHIgPSAnJztcblx0XHRpZihzdXByPT11bmRlZmluZWQpIHN1cHIgPSAnJztcblx0XHRyZXR1cm4gSW1iYS5UQUdTLmRlZmluZVRhZyhuYW1lLHN1cHIsYm9keSk7XG5cdH07XG5cdFxuXHRJbWJhLmRlZmluZVNpbmdsZXRvblRhZyA9IGZ1bmN0aW9uIChpZCxzdXByLGJvZHkpe1xuXHRcdGlmKGJvZHk9PXVuZGVmaW5lZCAmJiB0eXBlb2Ygc3VwciA9PSAnZnVuY3Rpb24nKSBib2R5ID0gc3VwcixzdXByID0gJ2Rpdic7XG5cdFx0aWYoc3Vwcj09dW5kZWZpbmVkKSBzdXByID0gJ2Rpdic7XG5cdFx0cmV0dXJuIEltYmEuVEFHUy5kZWZpbmVUYWcodGhpcy5uYW1lKCksc3Vwcixib2R5KTtcblx0fTtcblx0XG5cdEltYmEuZXh0ZW5kVGFnID0gZnVuY3Rpb24gKG5hbWUsYm9keSl7XG5cdFx0cmV0dXJuIEltYmEuVEFHUy5leHRlbmRUYWcobmFtZSxib2R5KTtcblx0fTtcblx0XG5cdEltYmEudGFnID0gZnVuY3Rpb24gKG5hbWUpe1xuXHRcdHZhciB0eXAgPSBJbWJhLlRBR1NbbmFtZV07XG5cdFx0aWYgKCF0eXApIHsgdGhyb3cgbmV3IEVycm9yKChcInRhZyBcIiArIG5hbWUgKyBcIiBpcyBub3QgZGVmaW5lZFwiKSkgfTtcblx0XHRyZXR1cm4gbmV3IHR5cCh0eXAuY3JlYXRlTm9kZSgpKTtcblx0fTtcblx0XG5cdEltYmEudGFnV2l0aElkID0gZnVuY3Rpb24gKG5hbWUsaWQpe1xuXHRcdHZhciB0eXAgPSBJbWJhLlRBR1NbbmFtZV07XG5cdFx0aWYgKCF0eXApIHsgdGhyb3cgbmV3IEVycm9yKChcInRhZyBcIiArIG5hbWUgKyBcIiBpcyBub3QgZGVmaW5lZFwiKSkgfTtcblx0XHR2YXIgZG9tID0gdHlwLmNyZWF0ZU5vZGUoKTtcblx0XHRkb20uaWQgPSBpZDtcblx0XHRyZXR1cm4gbmV3IHR5cChkb20pO1xuXHR9O1xuXHRcblx0Ly8gVE9ETzogQ2FuIHdlIG1vdmUgdGhlc2Ugb3V0IGFuZCBpbnRvIGRvbS5pbWJhIGluIGEgY2xlYW4gd2F5P1xuXHQvLyBUaGVzZSBtZXRob2RzIGRlcGVuZHMgb24gSW1iYS5kb2N1bWVudC5nZXRFbGVtZW50QnlJZFxuXHRcblx0SW1iYS5nZXRUYWdTaW5nbGV0b24gPSBmdW5jdGlvbiAoaWQpe1xuXHRcdHZhciBrbGFzcztcblx0XHR2YXIgZG9tLG5vZGU7XG5cdFx0XG5cdFx0aWYgKGtsYXNzID0gSW1iYS5TSU5HTEVUT05TW2lkXSkge1xuXHRcdFx0aWYgKGtsYXNzICYmIGtsYXNzLkluc3RhbmNlKSB7IHJldHVybiBrbGFzcy5JbnN0YW5jZSB9O1xuXHRcdFx0XG5cdFx0XHQvLyBubyBpbnN0YW5jZSAtIGNoZWNrIGZvciBlbGVtZW50XG5cdFx0XHRpZiAoZG9tID0gSW1iYS5kb2N1bWVudCgpLmdldEVsZW1lbnRCeUlkKGlkKSkge1xuXHRcdFx0XHQvLyB3ZSBoYXZlIGEgbGl2ZSBpbnN0YW5jZSAtIHdoZW4gZmluZGluZyBpdCB0aHJvdWdoIGEgc2VsZWN0b3Igd2Ugc2hvdWxkIGF3YWtlIGl0LCBubz9cblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ2NyZWF0aW5nIHRoZSBzaW5nbGV0b24gZnJvbSBleGlzdGluZyBub2RlIGluIGRvbT8nLGlkLHR5cGUpXG5cdFx0XHRcdG5vZGUgPSBrbGFzcy5JbnN0YW5jZSA9IG5ldyBrbGFzcyhkb20pO1xuXHRcdFx0XHRub2RlLmF3YWtlbihkb20pOyAvLyBzaG91bGQgb25seSBhd2FrZW5cblx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRkb20gPSBrbGFzcy5jcmVhdGVOb2RlKCk7XG5cdFx0XHRkb20uaWQgPSBpZDtcblx0XHRcdG5vZGUgPSBrbGFzcy5JbnN0YW5jZSA9IG5ldyBrbGFzcyhkb20pO1xuXHRcdFx0bm9kZS5lbmQoKS5hd2FrZW4oZG9tKTtcblx0XHRcdHJldHVybiBub2RlO1xuXHRcdH0gZWxzZSBpZiAoZG9tID0gSW1iYS5kb2N1bWVudCgpLmdldEVsZW1lbnRCeUlkKGlkKSkge1xuXHRcdFx0cmV0dXJuIEltYmEuZ2V0VGFnRm9yRG9tKGRvbSk7XG5cdFx0fTtcblx0fTtcblx0XG5cdHZhciBzdmdTdXBwb3J0ID0gdHlwZW9mIFNWR0VsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXHRcblx0SW1iYS5nZXRUYWdGb3JEb20gPSBmdW5jdGlvbiAoZG9tKXtcblx0XHR2YXIgbTtcblx0XHRpZiAoIWRvbSkgeyByZXR1cm4gbnVsbCB9O1xuXHRcdGlmIChkb20uX2RvbSkgeyByZXR1cm4gZG9tIH07IC8vIGNvdWxkIHVzZSBpbmhlcml0YW5jZSBpbnN0ZWFkXG5cdFx0aWYgKGRvbS5fdGFnKSB7IHJldHVybiBkb20uX3RhZyB9O1xuXHRcdGlmICghZG9tLm5vZGVOYW1lKSB7IHJldHVybiBudWxsIH07XG5cdFx0XG5cdFx0dmFyIG5zID0gbnVsbDtcblx0XHR2YXIgaWQgPSBkb20uaWQ7XG5cdFx0dmFyIHR5cGUgPSBkb20ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHR2YXIgdGFncyA9IEltYmEuVEFHUztcblx0XHR2YXIgbmF0aXZlJCA9IHR5cGU7XG5cdFx0dmFyIGNscyA9IGRvbS5jbGFzc05hbWU7XG5cdFx0XG5cdFx0aWYgKGlkICYmIEltYmEuU0lOR0xFVE9OU1tpZF0pIHtcblx0XHRcdC8vIEZJWE1FIGNvbnRyb2wgdGhhdCBpdCBpcyB0aGUgc2FtZSBzaW5nbGV0b24/XG5cdFx0XHQvLyBtaWdodCBjb2xsaWRlIC0tIG5vdCBnb29kP1xuXHRcdFx0cmV0dXJuIEltYmEuZ2V0VGFnU2luZ2xldG9uKGlkKTtcblx0XHR9O1xuXHRcdC8vIGxvb2sgZm9yIGlkIC0gc2luZ2xldG9uXG5cdFx0XG5cdFx0Ly8gbmVlZCBiZXR0ZXIgdGVzdCBoZXJlXG5cdFx0aWYgKHN2Z1N1cHBvcnQgJiYgKGRvbSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpKSB7XG5cdFx0XHRucyA9IFwic3ZnXCI7XG5cdFx0XHRjbHMgPSBkb20uY2xhc3NOYW1lLmJhc2VWYWw7XG5cdFx0XHR0YWdzID0gdGFncy5TVkc7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgc3Bhd25lcjtcblx0XHRcblx0XHRpZiAoY2xzKSB7XG5cdFx0XHQvLyB0aGVyZSBjYW4gYmUgc2V2ZXJhbCBtYXRjaGVzIGhlcmUgLSBzaG91bGQgY2hvb3NlIHRoZSBsYXN0XG5cdFx0XHQvLyBzaG91bGQgZmFsbCBiYWNrIHRvIGxlc3Mgc3BlY2lmaWMgbGF0ZXI/IC0gb3RoZXJ3aXNlIHRoaW5ncyBtYXkgZmFpbFxuXHRcdFx0Ly8gVE9ETyByZXdvcmsgdGhpc1xuXHRcdFx0aWYgKG0gPSBjbHMubWF0Y2goL1xcYl8oW2EtelxcLV0rKVxcYig/IVxccypfW2EtelxcLV0rKS8pKSB7XG5cdFx0XHRcdHR5cGUgPSBtWzFdOyAvLyAucmVwbGFjZSgvLS9nLCdfJylcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChtID0gY2xzLm1hdGNoKC9cXGIoW0EtWlxcLV0rKV9cXGIvKSkge1xuXHRcdFx0XHRucyA9IG1bMV07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0c3Bhd25lciA9IHRhZ3NbdHlwZV0gfHwgdGFnc1tuYXRpdmUkXTtcblx0XHRyZXR1cm4gc3Bhd25lciA/IChuZXcgc3Bhd25lcihkb20pLmF3YWtlbihkb20pKSA6IChudWxsKTtcblx0fTtcblx0XG5cdHRhZyQgPSBJbWJhLlRBR1M7XG5cdHQkID0gSW1iYS50YWc7XG5cdHRjJCA9IEltYmEudGFnV2l0aEZsYWdzO1xuXHR0aSQgPSBJbWJhLnRhZ1dpdGhJZDtcblx0dGljJCA9IEltYmEudGFnV2l0aElkQW5kRmxhZ3M7XG5cdGlkJCA9IEltYmEuZ2V0VGFnU2luZ2xldG9uO1xuXHRyZXR1cm4gdGFnJHdyYXAgPSBJbWJhLmdldFRhZ0ZvckRvbTtcblx0XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvdGFnLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdFxuXHRJbWJhLmRvY3VtZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHdpbmRvdy5kb2N1bWVudDtcblx0fTtcblx0XG5cdC8qXG5cdFJldHVybnMgdGhlIGJvZHkgZWxlbWVudCB3cmFwcGVkIGluIGFuIEltYmEuVGFnXG5cdCovXG5cdFxuXHRJbWJhLnJvb3QgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGFnJHdyYXAoSW1iYS5kb2N1bWVudCgpLmJvZHkpO1xuXHR9O1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2h0bWxlbGVtZW50JywgJ2VsZW1lbnQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRDYWxsZWQgd2hlbiBhIHRhZyB0eXBlIGlzIGJlaW5nIHN1YmNsYXNzZWQuXG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5pbmhlcml0ID0gZnVuY3Rpb24gKGNoaWxkKXtcblx0XHRcdGNoaWxkLnByb3RvdHlwZS5fZW1wdHkgPSB0cnVlO1xuXHRcdFx0Y2hpbGQuX3Byb3RvRG9tID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuX25vZGVUeXBlKSB7XG5cdFx0XHRcdGNoaWxkLl9ub2RlVHlwZSA9IHRoaXMuX25vZGVUeXBlO1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSA9IFwiX1wiICsgY2hpbGQuX25hbWUucmVwbGFjZSgvXy9nLCctJyk7XG5cdFx0XHRcdGlmIChjaGlsZC5fbmFtZVswXSAhPSAnIycpIHsgcmV0dXJuIGNoaWxkLl9jbGFzc2VzID0gdGhpcy5fY2xhc3Nlcy5jb25jYXQoY2xhc3NOYW1lKSB9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hpbGQuX25vZGVUeXBlID0gY2hpbGQuX25hbWU7XG5cdFx0XHRcdHJldHVybiBjaGlsZC5fY2xhc3NlcyA9IFtdO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5idWlsZE5vZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBkb20gPSBJbWJhLmRvY3VtZW50KCkuY3JlYXRlRWxlbWVudCh0aGlzLl9ub2RlVHlwZSk7XG5cdFx0XHR2YXIgY2xzID0gdGhpcy5fY2xhc3Nlcy5qb2luKFwiIFwiKTtcblx0XHRcdGlmIChjbHMpIHsgZG9tLmNsYXNzTmFtZSA9IGNscyB9O1xuXHRcdFx0cmV0dXJuIGRvbTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5jcmVhdGVOb2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgcHJvdG8gPSAodGhpcy5fcHJvdG9Eb20gfHwgKHRoaXMuX3Byb3RvRG9tID0gdGhpcy5idWlsZE5vZGUoKSkpO1xuXHRcdFx0cmV0dXJuIHByb3RvLmNsb25lTm9kZShmYWxzZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcuZG9tID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcHJvdG9Eb20gfHwgKHRoaXMuX3Byb3RvRG9tID0gdGhpcy5idWlsZE5vZGUoKSk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnaWQnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SWQgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2lkJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50YWJpbmRleCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFRhYmluZGV4ID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudGl0bGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd0aXRsZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUaXRsZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgndGl0bGUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvbGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdyb2xlJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJvbGUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tLm9mZnNldFdpZHRoO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9kb20ub2Zmc2V0SGVpZ2h0O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDaGlsZHJlbiA9IGZ1bmN0aW9uIChub2Rlcyx0eXBlKXtcblx0XHRcdHRoaXMuX2VtcHR5ID8gKHRoaXMuYXBwZW5kKG5vZGVzKSkgOiAodGhpcy5lbXB0eSgpLmFwcGVuZChub2RlcykpO1xuXHRcdFx0dGhpcy5fY2hpbGRyZW4gPSBudWxsO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0U2V0IGlubmVyIGh0bWwgb2Ygbm9kZVxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldEh0bWwgPSBmdW5jdGlvbiAoaHRtbCl7XG5cdFx0XHR0aGlzLl9kb20uaW5uZXJIVE1MID0gaHRtbDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdEdldCBpbm5lciBodG1sIG9mIG5vZGVcblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5odG1sID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tLmlubmVySFRNTDtcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRSZW1vdmUgYWxsIGNvbnRlbnQgaW5zaWRlIG5vZGVcblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0d2hpbGUgKHRoaXMuX2RvbS5maXJzdENoaWxkKXtcblx0XHRcdFx0dGhpcy5fZG9tLnJlbW92ZUNoaWxkKHRoaXMuX2RvbS5maXJzdENoaWxkKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLl9jaGlsZHJlbiA9IG51bGw7XG5cdFx0XHR0aGlzLl9lbXB0eSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRSZW1vdmUgc3BlY2lmaWVkIGNoaWxkIGZyb20gY3VycmVudCBub2RlLlxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChjaGlsZCl7XG5cdFx0XHR2YXIgcGFyID0gdGhpcy5kb20oKTtcblx0XHRcdHZhciBlbCA9IGNoaWxkICYmIGNoaWxkLmRvbSgpO1xuXHRcdFx0aWYgKGVsICYmIGVsLnBhcmVudE5vZGUgPT0gcGFyKSB7IHBhci5yZW1vdmVDaGlsZChlbCkgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKG5hbWUscGFycyl7XG5cdFx0XHRpZighcGFyc3x8cGFycy5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSBwYXJzID0ge307XG5cdFx0XHR2YXIgZGF0YSA9IHBhcnMuZGF0YSAhPT0gdW5kZWZpbmVkID8gcGFycy5kYXRhIDogbnVsbDtcblx0XHRcdHZhciBidWJibGUgPSBwYXJzLmJ1YmJsZSAhPT0gdW5kZWZpbmVkID8gcGFycy5idWJibGUgOiB0cnVlO1xuXHRcdFx0SW1iYS5FdmVudHMudHJpZ2dlcihuYW1lLHRoaXMse2RhdGE6IGRhdGEsYnViYmxlOiBidWJibGV9KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jc3MgPSBmdW5jdGlvbiAoa2V5LHZhbCl7XG5cdFx0XHRpZiAoa2V5IGluc3RhbmNlb2YgT2JqZWN0KSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMoa2V5KSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKXtcblx0XHRcdFx0XHR0aGlzLmNzcyhrZXlzW2ldLGtleVtrZXlzW2ldXSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKHZhbCA9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuZG9tKCkuc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcblx0XHRcdH0gZWxzZSBpZiAodmFsID09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5kb20oKS5zdHlsZVtrZXldO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCh0eXBlb2YgdmFsPT0nbnVtYmVyJ3x8dmFsIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBrZXkubWF0Y2goL3dpZHRofGhlaWdodHxsZWZ0fHJpZ2h0fHRvcHxib3R0b20vKSkge1xuXHRcdFx0XHRcdHZhbCA9IHZhbCArIFwicHhcIjtcblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5kb20oKS5zdHlsZVtrZXldID0gdmFsO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kYXRhc2V0ID0gZnVuY3Rpb24gKGtleSx2YWwpe1xuXHRcdFx0aWYgKGtleSBpbnN0YW5jZW9mIE9iamVjdCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKGtleSksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdFx0dGhpcy5kYXRhc2V0KGtleXNbaV0sa2V5W2tleXNbaV1dKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG5cdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKChcImRhdGEtXCIgKyBrZXkpLHZhbCk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGtleSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoKFwiZGF0YS1cIiArIGtleSkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmRvbSgpLmRhdGFzZXQ7XG5cdFx0XHRcblx0XHRcdGlmICghZGF0YXNldCkge1xuXHRcdFx0XHRkYXRhc2V0ID0ge307XG5cdFx0XHRcdGZvciAodmFyIGkxID0gMCwgYXJ5ID0gaXRlciQodGhpcy5kb20oKS5hdHRyaWJ1dGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgYXRyOyBpMSA8IGxlbjsgaTErKykge1xuXHRcdFx0XHRcdGF0ciA9IGFyeVtpMV07XG5cdFx0XHRcdFx0aWYgKGF0ci5uYW1lLnN1YnN0cigwLDUpID09ICdkYXRhLScpIHtcblx0XHRcdFx0XHRcdGRhdGFzZXRbSW1iYS50b0NhbWVsQ2FzZShhdHIubmFtZS5zbGljZSg1KSldID0gYXRyLnZhbHVlO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZGF0YXNldDtcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRHZXQgZGVzY2VuZGFudHMgb2YgY3VycmVudCBub2RlLCBvcHRpb25hbGx5IG1hdGNoaW5nIHNlbGVjdG9yXG5cdFx0XHRAcmV0dXJuIHtJbWJhLlNlbGVjdG9yfVxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHRcdHJldHVybiBuZXcgSW1iYS5TZWxlY3RvcihzZWwsdGhpcyk7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0R2V0IHRoZSBmaXJzdCBtYXRjaGluZyBjaGlsZCBvZiBub2RlXG5cdFx0XG5cdFx0XHRAcmV0dXJuIHtJbWJhLlRhZ31cblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5maXJzdCA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdFx0cmV0dXJuIHNlbCA/ICh0aGlzLmZpbmQoc2VsKS5maXJzdCgpKSA6ICh0YWckd3JhcCh0aGlzLmRvbSgpLmZpcnN0RWxlbWVudENoaWxkKSk7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0R2V0IHRoZSBsYXN0IG1hdGNoaW5nIGNoaWxkIG9mIG5vZGVcblx0XHRcblx0XHRcdFx0bm9kZS5sYXN0ICMgcmV0dXJucyB0aGUgbGFzdCBjaGlsZCBvZiBub2RlXG5cdFx0XHRcdG5vZGUubGFzdCAlc3BhbiAjIHJldHVybnMgdGhlIGxhc3Qgc3BhbiBpbnNpZGUgbm9kZVxuXHRcdFx0XHRub2RlLmxhc3QgZG8gfGVsfCBlbC50ZXh0ID09ICdIaScgIyByZXR1cm4gbGFzdCBub2RlIHdpdGggdGV4dCBIaVxuXHRcdFxuXHRcdFx0QHJldHVybiB7SW1iYS5UYWd9XG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdFx0cmV0dXJuIHNlbCA/ICh0aGlzLmZpbmQoc2VsKS5sYXN0KCkpIDogKHRhZyR3cmFwKHRoaXMuZG9tKCkubGFzdEVsZW1lbnRDaGlsZCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdEdldCB0aGUgY2hpbGQgYXQgaW5kZXhcblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uIChpKXtcblx0XHRcdHJldHVybiB0YWckd3JhcCh0aGlzLmRvbSgpLmNoaWxkcmVuW2kgfHwgMF0pO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdFx0dmFyIG5vZGVzID0gbmV3IEltYmEuU2VsZWN0b3IobnVsbCx0aGlzLHRoaXMuX2RvbS5jaGlsZHJlbik7XG5cdFx0XHRyZXR1cm4gc2VsID8gKG5vZGVzLmZpbHRlcihzZWwpKSA6IChub2Rlcyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ycGhhbml6ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHBhcjtcblx0XHRcdGlmIChwYXIgPSB0aGlzLmRvbSgpLnBhcmVudE5vZGUpIHsgcGFyLnJlbW92ZUNoaWxkKHRoaXMuX2RvbSkgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0XHR2YXIgZm47XG5cdFx0XHRpZiAoc2VsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdFx0cmV0dXJuIHNlbCh0aGlzKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChzZWwucXVlcnkpIHsgc2VsID0gc2VsLnF1ZXJ5KCkgfTtcblx0XHRcdGlmIChmbiA9ICh0aGlzLl9kb20ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IHRoaXMuX2RvbS5tYXRjaGVzKSkgeyByZXR1cm4gZm4uY2FsbCh0aGlzLl9kb20sc2VsKSB9O1xuXHRcdFx0Ly8gVE9ETyBzdXBwb3J0IG90aGVyIGJyb3dzZXJzIGV0Yz9cblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRHZXQgdGhlIGZpcnN0IGVsZW1lbnQgbWF0Y2hpbmcgc3VwcGxpZWQgc2VsZWN0b3IgLyBmaWx0ZXJcblx0XHRcdHRyYXZlcnNpbmcgdXB3YXJkcywgYnV0IGluY2x1ZGluZyB0aGUgbm9kZSBpdHNlbGYuXG5cdFx0XHRAcmV0dXJuIHtJbWJhLlRhZ31cblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0XHRpZiAoIXNlbCkgeyByZXR1cm4gdGhpcy5wYXJlbnQoKSB9OyAvLyBzaG91bGQgcmV0dXJuIHNlbGY/IVxuXHRcdFx0dmFyIG5vZGUgPSB0aGlzO1xuXHRcdFx0aWYgKHNlbC5xdWVyeSkgeyBzZWwgPSBzZWwucXVlcnkoKSB9O1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAobm9kZSl7XG5cdFx0XHRcdGlmIChub2RlLm1hdGNoZXMoc2VsKSkgeyByZXR1cm4gbm9kZSB9O1xuXHRcdFx0XHRub2RlID0gbm9kZS5wYXJlbnQoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRHZXQgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2Ygbm9kZSB0aGF0IG1hdGNoZXNcblx0XHRcdHNwZWNpZmllZCBzZWxlY3RvciAvIG1hdGNoZXIuXG5cdFx0XG5cdFx0XHRAcmV0dXJuIHtJbWJhLlRhZ31cblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS51cCA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdFx0aWYgKCFzZWwpIHsgcmV0dXJuIHRoaXMucGFyZW50KCkgfTtcblx0XHRcdHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuY2xvc2VzdChzZWwpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0XHR2YXIgbm9kZSA9IHRoaXM7XG5cdFx0XHR2YXIgbm9kZXMgPSBbXTtcblx0XHRcdGlmIChzZWwgJiYgc2VsLnF1ZXJ5KSB7IHNlbCA9IHNlbC5xdWVyeSgpIH07XG5cdFx0XHRcblx0XHRcdHdoaWxlIChub2RlKXtcblx0XHRcdFx0aWYgKCFzZWwgfHwgbm9kZS5tYXRjaGVzKHNlbCkpIHsgbm9kZXMucHVzaChub2RlKSB9O1xuXHRcdFx0XHRub2RlID0gbm9kZS5wYXJlbnQoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gbm9kZXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnBhcmVudHMgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHRcdHZhciBwYXIgPSB0aGlzLnBhcmVudCgpO1xuXHRcdFx0cmV0dXJuIHBhciA/IChwYXIucGF0aChzZWwpKSA6IChbXSk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNpYmxpbmdzID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0XHR2YXIgcGFyLCBzZWxmID0gdGhpcztcblx0XHRcdGlmICghKHBhciA9IHRoaXMucGFyZW50KCkpKSB7IHJldHVybiBbXSB9OyAvLyBGSVhNRVxuXHRcdFx0dmFyIGFyeSA9IHRoaXMuZG9tKCkucGFyZW50Tm9kZS5jaGlsZHJlbjtcblx0XHRcdHZhciBub2RlcyA9IG5ldyBJbWJhLlNlbGVjdG9yKG51bGwsdGhpcyxhcnkpO1xuXHRcdFx0cmV0dXJuIG5vZGVzLmZpbHRlcihmdW5jdGlvbihuKSB7IHJldHVybiBuICE9IHNlbGYgJiYgKCFzZWwgfHwgbi5tYXRjaGVzKHNlbCkpOyB9KTtcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRHZXQgdGhlIGltbWVkaWF0ZWx5IGZvbGxvd2luZyBzaWJsaW5nIG9mIG5vZGUuXG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChzZWwpe1xuXHRcdFx0aWYgKHNlbCkge1xuXHRcdFx0XHR2YXIgZWwgPSB0aGlzO1xuXHRcdFx0XHR3aGlsZSAoZWwgPSBlbC5uZXh0KCkpe1xuXHRcdFx0XHRcdGlmIChlbC5tYXRjaGVzKHNlbCkpIHsgcmV0dXJuIGVsIH07XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0YWckd3JhcCh0aGlzLmRvbSgpLm5leHRFbGVtZW50U2libGluZyk7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0R2V0IHRoZSBpbW1lZGlhdGVseSBwcmVjZWVkaW5nIHNpYmxpbmcgb2Ygbm9kZS5cblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKHNlbCl7XG5cdFx0XHRpZiAoc2VsKSB7XG5cdFx0XHRcdHZhciBlbCA9IHRoaXM7XG5cdFx0XHRcdHdoaWxlIChlbCA9IGVsLnByZXYoKSl7XG5cdFx0XHRcdFx0aWYgKGVsLm1hdGNoZXMoc2VsKSkgeyByZXR1cm4gZWwgfTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRhZyR3cmFwKHRoaXMuZG9tKCkucHJldmlvdXNFbGVtZW50U2libGluZyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkuY29udGFpbnMobm9kZSAmJiBub2RlLl9kb20gfHwgbm9kZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHR2YXIgZWwgPSB0aGlzLmRvbSgpO1xuXHRcdFx0d2hpbGUgKGVsLnByZXZpb3VzU2libGluZyl7XG5cdFx0XHRcdGVsID0gZWwucHJldmlvdXNTaWJsaW5nO1xuXHRcdFx0XHRpKys7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKlxuXHRcdFx0XG5cdFx0XHRAZGVwcmVjYXRlZFxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChub2RlLHBhcnMpe1xuXHRcdFx0aWYoIXBhcnN8fHBhcnMuY29uc3RydWN0b3IgIT09IE9iamVjdCkgcGFycyA9IHt9O1xuXHRcdFx0dmFyIGJlZm9yZSA9IHBhcnMuYmVmb3JlICE9PSB1bmRlZmluZWQgPyBwYXJzLmJlZm9yZSA6IG51bGw7XG5cdFx0XHR2YXIgYWZ0ZXIgPSBwYXJzLmFmdGVyICE9PSB1bmRlZmluZWQgPyBwYXJzLmFmdGVyIDogbnVsbDtcblx0XHRcdGlmIChhZnRlcikgeyBiZWZvcmUgPSBhZnRlci5uZXh0KCkgfTtcblx0XHRcdGlmIChub2RlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0bm9kZSA9ICh0YWckLiRmcmFnbWVudCgpLnNldENvbnRlbnQobm9kZSwwKS5lbmQoKSk7XG5cdFx0XHR9O1xuXHRcdFx0aWYgKGJlZm9yZSkge1xuXHRcdFx0XHR0aGlzLmRvbSgpLmluc2VydEJlZm9yZShub2RlLmRvbSgpLGJlZm9yZS5kb20oKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmFwcGVuZChub2RlKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRGb2N1cyBvbiBjdXJyZW50IG5vZGVcblx0XHRcdEByZXR1cm4ge3NlbGZ9XG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuZG9tKCkuZm9jdXMoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdFJlbW92ZSBmb2N1cyBmcm9tIGN1cnJlbnQgbm9kZVxuXHRcdFx0QHJldHVybiB7c2VsZn1cblx0XHRcdCovXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ibHVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmRvbSgpLmJsdXIoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50ZW1wbGF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRcblx0XHQvKlxuXHRcdFx0QHRvZG8gU2hvdWxkIHN1cHBvcnQgbXVsdGlwbGUgYXJndW1lbnRzIGxpa2UgYXBwZW5kXG5cdFx0XG5cdFx0XHRUaGUgLnByZXBlbmQgbWV0aG9kIGluc2VydHMgdGhlIHNwZWNpZmllZCBjb250ZW50IGFzIHRoZSBmaXJzdFxuXHRcdFx0Y2hpbGQgb2YgdGhlIHRhcmdldCBub2RlLiBJZiB0aGUgY29udGVudCBpcyBhbHJlYWR5IGEgY2hpbGQgb2YgXG5cdFx0XHRub2RlIGl0IHdpbGwgYmUgbW92ZWQgdG8gdGhlIHN0YXJ0LlxuXHRcdFx0XG5cdFx0ICAgIFx0bm9kZS5wcmVwZW5kIDxkaXYudG9wPiAjIHByZXBlbmQgbm9kZVxuXHRcdCAgICBcdG5vZGUucHJlcGVuZCBcInNvbWUgdGV4dFwiICMgcHJlcGVuZCB0ZXh0XG5cdFx0ICAgIFx0bm9kZS5wcmVwZW5kIFs8dWw+LDx1bD5dICMgcHJlcGVuZCBhcnJheVxuXHRcdFxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiAoaXRlbSl7XG5cdFx0XHR2YXIgZmlyc3QgPSB0aGlzLl9kb20uY2hpbGROb2Rlc1swXTtcblx0XHRcdGZpcnN0ID8gKHRoaXMuaW5zZXJ0QmVmb3JlKGl0ZW0sZmlyc3QpKSA6ICh0aGlzLmFwcGVuZENoaWxkKGl0ZW0pKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdFRoZSAuYXBwZW5kIG1ldGhvZCBpbnNlcnRzIHRoZSBzcGVjaWZpZWQgY29udGVudCBhcyB0aGUgbGFzdCBjaGlsZFxuXHRcdFx0b2YgdGhlIHRhcmdldCBub2RlLiBJZiB0aGUgY29udGVudCBpcyBhbHJlYWR5IGEgY2hpbGQgb2Ygbm9kZSBpdFxuXHRcdFx0d2lsbCBiZSBtb3ZlZCB0byB0aGUgZW5kLlxuXHRcdFx0XG5cdFx0XHQjIGV4YW1wbGVcblx0XHRcdCAgICB2YXIgcm9vdCA9IDxkaXYucm9vdD5cblx0XHRcdCAgICB2YXIgaXRlbSA9IDxkaXYuaXRlbT4gXCJUaGlzIGlzIGFuIGl0ZW1cIlxuXHRcdFx0ICAgIHJvb3QuYXBwZW5kIGl0ZW0gIyBhcHBlbmRzIGl0ZW0gdG8gdGhlIGVuZCBvZiByb290XG5cdFx0XG5cdFx0XHQgICAgcm9vdC5wcmVwZW5kIFwic29tZSB0ZXh0XCIgIyBhcHBlbmQgdGV4dFxuXHRcdFx0ICAgIHJvb3QucHJlcGVuZCBbPHVsPiw8dWw+XSAjIGFwcGVuZCBhcnJheVxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChpdGVtKXtcblx0XHRcdC8vIHBvc3NpYmxlIHRvIGFwcGVuZCBibGFua1xuXHRcdFx0Ly8gcG9zc2libGUgdG8gc2ltcGxpZnkgb24gc2VydmVyP1xuXHRcdFx0aWYgKCFpdGVtKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XHRcblx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGl0ZW0pLCBsZW4gPSBhcnkubGVuZ3RoLCBtZW1iZXI7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdG1lbWJlciA9IGFyeVtpXTtcblx0XHRcdFx0XHRtZW1iZXIgJiYgdGhpcy5hcHBlbmQobWVtYmVyKTtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAoKHR5cGVvZiBpdGVtPT0nc3RyaW5nJ3x8aXRlbSBpbnN0YW5jZW9mIFN0cmluZykgfHwgKHR5cGVvZiBpdGVtPT0nbnVtYmVyJ3x8aXRlbSBpbnN0YW5jZW9mIE51bWJlcikpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSBJbWJhLmRvY3VtZW50KCkuY3JlYXRlVGV4dE5vZGUoaXRlbSk7XG5cdFx0XHRcdHRoaXMuX2RvbS5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdFx0aWYgKHRoaXMuX2VtcHR5KSB7IHRoaXMuX2VtcHR5ID0gZmFsc2UgfTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2RvbS5hcHBlbmRDaGlsZChpdGVtLl9kb20gfHwgaXRlbSk7XG5cdFx0XHRcdGlmICh0aGlzLl9lbXB0eSkgeyB0aGlzLl9lbXB0eSA9IGZhbHNlIH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRJbnNlcnQgYSBub2RlIGludG8gdGhlIGN1cnJlbnQgbm9kZSAoc2VsZiksIGJlZm9yZSBhbm90aGVyLlxuXHRcdFx0VGhlIHJlbGF0aXZlIG5vZGUgbXVzdCBiZSBhIGNoaWxkIG9mIGN1cnJlbnQgbm9kZS4gXG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKG5vZGUscmVsKXtcblx0XHRcdGlmICgodHlwZW9mIG5vZGU9PSdzdHJpbmcnfHxub2RlIGluc3RhbmNlb2YgU3RyaW5nKSkgeyBub2RlID0gSW1iYS5kb2N1bWVudCgpLmNyZWF0ZVRleHROb2RlKG5vZGUpIH07XG5cdFx0XHRpZiAobm9kZSAmJiByZWwpIHsgdGhpcy5kb20oKS5pbnNlcnRCZWZvcmUoKG5vZGUuX2RvbSB8fCBub2RlKSwocmVsLl9kb20gfHwgcmVsKSkgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Lypcblx0XHRcdEFwcGVuZCBhIHNpbmdsZSBpdGVtIChub2RlIG9yIHN0cmluZykgdG8gdGhlIGN1cnJlbnQgbm9kZS5cblx0XHRcdElmIHN1cHBsaWVkIGl0ZW0gaXMgYSBzdHJpbmcgaXQgd2lsbCBhdXRvbWF0aWNhbGx5LiBUaGlzIGlzIHVzZWRcblx0XHRcdGJ5IEltYmEgaW50ZXJuYWxseSwgYnV0IHdpbGwgcHJhY3RpY2FsbHkgbmV2ZXIgYmUgdXNlZCBleHBsaWNpdGx5LlxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdFx0aWYgKCh0eXBlb2Ygbm9kZT09J3N0cmluZyd8fG5vZGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7IG5vZGUgPSBJbWJhLmRvY3VtZW50KCkuY3JlYXRlVGV4dE5vZGUobm9kZSkgfTtcblx0XHRcdGlmIChub2RlKSB7IHRoaXMuZG9tKCkuYXBwZW5kQ2hpbGQobm9kZS5fZG9tIHx8IG5vZGUpIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRSZW1vdmUgYSBzaW5nbGUgY2hpbGQgZnJvbSB0aGUgY3VycmVudCBub2RlLlxuXHRcdFx0VXNlZCBieSBJbWJhIGludGVybmFsbHkuXG5cdFx0XHQqL1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0XHRpZiAobm9kZSkgeyB0aGlzLmRvbSgpLnJlbW92ZUNoaWxkKG5vZGUuX2RvbSB8fCBub2RlKSB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tLnRvU3RyaW5nKCk7IC8vIHJlYWxseT9cblx0XHR9O1xuXHRcdFxuXHRcdC8qXG5cdFx0XHRAZGVwcmVjYXRlZFxuXHRcdFx0Ki9cblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNsYXNzZXMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGNvbnNvbGUubG9nKCdJbWJhLlRhZyNjbGFzc2VzIGlzIGRlcHJlY2F0ZWQnKTtcblx0XHRcdHJldHVybiB0aGlzLl9kb20uY2xhc3NMaXN0O1xuXHRcdH07XG5cdH0pO1xuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdzdmdlbGVtZW50JywgJ2h0bWxlbGVtZW50Jyk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvZG9tLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdC8vIEV4dGVuZGluZyBJbWJhLlRhZyNjc3MgdG8gd29yayB3aXRob3V0IHByZWZpeGVzIGJ5IGluc3BlY3Rpbmdcblx0Ly8gdGhlIHByb3BlcnRpZXMgb2YgYSBDU1NTdHlsZURlY2xhcmF0aW9uIGFuZCBjcmVhdGluZyBhIG1hcFxuXHRcblx0Ly8gdmFyIHByZWZpeGVzID0gWyctd2Via2l0LScsJy1tcy0nLCctbW96LScsJy1vLScsJy1ibGluay0nXVxuXHQvLyB2YXIgcHJvcHMgPSBbJ3RyYW5zZm9ybScsJ3RyYW5zaXRpb24nLCdhbmltYXRpb24nXVxuXHRcblx0dmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwnJyk7XG5cdFxuXHRJbWJhLkNTU0tleU1hcCA9IHt9O1xuXHRcblx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHN0eWxlcyksIGxlbiA9IGFyeS5sZW5ndGgsIHByZWZpeGVkOyBpIDwgbGVuOyBpKyspIHtcblx0XHRwcmVmaXhlZCA9IGFyeVtpXTtcblx0XHR2YXIgdW5wcmVmaXhlZCA9IHByZWZpeGVkLnJlcGxhY2UoL14tKHdlYmtpdHxtc3xtb3p8b3xibGluayktLywnJyk7XG5cdFx0dmFyIGNhbWVsQ2FzZSA9IHVucHJlZml4ZWQucmVwbGFjZSgvLShcXHcpL2csZnVuY3Rpb24obSxhKSB7IHJldHVybiBhLnRvVXBwZXJDYXNlKCk7IH0pO1xuXHRcdFxuXHRcdC8vIGlmIHRoZXJlIGV4aXN0cyBhbiB1bnByZWZpeGVkIHZlcnNpb24gLS0gYWx3YXlzIHVzZSB0aGlzXG5cdFx0aWYgKHByZWZpeGVkICE9IHVucHJlZml4ZWQpIHtcblx0XHRcdGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkodW5wcmVmaXhlZCkpIHsgY29udGludWU7IH07XG5cdFx0fTtcblx0XHRcblx0XHQvLyByZWdpc3RlciB0aGUgcHJlZml4ZXNcblx0XHRJbWJhLkNTU0tleU1hcFt1bnByZWZpeGVkXSA9IEltYmEuQ1NTS2V5TWFwW2NhbWVsQ2FzZV0gPSBwcmVmaXhlZDtcblx0fTtcblx0XG5cdHJldHVybiB0YWckLmV4dGVuZFRhZygnaHRtbGVsZW1lbnQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdC8vIG92ZXJyaWRlIHRoZSBvcmlnaW5hbCBjc3MgbWV0aG9kXG5cdFx0dGFnLnByb3RvdHlwZS5jc3MgPSBmdW5jdGlvbiAoa2V5LHZhbCl7XG5cdFx0XHRpZiAoa2V5IGluc3RhbmNlb2YgT2JqZWN0KSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMoa2V5KSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKXtcblx0XHRcdFx0XHR0aGlzLmNzcyhrZXlzW2ldLGtleVtrZXlzW2ldXSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0a2V5ID0gSW1iYS5DU1NLZXlNYXBba2V5XSB8fCBrZXk7XG5cdFx0XHRcblx0XHRcdGlmICh2YWwgPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmRvbSgpLnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbCA9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkuc3R5bGVba2V5XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICgodHlwZW9mIHZhbD09J251bWJlcid8fHZhbCBpbnN0YW5jZW9mIE51bWJlcikgJiYga2V5Lm1hdGNoKC93aWR0aHxoZWlnaHR8bGVmdHxyaWdodHx0b3B8Ym90dG9tLykpIHtcblx0XHRcdFx0XHR2YWwgPSB2YWwgKyBcInB4XCI7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRoaXMuZG9tKCkuc3R5bGVba2V5XSA9IHZhbDtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9saWIvaW1iYS9kb20uY2xpZW50LmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHQvLyBwcmVkZWZpbmUgYWxsIHN1cHBvcnRlZCBodG1sIHRhZ3Ncblx0dGFnJC5kZWZpbmVUYWcoJ2ZyYWdtZW50JywgJ2h0bWxlbGVtZW50JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIEltYmEuZG9jdW1lbnQoKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ocmVmID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnaHJlZicpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIcmVmID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdocmVmJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2FiYnInKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2FkZHJlc3MnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2FyZWEnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2FydGljbGUnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2FzaWRlJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdhdWRpbycpO1xuXHR0YWckLmRlZmluZVRhZygnYicpO1xuXHR0YWckLmRlZmluZVRhZygnYmFzZScpO1xuXHR0YWckLmRlZmluZVRhZygnYmRpJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdiZG8nKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2JpZycpO1xuXHR0YWckLmRlZmluZVRhZygnYmxvY2txdW90ZScpO1xuXHR0YWckLmRlZmluZVRhZygnYm9keScpO1xuXHR0YWckLmRlZmluZVRhZygnYnInKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdidXR0b24nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXV0b2ZvY3VzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnYXV0b2ZvY3VzJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEF1dG9mb2N1cyA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnYXV0b2ZvY3VzJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCd0eXBlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kaXNhYmxlZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldERpc2FibGVkID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdjYW52YXMnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy5wcm90b3R5cGUuc2V0V2lkdGggPSBmdW5jdGlvbiAodmFsKXtcblx0XHRcdGlmICh0aGlzLndpZHRoKCkgIT0gdmFsKSB7IHRoaXMuZG9tKCkud2lkdGggPSB2YWwgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRcdGlmICh0aGlzLmhlaWdodCgpICE9IHZhbCkgeyB0aGlzLmRvbSgpLmhlaWdodCA9IHZhbCB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS53aWR0aDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS5oZWlnaHQ7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbnRleHQgPSBmdW5jdGlvbiAodHlwZSl7XG5cdFx0XHRpZih0eXBlID09PSB1bmRlZmluZWQpIHR5cGUgPSAnMmQnO1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkuZ2V0Q29udGV4dCh0eXBlKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdjYXB0aW9uJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdjaXRlJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdjb2RlJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdjb2wnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2NvbGdyb3VwJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdkYXRhJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdkYXRhbGlzdCcpO1xuXHR0YWckLmRlZmluZVRhZygnZGQnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2RlbCcpO1xuXHR0YWckLmRlZmluZVRhZygnZGV0YWlscycpO1xuXHR0YWckLmRlZmluZVRhZygnZGZuJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdkaXYnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2RsJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdkdCcpO1xuXHR0YWckLmRlZmluZVRhZygnZW0nKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2VtYmVkJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdmaWVsZHNldCcpO1xuXHR0YWckLmRlZmluZVRhZygnZmlnY2FwdGlvbicpO1xuXHR0YWckLmRlZmluZVRhZygnZmlndXJlJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdmb290ZXInKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdmb3JtJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm1ldGhvZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ21ldGhvZCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRNZXRob2QgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ21ldGhvZCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYWN0aW9uID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aW9uJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEFjdGlvbiA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnYWN0aW9uJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2gxJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdoMicpO1xuXHR0YWckLmRlZmluZVRhZygnaDMnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2g0Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdoNScpO1xuXHR0YWckLmRlZmluZVRhZygnaDYnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2hlYWQnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2hlYWRlcicpO1xuXHR0YWckLmRlZmluZVRhZygnaHInKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2h0bWwnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2knKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpZnJhbWUnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc3JjID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnc3JjJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFNyYyA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnc3JjJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltZycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zcmMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdzcmMnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0U3JjID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdzcmMnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW5wdXQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdC8vIGNhbiB1c2UgYXR0ciBpbnN0ZWFkXG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbmFtZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCduYW1lJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCd0eXBlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXF1aXJlZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlcXVpcmVkJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJlcXVpcmVkID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdyZXF1aXJlZCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGlzYWJsZWQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdkaXNhYmxlZCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXREaXNhYmxlZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmF1dG9mb2N1cyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2F1dG9mb2N1cycpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRBdXRvZm9jdXMgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2F1dG9mb2N1cycsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnZhbHVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2KXtcblx0XHRcdGlmICh2ICE9IHRoaXMuZG9tKCkudmFsdWUpIHsgdGhpcy5kb20oKS52YWx1ZSA9IHYgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uICh2KXtcblx0XHRcdGlmICh2ICE9IHRoaXMuZG9tKCkucGxhY2Vob2xkZXIpIHsgdGhpcy5kb20oKS5wbGFjZWhvbGRlciA9IHYgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wbGFjZWhvbGRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkucGxhY2Vob2xkZXI7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNoZWNrZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLmNoZWNrZWQ7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldENoZWNrZWQgPSBmdW5jdGlvbiAoYm9vbCl7XG5cdFx0XHRpZiAoYm9vbCAhPSB0aGlzLmRvbSgpLmNoZWNrZWQpIHsgdGhpcy5kb20oKS5jaGVja2VkID0gYm9vbCB9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW5zJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdrYmQnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2tleWdlbicpO1xuXHR0YWckLmRlZmluZVRhZygnbGFiZWwnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ2xlZ2VuZCcpO1xuXHR0YWckLmRlZmluZVRhZygnbGknKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdsaW5rJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlbCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSZWwgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JlbCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VHlwZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgndHlwZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaHJlZiA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SHJlZiA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnaHJlZicsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubWVkaWEgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdtZWRpYScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRNZWRpYSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnbWVkaWEnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnbWFpbicpO1xuXHR0YWckLmRlZmluZVRhZygnbWFwJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdtYXJrJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdtZW51Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdtZW51aXRlbScpO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ21ldGEnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TmFtZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnbmFtZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnY29udGVudCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2hhcnNldCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NoYXJzZXQnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q2hhcnNldCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnY2hhcnNldCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdtZXRlcicpO1xuXHR0YWckLmRlZmluZVRhZygnbmF2Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdub3NjcmlwdCcpO1xuXHR0YWckLmRlZmluZVRhZygnb2JqZWN0Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdvbCcpO1xuXHR0YWckLmRlZmluZVRhZygnb3B0Z3JvdXAnKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdvcHRpb24nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgndmFsdWUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnb3V0cHV0Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdwJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdwYXJhbScpO1xuXHR0YWckLmRlZmluZVRhZygncHJlJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdwcm9ncmVzcycpO1xuXHR0YWckLmRlZmluZVRhZygncScpO1xuXHR0YWckLmRlZmluZVRhZygncnAnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3J0Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdydWJ5Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdzJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdzYW1wJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnc2NyaXB0JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNyYyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NyYycpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRTcmMgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NyYycsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VHlwZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgndHlwZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdzZWN0aW9uJyk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnc2VsZWN0JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCduYW1lJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ25hbWUnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11bHRpcGxlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbXVsdGlwbGUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TXVsdGlwbGUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXF1aXJlZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlcXVpcmVkJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJlcXVpcmVkID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdyZXF1aXJlZCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGlzYWJsZWQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdkaXNhYmxlZCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXREaXNhYmxlZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb20oKS52YWx1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodil7XG5cdFx0XHRpZiAodiAhPSB0aGlzLmRvbSgpLnZhbHVlKSB7IHRoaXMuZG9tKCkudmFsdWUgPSB2IH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnc21hbGwnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3NvdXJjZScpO1xuXHR0YWckLmRlZmluZVRhZygnc3BhbicpO1xuXHR0YWckLmRlZmluZVRhZygnc3Ryb25nJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdzdHlsZScpO1xuXHR0YWckLmRlZmluZVRhZygnc3ViJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdzdW1tYXJ5Jyk7XG5cdHRhZyQuZGVmaW5lVGFnKCdzdXAnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3RhYmxlJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCd0Ym9keScpO1xuXHR0YWckLmRlZmluZVRhZygndGQnKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCd0ZXh0YXJlYScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbmFtZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCduYW1lJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kaXNhYmxlZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldERpc2FibGVkID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVxdWlyZWQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdyZXF1aXJlZCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSZXF1aXJlZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgncmVxdWlyZWQnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvd3MgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdyb3dzJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJvd3MgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3Jvd3MnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbHMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdjb2xzJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldENvbHMgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2NvbHMnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmF1dG9mb2N1cyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2F1dG9mb2N1cycpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRBdXRvZm9jdXMgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2F1dG9mb2N1cycsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnZhbHVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2KXtcblx0XHRcdGlmICh2ICE9IHRoaXMuZG9tKCkudmFsdWUpIHsgdGhpcy5kb20oKS52YWx1ZSA9IHYgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uICh2KXtcblx0XHRcdGlmICh2ICE9IHRoaXMuZG9tKCkucGxhY2Vob2xkZXIpIHsgdGhpcy5kb20oKS5wbGFjZWhvbGRlciA9IHYgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wbGFjZWhvbGRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkucGxhY2Vob2xkZXI7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygndGZvb3QnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3RoJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCd0aGVhZCcpO1xuXHR0YWckLmRlZmluZVRhZygndGltZScpO1xuXHR0YWckLmRlZmluZVRhZygndGl0bGUnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3RyJyk7XG5cdHRhZyQuZGVmaW5lVGFnKCd0cmFjaycpO1xuXHR0YWckLmRlZmluZVRhZygndScpO1xuXHR0YWckLmRlZmluZVRhZygndWwnKTtcblx0dGFnJC5kZWZpbmVUYWcoJ3ZpZGVvJyk7XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnd2JyJyk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYmEvbGliL2ltYmEvZG9tLmh0bWwuanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaWR4JChhLGIpe1xuXHRcdHJldHVybiAoYiAmJiBiLmluZGV4T2YpID8gYi5pbmRleE9mKGEpIDogW10uaW5kZXhPZi5jYWxsKGEsYik7XG5cdH07XG5cdFxuXHRcblx0dGFnJC5TVkcuZGVmaW5lVGFnKCdzdmdlbGVtZW50JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcubmFtZXNwYWNlVVJJID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHR5cGVzID0gXCJjaXJjbGUgZGVmcyBlbGxpcHNlIGcgbGluZSBsaW5lYXJHcmFkaWVudCBtYXNrIHBhdGggcGF0dGVybiBwb2x5Z29uIHBvbHlsaW5lIHJhZGlhbEdyYWRpZW50IHJlY3Qgc3RvcCBzdmcgdGV4dCB0c3BhblwiLnNwbGl0KFwiIFwiKTtcblx0XHRcblx0XHR0YWcuYnVpbGROb2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgZG9tID0gSW1iYS5kb2N1bWVudCgpLmNyZWF0ZUVsZW1lbnROUyh0aGlzLm5hbWVzcGFjZVVSSSgpLHRoaXMuX25vZGVUeXBlKTtcblx0XHRcdHZhciBjbHMgPSB0aGlzLl9jbGFzc2VzLmpvaW4oXCIgXCIpO1xuXHRcdFx0aWYgKGNscykgeyBkb20uY2xhc3NOYW1lLmJhc2VWYWwgPSBjbHMgfTtcblx0XHRcdHJldHVybiBkb207XG5cdFx0fTtcblx0XHRcblx0XHR0YWcuaW5oZXJpdCA9IGZ1bmN0aW9uIChjaGlsZCl7XG5cdFx0XHRjaGlsZC5fcHJvdG9Eb20gPSBudWxsO1xuXHRcdFx0XG5cdFx0XHRpZiAoaWR4JChjaGlsZC5fbmFtZSx0eXBlcykgPj0gMCkge1xuXHRcdFx0XHRjaGlsZC5fbm9kZVR5cGUgPSBjaGlsZC5fbmFtZTtcblx0XHRcdFx0cmV0dXJuIGNoaWxkLl9jbGFzc2VzID0gW107XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaGlsZC5fbm9kZVR5cGUgPSB0aGlzLl9ub2RlVHlwZTtcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSA9IFwiX1wiICsgY2hpbGQuX25hbWUucmVwbGFjZSgvXy9nLCctJyk7XG5cdFx0XHRcdHJldHVybiBjaGlsZC5fY2xhc3NlcyA9IHRoaXMuX2NsYXNzZXMuY29uY2F0KGNsYXNzTmFtZSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0SW1iYS5hdHRyKHRhZywneCcpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3knKTtcblx0XHRcblx0XHRJbWJhLmF0dHIodGFnLCd3aWR0aCcpO1xuXHRcdEltYmEuYXR0cih0YWcsJ2hlaWdodCcpO1xuXHRcdFxuXHRcdEltYmEuYXR0cih0YWcsJ3N0cm9rZScpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3N0cm9rZS13aWR0aCcpO1xuXHR9KTtcblx0XG5cdHRhZyQuU1ZHLmRlZmluZVRhZygnc3ZnJywgZnVuY3Rpb24odGFnKXtcblx0XHRJbWJhLmF0dHIodGFnLCd2aWV3Ym94Jyk7XG5cdH0pO1xuXHRcblx0dGFnJC5TVkcuZGVmaW5lVGFnKCdyZWN0Jyk7XG5cdFxuXHR0YWckLlNWRy5kZWZpbmVUYWcoJ2NpcmNsZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0SW1iYS5hdHRyKHRhZywnY3gnKTtcblx0XHRJbWJhLmF0dHIodGFnLCdjeScpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3InKTtcblx0fSk7XG5cdFxuXHR0YWckLlNWRy5kZWZpbmVUYWcoJ2VsbGlwc2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdEltYmEuYXR0cih0YWcsJ2N4Jyk7XG5cdFx0SW1iYS5hdHRyKHRhZywnY3knKTtcblx0XHRJbWJhLmF0dHIodGFnLCdyeCcpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3J5Jyk7XG5cdH0pO1xuXHRcblx0dGFnJC5TVkcuZGVmaW5lVGFnKCdwYXRoJywgZnVuY3Rpb24odGFnKXtcblx0XHRJbWJhLmF0dHIodGFnLCdkJyk7XG5cdFx0SW1iYS5hdHRyKHRhZywncGF0aExlbmd0aCcpO1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLlNWRy5kZWZpbmVUYWcoJ2xpbmUnLCBmdW5jdGlvbih0YWcpe1xuXHRcdEltYmEuYXR0cih0YWcsJ3gxJyk7XG5cdFx0SW1iYS5hdHRyKHRhZywneDInKTtcblx0XHRJbWJhLmF0dHIodGFnLCd5MScpO1xuXHRcdEltYmEuYXR0cih0YWcsJ3kyJyk7XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9pbWJhL2xpYi9pbWJhL2RvbS5zdmcuanNcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0aWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0KSB7XG5cdFx0dGFnJC5leHRlbmRUYWcoJ2h0bWxlbGVtZW50JywgZnVuY3Rpb24odGFnKXtcblx0XHRcdFxuXHRcdFx0dGFnLnByb3RvdHlwZS5oYXNGbGFnID0gZnVuY3Rpb24gKHJlZil7XG5cdFx0XHRcdHJldHVybiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgcmVmICsgJyhcXFxcc3wkKScpLnRlc3QodGhpcy5fZG9tLmNsYXNzTmFtZSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0YWcucHJvdG90eXBlLmFkZEZsYWcgPSBmdW5jdGlvbiAocmVmKXtcblx0XHRcdFx0aWYgKHRoaXMuaGFzRmxhZyhyZWYpKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XHRcdHRoaXMuX2RvbS5jbGFzc05hbWUgKz0gKHRoaXMuX2RvbS5jbGFzc05hbWUgPyAoJyAnKSA6ICgnJykpICsgcmVmO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRhZy5wcm90b3R5cGUudW5mbGFnID0gZnVuY3Rpb24gKHJlZil7XG5cdFx0XHRcdGlmICghdGhpcy5oYXNGbGFnKHJlZikpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcdFx0dmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnKF58XFxcXHMpKicgKyByZWYgKyAnKFxcXFxzfCQpKicsJ2cnKTtcblx0XHRcdFx0dGhpcy5fZG9tLmNsYXNzTmFtZSA9IHRoaXMuX2RvbS5jbGFzc05hbWUucmVwbGFjZShyZWdleCwnJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGFnLnByb3RvdHlwZS50b2dnbGVGbGFnID0gZnVuY3Rpb24gKHJlZil7XG5cdFx0XHRcdHJldHVybiB0aGlzLmhhc0ZsYWcocmVmKSA/ICh0aGlzLnVuZmxhZyhyZWYpKSA6ICh0aGlzLmZsYWcocmVmKSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0YWcucHJvdG90eXBlLmZsYWcgPSBmdW5jdGlvbiAocmVmLGJvb2wpe1xuXHRcdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyICYmICEhYm9vbCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy51bmZsYWcocmVmKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkRmxhZyhyZWYpO1xuXHRcdFx0fTtcblx0XHR9KTtcblx0XHRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9saWIvaW1iYS9kb20ubGVnYWN5LmpzXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHR2YXIgZG9jID0gZG9jdW1lbnQ7XG5cdHZhciB3aW4gPSB3aW5kb3c7XG5cdFxuXHR2YXIgaGFzVG91Y2hFdmVudHMgPSB3aW5kb3cgJiYgd2luZG93Lm9udG91Y2hzdGFydCAhPT0gdW5kZWZpbmVkO1xuXHRcblx0SW1iYS5Qb2ludGVyID0gZnVuY3Rpb24gUG9pbnRlcigpe1xuXHRcdHRoaXMuc2V0QnV0dG9uKC0xKTtcblx0XHR0aGlzLnNldEV2ZW50KHt4OiAwLHk6IDAsdHlwZTogJ3VuaW5pdGlhbGl6ZWQnfSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUucGhhc2UgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3BoYXNlOyB9XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuc2V0UGhhc2UgPSBmdW5jdGlvbih2KXsgdGhpcy5fcGhhc2UgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLnByZXZFdmVudCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcHJldkV2ZW50OyB9XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuc2V0UHJldkV2ZW50ID0gZnVuY3Rpb24odil7IHRoaXMuX3ByZXZFdmVudCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuYnV0dG9uID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9idXR0b247IH1cblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5zZXRCdXR0b24gPSBmdW5jdGlvbih2KXsgdGhpcy5fYnV0dG9uID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5ldmVudCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZXZlbnQ7IH1cblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5zZXRFdmVudCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9ldmVudCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuZGlydHkgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2RpcnR5OyB9XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuc2V0RGlydHkgPSBmdW5jdGlvbih2KXsgdGhpcy5fZGlydHkgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLmV2ZW50cyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZXZlbnRzOyB9XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuc2V0RXZlbnRzID0gZnVuY3Rpb24odil7IHRoaXMuX2V2ZW50cyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUudG91Y2ggPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3RvdWNoOyB9XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUuc2V0VG91Y2ggPSBmdW5jdGlvbih2KXsgdGhpcy5fdG91Y2ggPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGUpe1xuXHRcdHRoaXMuc2V0RXZlbnQoZSk7XG5cdFx0dGhpcy5zZXREaXJ0eSh0cnVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIHRoaXMgaXMganVzdCBmb3IgcmVndWxhciBtb3VzZSBub3dcblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGUxID0gdGhpcy5ldmVudCgpO1xuXHRcdFxuXHRcdGlmICh0aGlzLmRpcnR5KCkpIHtcblx0XHRcdHRoaXMuc2V0UHJldkV2ZW50KGUxKTtcblx0XHRcdHRoaXMuc2V0RGlydHkoZmFsc2UpO1xuXHRcdFx0XG5cdFx0XHQvLyBidXR0b24gc2hvdWxkIG9ubHkgY2hhbmdlIG9uIG1vdXNlZG93biBldGNcblx0XHRcdGlmIChlMS50eXBlID09ICdtb3VzZWRvd24nKSB7XG5cdFx0XHRcdHRoaXMuc2V0QnV0dG9uKGUxLmJ1dHRvbik7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBkbyBub3QgY3JlYXRlIHRvdWNoIGZvciByaWdodCBjbGlja1xuXHRcdFx0XHRpZiAodGhpcy5idXR0b24oKSA9PSAyIHx8ICh0aGlzLnRvdWNoKCkgJiYgdGhpcy5idXR0b24oKSAhPSAwKSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGNhbmNlbCB0aGUgcHJldmlvdXMgdG91Y2hcblx0XHRcdFx0aWYgKHRoaXMudG91Y2goKSkgeyB0aGlzLnRvdWNoKCkuY2FuY2VsKCkgfTtcblx0XHRcdFx0dGhpcy5zZXRUb3VjaChuZXcgSW1iYS5Ub3VjaChlMSx0aGlzKSk7XG5cdFx0XHRcdHRoaXMudG91Y2goKS5tb3VzZWRvd24oZTEsZTEpO1xuXHRcdFx0fSBlbHNlIGlmIChlMS50eXBlID09ICdtb3VzZW1vdmUnKSB7XG5cdFx0XHRcdGlmICh0aGlzLnRvdWNoKCkpIHsgdGhpcy50b3VjaCgpLm1vdXNlbW92ZShlMSxlMSkgfTtcblx0XHRcdH0gZWxzZSBpZiAoZTEudHlwZSA9PSAnbW91c2V1cCcpIHtcblx0XHRcdFx0dGhpcy5zZXRCdXR0b24oLTEpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHRoaXMudG91Y2goKSAmJiB0aGlzLnRvdWNoKCkuYnV0dG9uKCkgPT0gZTEuYnV0dG9uKSB7XG5cdFx0XHRcdFx0dGhpcy50b3VjaCgpLm1vdXNldXAoZTEsZTEpO1xuXHRcdFx0XHRcdHRoaXMuc2V0VG91Y2gobnVsbCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdC8vIHRyaWdnZXIgcG9pbnRlcnVwXG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodGhpcy50b3VjaCgpKSB7IHRoaXMudG91Y2goKS5pZGxlKCkgfTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Qb2ludGVyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIEltYmEuUE9JTlRFUlM7XG5cdH07XG5cdFxuXHRJbWJhLlBvaW50ZXIucHJvdG90eXBlLnggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5ldmVudCgpLng7XG5cdH07XG5cdEltYmEuUG9pbnRlci5wcm90b3R5cGUueSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmV2ZW50KCkueTtcblx0fTtcblx0XG5cdC8vIGRlcHJlY2F0ZWQgLS0gc2hvdWxkIHJlbW92ZVxuXHRJbWJhLlBvaW50ZXIudXBkYXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gY29uc29sZS5sb2coJ3VwZGF0ZSB0b3VjaCcpXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKEltYmEuUE9JTlRFUlMpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGFyeVtpXS5wcm9jZXNzKCk7XG5cdFx0fTtcblx0XHQvLyBuZWVkIHRvIGJlIGFibGUgdG8gcHJldmVudCB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdG91Y2gsIG5vP1xuXHRcdHdpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoSW1iYS5Qb2ludGVyLnVwZGF0ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHR2YXIgbGFzdE5hdGl2ZVRvdWNoVGltZVN0YW1wID0gMDtcblx0dmFyIGxhc3ROYXRpdmVUb3VjaFRpbWVvdXQgPSA1MDtcblx0XG5cdC8vIEltYmEuVG91Y2hcblx0Ly8gQmVnYW5cdEEgZmluZ2VyIHRvdWNoZWQgdGhlIHNjcmVlbi5cblx0Ly8gTW92ZWRcdEEgZmluZ2VyIG1vdmVkIG9uIHRoZSBzY3JlZW4uXG5cdC8vIFN0YXRpb25hcnlcdEEgZmluZ2VyIGlzIHRvdWNoaW5nIHRoZSBzY3JlZW4gYnV0IGhhc24ndCBtb3ZlZC5cblx0Ly8gRW5kZWRcdEEgZmluZ2VyIHdhcyBsaWZ0ZWQgZnJvbSB0aGUgc2NyZWVuLiBUaGlzIGlzIHRoZSBmaW5hbCBwaGFzZSBvZiBhIHRvdWNoLlxuXHQvLyBDYW5jZWxlZCBUaGUgc3lzdGVtIGNhbmNlbGxlZCB0cmFja2luZyBmb3IgdGhlIHRvdWNoLlxuXHRcblx0Lypcblx0Q29uc29saWRhdGVzIG1vdXNlIGFuZCB0b3VjaCBldmVudHMuIFRvdWNoIG9iamVjdHMgcGVyc2lzdCBhY3Jvc3MgYSB0b3VjaCxcblx0ZnJvbSB0b3VjaHN0YXJ0IHVudGlsIGVuZC9jYW5jZWwuIFdoZW4gYSB0b3VjaCBzdGFydHMsIGl0IHdpbGwgdHJhdmVyc2Vcblx0ZG93biBmcm9tIHRoZSBpbm5lcm1vc3QgdGFyZ2V0LCB1bnRpbCBpdCBmaW5kcyBhIG5vZGUgdGhhdCByZXNwb25kcyB0b1xuXHRvbnRvdWNoc3RhcnQuIFVubGVzcyB0aGUgdG91Y2ggaXMgZXhwbGljaXRseSByZWRpcmVjdGVkLCB0aGUgdG91Y2ggd2lsbFxuXHRjYWxsIG9udG91Y2htb3ZlIGFuZCBvbnRvdWNoZW5kIC8gb250b3VjaGNhbmNlbCBvbiB0aGUgcmVzcG9uZGVyIHdoZW4gYXBwcm9wcmlhdGUuXG5cdFxuXHRcdHRhZyBkcmFnZ2FibGVcblx0XHRcdCMgY2FsbGVkIHdoZW4gYSB0b3VjaCBzdGFydHNcblx0XHRcdGRlZiBvbnRvdWNoc3RhcnQgdG91Y2hcblx0XHRcdFx0ZmxhZyAnZHJhZ2dpbmcnXG5cdFx0XHRcdHNlbGZcblx0XHRcdFxuXHRcdFx0IyBjYWxsZWQgd2hlbiB0b3VjaCBtb3ZlcyAtIHNhbWUgdG91Y2ggb2JqZWN0XG5cdFx0XHRkZWYgb250b3VjaG1vdmUgdG91Y2hcblx0XHRcdFx0IyBtb3ZlIHRoZSBub2RlIHdpdGggdG91Y2hcblx0XHRcdFx0Y3NzIHRvcDogdG91Y2guZHksIGxlZnQ6IHRvdWNoLmR4XG5cdFx0XHRcblx0XHRcdCMgY2FsbGVkIHdoZW4gdG91Y2ggZW5kc1xuXHRcdFx0ZGVmIG9udG91Y2hlbmQgdG91Y2hcblx0XHRcdFx0dW5mbGFnICdkcmFnZ2luZydcblx0XG5cdEBpbmFtZSB0b3VjaFxuXHQqL1xuXHRcblx0SW1iYS5Ub3VjaCA9IGZ1bmN0aW9uIFRvdWNoKGV2ZW50LHBvaW50ZXIpe1xuXHRcdC8vIEBuYXRpdmUgID0gZmFsc2Vcblx0XHR0aGlzLnNldEV2ZW50KGV2ZW50KTtcblx0XHR0aGlzLnNldERhdGEoe30pO1xuXHRcdHRoaXMuc2V0QWN0aXZlKHRydWUpO1xuXHRcdHRoaXMuX2J1dHRvbiA9IGV2ZW50ICYmIGV2ZW50LmJ1dHRvbiB8fCAwO1xuXHRcdHRoaXMuX3N1cHByZXNzID0gZmFsc2U7IC8vIGRlcHJlY2F0ZWRcblx0XHR0aGlzLl9jYXB0dXJlZCA9IGZhbHNlO1xuXHRcdHRoaXMuc2V0QnViYmxlKGZhbHNlKTtcblx0XHRwb2ludGVyID0gcG9pbnRlcjtcblx0XHR0aGlzLnNldFVwZGF0ZXMoMCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHR2YXIgdG91Y2hlcyA9IFtdO1xuXHR2YXIgY291bnQgPSAwO1xuXHR2YXIgaWRlbnRpZmllcnMgPSB7fTtcblx0XG5cdEltYmEuVG91Y2guY291bnQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gY291bnQ7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLmxvb2t1cCA9IGZ1bmN0aW9uIChpdGVtKXtcblx0XHRyZXR1cm4gaXRlbSAmJiAoaXRlbS5fX3RvdWNoX18gfHwgaWRlbnRpZmllcnNbaXRlbS5pZGVudGlmaWVyXSk7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnJlbGVhc2UgPSBmdW5jdGlvbiAoaXRlbSx0b3VjaCl7XG5cdFx0dmFyIHZfLCAkMTtcblx0XHQoKCh2XyA9IGlkZW50aWZpZXJzW2l0ZW0uaWRlbnRpZmllcl0pLGRlbGV0ZSBpZGVudGlmaWVyc1tpdGVtLmlkZW50aWZpZXJdLCB2XykpO1xuXHRcdCgoKCQxID0gaXRlbS5fX3RvdWNoX18pLGRlbGV0ZSBpdGVtLl9fdG91Y2hfXywgJDEpKTtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLm9udG91Y2hzdGFydCA9IGZ1bmN0aW9uIChlKXtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoZS5jaGFuZ2VkVG91Y2hlcyksIGxlbiA9IGFyeS5sZW5ndGgsIHQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dCA9IGFyeVtpXTtcblx0XHRcdGlmICh0aGlzLmxvb2t1cCh0KSkgeyBjb250aW51ZTsgfTtcblx0XHRcdHZhciB0b3VjaCA9IGlkZW50aWZpZXJzW3QuaWRlbnRpZmllcl0gPSBuZXcgdGhpcyhlKTsgLy8gKGUpXG5cdFx0XHR0Ll9fdG91Y2hfXyA9IHRvdWNoO1xuXHRcdFx0dG91Y2hlcy5wdXNoKHRvdWNoKTtcblx0XHRcdGNvdW50Kys7XG5cdFx0XHR0b3VjaC50b3VjaHN0YXJ0KGUsdCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gub250b3VjaG1vdmUgPSBmdW5jdGlvbiAoZSl7XG5cdFx0dmFyIHRvdWNoO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChlLmNoYW5nZWRUb3VjaGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgdDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR0ID0gYXJ5W2ldO1xuXHRcdFx0aWYgKHRvdWNoID0gdGhpcy5sb29rdXAodCkpIHtcblx0XHRcdFx0dG91Y2gudG91Y2htb3ZlKGUsdCk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLm9udG91Y2hlbmQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0dmFyIHRvdWNoO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChlLmNoYW5nZWRUb3VjaGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgdDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR0ID0gYXJ5W2ldO1xuXHRcdFx0aWYgKHRvdWNoID0gdGhpcy5sb29rdXAodCkpIHtcblx0XHRcdFx0dG91Y2gudG91Y2hlbmQoZSx0KTtcblx0XHRcdFx0dGhpcy5yZWxlYXNlKHQsdG91Y2gpO1xuXHRcdFx0XHRjb3VudC0tO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGUucHJldmVudERlZmF1bHRcblx0XHQvLyBub3QgYWx3YXlzIHN1cHBvcnRlZCFcblx0XHQvLyB0b3VjaGVzID0gdG91Y2hlcy5maWx0ZXIofHwpXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLm9udG91Y2hjYW5jZWwgPSBmdW5jdGlvbiAoZSl7XG5cdFx0dmFyIHRvdWNoO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChlLmNoYW5nZWRUb3VjaGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgdDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR0ID0gYXJ5W2ldO1xuXHRcdFx0aWYgKHRvdWNoID0gdGhpcy5sb29rdXAodCkpIHtcblx0XHRcdFx0dG91Y2gudG91Y2hjYW5jZWwoZSx0KTtcblx0XHRcdFx0dGhpcy5yZWxlYXNlKHQsdG91Y2gpO1xuXHRcdFx0XHRjb3VudC0tO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5vbm1vdXNlZG93biA9IGZ1bmN0aW9uIChlKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gub25tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLm9ubW91c2V1cCA9IGZ1bmN0aW9uIChlKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnBoYXNlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9waGFzZTsgfVxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5zZXRQaGFzZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9waGFzZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmFjdGl2ZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fYWN0aXZlOyB9XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldEFjdGl2ZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9hY3RpdmUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5ldmVudCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZXZlbnQ7IH1cblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuc2V0RXZlbnQgPSBmdW5jdGlvbih2KXsgdGhpcy5fZXZlbnQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5wb2ludGVyID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9wb2ludGVyOyB9XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldFBvaW50ZXIgPSBmdW5jdGlvbih2KXsgdGhpcy5fcG9pbnRlciA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnRhcmdldCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdGFyZ2V0OyB9XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldFRhcmdldCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl90YXJnZXQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5oYW5kbGVyID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9oYW5kbGVyOyB9XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldEhhbmRsZXIgPSBmdW5jdGlvbih2KXsgdGhpcy5faGFuZGxlciA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnVwZGF0ZXMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3VwZGF0ZXM7IH1cblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuc2V0VXBkYXRlcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl91cGRhdGVzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuc3VwcHJlc3MgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3N1cHByZXNzOyB9XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldFN1cHByZXNzID0gZnVuY3Rpb24odil7IHRoaXMuX3N1cHByZXNzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZGF0YTsgfVxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24odil7IHRoaXMuX2RhdGEgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLl9fYnViYmxlID0ge2NoYWluYWJsZTogdHJ1ZSxuYW1lOiAnYnViYmxlJ307XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmJ1YmJsZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkID8gKHRoaXMuc2V0QnViYmxlKHYpLHRoaXMpIDogdGhpcy5fYnViYmxlOyB9XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldEJ1YmJsZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9idWJibGUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuZ2VzdHVyZXMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2dlc3R1cmVzOyB9XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNldEdlc3R1cmVzID0gZnVuY3Rpb24odil7IHRoaXMuX2dlc3R1cmVzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHQvKlxuXHRcdFxuXHRcblx0XHRAaW50ZXJuYWxcblx0XHRAY29uc3RydWN0b3Jcblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuY2FwdHVyZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMuX2NhcHR1cmVkID0gdHJ1ZTtcblx0XHR0aGlzLl9ldmVudCAmJiB0aGlzLl9ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuaXNDYXB0dXJlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiAhIXRoaXMuX2NhcHR1cmVkO1xuXHR9O1xuXHRcblx0Lypcblx0XHRFeHRlbmQgdGhlIHRvdWNoIHdpdGggYSBwbHVnaW4gLyBnZXN0dXJlLiBcblx0XHRBbGwgZXZlbnRzICh0b3VjaHN0YXJ0LG1vdmUgZXRjKSBmb3IgdGhlIHRvdWNoXG5cdFx0d2lsbCBiZSB0cmlnZ2VyZWQgb24gdGhlIHBsdWdpbnMgaW4gdGhlIG9yZGVyIHRoZXlcblx0XHRhcmUgYWRkZWQuXG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIChwbHVnaW4pe1xuXHRcdC8vIGNvbnNvbGUubG9nIFwiYWRkZWQgZ2VzdHVyZSEhIVwiXG5cdFx0dGhpcy5fZ2VzdHVyZXMgfHwgKHRoaXMuX2dlc3R1cmVzID0gW10pO1xuXHRcdHRoaXMuX2dlc3R1cmVzLnB1c2gocGx1Z2luKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0UmVkaXJlY3QgdG91Y2ggdG8gc3BlY2lmaWVkIHRhcmdldC4gb250b3VjaHN0YXJ0IHdpbGwgYWx3YXlzIGJlXG5cdFx0Y2FsbGVkIG9uIHRoZSBuZXcgdGFyZ2V0LlxuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUucmVkaXJlY3QgPSBmdW5jdGlvbiAodGFyZ2V0KXtcblx0XHR0aGlzLl9yZWRpcmVjdCA9IHRhcmdldDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0U3VwcHJlc3MgdGhlIGRlZmF1bHQgYmVoYXZpb3VyLiBXaWxsIGNhbGwgcHJldmVudERlZmF1bHQgZm9yXG5cdFx0YWxsIG5hdGl2ZSBldmVudHMgdGhhdCBhcmUgcGFydCBvZiB0aGUgdG91Y2guXG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnN1cHByZXNzID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gY29sbGlzaW9uIHdpdGggdGhlIHN1cHByZXNzIHByb3BlcnR5XG5cdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5zZXRTdXBwcmVzcyA9IGZ1bmN0aW9uICh2YWx1ZSl7XG5cdFx0Y29uc29sZS53YXJuKCdJbWJhLlRvdWNoI3N1cHByZXNzPSBpcyBkZXByZWNhdGVkJyk7XG5cdFx0dGhpcy5fc3VwcmVzcyA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUudG91Y2hzdGFydCA9IGZ1bmN0aW9uIChlLHQpe1xuXHRcdHRoaXMuX2V2ZW50ID0gZTtcblx0XHR0aGlzLl90b3VjaCA9IHQ7XG5cdFx0dGhpcy5fYnV0dG9uID0gMDtcblx0XHR0aGlzLl94ID0gdC5jbGllbnRYO1xuXHRcdHRoaXMuX3kgPSB0LmNsaWVudFk7XG5cdFx0dGhpcy5iZWdhbigpO1xuXHRcdGlmIChlICYmIHRoaXMuaXNDYXB0dXJlZCgpKSB7IGUucHJldmVudERlZmF1bHQoKSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUudG91Y2htb3ZlID0gZnVuY3Rpb24gKGUsdCl7XG5cdFx0dGhpcy5fZXZlbnQgPSBlO1xuXHRcdHRoaXMuX3ggPSB0LmNsaWVudFg7XG5cdFx0dGhpcy5feSA9IHQuY2xpZW50WTtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdGlmIChlICYmIHRoaXMuaXNDYXB0dXJlZCgpKSB7IGUucHJldmVudERlZmF1bHQoKSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUudG91Y2hlbmQgPSBmdW5jdGlvbiAoZSx0KXtcblx0XHR0aGlzLl9ldmVudCA9IGU7XG5cdFx0dGhpcy5feCA9IHQuY2xpZW50WDtcblx0XHR0aGlzLl95ID0gdC5jbGllbnRZO1xuXHRcdHRoaXMuZW5kZWQoKTtcblx0XHRcblx0XHRsYXN0TmF0aXZlVG91Y2hUaW1lU3RhbXAgPSBlLnRpbWVTdGFtcDtcblx0XHRcblx0XHRpZiAodGhpcy5fbWF4ZHIgPCAyMCkge1xuXHRcdFx0dmFyIHRhcCA9IG5ldyBJbWJhLkV2ZW50KGUpO1xuXHRcdFx0dGFwLnNldFR5cGUoJ3RhcCcpO1xuXHRcdFx0dGFwLnByb2Nlc3MoKTtcblx0XHRcdGlmICh0YXAuX3Jlc3BvbmRlcikgeyBlLnByZXZlbnREZWZhdWx0KCkgfTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChlICYmIHRoaXMuaXNDYXB0dXJlZCgpKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnRvdWNoY2FuY2VsID0gZnVuY3Rpb24gKGUsdCl7XG5cdFx0cmV0dXJuIHRoaXMuY2FuY2VsKCk7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5tb3VzZWRvd24gPSBmdW5jdGlvbiAoZSx0KXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0c2VsZi5fZXZlbnQgPSBlO1xuXHRcdHNlbGYuX2J1dHRvbiA9IGUuYnV0dG9uO1xuXHRcdHNlbGYuX3ggPSB0LmNsaWVudFg7XG5cdFx0c2VsZi5feSA9IHQuY2xpZW50WTtcblx0XHRzZWxmLmJlZ2FuKCk7XG5cdFx0XG5cdFx0c2VsZi5fbW91c2Vtb3ZlID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gc2VsZi5tb3VzZW1vdmUoZSxlKTsgfTtcblx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJyxzZWxmLl9tb3VzZW1vdmUsdHJ1ZSk7XG5cdFx0cmV0dXJuIHNlbGY7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSx0KXtcblx0XHR0aGlzLl94ID0gdC5jbGllbnRYO1xuXHRcdHRoaXMuX3kgPSB0LmNsaWVudFk7XG5cdFx0dGhpcy5fZXZlbnQgPSBlO1xuXHRcdGlmICh0aGlzLmlzQ2FwdHVyZWQoKSkgeyBlLnByZXZlbnREZWZhdWx0KCkgfTtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdHRoaXMubW92ZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUubW91c2V1cCA9IGZ1bmN0aW9uIChlLHQpe1xuXHRcdHRoaXMuX3ggPSB0LmNsaWVudFg7XG5cdFx0dGhpcy5feSA9IHQuY2xpZW50WTtcblx0XHR0aGlzLmVuZGVkKCk7XG5cdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsdGhpcy5fbW91c2Vtb3ZlLHRydWUpO1xuXHRcdHRoaXMuX21vdXNlbW92ZSA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5pZGxlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlKCk7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5iZWdhbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMuX21heGRyID0gdGhpcy5fZHIgPSAwO1xuXHRcdHRoaXMuX3gwID0gdGhpcy5feDtcblx0XHR0aGlzLl95MCA9IHRoaXMuX3k7XG5cdFx0XG5cdFx0dmFyIGRvbSA9IHRoaXMuZXZlbnQoKS50YXJnZXQ7XG5cdFx0dmFyIG5vZGUgPSBudWxsO1xuXHRcdFxuXHRcdHRoaXMuX3NvdXJjZVRhcmdldCA9IGRvbSAmJiB0YWckd3JhcChkb20pO1xuXHRcdFxuXHRcdHdoaWxlIChkb20pe1xuXHRcdFx0bm9kZSA9IHRhZyR3cmFwKGRvbSk7XG5cdFx0XHRpZiAobm9kZSAmJiBub2RlLm9udG91Y2hzdGFydCkge1xuXHRcdFx0XHR0aGlzLl9idWJibGUgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5zZXRUYXJnZXQobm9kZSk7XG5cdFx0XHRcdHRoaXMudGFyZ2V0KCkub250b3VjaHN0YXJ0KHRoaXMpO1xuXHRcdFx0XHRpZiAoIXRoaXMuX2J1YmJsZSkgeyBicmVhazsgfTtcblx0XHRcdH07XG5cdFx0XHRkb20gPSBkb20ucGFyZW50Tm9kZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMuX3VwZGF0ZXMrKztcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciB0YXJnZXRfO1xuXHRcdGlmICghdGhpcy5fYWN0aXZlKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XG5cdFx0dmFyIGRyID0gTWF0aC5zcXJ0KHRoaXMuZHgoKSAqIHRoaXMuZHgoKSArIHRoaXMuZHkoKSAqIHRoaXMuZHkoKSk7XG5cdFx0aWYgKGRyID4gdGhpcy5fZHIpIHsgdGhpcy5fbWF4ZHIgPSBkciB9O1xuXHRcdHRoaXMuX2RyID0gZHI7XG5cdFx0XG5cdFx0Ly8gY2F0Y2hpbmcgYSB0b3VjaC1yZWRpcmVjdD8hP1xuXHRcdGlmICh0aGlzLl9yZWRpcmVjdCkge1xuXHRcdFx0aWYgKHRoaXMuX3RhcmdldCAmJiB0aGlzLl90YXJnZXQub250b3VjaGNhbmNlbCkge1xuXHRcdFx0XHR0aGlzLl90YXJnZXQub250b3VjaGNhbmNlbCh0aGlzKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLnNldFRhcmdldCh0aGlzLl9yZWRpcmVjdCk7XG5cdFx0XHR0aGlzLl9yZWRpcmVjdCA9IG51bGw7XG5cdFx0XHRpZiAodGhpcy50YXJnZXQoKS5vbnRvdWNoc3RhcnQpIHsgdGhpcy50YXJnZXQoKS5vbnRvdWNoc3RhcnQodGhpcykgfTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHRoaXMuX3VwZGF0ZXMrKztcblx0XHRpZiAodGhpcy5fZ2VzdHVyZXMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLl9nZXN0dXJlcyksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRhcnlbaV0ub250b3VjaHVwZGF0ZSh0aGlzKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHQodGFyZ2V0XyA9IHRoaXMudGFyZ2V0KCkpICYmIHRhcmdldF8ub250b3VjaHVwZGF0ZSAgJiYgIHRhcmdldF8ub250b3VjaHVwZGF0ZSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdGFyZ2V0Xztcblx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFxuXHRcdGlmICh0aGlzLl9nZXN0dXJlcykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMuX2dlc3R1cmVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgZzsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGcgPSBhcnlbaV07XG5cdFx0XHRcdGlmIChnLm9udG91Y2htb3ZlKSB7IGcub250b3VjaG1vdmUodGhpcyx0aGlzLl9ldmVudCkgfTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHQodGFyZ2V0XyA9IHRoaXMudGFyZ2V0KCkpICYmIHRhcmdldF8ub250b3VjaG1vdmUgICYmICB0YXJnZXRfLm9udG91Y2htb3ZlKHRoaXMsdGhpcy5fZXZlbnQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuZW5kZWQgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdGFyZ2V0Xztcblx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFxuXHRcdHRoaXMuX3VwZGF0ZXMrKztcblx0XHRcblx0XHRpZiAodGhpcy5fZ2VzdHVyZXMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLl9nZXN0dXJlcyksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRhcnlbaV0ub250b3VjaGVuZCh0aGlzKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHQodGFyZ2V0XyA9IHRoaXMudGFyZ2V0KCkpICYmIHRhcmdldF8ub250b3VjaGVuZCAgJiYgIHRhcmdldF8ub250b3VjaGVuZCh0aGlzKTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICghdGhpcy5fY2FuY2VsbGVkKSB7XG5cdFx0XHR0aGlzLl9jYW5jZWxsZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5jYW5jZWxsZWQoKTtcblx0XHRcdGlmICh0aGlzLl9tb3VzZW1vdmUpIHsgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsdGhpcy5fbW91c2Vtb3ZlLHRydWUpIH07XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmNhbmNlbGxlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciB0YXJnZXRfO1xuXHRcdGlmICghdGhpcy5fYWN0aXZlKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XG5cdFx0dGhpcy5fY2FuY2VsbGVkID0gdHJ1ZTtcblx0XHR0aGlzLl91cGRhdGVzKys7XG5cdFx0XG5cdFx0aWYgKHRoaXMuX2dlc3R1cmVzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5fZ2VzdHVyZXMpLCBsZW4gPSBhcnkubGVuZ3RoLCBnOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0ZyA9IGFyeVtpXTtcblx0XHRcdFx0aWYgKGcub250b3VjaGNhbmNlbCkgeyBnLm9udG91Y2hjYW5jZWwodGhpcykgfTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHQodGFyZ2V0XyA9IHRoaXMudGFyZ2V0KCkpICYmIHRhcmdldF8ub250b3VjaGNhbmNlbCAgJiYgIHRhcmdldF8ub250b3VjaGNhbmNlbCh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0VGhlIGFic29sdXRlIGRpc3RhbmNlIHRoZSB0b3VjaCBoYXMgbW92ZWQgZnJvbSBzdGFydGluZyBwb3NpdGlvbiBcblx0XHRAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmRyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2RyO1xuXHR9O1xuXHRcblx0Lypcblx0XHRUaGUgZGlzdGFuY2UgdGhlIHRvdWNoIGhhcyBtb3ZlZCBob3Jpem9udGFsbHlcblx0XHRAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLmR4ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3ggLSB0aGlzLl94MDtcblx0fTtcblx0XG5cdC8qXG5cdFx0VGhlIGRpc3RhbmNlIHRoZSB0b3VjaCBoYXMgbW92ZWQgdmVydGljYWxseVxuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUuZHkgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5feSAtIHRoaXMuX3kwO1xuXHR9O1xuXHRcblx0Lypcblx0XHRJbml0aWFsIGhvcml6b250YWwgcG9zaXRpb24gb2YgdG91Y2hcblx0XHRAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0Ki9cblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLngwID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3gwO1xuXHR9O1xuXHRcblx0Lypcblx0XHRJbml0aWFsIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRvdWNoXG5cdFx0QHJldHVybiB7TnVtYmVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS55MCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl95MDtcblx0fTtcblx0XG5cdC8qXG5cdFx0SG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0b3VjaFxuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUueCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl94O1xuXHR9O1xuXHRcblx0Lypcblx0XHRWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0b3VjaFxuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUueSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl95O1xuXHR9O1xuXHRcblx0Lypcblx0XHRIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRvdWNoIHJlbGF0aXZlIHRvIHRhcmdldFxuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5Ub3VjaC5wcm90b3R5cGUudHggPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl90YXJnZXRCb3ggfHwgKHRoaXMuX3RhcmdldEJveCA9IHRoaXMuX3RhcmdldC5kb20oKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG5cdFx0cmV0dXJuIHRoaXMuX3ggLSB0aGlzLl90YXJnZXRCb3gubGVmdDtcblx0fTtcblx0XG5cdC8qXG5cdFx0VmVydGljYWwgcG9zaXRpb24gb2YgdG91Y2ggcmVsYXRpdmUgdG8gdGFyZ2V0XG5cdFx0QHJldHVybiB7TnVtYmVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS50eSA9IGZ1bmN0aW9uICgpe1xuXHRcdHRoaXMuX3RhcmdldEJveCB8fCAodGhpcy5fdGFyZ2V0Qm94ID0gdGhpcy5fdGFyZ2V0LmRvbSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcblx0XHRyZXR1cm4gdGhpcy5feSAtIHRoaXMuX3RhcmdldEJveC50b3A7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEJ1dHRvbiBwcmVzc2VkIGluIHRoaXMgdG91Y2guIE5hdGl2ZSB0b3VjaGVzIGRlZmF1bHRzIHRvIGxlZnQtY2xpY2sgKDApXG5cdFx0QHJldHVybiB7TnVtYmVyfVxuXHRcdCovXG5cdFxuXHRJbWJhLlRvdWNoLnByb3RvdHlwZS5idXR0b24gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fYnV0dG9uO1xuXHR9OyAvLyBAcG9pbnRlciA/IEBwb2ludGVyLmJ1dHRvbiA6IDBcblx0XG5cdEltYmEuVG91Y2gucHJvdG90eXBlLnNvdXJjZVRhcmdldCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9zb3VyY2VUYXJnZXQ7XG5cdH07XG5cdFxuXHRcblx0SW1iYS5Ub3VjaEdlc3R1cmUgPSBmdW5jdGlvbiBUb3VjaEdlc3R1cmUoKXsgfTtcblx0XG5cdFxuXHRJbWJhLlRvdWNoR2VzdHVyZS5wcm90b3R5cGUuX19hY3RpdmUgPSB7J2RlZmF1bHQnOiBmYWxzZSxuYW1lOiAnYWN0aXZlJ307XG5cdEltYmEuVG91Y2hHZXN0dXJlLnByb3RvdHlwZS5hY3RpdmUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2FjdGl2ZTsgfVxuXHRJbWJhLlRvdWNoR2VzdHVyZS5wcm90b3R5cGUuc2V0QWN0aXZlID0gZnVuY3Rpb24odil7IHRoaXMuX2FjdGl2ZSA9IHY7IHJldHVybiB0aGlzOyB9XG5cdEltYmEuVG91Y2hHZXN0dXJlLnByb3RvdHlwZS5fYWN0aXZlID0gZmFsc2U7XG5cdFxuXHRJbWJhLlRvdWNoR2VzdHVyZS5wcm90b3R5cGUub250b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5Ub3VjaEdlc3R1cmUucHJvdG90eXBlLm9udG91Y2h1cGRhdGUgPSBmdW5jdGlvbiAoZSl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlRvdWNoR2VzdHVyZS5wcm90b3R5cGUub250b3VjaGVuZCA9IGZ1bmN0aW9uIChlKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHQvLyBBIFRvdWNoLWV2ZW50IGlzIGNyZWF0ZWQgb24gbW91c2Vkb3duIChhbHdheXMpXG5cdC8vIGFuZCB3aGlsZSBpdCBleGlzdHMsIG1vdXNlbW92ZSBhbmQgbW91c2V1cCB3aWxsXG5cdC8vIGJlIGRlbGVnYXRlZCB0byB0aGlzIGFjdGl2ZSBldmVudC5cblx0SW1iYS5QT0lOVEVSID0gbmV3IEltYmEuUG9pbnRlcigpO1xuXHRJbWJhLlBPSU5URVJTID0gW0ltYmEuUE9JTlRFUl07XG5cdFxuXHRcblx0Ly8gcmVndWxhciBldmVudCBzdHVmZlxuXHRJbWJhLktFWU1BUCA9IHtcblx0XHRcIjhcIjogJ2JhY2tzcGFjZScsXG5cdFx0XCI5XCI6ICd0YWInLFxuXHRcdFwiMTNcIjogJ2VudGVyJyxcblx0XHRcIjE2XCI6ICdzaGlmdCcsXG5cdFx0XCIxN1wiOiAnY3RybCcsXG5cdFx0XCIxOFwiOiAnYWx0Jyxcblx0XHRcIjE5XCI6ICdicmVhaycsXG5cdFx0XCIyMFwiOiAnY2FwcycsXG5cdFx0XCIyN1wiOiAnZXNjJyxcblx0XHRcIjMyXCI6ICdzcGFjZScsXG5cdFx0XCIzNVwiOiAnZW5kJyxcblx0XHRcIjM2XCI6ICdob21lJyxcblx0XHRcIjM3XCI6ICdsYXJyJyxcblx0XHRcIjM4XCI6ICd1YXJyJyxcblx0XHRcIjM5XCI6ICdyYXJyJyxcblx0XHRcIjQwXCI6ICdkYXJyJyxcblx0XHRcIjQ1XCI6ICdpbnNlcnQnLFxuXHRcdFwiNDZcIjogJ2RlbGV0ZScsXG5cdFx0XCIxMDdcIjogJ3BsdXMnLFxuXHRcdFwiMTA2XCI6ICdtdWx0Jyxcblx0XHRcIjkxXCI6ICdtZXRhJ1xuXHR9O1xuXHRcblx0SW1iYS5DSEFSTUFQID0ge1xuXHRcdFwiJVwiOiAnbW9kdWxvJyxcblx0XHRcIipcIjogJ211bHRpcGx5Jyxcblx0XHRcIitcIjogJ2FkZCcsXG5cdFx0XCItXCI6ICdzdWInLFxuXHRcdFwiL1wiOiAnZGl2aWRlJyxcblx0XHRcIi5cIjogJ2RvdCdcblx0fTtcblx0XG5cdC8qXG5cdEltYmEgaGFuZGxlcyBhbGwgZXZlbnRzIGluIHRoZSBkb20gdGhyb3VnaCBhIHNpbmdsZSBtYW5hZ2VyLFxuXHRsaXN0ZW5pbmcgYXQgdGhlIHJvb3Qgb2YgeW91ciBkb2N1bWVudC4gSWYgSW1iYSBmaW5kcyBhIHRhZ1xuXHR0aGF0IGxpc3RlbnMgdG8gYSBjZXJ0YWluIGV2ZW50LCB0aGUgZXZlbnQgd2lsbCBiZSB3cmFwcGVkIFxuXHRpbiBhbiBgSW1iYS5FdmVudGAsIHdoaWNoIG5vcm1hbGl6ZXMgc29tZSBvZiB0aGUgcXVpcmtzIGFuZCBcblx0YnJvd3NlciBkaWZmZXJlbmNlcy5cblx0XG5cdEBpbmFtZSBldmVudFxuXHQqL1xuXHRcblx0SW1iYS5FdmVudCA9IGZ1bmN0aW9uIEV2ZW50KGUpe1xuXHRcdHRoaXMuc2V0RXZlbnQoZSk7XG5cdFx0dGhpcy5zZXRCdWJibGUodHJ1ZSk7XG5cdH07XG5cdFxuXHQvKiByZWZlcmVuY2UgdG8gdGhlIG5hdGl2ZSBldmVudCAqL1xuXHRcblx0XG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5ldmVudCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZXZlbnQ7IH1cblx0SW1iYS5FdmVudC5wcm90b3R5cGUuc2V0RXZlbnQgPSBmdW5jdGlvbih2KXsgdGhpcy5fZXZlbnQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdC8qIHJlZmVyZW5jZSB0byB0aGUgbmF0aXZlIGV2ZW50ICovXG5cdFxuXHRcblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnByZWZpeCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcHJlZml4OyB9XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnNldFByZWZpeCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9wcmVmaXggPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZGF0YTsgfVxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24odil7IHRoaXMuX2RhdGEgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdC8qXG5cdFx0c2hvdWxkIHJlbW92ZSB0aGlzIGFsbHRvZ2V0aGVyP1xuXHRcdEBkZXByZWNhdGVkXG5cdFx0Ki9cblx0XG5cdFxuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9zb3VyY2U7IH1cblx0SW1iYS5FdmVudC5wcm90b3R5cGUuc2V0U291cmNlID0gZnVuY3Rpb24odil7IHRoaXMuX3NvdXJjZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0LyogQSB7Qm9vbGVhbn0gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBldmVudCBidWJibGVzIHVwIG9yIG5vdCAqL1xuXHRcblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLl9fYnViYmxlID0ge3R5cGU6IEJvb2xlYW4sY2hhaW5hYmxlOiB0cnVlLG5hbWU6ICdidWJibGUnfTtcblx0SW1iYS5FdmVudC5wcm90b3R5cGUuYnViYmxlID0gZnVuY3Rpb24odil7IHJldHVybiB2ICE9PSB1bmRlZmluZWQgPyAodGhpcy5zZXRCdWJibGUodiksdGhpcykgOiB0aGlzLl9idWJibGU7IH1cblx0SW1iYS5FdmVudC5wcm90b3R5cGUuc2V0QnViYmxlID0gZnVuY3Rpb24odil7IHRoaXMuX2J1YmJsZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0SW1iYS5FdmVudC53cmFwID0gZnVuY3Rpb24gKGUpe1xuXHRcdHJldHVybiBuZXcgdGhpcyhlKTtcblx0fTtcblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnNldFR5cGUgPSBmdW5jdGlvbiAodHlwZSl7XG5cdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEByZXR1cm4ge1N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChjYXNlLWluc2Vuc2l0aXZlKVxuXHRcdCovXG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGUgfHwgdGhpcy5ldmVudCgpLnR5cGU7XG5cdH07XG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX25hbWUgfHwgKHRoaXMuX25hbWUgPSB0aGlzLnR5cGUoKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xcOi9nLCcnKSk7XG5cdH07XG5cdFxuXHQvLyBtaW1jIGdldHNldFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5idWJibGUgPSBmdW5jdGlvbiAodil7XG5cdFx0aWYgKHYgIT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldEJ1YmJsZSh2KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXMuX2J1YmJsZTtcblx0fTtcblx0XG5cdC8qXG5cdFx0UHJldmVudHMgZnVydGhlciBwcm9wYWdhdGlvbiBvZiB0aGUgY3VycmVudCBldmVudC5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5oYWx0ID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5zZXRCdWJibGUoZmFsc2UpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRDYW5jZWwgdGhlIGV2ZW50IChpZiBjYW5jZWxhYmxlKS4gSW4gdGhlIGNhc2Ugb2YgbmF0aXZlIGV2ZW50cyBpdFxuXHRcdHdpbGwgY2FsbCBgcHJldmVudERlZmF1bHRgIG9uIHRoZSB3cmFwcGVkIGV2ZW50IG9iamVjdC5cblx0XHRAcmV0dXJuIHtzZWxmfVxuXHRcdCovXG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5ldmVudCgpLnByZXZlbnREZWZhdWx0KSB7IHRoaXMuZXZlbnQoKS5wcmV2ZW50RGVmYXVsdCgpIH07XG5cdFx0dGhpcy5fY2FuY2VsID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0SW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IGV2ZW50LmNhbmNlbCBoYXMgYmVlbiBjYWxsZWQuXG5cdFxuXHRcdEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0Ki9cblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLmlzUHJldmVudGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuZXZlbnQoKSAmJiB0aGlzLmV2ZW50KCkuZGVmYXVsdFByZXZlbnRlZCB8fCB0aGlzLl9jYW5jZWw7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEEgcmVmZXJlbmNlIHRvIHRoZSBpbml0aWFsIHRhcmdldCBvZiB0aGUgZXZlbnQuXG5cdFx0Ki9cblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnRhcmdldCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0YWckd3JhcCh0aGlzLmV2ZW50KCkuX3RhcmdldCB8fCB0aGlzLmV2ZW50KCkudGFyZ2V0KTtcblx0fTtcblx0XG5cdC8qXG5cdFx0QSByZWZlcmVuY2UgdG8gdGhlIG9iamVjdCByZXNwb25kaW5nIHRvIHRoZSBldmVudC5cblx0XHQqL1xuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUucmVzcG9uZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3Jlc3BvbmRlcjtcblx0fTtcblx0XG5cdC8qXG5cdFx0UmVkaXJlY3QgdGhlIGV2ZW50IHRvIG5ldyB0YXJnZXRcblx0XHQqL1xuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUucmVkaXJlY3QgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0dGhpcy5fcmVkaXJlY3QgPSBub2RlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRHZXQgdGhlIG5vcm1hbGl6ZWQgY2hhcmFjdGVyIGZvciBLZXlib2FyZEV2ZW50L1RleHRFdmVudFxuXHRcdEByZXR1cm4ge1N0cmluZ31cblx0XHQqL1xuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUua2V5Y2hhciA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLmV2ZW50KCkgaW5zdGFuY2VvZiBUZXh0RXZlbnQpIHtcblx0XHRcdHJldHVybiB0aGlzLmV2ZW50KCkuZGF0YTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh0aGlzLmV2ZW50KCkgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50KSB7XG5cdFx0XHR2YXIga2kgPSB0aGlzLmV2ZW50KCkua2V5SWRlbnRpZmllcjtcblx0XHRcdHZhciBzeW0gPSBJbWJhLktFWU1BUFt0aGlzLmV2ZW50KCkua2V5Q29kZV07XG5cdFx0XHRcblx0XHRcdC8vIHAgJ2tleXN5bSEnLGtpLHN5bVxuXHRcdFx0XG5cdFx0XHRpZiAoIXN5bSAmJiBraS5zdWJzdHIoMCwyKSA9PSBcIlUrXCIpIHtcblx0XHRcdFx0c3ltID0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChraS5zdWJzdHIoMiksMTYpKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gc3ltO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cdFxuXHQvKlxuXHRcdEBkZXByZWNhdGVkXG5cdFx0Ki9cblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLmtleWNvbWJvID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHN5bTtcblx0XHRpZiAoIShzeW0gPSB0aGlzLmtleWNoYXIoKSkpIHsgcmV0dXJuIH07XG5cdFx0c3ltID0gSW1iYS5DSEFSTUFQW3N5bV0gfHwgc3ltO1xuXHRcdHZhciBjb21ibyA9IFtdLGUgPSB0aGlzLmV2ZW50KCk7XG5cdFx0aWYgKGUuY3RybEtleSkgeyBjb21iby5wdXNoKCdjdHJsJykgfTtcblx0XHRpZiAoZS5zaGlmdEtleSkgeyBjb21iby5wdXNoKCdzaGlmdCcpIH07XG5cdFx0aWYgKGUuYWx0S2V5KSB7IGNvbWJvLnB1c2goJ2FsdCcpIH07XG5cdFx0aWYgKGUubWV0YUtleSkgeyBjb21iby5wdXNoKCdjbWQnKSB9O1xuXHRcdGNvbWJvLnB1c2goc3ltKTtcblx0XHRyZXR1cm4gY29tYm8uam9pbihcIl9cIikudG9Mb3dlckNhc2UoKTtcblx0fTtcblx0XG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG5vZGU7XG5cdFx0dmFyIG1ldGggPSAoXCJvblwiICsgKHRoaXMuX3ByZWZpeCB8fCAnJykgKyB0aGlzLm5hbWUoKSk7XG5cdFx0dmFyIGFyZ3MgPSBudWxsO1xuXHRcdHZhciBkb210YXJnZXQgPSB0aGlzLmV2ZW50KCkuX3RhcmdldCB8fCB0aGlzLmV2ZW50KCkudGFyZ2V0O1xuXHRcdC8vIHZhciBub2RlID0gPHtkb210YXJnZXQ6X3Jlc3BvbmRlciBvciBkb210YXJnZXR9PlxuXHRcdC8vIG5lZWQgdG8gY2xlYW4gdXAgYW5kIGRvY3VtZW50IHRoaXMgYmVoYXZpb3VyXG5cdFx0XG5cdFx0dmFyIGRvbW5vZGUgPSBkb210YXJnZXQuX3Jlc3BvbmRlciB8fCBkb210YXJnZXQ7XG5cdFx0Ly8gQHRvZG8gbmVlZCB0byBzdG9wIGluZmluaXRlIHJlZGlyZWN0LXJ1bGVzIGhlcmVcblx0XHRcblx0XHR2YXIgJDE7d2hpbGUgKGRvbW5vZGUpe1xuXHRcdFx0dGhpcy5fcmVkaXJlY3QgPSBudWxsO1xuXHRcdFx0aWYgKG5vZGUgPSB0YWckd3JhcChkb21ub2RlKSkgeyAvLyBub3Qgb25seSB0YWcgXG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoKHR5cGVvZiBub2RlWygkMSA9IG1ldGgpXT09J3N0cmluZyd8fG5vZGVbJDFdIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuXHRcdFx0XHRcdC8vIHNob3VsZCByZW1lbWJlciB0aGUgcmVjZWl2ZXIgb2YgdGhlIGV2ZW50XG5cdFx0XHRcdFx0bWV0aCA9IG5vZGVbbWV0aF07XG5cdFx0XHRcdFx0Y29udGludWU7IC8vIHNob3VsZCBub3QgY29udGludWU/XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobm9kZVttZXRoXSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdFx0YXJncyA9IG5vZGVbbWV0aF0uY29uY2F0KG5vZGUpO1xuXHRcdFx0XHRcdG1ldGggPSBhcmdzLnNoaWZ0KCk7XG5cdFx0XHRcdFx0Y29udGludWU7IC8vIHNob3VsZCBub3QgY29udGludWU/XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobm9kZVttZXRoXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmVzcG9uZGVyIHx8ICh0aGlzLl9yZXNwb25kZXIgPSBub2RlKTtcblx0XHRcdFx0XHQvLyBzaG91bGQgYXV0b3N0b3AgYnViYmxlIGhlcmU/XG5cdFx0XHRcdFx0YXJncyA/IChub2RlW21ldGhdLmFwcGx5KG5vZGUsYXJncykpIDogKG5vZGVbbWV0aF0odGhpcyx0aGlzLmRhdGEoKSkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gYWRkIG5vZGUubmV4dEV2ZW50UmVzcG9uZGVyIGFzIGEgc2VwYXJhdGUgbWV0aG9kIGhlcmU/XG5cdFx0XHRpZiAoISh0aGlzLmJ1YmJsZSgpICYmIChkb21ub2RlID0gKHRoaXMuX3JlZGlyZWN0IHx8IChub2RlID8gKG5vZGUucGFyZW50KCkpIDogKGRvbW5vZGUucGFyZW50Tm9kZSkpKSkpKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMucHJvY2Vzc2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUucHJvY2Vzc2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0SW1iYS5lbWl0KEltYmEsJ2V2ZW50JyxbdGhpc10pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Lypcblx0XHRSZXR1cm4gdGhlIHgvbGVmdCBjb29yZGluYXRlIG9mIHRoZSBtb3VzZSAvIHBvaW50ZXIgZm9yIHRoaXMgZXZlbnRcblx0XHRAcmV0dXJuIHtOdW1iZXJ9IHggY29vcmRpbmF0ZSBvZiBtb3VzZSAvIHBvaW50ZXIgZm9yIGV2ZW50XG5cdFx0Ki9cblx0XG5cdEltYmEuRXZlbnQucHJvdG90eXBlLnggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5ldmVudCgpLng7XG5cdH07XG5cdFxuXHQvKlxuXHRcdFJldHVybiB0aGUgeS90b3AgY29vcmRpbmF0ZSBvZiB0aGUgbW91c2UgLyBwb2ludGVyIGZvciB0aGlzIGV2ZW50XG5cdFx0QHJldHVybiB7TnVtYmVyfSB5IGNvb3JkaW5hdGUgb2YgbW91c2UgLyBwb2ludGVyIGZvciBldmVudFxuXHRcdCovXG5cdFxuXHRJbWJhLkV2ZW50LnByb3RvdHlwZS55ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuZXZlbnQoKS55O1xuXHR9O1xuXHRcblx0Lypcblx0XHRSZXR1cm5zIGEgTnVtYmVyIHJlcHJlc2VudGluZyBhIHN5c3RlbSBhbmQgaW1wbGVtZW50YXRpb25cblx0XHRkZXBlbmRlbnQgbnVtZXJpYyBjb2RlIGlkZW50aWZ5aW5nIHRoZSB1bm1vZGlmaWVkIHZhbHVlIG9mIHRoZVxuXHRcdHByZXNzZWQga2V5OyB0aGlzIGlzIHVzdWFsbHkgdGhlIHNhbWUgYXMga2V5Q29kZS5cblx0XG5cdFx0Rm9yIG1vdXNlLWV2ZW50cywgdGhlIHJldHVybmVkIHZhbHVlIGluZGljYXRlcyB3aGljaCBidXR0b24gd2FzXG5cdFx0cHJlc3NlZCBvbiB0aGUgbW91c2UgdG8gdHJpZ2dlciB0aGUgZXZlbnQuXG5cdFxuXHRcdEByZXR1cm4ge051bWJlcn1cblx0XHQqL1xuXHRcblx0SW1iYS5FdmVudC5wcm90b3R5cGUud2hpY2ggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5ldmVudCgpLndoaWNoO1xuXHR9O1xuXHRcblx0XG5cdC8qXG5cdFxuXHRNYW5hZ2VyIGZvciBsaXN0ZW5pbmcgdG8gYW5kIGRlbGVnYXRpbmcgZXZlbnRzIGluIEltYmEuIEEgc2luZ2xlIGluc3RhbmNlXG5cdGlzIGFsd2F5cyBjcmVhdGVkIGJ5IEltYmEgKGFzIGBJbWJhLkV2ZW50c2ApLCB3aGljaCBoYW5kbGVzIGFuZCBkZWxlZ2F0ZXMgYWxsXG5cdGV2ZW50cyBhdCB0aGUgdmVyeSByb290IG9mIHRoZSBkb2N1bWVudC4gSW1iYSBkb2VzIG5vdCBjYXB0dXJlIGFsbCBldmVudHNcblx0YnkgZGVmYXVsdCwgc28gaWYgeW91IHdhbnQgdG8gbWFrZSBzdXJlIGV4b3RpYyBvciBjdXN0b20gRE9NRXZlbnRzIGFyZSBkZWxlZ2F0ZWRcblx0aW4gSW1iYSB5b3Ugd2lsbCBuZWVkIHRvIHJlZ2lzdGVyIHRoZW0gaW4gYEltYmEuRXZlbnRzLnJlZ2lzdGVyKG15Q3VzdG9tRXZlbnROYW1lKWBcblx0XG5cdEBpbmFtZSBtYW5hZ2VyXG5cdFxuXHQqL1xuXHRcblx0SW1iYS5FdmVudE1hbmFnZXIgPSBmdW5jdGlvbiBFdmVudE1hbmFnZXIobm9kZSxwYXJzKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYoIXBhcnN8fHBhcnMuY29uc3RydWN0b3IgIT09IE9iamVjdCkgcGFycyA9IHt9O1xuXHRcdHZhciBldmVudHMgPSBwYXJzLmV2ZW50cyAhPT0gdW5kZWZpbmVkID8gcGFycy5ldmVudHMgOiBbXTtcblx0XHRzZWxmLnNldFJvb3Qobm9kZSk7XG5cdFx0c2VsZi5zZXRDb3VudCgwKTtcblx0XHRzZWxmLnNldExpc3RlbmVycyhbXSk7XG5cdFx0c2VsZi5zZXREZWxlZ2F0b3JzKHt9KTtcblx0XHRzZWxmLnNldERlbGVnYXRvcihmdW5jdGlvbihlKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImRlbGVnYXRpbmcgZXZlbnQ/ISB7ZX1cIlxuXHRcdFx0c2VsZi5kZWxlZ2F0ZShlKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0pO1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChldmVudHMpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHNlbGYucmVnaXN0ZXIoYXJ5W2ldKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBzZWxmO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUucm9vdCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcm9vdDsgfVxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuc2V0Um9vdCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9yb290ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9jb3VudDsgfVxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuc2V0Q291bnQgPSBmdW5jdGlvbih2KXsgdGhpcy5fY291bnQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5fX2VuYWJsZWQgPSB7J2RlZmF1bHQnOiBmYWxzZSx3YXRjaDogJ2VuYWJsZWREaWRTZXQnLG5hbWU6ICdlbmFibGVkJ307XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5lbmFibGVkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9lbmFibGVkOyB9XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5zZXRFbmFibGVkID0gZnVuY3Rpb24odil7XG5cdFx0dmFyIGEgPSB0aGlzLmVuYWJsZWQoKTtcblx0XHRpZih2ICE9IGEpIHsgdGhpcy5fZW5hYmxlZCA9IHY7IH1cblx0XHRpZih2ICE9IGEpIHsgdGhpcy5lbmFibGVkRGlkU2V0ICYmIHRoaXMuZW5hYmxlZERpZFNldCh2LGEsdGhpcy5fX2VuYWJsZWQpIH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuX2VuYWJsZWQgPSBmYWxzZTtcblx0XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9saXN0ZW5lcnM7IH1cblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLnNldExpc3RlbmVycyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9saXN0ZW5lcnMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuZGVsZWdhdG9ycyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZGVsZWdhdG9yczsgfVxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuc2V0RGVsZWdhdG9ycyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9kZWxlZ2F0b3JzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLmRlbGVnYXRvciA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZGVsZWdhdG9yOyB9XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5zZXREZWxlZ2F0b3IgPSBmdW5jdGlvbih2KXsgdGhpcy5fZGVsZWdhdG9yID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuZW5hYmxlZERpZFNldCA9IGZ1bmN0aW9uIChib29sKXtcblx0XHRib29sID8gKHRoaXMub25lbmFibGUoKSkgOiAodGhpcy5vbmRpc2FibGUoKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKlxuXHRcblx0XHRUZWxsIHRoZSBjdXJyZW50IEV2ZW50TWFuYWdlciB0byBpbnRlcmNlcHQgYW5kIGhhbmRsZSBldmVudCBvZiBhIGNlcnRhaW4gbmFtZS5cblx0XHRCeSBkZWZhdWx0LCBJbWJhLkV2ZW50cyB3aWxsIHJlZ2lzdGVyIGludGVyY2VwdG9ycyBmb3I6ICprZXlkb3duKiwgKmtleXVwKiwgXG5cdFx0KmtleXByZXNzKiwgKnRleHRJbnB1dCosICppbnB1dCosICpjaGFuZ2UqLCAqc3VibWl0KiwgKmZvY3VzaW4qLCAqZm9jdXNvdXQqLCBcblx0XHQqYmx1ciosICpjb250ZXh0bWVudSosICpkYmxjbGljayosICptb3VzZXdoZWVsKiwgKndoZWVsKlxuXHRcblx0XHQqL1xuXHRcblx0SW1iYS5FdmVudE1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKG5hbWUsaGFuZGxlcil7XG5cdFx0aWYoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSBoYW5kbGVyID0gdHJ1ZTtcblx0XHRpZiAobmFtZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobmFtZSksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHR0aGlzLnJlZ2lzdGVyKGFyeVtpXSxoYW5kbGVyKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh0aGlzLmRlbGVnYXRvcnMoKVtuYW1lXSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdC8vIGNvbnNvbGUubG9nKFwicmVnaXN0ZXIgZm9yIGV2ZW50IHtuYW1lfVwiKVxuXHRcdHZhciBmbiA9IHRoaXMuZGVsZWdhdG9ycygpW25hbWVdID0gaGFuZGxlciBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gKGhhbmRsZXIpIDogKHRoaXMuZGVsZWdhdG9yKCkpO1xuXHRcdGlmICh0aGlzLmVuYWJsZWQoKSkgeyByZXR1cm4gdGhpcy5yb290KCkuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLGZuLHRydWUpIH07XG5cdH07XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKG5hbWUsaGFuZGxlcixjYXB0dXJlKXtcblx0XHRpZihjYXB0dXJlID09PSB1bmRlZmluZWQpIGNhcHR1cmUgPSB0cnVlO1xuXHRcdHRoaXMubGlzdGVuZXJzKCkucHVzaChbbmFtZSxoYW5kbGVyLGNhcHR1cmVdKTtcblx0XHRpZiAodGhpcy5lbmFibGVkKCkpIHsgdGhpcy5yb290KCkuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLGhhbmRsZXIsY2FwdHVyZSkgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5kZWxlZ2F0ZSA9IGZ1bmN0aW9uIChlKXtcblx0XHR0aGlzLnNldENvdW50KHRoaXMuY291bnQoKSArIDEpO1xuXHRcdHZhciBldmVudCA9IEltYmEuRXZlbnQud3JhcChlKTtcblx0XHRldmVudC5wcm9jZXNzKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHR5cGUsdGFyZ2V0LHBhcnMpe1xuXHRcdGlmKCFwYXJzfHxwYXJzLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHBhcnMgPSB7fTtcblx0XHR2YXIgZGF0YSA9IHBhcnMuZGF0YSAhPT0gdW5kZWZpbmVkID8gcGFycy5kYXRhIDogbnVsbDtcblx0XHR2YXIgc291cmNlID0gcGFycy5zb3VyY2UgIT09IHVuZGVmaW5lZCA/IHBhcnMuc291cmNlIDogbnVsbDtcblx0XHR2YXIgZXZlbnQgPSBJbWJhLkV2ZW50LndyYXAoe3R5cGU6IHR5cGUsdGFyZ2V0OiB0YXJnZXR9KTtcblx0XHRpZiAoZGF0YSkgeyAoZXZlbnQuc2V0RGF0YShkYXRhKSxkYXRhKSB9O1xuXHRcdGlmIChzb3VyY2UpIHsgKGV2ZW50LnNldFNvdXJjZShzb3VyY2UpLHNvdXJjZSkgfTtcblx0XHRyZXR1cm4gZXZlbnQ7XG5cdH07XG5cdFxuXHQvLyB1c2UgY3JlYXRlIGluc3RlYWQ/XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuY3JlYXRlLmFwcGx5KHRoaXMsYXJndW1lbnRzKS5wcm9jZXNzKCk7XG5cdH07XG5cdFxuXHRJbWJhLkV2ZW50TWFuYWdlci5wcm90b3R5cGUub25lbmFibGUgPSBmdW5jdGlvbiAoKXtcblx0XHRmb3IgKHZhciBvID0gdGhpcy5kZWxlZ2F0b3JzKCksIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMobyksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHR0aGlzLnJvb3QoKS5hZGRFdmVudExpc3RlbmVyKGtleXNbaV0sb1trZXlzW2ldXSx0cnVlKTtcblx0XHR9O1xuXHRcdFxuXHRcdGZvciAodmFyIGogPSAwLCBhcnkgPSBpdGVyJCh0aGlzLmxpc3RlbmVycygpKSwgbGVuID0gYXJ5Lmxlbmd0aCwgaXRlbTsgaiA8IGxlbjsgaisrKSB7XG5cdFx0XHRpdGVtID0gYXJ5W2pdO1xuXHRcdFx0dGhpcy5yb290KCkuYWRkRXZlbnRMaXN0ZW5lcihpdGVtWzBdLGl0ZW1bMV0saXRlbVsyXSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmEuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5vbmRpc2FibGUgPSBmdW5jdGlvbiAoKXtcblx0XHRmb3IgKHZhciBvID0gdGhpcy5kZWxlZ2F0b3JzKCksIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMobyksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHR0aGlzLnJvb3QoKS5yZW1vdmVFdmVudExpc3RlbmVyKGtleXNbaV0sb1trZXlzW2ldXSx0cnVlKTtcblx0XHR9O1xuXHRcdFxuXHRcdGZvciAodmFyIGogPSAwLCBhcnkgPSBpdGVyJCh0aGlzLmxpc3RlbmVycygpKSwgbGVuID0gYXJ5Lmxlbmd0aCwgaXRlbTsgaiA8IGxlbjsgaisrKSB7XG5cdFx0XHRpdGVtID0gYXJ5W2pdO1xuXHRcdFx0dGhpcy5yb290KCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihpdGVtWzBdLGl0ZW1bMV0saXRlbVsyXSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFxuXHRFRCA9IEltYmEuRXZlbnRzID0gbmV3IEltYmEuRXZlbnRNYW5hZ2VyKGRvY3VtZW50LHtldmVudHM6IFtcblx0XHQna2V5ZG93bicsJ2tleXVwJywna2V5cHJlc3MnLCd0ZXh0SW5wdXQnLCdpbnB1dCcsJ2NoYW5nZScsJ3N1Ym1pdCcsXG5cdFx0J2ZvY3VzaW4nLCdmb2N1c291dCcsJ2JsdXInLCdjb250ZXh0bWVudScsJ2RibGNsaWNrJyxcblx0XHQnbW91c2V3aGVlbCcsJ3doZWVsJ1xuXHRdfSk7XG5cdFxuXHQvLyBzaG91bGQgc2V0IHRoZXNlIHVwIGluc2lkZSB0aGUgSW1iYS5FdmVudHMgb2JqZWN0IGl0c2VsZlxuXHQvLyBzbyB0aGF0IHdlIGNhbiBoYXZlIGRpZmZlcmVudCBFdmVudE1hbmFnZXIgZm9yIGRpZmZlcmVudCByb290c1xuXHRcblx0aWYgKGhhc1RvdWNoRXZlbnRzKSB7XG5cdFx0SW1iYS5FdmVudHMubGlzdGVuKCd0b3VjaHN0YXJ0JyxmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgRXZlbnRzXywgdl87XG5cdFx0XHQoKChFdmVudHNfID0gSW1iYS5FdmVudHMpLnNldENvdW50KHZfID0gRXZlbnRzXy5jb3VudCgpICsgMSksdl8pKSAtIDE7XG5cdFx0XHRyZXR1cm4gSW1iYS5Ub3VjaC5vbnRvdWNoc3RhcnQoZSk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0SW1iYS5FdmVudHMubGlzdGVuKCd0b3VjaG1vdmUnLGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBFdmVudHNfLCB2Xztcblx0XHRcdCgoKEV2ZW50c18gPSBJbWJhLkV2ZW50cykuc2V0Q291bnQodl8gPSBFdmVudHNfLmNvdW50KCkgKyAxKSx2XykpIC0gMTtcblx0XHRcdHJldHVybiBJbWJhLlRvdWNoLm9udG91Y2htb3ZlKGUpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdEltYmEuRXZlbnRzLmxpc3RlbigndG91Y2hlbmQnLGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBFdmVudHNfLCB2Xztcblx0XHRcdCgoKEV2ZW50c18gPSBJbWJhLkV2ZW50cykuc2V0Q291bnQodl8gPSBFdmVudHNfLmNvdW50KCkgKyAxKSx2XykpIC0gMTtcblx0XHRcdHJldHVybiBJbWJhLlRvdWNoLm9udG91Y2hlbmQoZSk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0SW1iYS5FdmVudHMubGlzdGVuKCd0b3VjaGNhbmNlbCcsZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIEV2ZW50c18sIHZfO1xuXHRcdFx0KCgoRXZlbnRzXyA9IEltYmEuRXZlbnRzKS5zZXRDb3VudCh2XyA9IEV2ZW50c18uY291bnQoKSArIDEpLHZfKSkgLSAxO1xuXHRcdFx0cmV0dXJuIEltYmEuVG91Y2gub250b3VjaGNhbmNlbChlKTtcblx0XHR9KTtcblx0fTtcblx0XG5cdEltYmEuRXZlbnRzLnJlZ2lzdGVyKCdjbGljaycsZnVuY3Rpb24oZSkge1xuXHRcdC8vIE9ubHkgZm9yIG1haW4gbW91c2VidXR0b24sIG5vP1xuXHRcdGlmICgoZS50aW1lU3RhbXAgLSBsYXN0TmF0aXZlVG91Y2hUaW1lU3RhbXApID4gbGFzdE5hdGl2ZVRvdWNoVGltZW91dCkge1xuXHRcdFx0dmFyIHRhcCA9IG5ldyBJbWJhLkV2ZW50KGUpO1xuXHRcdFx0dGFwLnNldFR5cGUoJ3RhcCcpO1xuXHRcdFx0dGFwLnByb2Nlc3MoKTtcblx0XHRcdGlmICh0YXAuX3Jlc3BvbmRlcikge1xuXHRcdFx0XHRyZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdC8vIGRlbGVnYXRlIHRoZSByZWFsIGNsaWNrIGV2ZW50XG5cdFx0cmV0dXJuIEltYmEuRXZlbnRzLmRlbGVnYXRlKGUpO1xuXHR9KTtcblx0XG5cdEltYmEuRXZlbnRzLmxpc3RlbignbW91c2Vkb3duJyxmdW5jdGlvbihlKSB7XG5cdFx0aWYgKChlLnRpbWVTdGFtcCAtIGxhc3ROYXRpdmVUb3VjaFRpbWVTdGFtcCkgPiBsYXN0TmF0aXZlVG91Y2hUaW1lb3V0KSB7XG5cdFx0XHRpZiAoSW1iYS5QT0lOVEVSKSB7IHJldHVybiBJbWJhLlBPSU5URVIudXBkYXRlKGUpLnByb2Nlc3MoKSB9O1xuXHRcdH07XG5cdH0pO1xuXHRcblx0Ly8gSW1iYS5FdmVudHMubGlzdGVuKDptb3VzZW1vdmUpIGRvIHxlfFxuXHQvLyBcdCMgY29uc29sZS5sb2cgJ21vdXNlbW92ZScsZTp0aW1lU3RhbXBcblx0Ly8gXHRpZiAoZTp0aW1lU3RhbXAgLSBsYXN0TmF0aXZlVG91Y2hUaW1lU3RhbXApID4gbGFzdE5hdGl2ZVRvdWNoVGltZW91dFxuXHQvLyBcdFx0SW1iYS5QT0lOVEVSLnVwZGF0ZShlKS5wcm9jZXNzIGlmIEltYmEuUE9JTlRFUiAjIC5wcm9jZXNzIGlmIHRvdWNoICMgc2hvdWxkIG5vdCBoYXBwZW4/IFdlIHByb2Nlc3MgdGhyb3VnaCBcblx0XG5cdEltYmEuRXZlbnRzLmxpc3RlbignbW91c2V1cCcsZnVuY3Rpb24oZSkge1xuXHRcdC8vIGNvbnNvbGUubG9nICdtb3VzZXVwJyxlOnRpbWVTdGFtcFxuXHRcdGlmICgoZS50aW1lU3RhbXAgLSBsYXN0TmF0aXZlVG91Y2hUaW1lU3RhbXApID4gbGFzdE5hdGl2ZVRvdWNoVGltZW91dCkge1xuXHRcdFx0aWYgKEltYmEuUE9JTlRFUikgeyByZXR1cm4gSW1iYS5QT0lOVEVSLnVwZGF0ZShlKS5wcm9jZXNzKCkgfTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHRJbWJhLkV2ZW50cy5yZWdpc3RlcihbJ21vdXNlZG93bicsJ21vdXNldXAnXSk7XG5cdHJldHVybiAoSW1iYS5FdmVudHMuc2V0RW5hYmxlZCh0cnVlKSx0cnVlKTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9saWIvaW1iYS9kb20uZXZlbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHR2YXIgSW1iYVRhZyA9IEltYmEuVEFHUy5lbGVtZW50O1xuXHRcblx0ZnVuY3Rpb24gcmVtb3ZlTmVzdGVkKHJvb3Qsbm9kZSxjYXJldCl7XG5cdFx0Ly8gaWYgbm9kZS9ub2RlcyBpc2EgU3RyaW5nXG5cdFx0Ly8gXHR3ZSBuZWVkIHRvIHVzZSB0aGUgY2FyZXQgdG8gcmVtb3ZlIGVsZW1lbnRzXG5cdFx0Ly8gXHRmb3Igbm93IHdlIHdpbGwgc2ltcGx5IG5vdCBzdXBwb3J0IHRoaXNcblx0XHRpZiAobm9kZSBpbnN0YW5jZW9mIEltYmFUYWcpIHtcblx0XHRcdHJvb3QucmVtb3ZlQ2hpbGQobm9kZSk7XG5cdFx0fSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChub2RlKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJlbW92ZU5lc3RlZChyb290LGFyeVtpXSxjYXJldCk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyB3aGF0IGlmIHRoaXMgaXMgbm90IG51bGw/IT8hP1xuXHRcdFx0Ly8gdGFrZSBhIGNoYW5jZSBhbmQgcmVtb3ZlIGEgdGV4dC1lbGVtZW50bmdcblx0XHRcdHZhciBuZXh0ID0gY2FyZXQgPyAoY2FyZXQubmV4dFNpYmxpbmcpIDogKHJvb3QuX2RvbS5maXJzdENoaWxkKTtcblx0XHRcdGlmICgobmV4dCBpbnN0YW5jZW9mIFRleHQpICYmIG5leHQudGV4dENvbnRlbnQgPT0gbm9kZSkge1xuXHRcdFx0XHRyb290LnJlbW92ZUNoaWxkKG5leHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgJ2Nhbm5vdCByZW1vdmUgc3RyaW5nJztcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gY2FyZXQ7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBhcHBlbmROZXN0ZWQocm9vdCxub2RlKXtcblx0XHRpZiAobm9kZSBpbnN0YW5jZW9mIEltYmFUYWcpIHtcblx0XHRcdHJvb3QuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdFx0fSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChub2RlKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGFwcGVuZE5lc3RlZChyb290LGFyeVtpXSk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAobm9kZSAhPSBudWxsICYmIG5vZGUgIT09IGZhbHNlKSB7XG5cdFx0XHRyb290LmFwcGVuZENoaWxkKEltYmEuZG9jdW1lbnQoKS5jcmVhdGVUZXh0Tm9kZShub2RlKSk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHRcblx0Ly8gaW5zZXJ0IG5vZGVzIGJlZm9yZSBhIGNlcnRhaW4gbm9kZVxuXHQvLyBkb2VzIG5vdCBuZWVkIHRvIHJldHVybiBhbnkgdGFpbCwgYXMgYmVmb3JlXG5cdC8vIHdpbGwgc3RpbGwgYmUgY29ycmVjdCB0aGVyZVxuXHQvLyBiZWZvcmUgbXVzdCBiZSBhbiBhY3R1YWwgZG9tbm9kZVxuXHRmdW5jdGlvbiBpbnNlcnROZXN0ZWRCZWZvcmUocm9vdCxub2RlLGJlZm9yZSl7XG5cdFx0aWYgKG5vZGUgaW5zdGFuY2VvZiBJbWJhVGFnKSB7XG5cdFx0XHRyb290Lmluc2VydEJlZm9yZShub2RlLGJlZm9yZSk7XG5cdFx0fSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChub2RlKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGluc2VydE5lc3RlZEJlZm9yZShyb290LGFyeVtpXSxiZWZvcmUpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKG5vZGUgIT0gbnVsbCAmJiBub2RlICE9PSBmYWxzZSkge1xuXHRcdFx0cm9vdC5pbnNlcnRCZWZvcmUoSW1iYS5kb2N1bWVudCgpLmNyZWF0ZVRleHROb2RlKG5vZGUpLGJlZm9yZSk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gYmVmb3JlO1xuXHR9O1xuXHRcblx0Ly8gYWZ0ZXIgbXVzdCBiZSBhbiBhY3R1YWwgZG9tbm9kZVxuXHRmdW5jdGlvbiBpbnNlcnROZXN0ZWRBZnRlcihyb290LG5vZGUsYWZ0ZXIpe1xuXHRcdHZhciBiZWZvcmUgPSBhZnRlciA/IChhZnRlci5uZXh0U2libGluZykgOiAocm9vdC5fZG9tLmZpcnN0Q2hpbGQpO1xuXHRcdFxuXHRcdGlmIChiZWZvcmUpIHtcblx0XHRcdGluc2VydE5lc3RlZEJlZm9yZShyb290LG5vZGUsYmVmb3JlKTtcblx0XHRcdHJldHVybiBiZWZvcmUucHJldmlvdXNTaWJsaW5nO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhcHBlbmROZXN0ZWQocm9vdCxub2RlKTtcblx0XHRcdHJldHVybiByb290Ll9kb20ubGFzdENoaWxkO1xuXHRcdH07XG5cdH07XG5cdFxuXHRmdW5jdGlvbiByZWNvbmNpbGVDb2xsZWN0aW9uQ2hhbmdlcyhyb290LG5ldyQsb2xkLGNhcmV0KXtcblx0XHRcblx0XHR2YXIgbmV3TGVuID0gbmV3JC5sZW5ndGg7XG5cdFx0dmFyIGxhc3ROZXcgPSBuZXckW25ld0xlbiAtIDFdO1xuXHRcdFxuXHRcdC8vIFRoaXMgcmUtb3JkZXIgYWxnb3JpdGhtIGlzIGJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgcHJpbmNpcGxlOlxuXHRcdC8vIFxuXHRcdC8vIFdlIGJ1aWxkIGEgXCJjaGFpblwiIHdoaWNoIHNob3dzIHdoaWNoIGl0ZW1zIGFyZSBhbHJlYWR5IHNvcnRlZC5cblx0XHQvLyBJZiB3ZSdyZSBnb2luZyBmcm9tIFsxLCAyLCAzXSAtPiBbMiwgMSwgM10sIHRoZSB0cmVlIGxvb2tzIGxpa2U6XG5cdFx0Ly9cblx0XHQvLyBcdDMgLT4gIDAgKGlkeClcblx0XHQvLyBcdDIgLT4gLTEgKGlkeClcblx0XHQvLyBcdDEgLT4gLTEgKGlkeClcblx0XHQvL1xuXHRcdC8vIFRoaXMgdGVsbHMgdXMgdGhhdCB3ZSBoYXZlIHR3byBjaGFpbnMgb2Ygb3JkZXJlZCBpdGVtczpcblx0XHQvLyBcblx0XHQvLyBcdCgxLCAzKSBhbmQgKDIpXG5cdFx0Ly8gXG5cdFx0Ly8gVGhlIG9wdGltYWwgcmUtb3JkZXJpbmcgdGhlbiBiZWNvbWVzIHR3byBrZWVwIHRoZSBsb25nZXN0IGNoYWluIGludGFjdCxcblx0XHQvLyBhbmQgbW92ZSBhbGwgdGhlIG90aGVyIGl0ZW1zLlxuXHRcdFxuXHRcdHZhciBuZXdQb3NpdGlvbiA9IFtdO1xuXHRcdFxuXHRcdC8vIFRoZSB0cmVlL2dyYXBoIGl0c2VsZlxuXHRcdHZhciBwcmV2Q2hhaW4gPSBbXTtcblx0XHQvLyBUaGUgbGVuZ3RoIG9mIHRoZSBjaGFpblxuXHRcdHZhciBsZW5ndGhDaGFpbiA9IFtdO1xuXHRcdFxuXHRcdC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxvbmdlc3QgY2hhaW5cblx0XHR2YXIgbWF4Q2hhaW5MZW5ndGggPSAwO1xuXHRcdHZhciBtYXhDaGFpbkVuZCA9IDA7XG5cdFx0XG5cdFx0Zm9yICh2YXIgaWR4ID0gMCwgYXJ5ID0gaXRlciQob2xkKSwgbGVuID0gYXJ5Lmxlbmd0aCwgbm9kZTsgaWR4IDwgbGVuOyBpZHgrKykge1xuXHRcdFx0bm9kZSA9IGFyeVtpZHhdO1xuXHRcdFx0dmFyIG5ld1BvcyA9IG5ldyQuaW5kZXhPZihub2RlKTtcblx0XHRcdG5ld1Bvc2l0aW9uLnB1c2gobmV3UG9zKTtcblx0XHRcdFxuXHRcdFx0aWYgKG5ld1BvcyA9PSAtMSkge1xuXHRcdFx0XHRyb290LnJlbW92ZUNoaWxkKG5vZGUpO1xuXHRcdFx0XHRwcmV2Q2hhaW4ucHVzaCgtMSk7XG5cdFx0XHRcdGxlbmd0aENoYWluLnB1c2goLTEpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBwcmV2SWR4ID0gbmV3UG9zaXRpb24ubGVuZ3RoIC0gMjtcblx0XHRcdFxuXHRcdFx0Ly8gQnVpbGQgdGhlIGNoYWluOlxuXHRcdFx0d2hpbGUgKHByZXZJZHggPj0gMCl7XG5cdFx0XHRcdGlmIChuZXdQb3NpdGlvbltwcmV2SWR4XSA9PSAtMSkge1xuXHRcdFx0XHRcdHByZXZJZHgtLTtcblx0XHRcdFx0fSBlbHNlIGlmIChuZXdQb3MgPiBuZXdQb3NpdGlvbltwcmV2SWR4XSkge1xuXHRcdFx0XHRcdC8vIFlheSwgd2UncmUgYmlnZ2VyIHRoYW4gdGhlIHByZXZpb3VzIVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIE5vcGUsIGxldCdzIHdhbGsgYmFjayB0aGUgY2hhaW5cblx0XHRcdFx0XHRwcmV2SWR4ID0gcHJldkNoYWluW3ByZXZJZHhdO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cHJldkNoYWluLnB1c2gocHJldklkeCk7XG5cdFx0XHRcblx0XHRcdHZhciBjdXJyTGVuZ3RoID0gKHByZXZJZHggPT0gLTEpID8gKDApIDogKGxlbmd0aENoYWluW3ByZXZJZHhdICsgMSk7XG5cdFx0XHRcblx0XHRcdGlmIChjdXJyTGVuZ3RoID4gbWF4Q2hhaW5MZW5ndGgpIHtcblx0XHRcdFx0bWF4Q2hhaW5MZW5ndGggPSBjdXJyTGVuZ3RoO1xuXHRcdFx0XHRtYXhDaGFpbkVuZCA9IGlkeDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGxlbmd0aENoYWluLnB1c2goY3Vyckxlbmd0aCk7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgc3RpY2t5Tm9kZXMgPSBbXTtcblx0XHRcblx0XHQvLyBOb3cgd2UgY2FuIHdhbGsgdGhlIGxvbmdlc3QgY2hhaW4gYmFja3dhcmRzIGFuZCBtYXJrIHRoZW0gYXMgXCJzdGlja3lcIixcblx0XHQvLyB3aGljaCBpbXBsaWVzIHRoYXQgdGhleSBzaG91bGQgbm90IGJlIG1vdmVkXG5cdFx0dmFyIGN1cnNvciA9IG5ld1Bvc2l0aW9uLmxlbmd0aCAtIDE7XG5cdFx0d2hpbGUgKGN1cnNvciA+PSAwKXtcblx0XHRcdGlmIChjdXJzb3IgPT0gbWF4Q2hhaW5FbmQgJiYgbmV3UG9zaXRpb25bY3Vyc29yXSAhPSAtMSkge1xuXHRcdFx0XHRzdGlja3lOb2Rlc1tuZXdQb3NpdGlvbltjdXJzb3JdXSA9IHRydWU7XG5cdFx0XHRcdG1heENoYWluRW5kID0gcHJldkNoYWluW21heENoYWluRW5kXTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGN1cnNvciAtPSAxO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gQW5kIGxldCdzIGl0ZXJhdGUgZm9yd2FyZCwgYnV0IG9ubHkgbW92ZSBub24tc3RpY2t5IG5vZGVzXG5cdFx0Zm9yICh2YXIgaWR4MSA9IDAsIGFyeSA9IGl0ZXIkKG5ldyQpLCBsZW4gPSBhcnkubGVuZ3RoOyBpZHgxIDwgbGVuOyBpZHgxKyspIHtcblx0XHRcdGlmICghc3RpY2t5Tm9kZXNbaWR4MV0pIHtcblx0XHRcdFx0dmFyIGFmdGVyID0gbmV3JFtpZHgxIC0gMV07XG5cdFx0XHRcdGluc2VydE5lc3RlZEFmdGVyKHJvb3QsYXJ5W2lkeDFdLChhZnRlciAmJiBhZnRlci5fZG9tKSB8fCBjYXJldCk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIHRydXN0IHRoYXQgdGhlIGxhc3QgaXRlbSBpbiBuZXcgbGlzdCBpcyB0aGUgY2FyZXRcblx0XHRyZXR1cm4gbGFzdE5ldyAmJiBsYXN0TmV3Ll9kb20gfHwgY2FyZXQ7XG5cdH07XG5cdFxuXHRcblx0Ly8gZXhwZWN0cyBhIGZsYXQgbm9uLXNwYXJzZSBhcnJheSBvZiBub2RlcyBpbiBib3RoIG5ldyBhbmQgb2xkLCBhbHdheXNcblx0ZnVuY3Rpb24gcmVjb25jaWxlQ29sbGVjdGlvbihyb290LG5ldyQsb2xkLGNhcmV0KXtcblx0XHR2YXIgayA9IG5ldyQubGVuZ3RoO1xuXHRcdHZhciBpID0gaztcblx0XHR2YXIgbGFzdCA9IG5ldyRbayAtIDFdO1xuXHRcdFxuXHRcdFxuXHRcdGlmIChrID09IG9sZC5sZW5ndGggJiYgbmV3JFswXSA9PT0gb2xkWzBdKSB7XG5cdFx0XHQvLyBydW5uaW5nIHRocm91Z2ggdG8gY29tcGFyZVxuXHRcdFx0d2hpbGUgKGktLSl7XG5cdFx0XHRcdGlmIChuZXckW2ldICE9PSBvbGRbaV0pIHsgYnJlYWs7IH07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGkgPT0gLTEpIHtcblx0XHRcdHJldHVybiBsYXN0ICYmIGxhc3QuX2RvbSB8fCBjYXJldDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHJlY29uY2lsZUNvbGxlY3Rpb25DaGFuZ2VzKHJvb3QsbmV3JCxvbGQsY2FyZXQpO1xuXHRcdH07XG5cdH07XG5cdFxuXHQvLyB0aGUgZ2VuZXJhbCByZWNvbmNpbGVyIHRoYXQgcmVzcGVjdHMgY29uZGl0aW9ucyBldGNcblx0Ly8gY2FyZXQgaXMgdGhlIGN1cnJlbnQgbm9kZSB3ZSB3YW50IHRvIGluc2VydCB0aGluZ3MgYWZ0ZXJcblx0ZnVuY3Rpb24gcmVjb25jaWxlTmVzdGVkKHJvb3QsbmV3JCxvbGQsY2FyZXQpe1xuXHRcdFxuXHRcdC8vIGlmIG5ldyA9PSBudWxsIG9yIG5ldyA9PT0gZmFsc2Ugb3IgbmV3ID09PSB0cnVlXG5cdFx0Ly8gXHRpZiBuZXcgPT09IG9sZFxuXHRcdC8vIFx0XHRyZXR1cm4gY2FyZXRcblx0XHQvLyBcdGlmIG9sZCAmJiBuZXcgIT0gb2xkXG5cdFx0Ly8gXHRcdHJlbW92ZU5lc3RlZChyb290LG9sZCxjYXJldCkgaWYgb2xkXG5cdFx0Ly8gXG5cdFx0Ly8gXHRyZXR1cm4gY2FyZXRcblx0XHRcblx0XHQvLyB2YXIgc2tpcG5ldyA9IG5ldyA9PSBudWxsIG9yIG5ldyA9PT0gZmFsc2Ugb3IgbmV3ID09PSB0cnVlXG5cdFx0dmFyIG5ld0lzTnVsbCA9IG5ldyQgPT0gbnVsbCB8fCBuZXckID09PSBmYWxzZTtcblx0XHR2YXIgb2xkSXNOdWxsID0gb2xkID09IG51bGwgfHwgb2xkID09PSBmYWxzZTtcblx0XHRcblx0XHRcblx0XHRpZiAobmV3JCA9PT0gb2xkKSB7XG5cdFx0XHQvLyByZW1lbWJlciB0aGF0IHRoZSBjYXJldCBtdXN0IGJlIGFuIGFjdHVhbCBkb20gZWxlbWVudFxuXHRcdFx0Ly8gd2Ugc2hvdWxkIGluc3RlYWQgbW92ZSB0aGUgYWN0dWFsIGNhcmV0PyAtIHRydXN0XG5cdFx0XHRpZiAobmV3SXNOdWxsKSB7XG5cdFx0XHRcdHJldHVybiBjYXJldDtcblx0XHRcdH0gZWxzZSBpZiAobmV3JCAmJiBuZXckLl9kb20pIHtcblx0XHRcdFx0cmV0dXJuIG5ldyQuX2RvbTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjYXJldCA/IChjYXJldC5uZXh0U2libGluZykgOiAocm9vdC5fZG9tLmZpcnN0Q2hpbGQpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKG5ldyQgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0aWYgKG9sZCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdGlmIChuZXckLnN0YXRpYyB8fCBvbGQuc3RhdGljKSB7XG5cdFx0XHRcdFx0Ly8gaWYgdGhlIHN0YXRpYyBpcyBub3QgbmVzdGVkIC0gd2UgY291bGQgZ2V0IGEgaGludCBmcm9tIGNvbXBpbGVyXG5cdFx0XHRcdFx0Ly8gYW5kIGp1c3Qgc2tpcCBpdFxuXHRcdFx0XHRcdGlmIChuZXckLnN0YXRpYyA9PSBvbGQuc3RhdGljKSB7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobmV3JCksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0XHQvLyB0aGlzIGlzIHdoZXJlIHdlIGNvdWxkIGRvIHRoZSB0cmlwbGUgZXF1YWwgZGlyZWN0bHlcblx0XHRcdFx0XHRcdFx0Y2FyZXQgPSByZWNvbmNpbGVOZXN0ZWQocm9vdCxhcnlbaV0sb2xkW2ldLGNhcmV0KTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRyZXR1cm4gY2FyZXQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlbW92ZU5lc3RlZChyb290LG9sZCxjYXJldCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBpZiB0aGV5IGFyZSBub3QgdGhlIHNhbWUgd2UgY29udGludWUgdGhyb3VnaCB0byB0aGUgZGVmYXVsdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiByZWNvbmNpbGVDb2xsZWN0aW9uKHJvb3QsbmV3JCxvbGQsY2FyZXQpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmIChvbGQgaW5zdGFuY2VvZiBJbWJhVGFnKSB7XG5cdFx0XHRcdHJvb3QucmVtb3ZlQ2hpbGQob2xkKTtcblx0XHRcdH0gZWxzZSBpZiAoIW9sZElzTnVsbCkge1xuXHRcdFx0XHQvLyBvbGQgd2FzIGEgc3RyaW5nLWxpa2Ugb2JqZWN0P1xuXHRcdFx0XHRyb290LnJlbW92ZUNoaWxkKGNhcmV0ID8gKGNhcmV0Lm5leHRTaWJsaW5nKSA6IChyb290Ll9kb20uZmlyc3RDaGlsZCkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGluc2VydE5lc3RlZEFmdGVyKHJvb3QsbmV3JCxjYXJldCk7XG5cdFx0XHQvLyByZW1vdmUgb2xkXG5cdFx0fSBlbHNlIGlmIChuZXckIGluc3RhbmNlb2YgSW1iYVRhZykge1xuXHRcdFx0aWYgKCFvbGRJc051bGwpIHsgcmVtb3ZlTmVzdGVkKHJvb3Qsb2xkLGNhcmV0KSB9O1xuXHRcdFx0aW5zZXJ0TmVzdGVkQWZ0ZXIocm9vdCxuZXckLGNhcmV0KTtcblx0XHRcdHJldHVybiBuZXckO1xuXHRcdH0gZWxzZSBpZiAobmV3SXNOdWxsKSB7XG5cdFx0XHRpZiAoIW9sZElzTnVsbCkgeyByZW1vdmVOZXN0ZWQocm9vdCxvbGQsY2FyZXQpIH07XG5cdFx0XHRyZXR1cm4gY2FyZXQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGlmIG9sZCBkaWQgbm90IGV4aXN0IHdlIG5lZWQgdG8gYWRkIGEgbmV3IGRpcmVjdGx5XG5cdFx0XHR2YXIgbmV4dE5vZGU7XG5cdFx0XHQvLyBpZiBvbGQgd2FzIGFycmF5IG9yIGltYmF0YWcgd2UgbmVlZCB0byByZW1vdmUgaXQgYW5kIHRoZW4gYWRkXG5cdFx0XHRpZiAob2xkIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0cmVtb3ZlTmVzdGVkKHJvb3Qsb2xkLGNhcmV0KTtcblx0XHRcdH0gZWxzZSBpZiAob2xkIGluc3RhbmNlb2YgSW1iYVRhZykge1xuXHRcdFx0XHRyb290LnJlbW92ZUNoaWxkKG9sZCk7XG5cdFx0XHR9IGVsc2UgaWYgKCFvbGRJc051bGwpIHtcblx0XHRcdFx0Ly8gLi4uXG5cdFx0XHRcdG5leHROb2RlID0gY2FyZXQgPyAoY2FyZXQubmV4dFNpYmxpbmcpIDogKHJvb3QuX2RvbS5maXJzdENoaWxkKTtcblx0XHRcdFx0aWYgKChuZXh0Tm9kZSBpbnN0YW5jZW9mIFRleHQpICYmIG5leHROb2RlLnRleHRDb250ZW50ICE9IG5ldyQpIHtcblx0XHRcdFx0XHRuZXh0Tm9kZS50ZXh0Q29udGVudCA9IG5ldyQ7XG5cdFx0XHRcdFx0cmV0dXJuIG5leHROb2RlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gbm93IGFkZCB0aGUgdGV4dG5vZGVcblx0XHRcdHJldHVybiBpbnNlcnROZXN0ZWRBZnRlcihyb290LG5ldyQsY2FyZXQpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRcblx0cmV0dXJuIHRhZyQuZXh0ZW5kVGFnKCdodG1sZWxlbWVudCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDaGlsZHJlbiA9IGZ1bmN0aW9uIChuZXckLHR5cCl7XG5cdFx0XHR2YXIgb2xkID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0XHQvLyB2YXIgaXNBcnJheSA9IG5vZGVzIGlzYSBBcnJheVxuXHRcdFx0aWYgKG5ldyQgPT09IG9sZCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICghb2xkKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKTtcblx0XHRcdFx0YXBwZW5kTmVzdGVkKHRoaXMsbmV3JCk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAyKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gMSkge1xuXHRcdFx0XHQvLyBoZXJlIHdlIF9rbm93IF90aGF0IGl0IGlzIGFuIGFycmF5IHdpdGggdGhlIHNhbWUgc2hhcGVcblx0XHRcdFx0Ly8gZXZlcnkgdGltZVxuXHRcdFx0XHR2YXIgY2FyZXQgPSBudWxsO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobmV3JCksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdC8vIHByZXYgPSBvbGRbaV1cblx0XHRcdFx0XHRjYXJldCA9IHJlY29uY2lsZU5lc3RlZCh0aGlzLGFyeVtpXSxvbGRbaV0sY2FyZXQpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gMykge1xuXHRcdFx0XHQvLyB0aGlzIGlzIHBvc3NpYmx5IGZ1bGx5IGR5bmFtaWMuIEl0IG9mdGVuIGlzXG5cdFx0XHRcdC8vIGJ1dCB0aGUgb2xkIG9yIG5ldyBjb3VsZCBiZSBzdGF0aWMgd2hpbGUgdGhlIG90aGVyIGlzIG5vdFxuXHRcdFx0XHQvLyB0aGlzIGlzIG5vdCBoYW5kbGVkIG5vd1xuXHRcdFx0XHQvLyB3aGF0IGlmIGl0IHdhcyBwcmV2aW91c2x5IGEgc3RhdGljIGFycmF5PyBlZGdlY2FzZSAtIGJ1dCBtdXN0IHdvcmtcblx0XHRcdFx0aWYgKG5ldyQgaW5zdGFuY2VvZiBJbWJhVGFnKSB7XG5cdFx0XHRcdFx0dGhpcy5lbXB0eSgpO1xuXHRcdFx0XHRcdHRoaXMuYXBwZW5kQ2hpbGQobmV3JCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAobmV3JCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdFx0aWYgKG9sZCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdFx0XHQvLyBpcyB0aGlzIG5vdCB0aGUgc2FtZSBhcyBzZXR0aW5nIHN0YXRpY0NoaWxkcmVuIG5vdyBidXQgd2l0aCB0aGVcblx0XHRcdFx0XHRcdHJlY29uY2lsZUNvbGxlY3Rpb24odGhpcyxuZXckLG9sZCxudWxsKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5lbXB0eSgpO1xuXHRcdFx0XHRcdFx0YXBwZW5kTmVzdGVkKHRoaXMsbmV3JCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnNldFRleHQobmV3JCk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKChuZXckIGluc3RhbmNlb2YgQXJyYXkpICYmIChvbGQgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0XHRcdFx0cmVjb25jaWxlQ29sbGVjdGlvbih0aGlzLG5ldyQsb2xkLG51bGwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpO1xuXHRcdFx0XHRhcHBlbmROZXN0ZWQodGhpcyxuZXckKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRoaXMuX2NoaWxkcmVuID0gbmV3JDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0Ly8gb25seSBldmVyIGNhbGxlZCB3aXRoIGFycmF5IGFzIGFyZ3VtZW50XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRTdGF0aWNDaGlsZHJlbiA9IGZ1bmN0aW9uIChuZXckKXtcblx0XHRcdHZhciBvbGQgPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdFxuXHRcdFx0dmFyIGNhcmV0ID0gbnVsbDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChuZXckKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdC8vIHByZXYgPSBvbGRbaV1cblx0XHRcdFx0Y2FyZXQgPSByZWNvbmNpbGVOZXN0ZWQodGhpcyxhcnlbaV0sb2xkW2ldLGNhcmV0KTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRoaXMuX2NoaWxkcmVuID0gbmV3JDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY29udGVudCB8fCB0aGlzLmNoaWxkcmVuKCkudG9BcnJheSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpe1xuXHRcdFx0aWYgKHRleHQgIT0gdGhpcy5fY2hpbGRyZW4pIHtcblx0XHRcdFx0dGhpcy5fY2hpbGRyZW4gPSB0ZXh0O1xuXHRcdFx0XHR0aGlzLmRvbSgpLnRleHRDb250ZW50ID0gdGV4dCA9PSBudWxsIHx8IHRleHQgPT09IGZhbHNlID8gKCcnKSA6ICh0ZXh0KTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vaW1iYS9saWIvaW1iYS9kb20uc3RhdGljLmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHRcblx0Lypcblx0VGhlIHNwZWNpYWwgc3ludGF4IGZvciBzZWxlY3RvcnMgaW4gSW1iYSBjcmVhdGVzIEltYmEuU2VsZWN0b3Jcblx0aW5zdGFuY2VzLlxuXHQqL1xuXHRcblx0SW1iYS5TZWxlY3RvciA9IGZ1bmN0aW9uIFNlbGVjdG9yKHNlbCxzY29wZSxub2Rlcyl7XG5cdFx0XG5cdFx0dGhpcy5fcXVlcnkgPSBzZWwgaW5zdGFuY2VvZiBJbWJhLlNlbGVjdG9yID8gKHNlbC5xdWVyeSgpKSA6IChzZWwpO1xuXHRcdHRoaXMuX2NvbnRleHQgPSBzY29wZTtcblx0XHRcblx0XHRpZiAobm9kZXMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChub2RlcyksIGxlbiA9IGFyeS5sZW5ndGgsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmVzLnB1c2godGFnJHdyYXAoYXJ5W2ldKSk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5fbm9kZXMgPSByZXM7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLl9sYXp5ID0gIW5vZGVzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SW1iYS5TZWxlY3Rvci5vbmUgPSBmdW5jdGlvbiAoc2VsLHNjb3BlKXtcblx0XHR2YXIgZWwgPSAoc2NvcGUgfHwgSW1iYS5kb2N1bWVudCgpKS5xdWVyeVNlbGVjdG9yKHNlbCk7XG5cdFx0cmV0dXJuIGVsICYmIHRhZyR3cmFwKGVsKSB8fCBudWxsO1xuXHR9O1xuXHRcblx0SW1iYS5TZWxlY3Rvci5hbGwgPSBmdW5jdGlvbiAoc2VsLHNjb3BlKXtcblx0XHRyZXR1cm4gbmV3IEltYmEuU2VsZWN0b3Ioc2VsLHNjb3BlKTtcblx0fTtcblx0XG5cdFxuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3F1ZXJ5OyB9XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLnNldFF1ZXJ5ID0gZnVuY3Rpb24odil7IHRoaXMuX3F1ZXJ5ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5yZWxvYWQgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl9ub2RlcyA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5zY29wZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBjdHg7XG5cdFx0aWYgKHRoaXMuX3Njb3BlKSB7IHJldHVybiB0aGlzLl9zY29wZSB9O1xuXHRcdGlmICghKGN0eCA9IHRoaXMuX2NvbnRleHQpKSB7IHJldHVybiBJbWJhLmRvY3VtZW50KCkgfTtcblx0XHRyZXR1cm4gdGhpcy5fc2NvcGUgPSBjdHgudG9TY29wZSA/IChjdHgudG9TY29wZSgpKSA6IChjdHgpO1xuXHR9O1xuXHRcblx0Lypcblx0XHRAcmV0dXJucyB7SW1iYS5UYWd9IGZpcnN0IG5vZGUgbWF0Y2hpbmcgdGhpcyBzZWxlY3RvclxuXHRcdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5maXJzdCA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9sYXp5KSB7IHJldHVybiB0YWckd3JhcCh0aGlzLl9maXJzdCB8fCAodGhpcy5fZmlyc3QgPSB0aGlzLnNjb3BlKCkucXVlcnlTZWxlY3Rvcih0aGlzLnF1ZXJ5KCkpKSkgfSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLm5vZGVzKClbMF07XG5cdFx0fTtcblx0fTtcblx0XG5cdC8qXG5cdFx0QHJldHVybnMge0ltYmEuVGFnfSBsYXN0IG5vZGUgbWF0Y2hpbmcgdGhpcyBzZWxlY3RvclxuXHRcdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMubm9kZXMoKVt0aGlzLl9ub2Rlcy5sZW5ndGggLSAxXTtcblx0fTtcblx0XG5cdC8qXG5cdFx0QHJldHVybnMgW0ltYmEuVGFnXSBhbGwgbm9kZXMgbWF0Y2hpbmcgdGhpcyBzZWxlY3RvclxuXHRcdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5ub2RlcyA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9ub2RlcykgeyByZXR1cm4gdGhpcy5fbm9kZXMgfTtcblx0XHR2YXIgaXRlbXMgPSB0aGlzLnNjb3BlKCkucXVlcnlTZWxlY3RvckFsbCh0aGlzLnF1ZXJ5KCkpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChpdGVtcyksIGxlbiA9IGFyeS5sZW5ndGgsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHJlcy5wdXNoKHRhZyR3cmFwKGFyeVtpXSkpO1xuXHRcdH07XG5cdFx0dGhpcy5fbm9kZXMgPSByZXM7XG5cdFx0dGhpcy5fbGF6eSA9IGZhbHNlO1xuXHRcdHJldHVybiB0aGlzLl9ub2Rlcztcblx0fTtcblx0XG5cdC8qXG5cdFx0VGhlIG51bWJlciBvZiBub2RlcyBtYXRjaGluZyB0aGlzIHNlbGVjdG9yXG5cdFx0Ki9cblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMubm9kZXMoKS5sZW5ndGg7XG5cdH07XG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5sZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5ub2RlcygpLmxlbmd0aDtcblx0fTtcblx0XG5cdC8qXG5cdFx0QHRvZG8gQWRkIHN1cHBvcnQgZm9yIGJsb2NrIG9yIHNlbGVjdG9yP1xuXHRcdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuY291bnQoKSA+PSAxO1xuXHR9O1xuXHRcblx0Lypcblx0XHRHZXQgbm9kZSBhdCBpbmRleFxuXHRcdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChpZHgpe1xuXHRcdHJldHVybiB0aGlzLm5vZGVzKClbaWR4XTtcblx0fTtcblx0XG5cdC8qXG5cdFx0TG9vcCB0aHJvdWdoIG5vZGVzXG5cdFx0Ki9cblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoYmxvY2spe1xuXHRcdHRoaXMubm9kZXMoKS5mb3JFYWNoKGJsb2NrKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qXG5cdFx0TWFwIG5vZGVzXG5cdFx0Ki9cblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChibG9jayl7XG5cdFx0cmV0dXJuIHRoaXMubm9kZXMoKS5tYXAoYmxvY2spO1xuXHR9O1xuXHRcblx0Lypcblx0XHRSZXR1cm5zIGEgcGxhaW4gYXJyYXkgY29udGFpbmluZyBub2Rlcy4gSW1wbGljaXRseSBjYWxsZWRcblx0XHR3aGVuIGl0ZXJhdGluZyBvdmVyIGEgc2VsZWN0b3IgaW4gSW1iYSBgKG5vZGUgZm9yIG5vZGUgaW4gJChzZWxlY3RvcikpYFxuXHRcdCovXG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMubm9kZXMoKTtcblx0fTtcblx0XG5cdC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdG9yLCBcblx0Ly8gYmVnaW5uaW5nIGF0IHRoZSBjdXJyZW50IGVsZW1lbnQgYW5kIHByb2dyZXNzaW5nIHVwIHRocm91Z2ggdGhlIERPTSB0cmVlXG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLmNsb3Nlc3QgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHQvLyBzZWVtcyBzdHJhbmdlIHRoYXQgd2UgYWx0ZXIgdGhpcyBzZWxlY3Rvcj9cblx0XHR0aGlzLl9ub2RlcyA9IHRoaXMubWFwKGZ1bmN0aW9uKG5vZGUpIHsgcmV0dXJuIG5vZGUuY2xvc2VzdChzZWwpOyB9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIEdldCB0aGUgc2libGluZ3Mgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQgb2YgbWF0Y2hlZCBlbGVtZW50cywgXG5cdC8vIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgYSBzZWxlY3Rvci5cblx0Ly8gVE9ETyByZW1vdmUgZHVwbGljYXRlcz9cblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUuc2libGluZ3MgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHR0aGlzLl9ub2RlcyA9IHRoaXMubWFwKGZ1bmN0aW9uKG5vZGUpIHsgcmV0dXJuIG5vZGUuc2libGluZ3Moc2VsKTsgfSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBHZXQgdGhlIGRlc2NlbmRhbnRzIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgY3VycmVudCBzZXQgb2YgbWF0Y2hlZCBcblx0Ly8gZWxlbWVudHMsIGZpbHRlcmVkIGJ5IGEgc2VsZWN0b3IuXG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHR0aGlzLl9ub2RlcyA9IHRoaXMuX19xdWVyeV9fKHNlbC5xdWVyeSgpLHRoaXMubm9kZXMoKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbiAoYmxrKXtcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoYmxrLGZhbHNlKTtcblx0fTtcblx0XG5cdC8qXG5cdFx0RmlsdGVyIHRoZSBub2RlcyBpbiBzZWxlY3RvciBieSBhIGZ1bmN0aW9uIG9yIG90aGVyIHNlbGVjdG9yXG5cdFx0Ki9cblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChibGssYm9vbCl7XG5cdFx0aWYoYm9vbCA9PT0gdW5kZWZpbmVkKSBib29sID0gdHJ1ZTtcblx0XHR2YXIgZm4gPSAoYmxrIGluc3RhbmNlb2YgRnVuY3Rpb24pICYmIGJsayB8fCBmdW5jdGlvbihuKSB7IHJldHVybiBuLm1hdGNoZXMoYmxrKTsgfTtcblx0XHR2YXIgYXJ5ID0gdGhpcy5ub2RlcygpLmZpbHRlcihmdW5jdGlvbihuKSB7IHJldHVybiBmbihuKSA9PSBib29sOyB9KTtcblx0XHQvLyBpZiB3ZSB3YW50IHRvIHJldHVybiBhIG5ldyBzZWxlY3RvciBmb3IgdGhpcywgd2Ugc2hvdWxkIGRvIHRoYXQgZm9yXG5cdFx0Ly8gb3RoZXJzIGFzIHdlbGxcblx0XHRyZXR1cm4gbmV3IEltYmEuU2VsZWN0b3IoXCJcIix0aGlzLl9zY29wZSxhcnkpO1xuXHR9O1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUuX19xdWVyeV9fID0gZnVuY3Rpb24gKHF1ZXJ5LGNvbnRleHRzKXtcblx0XHR2YXIgbm9kZXMgPSBbXTtcblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIGwgPSBjb250ZXh0cy5sZW5ndGg7XG5cdFx0XG5cdFx0d2hpbGUgKGkgPCBsKXtcblx0XHRcdG5vZGVzLnB1c2guYXBwbHkobm9kZXMsY29udGV4dHNbaSsrXS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gbm9kZXM7XG5cdH07XG5cdFxuXHRJbWJhLlNlbGVjdG9yLnByb3RvdHlwZS5fX21hdGNoZXNfXyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0Lypcblx0XHRBZGQgc3BlY2lmaWVkIGZsYWcgdG8gYWxsIG5vZGVzIGluIHNlbGVjdG9yXG5cdFx0Ki9cblx0XG5cdEltYmEuU2VsZWN0b3IucHJvdG90eXBlLmZsYWcgPSBmdW5jdGlvbiAoZmxhZyl7XG5cdFx0cmV0dXJuIHRoaXMuZm9yRWFjaChmdW5jdGlvbihuKSB7IHJldHVybiBuLmZsYWcoZmxhZyk7IH0pO1xuXHR9O1xuXHRcblx0Lypcblx0XHRSZW1vdmUgc3BlY2lmaWVkIGZsYWcgZnJvbSBhbGwgbm9kZXMgaW4gc2VsZWN0b3Jcblx0XHQqL1xuXHRcblx0SW1iYS5TZWxlY3Rvci5wcm90b3R5cGUudW5mbGFnID0gZnVuY3Rpb24gKGZsYWcpe1xuXHRcdHJldHVybiB0aGlzLmZvckVhY2goZnVuY3Rpb24obikgeyByZXR1cm4gbi51bmZsYWcoZmxhZyk7IH0pO1xuXHR9O1xuXHRcblx0XG5cdC8vIGRlZiBJbWJhLnF1ZXJ5U2VsZWN0b3JBbGxcblx0cSQgPSBmdW5jdGlvbihzZWwsc2NvcGUpIHsgcmV0dXJuIG5ldyBJbWJhLlNlbGVjdG9yKHNlbCxzY29wZSk7IH07XG5cdFxuXHQvLyBkZWYgSW1iYS5TZWxlY3Rvci5vbmVcblx0cSQkID0gZnVuY3Rpb24oc2VsLHNjb3BlKSB7XG5cdFx0dmFyIGVsID0gKHNjb3BlIHx8IEltYmEuZG9jdW1lbnQoKSkucXVlcnlTZWxlY3RvcihzZWwpO1xuXHRcdHJldHVybiBlbCAmJiB0YWckd3JhcChlbCkgfHwgbnVsbDtcblx0fTtcblx0XG5cdFxuXHQvLyBleHRlbmRpbmcgdGFncyB3aXRoIHF1ZXJ5LW1ldGhvZHNcblx0Ly8gbXVzdCBiZSBhIGJldHRlciB3YXkgdG8gcmVvcGVuIGNsYXNzZXNcblx0cmV0dXJuIHRhZyQuZXh0ZW5kVGFnKCdlbGVtZW50JywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwgPSBmdW5jdGlvbiAocSl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tLnF1ZXJ5U2VsZWN0b3JBbGwocSk7XG5cdFx0fTtcblx0XHR0YWcucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IgPSBmdW5jdGlvbiAocSl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tLnF1ZXJ5U2VsZWN0b3IocSk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBzaG91bGQgYmUgbW92ZWQgdG8gSW1iYS5UYWcgaW5zdGVhZD9cblx0XHQvLyBvciB3ZSBzaG91bGQgaW1wbGVtZW50IGFsbCBvZiB0aGVtIGhlcmVcblx0XHR0YWcucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoc2VsKXtcblx0XHRcdHJldHVybiBuZXcgSW1iYS5TZWxlY3RvcihzZWwsdGhpcyk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9pbWJhL2xpYi9pbWJhL3NlbGVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHR2YXIgdXRpbDtcblx0SU1ERUJVRyA9IHRydWU7XG5cdFxuXHQvLyB3dGYgZXIgYWx0IGRldHRlP1xuXHRJTSA9IHt9O1xuXHRJTS5ORVdMSU5FID0gJ1xcbic7XG5cdElNLkNIQVIgPSAwO1xuXHRJTS5XT1JEX1NUQVJUID0gMTtcblx0SU0uV09SRF9FTkQgPSAyO1xuXHRJTS5QVU5DVFVBVElPTl9TVEFSVCA9IDM7XG5cdElNLlBVTkNUVUFUSU9OX0VORCA9IDQ7XG5cdElNLlNVQl9XT1JEX1NUQVJUID0gNTtcblx0SU0uU1VCX1dPUkRfRU5EID0gNjtcblx0SU0uTElORV9TVEFSVCA9IDc7XG5cdElNLkxJTkVfRU5EID0gODtcblx0SU0uRU1QVFlfTElORSA9IDk7XG5cdFxuXHRJTS5GUyA9IHJlcXVpcmUoJy4vY29yZS9mcycpO1xuXHRcblx0dmFyIFNvdXJjZU1hcCA9IHJlcXVpcmUoJ3NvdXJjZS1tYXAnKTtcblx0XG5cdC8vIGlmIGdsb2JhbDpyZXF1aXJlXG5cdHZhciBSZWdpb24gPSByZXF1aXJlKFwiLi9yZWdpb25cIikuUmVnaW9uO1xuXHRcblx0cmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cdFxuXHRyZXF1aXJlKCcuL2NvcmUvaGlzdG9yeScpO1xuXHRyZXF1aXJlKCcuL2NvcmUvbG9nZ2VyJyk7XG5cdHJlcXVpcmUoJy4vY29yZS9zaG9ydGN1dHMnKTtcblx0XG5cdHJlcXVpcmUoXCIuL3ZpZXdzL2NhcHRvclwiKTtcblx0cmVxdWlyZShcIi4vdmlld1wiKTtcblx0cmVxdWlyZShcIi4vZWRpdG9yXCIpO1xuXHRcblx0dmFyIEhpZ2hsaWdodGVyID0gcmVxdWlyZShcIi4vY29yZS9oaWdobGlnaHRlclwiKS5IaWdobGlnaHRlcjtcblx0dmFyIEltYmFjV29ya2VyID0gcmVxdWlyZShcIi4vY29yZS93b3JrZXJcIikuSW1iYWNXb3JrZXI7XG5cdFxuXHRJTS53b3JrZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fd29ya2VyIHx8ICh0aGlzLl93b3JrZXIgPSBuZXcgSW1iYWNXb3JrZXIoKSk7XG5cdH07XG5cdFxuXHRtb2R1bGUuZXhwb3J0cy51dGlsID0gdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG5cdC8vIG5vZGVzXG5cdHJlcXVpcmUoXCIuL25vZGVzL2luZGV4XCIpO1xuXHRcblx0XG5cdGZ1bmN0aW9uIHdvcmtlcigpe1xuXHRcdHJldHVybiBJTS53b3JrZXIoKTtcblx0fTsgZXhwb3J0cy53b3JrZXIgPSB3b3JrZXI7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cy5Tb3VyY2VNYXAgPSBTb3VyY2VNYXA7XG5cdG1vZHVsZS5leHBvcnRzLlJlZ2lvbiA9IFJlZ2lvbjtcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzLkhpZ2hsaWdodGVyID0gSGlnaGxpZ2h0ZXI7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9pbmRleC5pbWJhXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHQvLyBleHRlcm5zO1xuXHRmdW5jdGlvbiBzYXZlKHBhdGgsY29udGVudCxlbmNvZGluZyxjYil7XG5cdFx0aWYoY2I9PXVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgPT0gJ2Z1bmN0aW9uJykgY2IgPSBlbmNvZGluZyxlbmNvZGluZyA9ICd1dGYtOCc7XG5cdFx0aWYoZW5jb2Rpbmc9PXVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmLTgnO1xuXHRcdGNvbnNvbGUubG9nKCdzYXZlJyxwYXRoLGNvbnRlbnQsZW5jb2RpbmcpO1xuXHRcdFxuXHRcdHJldHVybiB4ci5wb3N0KHBhdGgse2JvZHk6IGNvbnRlbnR9KS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29uc29sZS5sb2coJ3Jlc3BvbmRlZCcpO1xuXHRcdFx0cmV0dXJuIGNiICYmIGNiKGFyZ3VtZW50cyk7XG5cdFx0fSk7XG5cdH07IGV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5cdFxuXHRmdW5jdGlvbiByZWFkRmlsZUFzeW5jKHBhdGgsZW5jb2RpbmcsY2Ipe1xuXHRcdGlmKGNiPT11bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nID09ICdmdW5jdGlvbicpIGNiID0gZW5jb2RpbmcsZW5jb2RpbmcgPSAndXRmLTgnO1xuXHRcdGlmKGVuY29kaW5nPT11bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0Zi04Jztcblx0XHRjb25zb2xlLmxvZygnc2F2ZScscGF0aCxlbmNvZGluZyk7XG5cdFx0XG5cdFx0cmV0dXJuIHhyLmdldChwYXRoKS50aGVuKGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0Y29uc29sZS5sb2coJ3Jlc3BvbmRlZCcscmVzKTtcblx0XHRcdGNiICYmIGNiKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0pO1xuXHR9OyBleHBvcnRzLnJlYWRGaWxlQXN5bmMgPSByZWFkRmlsZUFzeW5jOzsgcmV0dXJuIHJlYWRGaWxlQXN5bmM7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9jb3JlL2ZzLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLnR4dCBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyJykuU291cmNlTWFwQ29uc3VtZXI7XG5leHBvcnRzLlNvdXJjZU5vZGUgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2Utbm9kZScpLlNvdXJjZU5vZGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL34vc291cmNlLW1hcC9zb3VyY2UtbWFwLmpzXG4gKiogbW9kdWxlIGlkID0gMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbntcbiAgdmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICB2YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xuICB2YXIgTWFwcGluZ0xpc3QgPSByZXF1aXJlKCcuL21hcHBpbmctbGlzdCcpLk1hcHBpbmdMaXN0O1xuXG4gIC8qKlxuICAgKiBBbiBpbnN0YW5jZSBvZiB0aGUgU291cmNlTWFwR2VuZXJhdG9yIHJlcHJlc2VudHMgYSBzb3VyY2UgbWFwIHdoaWNoIGlzXG4gICAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBzb3VyY2VSb290OiBBIHJvb3QgZm9yIGFsbCByZWxhdGl2ZSBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICAgIGlmICghYUFyZ3MpIHtcbiAgICAgIGFBcmdzID0ge307XG4gICAgfVxuICAgIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnLCBudWxsKTtcbiAgICB0aGlzLl9zb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2VSb290JywgbnVsbCk7XG4gICAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgJ3NraXBWYWxpZGF0aW9uJywgZmFsc2UpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHRoaXMuX21hcHBpbmdzID0gbmV3IE1hcHBpbmdMaXN0KCk7XG4gICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgfVxuXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFNvdXJjZU1hcEdlbmVyYXRvciBiYXNlZCBvbiBhIFNvdXJjZU1hcENvbnN1bWVyXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICAgIHZhciBzb3VyY2VSb290ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZVJvb3Q7XG4gICAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICAgIGZpbGU6IGFTb3VyY2VNYXBDb25zdW1lci5maWxlLFxuICAgICAgICBzb3VyY2VSb290OiBzb3VyY2VSb290XG4gICAgICB9KTtcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICB2YXIgbmV3TWFwcGluZyA9IHtcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBuZXdNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3TWFwcGluZy5vcmlnaW5hbCA9IHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgICAgfSk7XG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNpbmdsZSBtYXBwaW5nIGZyb20gb3JpZ2luYWwgc291cmNlIGxpbmUgYW5kIGNvbHVtbiB0byB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gICAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChyZWxhdGl2ZSB0byB0aGUgc291cmNlUm9vdCkuXG4gICAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICAgIHZhciBvcmlnaW5hbCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnb3JpZ2luYWwnLCBudWxsKTtcbiAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgICAgaWYgKCF0aGlzLl9za2lwVmFsaWRhdGlvbikge1xuICAgICAgICB0aGlzLl92YWxpZGF0ZU1hcHBpbmcoZ2VuZXJhdGVkLCBvcmlnaW5hbCwgc291cmNlLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21hcHBpbmdzLmFkZCh7XG4gICAgICAgIGdlbmVyYXRlZExpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICAgIG9yaWdpbmFsTGluZTogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5saW5lLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5jb2x1bW4sXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhU291cmNlRmlsZTtcbiAgICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLl9zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAvLyBBZGQgdGhlIHNvdXJjZSBjb250ZW50IHRvIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgbWFwcGluZ3Mgb2YgYSBzdWItc291cmNlLW1hcCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UgZmlsZSB0byB0aGVcbiAgICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAgICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gICAqIHJlc3VsdGluZyBtYXBwaW5ncyBpcyB0aGUgbWluaW1pdW0gb2YgdGhpcyBtYXAgYW5kIHRoZSBzdXBwbGllZCBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAgICogQHBhcmFtIGFTb3VyY2VGaWxlIE9wdGlvbmFsLiBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlLlxuICAgKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAgICogQHBhcmFtIGFTb3VyY2VNYXBQYXRoIE9wdGlvbmFsLiBUaGUgZGlybmFtZSBvZiB0aGUgcGF0aCB0byB0aGUgc291cmNlIG1hcFxuICAgKiAgICAgICAgdG8gYmUgYXBwbGllZC4gSWYgcmVsYXRpdmUsIGl0IGlzIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lci5cbiAgICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gICAqICAgICAgICBkaXJlY3RvcnksIGFuZCB0aGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkIGNvbnRhaW5zIHJlbGF0aXZlIHNvdXJjZVxuICAgKiAgICAgICAgcGF0aHMuIElmIHNvLCB0aG9zZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbmVlZCB0byBiZSByZXdyaXR0ZW5cbiAgICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICAgIHZhciBzb3VyY2VGaWxlID0gYVNvdXJjZUZpbGU7XG4gICAgICAvLyBJZiBhU291cmNlRmlsZSBpcyBvbWl0dGVkLCB3ZSB3aWxsIHVzZSB0aGUgZmlsZSBwcm9wZXJ0eSBvZiB0aGUgU291cmNlTWFwXG4gICAgICBpZiAoYVNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJyArXG4gICAgICAgICAgICAnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgICB9XG4gICAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgICAvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG4gICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgfVxuICAgICAgLy8gQXBwbHlpbmcgdGhlIFNvdXJjZU1hcCBjYW4gYWRkIGFuZCByZW1vdmUgaXRlbXMgZnJvbSB0aGUgc291cmNlcyBhbmRcbiAgICAgIC8vIHRoZSBuYW1lcyBhcnJheS5cbiAgICAgIHZhciBuZXdTb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgICB2YXIgbmV3TmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICAgICAgLy8gRmluZCBtYXBwaW5ncyBmb3IgdGhlIFwic291cmNlRmlsZVwiXG4gICAgICB0aGlzLl9tYXBwaW5ncy51bnNvcnRlZEZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBzb3VyY2VGaWxlICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgICBuZXdTb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIW5ld05hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgIG5ld05hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHRoaXMuX3NvdXJjZXMgPSBuZXdTb3VyY2VzO1xuICAgICAgdGhpcy5fbmFtZXMgPSBuZXdOYW1lcztcblxuICAgICAgLy8gQ29weSBzb3VyY2VzQ29udGVudHMgb2YgYXBwbGllZCBtYXAuXG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEEgbWFwcGluZyBjYW4gaGF2ZSBvbmUgb2YgdGhlIHRocmVlIGxldmVscyBvZiBkYXRhOlxuICAgKlxuICAgKiAgIDEuIEp1c3QgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAgICogICAyLiBUaGUgR2VuZXJhdGVkIHBvc2l0aW9uLCBvcmlnaW5hbCBwb3NpdGlvbiwgYW5kIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAzLiBHZW5lcmF0ZWQgYW5kIG9yaWdpbmFsIHBvc2l0aW9uLCBvcmlnaW5hbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBuYW1lXG4gICAqICAgICAgdG9rZW4uXG4gICAqXG4gICAqIFRvIG1haW50YWluIGNvbnNpc3RlbmN5LCB3ZSB2YWxpZGF0ZSB0aGF0IGFueSBuZXcgbWFwcGluZyBiZWluZyBhZGRlZCBmYWxsc1xuICAgKiBpbiB0byBvbmUgb2YgdGhlc2UgY2F0ZWdvcmllcy5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3ZhbGlkYXRlTWFwcGluZyhhR2VuZXJhdGVkLCBhT3JpZ2luYWwsIGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTmFtZSkge1xuICAgICAgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICYmICFhT3JpZ2luYWwgJiYgIWFTb3VyY2UgJiYgIWFOYW1lKSB7XG4gICAgICAgIC8vIENhc2UgMS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgICAgICAmJiBhT3JpZ2luYWwgJiYgJ2xpbmUnIGluIGFPcmlnaW5hbCAmJiAnY29sdW1uJyBpbiBhT3JpZ2luYWxcbiAgICAgICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICAgJiYgYU9yaWdpbmFsLmxpbmUgPiAwICYmIGFPcmlnaW5hbC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICAgJiYgYVNvdXJjZSkge1xuICAgICAgICAvLyBDYXNlcyAyIGFuZCAzLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcHBpbmc6ICcgKyBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZ2VuZXJhdGVkOiBhR2VuZXJhdGVkLFxuICAgICAgICAgIHNvdXJjZTogYVNvdXJjZSxcbiAgICAgICAgICBvcmlnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICAgIG5hbWU6IGFOYW1lXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gICAqIHNwZWNpZmllZCBieSB0aGUgc291cmNlIG1hcCBmb3JtYXQuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NlcmlhbGl6ZU1hcHBpbmdzKCkge1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHZhciBtYXBwaW5nO1xuICAgICAgdmFyIG5hbWVJZHg7XG4gICAgICB2YXIgc291cmNlSWR4O1xuXG4gICAgICB2YXIgbWFwcGluZ3MgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICB3aGlsZSAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyc7XG4gICAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZywgbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VJZHggPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKHNvdXJjZUlkeCAtIHByZXZpb3VzU291cmNlKTtcbiAgICAgICAgICBwcmV2aW91c1NvdXJjZSA9IHNvdXJjZUlkeDtcblxuICAgICAgICAgIC8vIGxpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZCBpbiBTb3VyY2VNYXAgc3BlYyB2ZXJzaW9uIDNcbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxMaW5lKTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMTtcblxuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBuYW1lSWR4ID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobmFtZUlkeCAtIHByZXZpb3VzTmFtZSk7XG4gICAgICAgICAgICBwcmV2aW91c05hbWUgPSBuYW1lSWR4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoYVNvdXJjZXMsIGFTb3VyY2VSb290KSB7XG4gICAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUoYVNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IHV0aWwudG9TZXRTdHJpbmcoc291cmNlKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zb3VyY2VzQ29udGVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5KVxuICAgICAgICAgID8gdGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV1cbiAgICAgICAgICA6IG51bGw7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9KU09OID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgICAgdmFyIG1hcCA9IHtcbiAgICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICAgIG1hcHBpbmdzOiB0aGlzLl9zZXJpYWxpemVNYXBwaW5ncygpXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuX2ZpbGUgIT0gbnVsbCkge1xuICAgICAgICBtYXAuZmlsZSA9IHRoaXMuX2ZpbGU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIG1hcC5zb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gdGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChtYXAuc291cmNlcywgbWFwLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSk7XG4gICAgfTtcblxuICBleHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IFNvdXJjZU1hcEdlbmVyYXRvcjtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqIEJhc2VkIG9uIHRoZSBCYXNlIDY0IFZMUSBpbXBsZW1lbnRhdGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyOlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxuICpcbiAqIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIENvbXBpbGVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG57XG4gIHZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4gIC8vIEEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgY2FuIGNvbnRhaW4gNiBiaXRzIG9mIGRhdGEuIEZvciB0aGUgYmFzZSA2NCB2YXJpYWJsZVxuICAvLyBsZW5ndGggcXVhbnRpdGllcyB3ZSB1c2UgaW4gdGhlIHNvdXJjZSBtYXAgc3BlYywgdGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbixcbiAgLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4gIC8vIGNvbnRpbnVhdGlvbiBiaXQuIFRoZSBjb250aW51YXRpb24gYml0IHRlbGxzIHVzIHdoZXRoZXIgdGhlcmUgYXJlIG1vcmVcbiAgLy8gZGlnaXRzIGluIHRoaXMgdmFsdWUgZm9sbG93aW5nIHRoaXMgZGlnaXQuXG4gIC8vXG4gIC8vICAgQ29udGludWF0aW9uXG4gIC8vICAgfCAgICBTaWduXG4gIC8vICAgfCAgICB8XG4gIC8vICAgViAgICBWXG4gIC8vICAgMTAxMDExXG5cbiAgdmFyIFZMUV9CQVNFX1NISUZUID0gNTtcblxuICAvLyBiaW5hcnk6IDEwMDAwMFxuICB2YXIgVkxRX0JBU0UgPSAxIDw8IFZMUV9CQVNFX1NISUZUO1xuXG4gIC8vIGJpbmFyeTogMDExMTExXG4gIHZhciBWTFFfQkFTRV9NQVNLID0gVkxRX0JBU0UgLSAxO1xuXG4gIC8vIGJpbmFyeTogMTAwMDAwXG4gIHZhciBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IFZMUV9CQVNFO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAgICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gICAqICAgMSBiZWNvbWVzIDIgKDEwIGJpbmFyeSksIC0xIGJlY29tZXMgMyAoMTEgYmluYXJ5KVxuICAgKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxuICAgKi9cbiAgZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKSB7XG4gICAgcmV0dXJuIGFWYWx1ZSA8IDBcbiAgICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcbiAgICAgIDogKGFWYWx1ZSA8PCAxKSArIDA7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdG8gYSB0d28tY29tcGxlbWVudCB2YWx1ZSBmcm9tIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gICAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICAgKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAgICogICA0ICgxMDAgYmluYXJ5KSBiZWNvbWVzIDIsIDUgKDEwMSBiaW5hcnkpIGJlY29tZXMgLTJcbiAgICovXG4gIGZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gICAgdmFyIGlzTmVnYXRpdmUgPSAoYVZhbHVlICYgMSkgPT09IDE7XG4gICAgdmFyIHNoaWZ0ZWQgPSBhVmFsdWUgPj4gMTtcbiAgICByZXR1cm4gaXNOZWdhdGl2ZVxuICAgICAgPyAtc2hpZnRlZFxuICAgICAgOiBzaGlmdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJhc2UgNjQgVkxRIGVuY29kZWQgdmFsdWUuXG4gICAqL1xuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9lbmNvZGUoYVZhbHVlKSB7XG4gICAgdmFyIGVuY29kZWQgPSBcIlwiO1xuICAgIHZhciBkaWdpdDtcblxuICAgIHZhciB2bHEgPSB0b1ZMUVNpZ25lZChhVmFsdWUpO1xuXG4gICAgZG8ge1xuICAgICAgZGlnaXQgPSB2bHEgJiBWTFFfQkFTRV9NQVNLO1xuICAgICAgdmxxID4+Pj0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgICBpZiAodmxxID4gMCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4gICAgICAgIC8vIGNvbnRpbnVhdGlvbiBiaXQgaXMgbWFya2VkLlxuICAgICAgICBkaWdpdCB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVDtcbiAgICAgIH1cbiAgICAgIGVuY29kZWQgKz0gYmFzZTY0LmVuY29kZShkaWdpdCk7XG4gICAgfSB3aGlsZSAodmxxID4gMCk7XG5cbiAgICByZXR1cm4gZW5jb2RlZDtcbiAgfTtcblxuICAvKipcbiAgICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gICAqIHZhbHVlIGFuZCB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nIHZpYSB0aGUgb3V0IHBhcmFtZXRlci5cbiAgICovXG4gIGV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyLCBhSW5kZXgsIGFPdXRQYXJhbSkge1xuICAgIHZhciBzdHJMZW4gPSBhU3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICB2YXIgc2hpZnQgPSAwO1xuICAgIHZhciBjb250aW51YXRpb24sIGRpZ2l0O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKGFJbmRleCA+PSBzdHJMZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbW9yZSBkaWdpdHMgaW4gYmFzZSA2NCBWTFEgdmFsdWUuXCIpO1xuICAgICAgfVxuXG4gICAgICBkaWdpdCA9IGJhc2U2NC5kZWNvZGUoYVN0ci5jaGFyQ29kZUF0KGFJbmRleCsrKSk7XG4gICAgICBpZiAoZGlnaXQgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGRpZ2l0OiBcIiArIGFTdHIuY2hhckF0KGFJbmRleCAtIDEpKTtcbiAgICAgIH1cblxuICAgICAgY29udGludWF0aW9uID0gISEoZGlnaXQgJiBWTFFfQ09OVElOVUFUSU9OX0JJVCk7XG4gICAgICBkaWdpdCAmPSBWTFFfQkFTRV9NQVNLO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICAgIHNoaWZ0ICs9IFZMUV9CQVNFX1NISUZUO1xuICAgIH0gd2hpbGUgKGNvbnRpbnVhdGlvbik7XG5cbiAgICBhT3V0UGFyYW0udmFsdWUgPSBmcm9tVkxRU2lnbmVkKHJlc3VsdCk7XG4gICAgYU91dFBhcmFtLnJlc3QgPSBhSW5kZXg7XG4gIH07XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvYmFzZTY0LXZscS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG57XG4gIHZhciBpbnRUb0NoYXJNYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycuc3BsaXQoJycpO1xuXG4gIC8qKlxuICAgKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICAgKi9cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgaWYgKDAgPD0gbnVtYmVyICYmIG51bWJlciA8IGludFRvQ2hhck1hcC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBpbnRUb0NoYXJNYXBbbnVtYmVyXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBudW1iZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBjaGFyYWN0ZXIgY29kZSBkaWdpdCB0byBhbiBpbnRlZ2VyLiBSZXR1cm5zIC0xIG9uXG4gICAqIGZhaWx1cmUuXG4gICAqL1xuICBleHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICAgIHZhciBiaWdBID0gNjU7ICAgICAvLyAnQSdcbiAgICB2YXIgYmlnWiA9IDkwOyAgICAgLy8gJ1onXG5cbiAgICB2YXIgbGl0dGxlQSA9IDk3OyAgLy8gJ2EnXG4gICAgdmFyIGxpdHRsZVogPSAxMjI7IC8vICd6J1xuXG4gICAgdmFyIHplcm8gPSA0ODsgICAgIC8vICcwJ1xuICAgIHZhciBuaW5lID0gNTc7ICAgICAvLyAnOSdcblxuICAgIHZhciBwbHVzID0gNDM7ICAgICAvLyAnKydcbiAgICB2YXIgc2xhc2ggPSA0NzsgICAgLy8gJy8nXG5cbiAgICB2YXIgbGl0dGxlT2Zmc2V0ID0gMjY7XG4gICAgdmFyIG51bWJlck9mZnNldCA9IDUyO1xuXG4gICAgLy8gMCAtIDI1OiBBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlxuICAgIGlmIChiaWdBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGJpZ1opIHtcbiAgICAgIHJldHVybiAoY2hhckNvZGUgLSBiaWdBKTtcbiAgICB9XG5cbiAgICAvLyAyNiAtIDUxOiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxuICAgIGlmIChsaXR0bGVBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGxpdHRsZVopIHtcbiAgICAgIHJldHVybiAoY2hhckNvZGUgLSBsaXR0bGVBICsgbGl0dGxlT2Zmc2V0KTtcbiAgICB9XG5cbiAgICAvLyA1MiAtIDYxOiAwMTIzNDU2Nzg5XG4gICAgaWYgKHplcm8gPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gbmluZSkge1xuICAgICAgcmV0dXJuIChjaGFyQ29kZSAtIHplcm8gKyBudW1iZXJPZmZzZXQpO1xuICAgIH1cblxuICAgIC8vIDYyOiArXG4gICAgaWYgKGNoYXJDb2RlID09IHBsdXMpIHtcbiAgICAgIHJldHVybiA2MjtcbiAgICB9XG5cbiAgICAvLyA2MzogL1xuICAgIGlmIChjaGFyQ29kZSA9PSBzbGFzaCkge1xuICAgICAgcmV0dXJuIDYzO1xuICAgIH1cblxuICAgIC8vIEludmFsaWQgYmFzZTY0IGRpZ2l0LlxuICAgIHJldHVybiAtMTtcbiAgfTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9iYXNlNjQuanNcbiAqKiBtb2R1bGUgaWQgPSAxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xue1xuICAvKipcbiAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICAgKiBvYmplY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgZ2V0dGluZy5cbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAgICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICAgKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoYU5hbWUgaW4gYUFyZ3MpIHtcbiAgICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gYURlZmF1bHRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICAgIH1cbiAgfVxuICBleHBvcnRzLmdldEFyZyA9IGdldEFyZztcblxuICB2YXIgdXJsUmVnZXhwID0gL14oPzooW1xcdytcXC0uXSspOik/XFwvXFwvKD86KFxcdys6XFx3KylAKT8oW1xcdy5dKikoPzo6KFxcZCspKT8oXFxTKikkLztcbiAgdmFyIGRhdGFVcmxSZWdleHAgPSAvXmRhdGE6LitcXCwuKyQvO1xuXG4gIGZ1bmN0aW9uIHVybFBhcnNlKGFVcmwpIHtcbiAgICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzY2hlbWU6IG1hdGNoWzFdLFxuICAgICAgYXV0aDogbWF0Y2hbMl0sXG4gICAgICBob3N0OiBtYXRjaFszXSxcbiAgICAgIHBvcnQ6IG1hdGNoWzRdLFxuICAgICAgcGF0aDogbWF0Y2hbNV1cbiAgICB9O1xuICB9XG4gIGV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuICBmdW5jdGlvbiB1cmxHZW5lcmF0ZShhUGFyc2VkVXJsKSB7XG4gICAgdmFyIHVybCA9ICcnO1xuICAgIGlmIChhUGFyc2VkVXJsLnNjaGVtZSkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwuc2NoZW1lICsgJzonO1xuICAgIH1cbiAgICB1cmwgKz0gJy8vJztcbiAgICBpZiAoYVBhcnNlZFVybC5hdXRoKSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5hdXRoICsgJ0AnO1xuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5ob3N0KSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5ob3N0O1xuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5wb3J0KSB7XG4gICAgICB1cmwgKz0gXCI6XCIgKyBhUGFyc2VkVXJsLnBvcnRcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwucGF0aCkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwucGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBleHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgYSBwYXRoLCBvciB0aGUgcGF0aCBwb3J0aW9uIG9mIGEgVVJMOlxuICAgKlxuICAgKiAtIFJlcGxhY2VzIGNvbnNlcXV0aXZlIHNsYXNoZXMgd2l0aCBvbmUgc2xhc2guXG4gICAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnLicgcGFydHMuXG4gICAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnPGRpcj4vLi4nIHBhcnRzLlxuICAgKlxuICAgKiBCYXNlZCBvbiBjb2RlIGluIHRoZSBOb2RlLmpzICdwYXRoJyBjb3JlIG1vZHVsZS5cbiAgICpcbiAgICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIHVybCB0byBub3JtYWxpemUuXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemUoYVBhdGgpIHtcbiAgICB2YXIgcGF0aCA9IGFQYXRoO1xuICAgIHZhciB1cmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gICAgaWYgKHVybCkge1xuICAgICAgaWYgKCF1cmwucGF0aCkge1xuICAgICAgICByZXR1cm4gYVBhdGg7XG4gICAgICB9XG4gICAgICBwYXRoID0gdXJsLnBhdGg7XG4gICAgfVxuICAgIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpO1xuXG4gICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgvXFwvKy8pO1xuICAgIGZvciAodmFyIHBhcnQsIHVwID0gMCwgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICB1cCsrO1xuICAgICAgfSBlbHNlIGlmICh1cCA+IDApIHtcbiAgICAgICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICAgICAgLy8gVGhlIGZpcnN0IHBhcnQgaXMgYmxhbmsgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGUuIFRyeWluZyB0byBnb1xuICAgICAgICAgIC8vIGFib3ZlIHRoZSByb290IGlzIGEgbm8tb3AuIFRoZXJlZm9yZSB3ZSBjYW4gcmVtb3ZlIGFsbCAnLi4nIHBhcnRzXG4gICAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgdGhlIHJvb3QuXG4gICAgICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCB1cCk7XG4gICAgICAgICAgdXAgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAyKTtcbiAgICAgICAgICB1cC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG5cbiAgICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICAgIHBhdGggPSBpc0Fic29sdXRlID8gJy8nIDogJy4nO1xuICAgIH1cblxuICAgIGlmICh1cmwpIHtcbiAgICAgIHVybC5wYXRoID0gcGF0aDtcbiAgICAgIHJldHVybiB1cmxHZW5lcmF0ZSh1cmwpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBleHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcblxuICAvKipcbiAgICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gICAqXG4gICAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAgICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAgICpcbiAgICogLSBJZiBhUGF0aCBpcyBhIFVSTCBvciBhIGRhdGEgVVJJLCBhUGF0aCBpcyByZXR1cm5lZCwgdW5sZXNzIGFQYXRoIGlzIGFcbiAgICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gICAqICAgZmlyc3QuXG4gICAqIC0gT3RoZXJ3aXNlIGFQYXRoIGlzIGEgcGF0aC4gSWYgYVJvb3QgaXMgYSBVUkwsIHRoZW4gaXRzIHBhdGggcG9ydGlvblxuICAgKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAgICogICBpcyByZXR1cm5lZC5cbiAgICogICAtIElmIGFQYXRoIGlzIGFic29sdXRlLCB0aGUgcmVzdWx0IGlzIGFQYXRoLlxuICAgKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gICAqIC0gSm9pbmluZyBmb3IgZXhhbXBsZSAnaHR0cDovLycgYW5kICd3d3cuZXhhbXBsZS5jb20nIGlzIGFsc28gc3VwcG9ydGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICAgIGFSb290ID0gXCIuXCI7XG4gICAgfVxuICAgIGlmIChhUGF0aCA9PT0gXCJcIikge1xuICAgICAgYVBhdGggPSBcIi5cIjtcbiAgICB9XG4gICAgdmFyIGFQYXRoVXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICAgIHZhciBhUm9vdFVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFSb290ID0gYVJvb3RVcmwucGF0aCB8fCAnLyc7XG4gICAgfVxuXG4gICAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgICBpZiAoYVBhdGhVcmwgJiYgIWFQYXRoVXJsLnNjaGVtZSkge1xuICAgICAgaWYgKGFSb290VXJsKSB7XG4gICAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUGF0aFVybCk7XG4gICAgfVxuXG4gICAgaWYgKGFQYXRoVXJsIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgLy8gYGpvaW4oJ2h0dHA6Ly8nLCAnd3d3LmV4YW1wbGUuY29tJylgXG4gICAgaWYgKGFSb290VXJsICYmICFhUm9vdFVybC5ob3N0ICYmICFhUm9vdFVybC5wYXRoKSB7XG4gICAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICAgIH1cblxuICAgIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgPyBhUGF0aFxuICAgICAgOiBub3JtYWxpemUoYVJvb3QucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyBhUGF0aCk7XG5cbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFSb290VXJsLnBhdGggPSBqb2luZWQ7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICAgIH1cbiAgICByZXR1cm4gam9pbmVkO1xuICB9XG4gIGV4cG9ydHMuam9pbiA9IGpvaW47XG5cbiAgZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24gKGFQYXRoKSB7XG4gICAgcmV0dXJuIGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nIHx8ICEhYVBhdGgubWF0Y2godXJsUmVnZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogTWFrZSBhIHBhdGggcmVsYXRpdmUgdG8gYSBVUkwgb3IgYW5vdGhlciBwYXRoLlxuICAgKlxuICAgKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gICAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgbWFkZSByZWxhdGl2ZSB0byBhUm9vdC5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbGF0aXZlKGFSb290LCBhUGF0aCkge1xuICAgIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgICAgYVJvb3QgPSBcIi5cIjtcbiAgICB9XG5cbiAgICBhUm9vdCA9IGFSb290LnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cbiAgICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhdGggdG8gYmUgYWJvdmUgdGhlIHJvb3QuIEluIHRoaXMgY2FzZSwgc2ltcGx5XG4gICAgLy8gY2hlY2tpbmcgd2hldGhlciB0aGUgcm9vdCBpcyBhIHByZWZpeCBvZiB0aGUgcGF0aCB3b24ndCB3b3JrLiBJbnN0ZWFkLCB3ZVxuICAgIC8vIG5lZWQgdG8gcmVtb3ZlIGNvbXBvbmVudHMgZnJvbSB0aGUgcm9vdCBvbmUgYnkgb25lLCB1bnRpbCBlaXRoZXIgd2UgZmluZFxuICAgIC8vIGEgcHJlZml4IHRoYXQgZml0cywgb3Igd2UgcnVuIG91dCBvZiBjb21wb25lbnRzIHRvIHJlbW92ZS5cbiAgICB2YXIgbGV2ZWwgPSAwO1xuICAgIHdoaWxlIChhUGF0aC5pbmRleE9mKGFSb290ICsgJy8nKSAhPT0gMCkge1xuICAgICAgdmFyIGluZGV4ID0gYVJvb3QubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gYVBhdGg7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBvbmx5IHBhcnQgb2YgdGhlIHJvb3QgdGhhdCBpcyBsZWZ0IGlzIHRoZSBzY2hlbWUgKGkuZS4gaHR0cDovLyxcbiAgICAgIC8vIGZpbGU6Ly8vLCBldGMuKSwgb25lIG9yIG1vcmUgc2xhc2hlcyAoLyksIG9yIHNpbXBseSBub3RoaW5nIGF0IGFsbCwgd2VcbiAgICAgIC8vIGhhdmUgZXhoYXVzdGVkIGFsbCBjb21wb25lbnRzLCBzbyB0aGUgcGF0aCBpcyBub3QgcmVsYXRpdmUgdG8gdGhlIHJvb3QuXG4gICAgICBhUm9vdCA9IGFSb290LnNsaWNlKDAsIGluZGV4KTtcbiAgICAgIGlmIChhUm9vdC5tYXRjaCgvXihbXlxcL10rOlxcLyk/XFwvKiQvKSkge1xuICAgICAgICByZXR1cm4gYVBhdGg7XG4gICAgICB9XG5cbiAgICAgICsrbGV2ZWw7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHdlIGFkZCBhIFwiLi4vXCIgZm9yIGVhY2ggY29tcG9uZW50IHdlIHJlbW92ZWQgZnJvbSB0aGUgcm9vdC5cbiAgICByZXR1cm4gQXJyYXkobGV2ZWwgKyAxKS5qb2luKFwiLi4vXCIpICsgYVBhdGguc3Vic3RyKGFSb290Lmxlbmd0aCArIDEpO1xuICB9XG4gIGV4cG9ydHMucmVsYXRpdmUgPSByZWxhdGl2ZTtcblxuICAvKipcbiAgICogQmVjYXVzZSBiZWhhdmlvciBnb2VzIHdhY2t5IHdoZW4geW91IHNldCBgX19wcm90b19fYCBvbiBvYmplY3RzLCB3ZVxuICAgKiBoYXZlIHRvIHByZWZpeCBhbGwgdGhlIHN0cmluZ3MgaW4gb3VyIHNldCB3aXRoIGFuIGFyYml0cmFyeSBjaGFyYWN0ZXIuXG4gICAqXG4gICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL3B1bGwvMzEgYW5kXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzMwXG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgZnVuY3Rpb24gdG9TZXRTdHJpbmcoYVN0cikge1xuICAgIHJldHVybiAnJCcgKyBhU3RyO1xuICB9XG4gIGV4cG9ydHMudG9TZXRTdHJpbmcgPSB0b1NldFN0cmluZztcblxuICBmdW5jdGlvbiBmcm9tU2V0U3RyaW5nKGFTdHIpIHtcbiAgICByZXR1cm4gYVN0ci5zdWJzdHIoMSk7XG4gIH1cbiAgZXhwb3J0cy5mcm9tU2V0U3RyaW5nID0gZnJvbVNldFN0cmluZztcblxuICAvKipcbiAgICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAgICpcbiAgICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICAgKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiwgYnV0IGRpZmZlcmVudCBnZW5lcmF0ZWRcbiAgICogbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGEgbWFwcGluZyB3aXRoIGFcbiAgICogc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgIHZhciBjbXAgPSBtYXBwaW5nQS5zb3VyY2UgLSBtYXBwaW5nQi5zb3VyY2U7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5nQS5uYW1lIC0gbWFwcGluZ0IubmFtZTtcbiAgfVxuICBleHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbiAgLyoqXG4gICAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBkZWZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgaW5kaWNlcyB3aGVyZVxuICAgKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gICAqXG4gICAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAgICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gICAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gICAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICAgIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Euc291cmNlIC0gbWFwcGluZ0Iuc291cmNlO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5nQS5uYW1lIC0gbWFwcGluZ0IubmFtZTtcbiAgfVxuICBleHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQ7XG5cbiAgZnVuY3Rpb24gc3RyY21wKGFTdHIxLCBhU3RyMikge1xuICAgIGlmIChhU3RyMSA9PT0gYVN0cjIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChhU3RyMSA+IGFTdHIyKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGluZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBzdHJpbmdzIHdoZXJlXG4gICAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICAgIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbiAgfVxuICBleHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQ7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG57XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLyoqXG4gICAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICAgKiBtZW1iZXIgaXMgTygxKSwgdGVzdGluZyBmb3IgbWVtYmVyc2hpcCBpcyBPKDEpLCBhbmQgZmluZGluZyB0aGUgaW5kZXggb2YgYW5cbiAgICogZWxlbWVudCBpcyBPKDEpLiBSZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSBzZXQgaXMgbm90IHN1cHBvcnRlZC4gT25seVxuICAgKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gICAqL1xuICBmdW5jdGlvbiBBcnJheVNldCgpIHtcbiAgICB0aGlzLl9hcnJheSA9IFtdO1xuICAgIHRoaXMuX3NldCA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBtZXRob2QgZm9yIGNyZWF0aW5nIEFycmF5U2V0IGluc3RhbmNlcyBmcm9tIGFuIGV4aXN0aW5nIGFycmF5LlxuICAgKi9cbiAgQXJyYXlTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHZhciBzZXQgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYUFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzZXQuYWRkKGFBcnJheVtpXSwgYUFsbG93RHVwbGljYXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBzZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBob3cgbWFueSB1bmlxdWUgaXRlbXMgYXJlIGluIHRoaXMgQXJyYXlTZXQuIElmIGR1cGxpY2F0ZXMgaGF2ZSBiZWVuXG4gICAqIGFkZGVkLCB0aGFuIHRob3NlIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzaXplLlxuICAgKlxuICAgKiBAcmV0dXJucyBOdW1iZXJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gQXJyYXlTZXRfc2l6ZSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fc2V0KS5sZW5ndGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHRoaXMgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBBcnJheVNldF9hZGQoYVN0ciwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICB2YXIgaXNEdXBsaWNhdGUgPSB0aGlzLl9zZXQuaGFzT3duUHJvcGVydHkoc1N0cik7XG4gICAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgICBpZiAoIWlzRHVwbGljYXRlIHx8IGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICAgIHRoaXMuX2FycmF5LnB1c2goYVN0cik7XG4gICAgfVxuICAgIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICAgIHRoaXMuX3NldFtzU3RyXSA9IGlkeDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIEFycmF5U2V0X2hhcyhhU3RyKSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIHJldHVybiB0aGlzLl9zZXQuaGFzT3duUHJvcGVydHkoc1N0cik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIGlmICh0aGlzLl9zZXQuaGFzT3duUHJvcGVydHkoc1N0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRbc1N0cl07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hhdCBpcyB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXg/XG4gICAqXG4gICAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gQXJyYXlTZXRfYXQoYUlkeCkge1xuICAgIGlmIChhSWR4ID49IDAgJiYgYUlkeCA8IHRoaXMuX2FycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FycmF5W2FJZHhdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgaW5kZXhlZCBieSAnICsgYUlkeCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gICAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gICAqIGZvciBzdG9yaW5nIHRoZSBtZW1iZXJzIHNvIHRoYXQgbm8gb25lIGNhbiBtZXNzIHdpdGggaW50ZXJuYWwgc3RhdGUuXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5LnNsaWNlKCk7XG4gIH07XG5cbiAgZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL2FycmF5LXNldC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTQgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG57XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIG1hcHBpbmdCIGlzIGFmdGVyIG1hcHBpbmdBIHdpdGggcmVzcGVjdCB0byBnZW5lcmF0ZWRcbiAgICogcG9zaXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICAgIC8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICAgIHZhciBsaW5lQSA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmU7XG4gICAgdmFyIGxpbmVCID0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICB2YXIgY29sdW1uQSA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbjtcbiAgICB2YXIgY29sdW1uQiA9IG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICByZXR1cm4gbGluZUIgPiBsaW5lQSB8fCBsaW5lQiA9PSBsaW5lQSAmJiBjb2x1bW5CID49IGNvbHVtbkEgfHxcbiAgICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIDw9IDA7XG4gIH1cblxuICAvKipcbiAgICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICAgKiBwZXJmb3JtYW5jZSBjb25zY2lvdXMgbWFubmVyLiBJdCB0cmFkZXMgYSBuZWdsaWJhYmxlIG92ZXJoZWFkIGluIGdlbmVyYWxcbiAgICogY2FzZSBmb3IgYSBsYXJnZSBzcGVlZHVwIGluIGNhc2Ugb2YgbWFwcGluZ3MgYmVpbmcgYWRkZWQgaW4gb3JkZXIuXG4gICAqL1xuICBmdW5jdGlvbiBNYXBwaW5nTGlzdCgpIHtcbiAgICB0aGlzLl9hcnJheSA9IFtdO1xuICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gICAgLy8gU2VydmVzIGFzIGluZmltdW1cbiAgICB0aGlzLl9sYXN0ID0ge2dlbmVyYXRlZExpbmU6IC0xLCBnZW5lcmF0ZWRDb2x1bW46IDB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBpbnRlcm5hbCBpdGVtcy4gVGhpcyBtZXRob2QgdGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIHRoYXRcbiAgICogYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCB0YWtlcy5cbiAgICpcbiAgICogTk9URTogVGhlIG9yZGVyIG9mIHRoZSBtYXBwaW5ncyBpcyBOT1QgZ3VhcmFudGVlZC5cbiAgICovXG4gIE1hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2ggPVxuICAgIGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2ZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZykge1xuICAgICAgdGhpcy5fYXJyYXkuZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIGdpdmVuIHNvdXJjZSBtYXBwaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gT2JqZWN0IGFNYXBwaW5nXG4gICAqL1xuICBNYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfYWRkKGFNYXBwaW5nKSB7XG4gICAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIodGhpcy5fbGFzdCwgYU1hcHBpbmcpKSB7XG4gICAgICB0aGlzLl9sYXN0ID0gYU1hcHBpbmc7XG4gICAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZsYXQsIHNvcnRlZCBhcnJheSBvZiBtYXBwaW5ncy4gVGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQgYnlcbiAgICogZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICAgKlxuICAgKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCByZXR1cm5zIGludGVybmFsIGRhdGEgd2l0aG91dCBjb3B5aW5nLCBmb3JcbiAgICogcGVyZm9ybWFuY2UuIFRoZSByZXR1cm4gdmFsdWUgbXVzdCBOT1QgYmUgbXV0YXRlZCwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gICAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gICAqIGNvcHkuXG4gICAqL1xuICBNYXBwaW5nTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X3RvQXJyYXkoKSB7XG4gICAgaWYgKCF0aGlzLl9zb3J0ZWQpIHtcbiAgICAgIHRoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCk7XG4gICAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYXJyYXk7XG4gIH07XG5cbiAgZXhwb3J0cy5NYXBwaW5nTGlzdCA9IE1hcHBpbmdMaXN0O1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL21hcHBpbmctbGlzdC5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG57XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4gIHZhciBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKCcuL2JpbmFyeS1zZWFyY2gnKTtcbiAgdmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbiAgdmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xuICB2YXIgcXVpY2tTb3J0ID0gcmVxdWlyZSgnLi9xdWljay1zb3J0JykucXVpY2tTb3J0O1xuXG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2VNYXAuc2VjdGlvbnMgIT0gbnVsbFxuICAgICAgPyBuZXcgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcClcbiAgICAgIDogbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKTtcbiAgfVxuXG4gIFNvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPSBmdW5jdGlvbihhU291cmNlTWFwKSB7XG4gICAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlXG4gIC8vIHBhcnNlZCBtYXBwaW5nIGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZSBtYXAncyBcIm1hcHBpbmdzXCIgYXR0cmlidXRlLiBUaGV5XG4gIC8vIGFyZSBsYXppbHkgaW5zdGFudGlhdGVkLCBhY2Nlc3NlZCB2aWEgdGhlIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICAvLyBgX29yaWdpbmFsTWFwcGluZ3NgIGdldHRlcnMgcmVzcGVjdGl2ZWx5LCBhbmQgd2Ugb25seSBwYXJzZSB0aGUgbWFwcGluZ3NcbiAgLy8gYW5kIGNyZWF0ZSB0aGVzZSBhcnJheXMgb25jZSBxdWVyaWVkIGZvciBhIHNvdXJjZSBsb2NhdGlvbi4gV2UganVtcCB0aHJvdWdoXG4gIC8vIHRoZXNlIGhvb3BzIGJlY2F1c2UgdGhlcmUgY2FuIGJlIG1hbnkgdGhvdXNhbmRzIG9mIG1hcHBpbmdzLCBhbmQgcGFyc2luZ1xuICAvLyB0aGVtIGlzIGV4cGVuc2l2ZSwgc28gd2Ugb25seSB3YW50IHRvIGRvIGl0IGlmIHdlIG11c3QuXG4gIC8vXG4gIC8vIEVhY2ggb2JqZWN0IGluIHRoZSBhcnJheXMgaXMgb2YgdGhlIGZvcm06XG4gIC8vXG4gIC8vICAgICB7XG4gIC8vICAgICAgIGdlbmVyYXRlZExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIGdlbmVyYXRlZENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBzb3VyY2U6IFRoZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSB0aGF0IGdlbmVyYXRlZCB0aGlzXG4gIC8vICAgICAgICAgICAgICAgY2h1bmsgb2YgY29kZSxcbiAgLy8gICAgICAgb3JpZ2luYWxMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4gIC8vICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgb3JpZ2luYWxDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgbmFtZTogVGhlIG5hbWUgb2YgdGhlIG9yaWdpbmFsIHN5bWJvbCB3aGljaCBnZW5lcmF0ZWQgdGhpcyBjaHVuayBvZlxuICAvLyAgICAgICAgICAgICBjb2RlLlxuICAvLyAgICAgfVxuICAvL1xuICAvLyBBbGwgcHJvcGVydGllcyBleGNlcHQgZm9yIGBnZW5lcmF0ZWRMaW5lYCBhbmQgYGdlbmVyYXRlZENvbHVtbmAgY2FuIGJlXG4gIC8vIGBudWxsYC5cbiAgLy9cbiAgLy8gYF9nZW5lcmF0ZWRNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucy5cbiAgLy9cbiAgLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMuXG5cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBudWxsO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX2dlbmVyYXRlZE1hcHBpbmdzJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MpIHtcbiAgICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICB9XG4gIH0pO1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX29yaWdpbmFsTWFwcGluZ3MnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzKSB7XG4gICAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgICB9XG4gIH0pO1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fY2hhcklzTWFwcGluZ1NlcGFyYXRvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBpbmRleCkge1xuICAgICAgdmFyIGMgPSBhU3RyLmNoYXJBdChpbmRleCk7XG4gICAgICByZXR1cm4gYyA9PT0gXCI7XCIgfHwgYyA9PT0gXCIsXCI7XG4gICAgfTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICAgKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBfcGFyc2VNYXBwaW5nc1wiKTtcbiAgICB9O1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUiA9IDE7XG4gIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjtcblxuICBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG4gIFNvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICAgKiBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gaW4gdGhpcyBzb3VyY2UgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBlYWNoIG1hcHBpbmcuXG4gICAqIEBwYXJhbSBPYmplY3QgYUNvbnRleHRcbiAgICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICAgKiAgICAgICAgdGltZSB0aGF0IGBhQ2FsbGJhY2tgIGlzIGNhbGxlZC5cbiAgICogQHBhcmFtIGFPcmRlclxuICAgKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gICAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVJgLiBTcGVjaWZpZXMgd2hldGhlciB5b3Ugd2FudCB0b1xuICAgKiAgICAgICAgaXRlcmF0ZSBvdmVyIHRoZSBtYXBwaW5ncyBzb3J0ZWQgYnkgdGhlIGdlbmVyYXRlZCBmaWxlJ3MgbGluZS9jb2x1bW5cbiAgICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICAgKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikge1xuICAgICAgdmFyIGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgICAgdmFyIG1hcHBpbmdzO1xuICAgICAgc3dpdGNoIChvcmRlcikge1xuICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICAgIG1hcHBpbmdzID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgICAgbWFwcGluZ3MgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgICBtYXBwaW5ncy5tYXAoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlID09PSBudWxsID8gbnVsbCA6IHRoaXMuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpXG4gICAgICAgIH07XG4gICAgICB9LCB0aGlzKS5mb3JFYWNoKGFDYWxsYmFjaywgY29udGV4dCk7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAgICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICAgKiBjb3JyZXNwb25kaW5nIHRvIGEgZWl0aGVyIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yIG9yIHRoZSBuZXh0XG4gICAqIGNsb3Nlc3QgbGluZSB0aGF0IGhhcyBhbnkgbWFwcGluZ3MuIE90aGVyd2lzZSwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAgICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAgICogb3IgdGhlIG5leHQgY2xvc2VzdCBjb2x1bW4gdGhhdCBoYXMgYW55IG9mZnNldHMuXG4gICAqXG4gICAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogT3B0aW9uYWwuIHRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihhQXJncykge1xuICAgICAgdmFyIGxpbmUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKTtcblxuICAgICAgLy8gV2hlbiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nXG4gICAgICAvLyByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBtYXBwaW5nIGxlc3MgdGhhbiB0aGUgbmVlZGxlLiBCeVxuICAgICAgLy8gc2V0dGluZyBuZWVkbGUub3JpZ2luYWxDb2x1bW4gdG8gMCwgd2UgdGh1cyBmaW5kIHRoZSBsYXN0IG1hcHBpbmcgZm9yXG4gICAgICAvLyB0aGUgZ2l2ZW4gbGluZSwgcHJvdmlkZWQgc3VjaCBhIG1hcHBpbmcgZXhpc3RzLlxuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgc291cmNlOiB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpLFxuICAgICAgICBvcmlnaW5hbExpbmU6IGxpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicsIDApXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgbmVlZGxlLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBuZWVkbGUuc291cmNlKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMobmVlZGxlLnNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbmVlZGxlLnNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihuZWVkbGUuc291cmNlKTtcblxuICAgICAgdmFyIG1hcHBpbmdzID0gW107XG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKG5lZWRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAgIGlmIChhQXJncy5jb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBvcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcblxuICAgICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSBmb3VuZC4gU2luY2VcbiAgICAgICAgICAvLyBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgICAgLy8gdGhlIGxpbmUgd2UgZm91bmQuXG4gICAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IG9yaWdpbmFsTGluZSkge1xuICAgICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2Ugd2VyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICAgIC8vIFNpbmNlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgICAvLyB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgICB3aGlsZSAobWFwcGluZyAmJlxuICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gbGluZSAmJlxuICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID09IG9yaWdpbmFsQ29sdW1uKSB7XG4gICAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcHBpbmdzO1xuICAgIH07XG5cbiAgZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4gIC8qKlxuICAgKiBBIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoIHdlIGNhblxuICAgKiBxdWVyeSBmb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGZpbGUgcG9zaXRpb25zIGJ5IGdpdmluZyBpdCBhIGZpbGVcbiAgICogcG9zaXRpb24gaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqXG4gICAqIFRoZSBvbmx5IHBhcmFtZXRlciBpcyB0aGUgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvclxuICAgKiBhbHJlYWR5IHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIHNvdXJjZSBtYXBzIGhhdmUgdGhlXG4gICAqIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICAgKlxuICAgKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAgICogICAtIHNvdXJjZXM6IEFuIGFycmF5IG9mIFVSTHMgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAgICogICAtIG5hbWVzOiBBbiBhcnJheSBvZiBpZGVudGlmaWVycyB3aGljaCBjYW4gYmUgcmVmZXJyZW5jZWQgYnkgaW5kaXZpZHVhbCBtYXBwaW5ncy5cbiAgICogICAtIHNvdXJjZVJvb3Q6IE9wdGlvbmFsLiBUaGUgVVJMIHJvb3QgZnJvbSB3aGljaCBhbGwgc291cmNlcyBhcmUgcmVsYXRpdmUuXG4gICAqICAgLSBzb3VyY2VzQ29udGVudDogT3B0aW9uYWwuIEFuIGFycmF5IG9mIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gICAqICAgLSBtYXBwaW5nczogQSBzdHJpbmcgb2YgYmFzZTY0IFZMUXMgd2hpY2ggY29udGFpbiB0aGUgYWN0dWFsIG1hcHBpbmdzLlxuICAgKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgKlxuICAgKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICAgKlxuICAgKiAgICAge1xuICAgKiAgICAgICB2ZXJzaW9uIDogMyxcbiAgICogICAgICAgZmlsZTogXCJvdXQuanNcIixcbiAgICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gICAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAgICogICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gICAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAgICovXG4gIGZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICAgIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICAgIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gICAgfVxuXG4gICAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gICAgdmFyIHNvdXJjZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzJyk7XG4gICAgLy8gU2FzcyAzLjMgbGVhdmVzIG91dCB0aGUgJ25hbWVzJyBhcnJheSwgc28gd2UgZGV2aWF0ZSBmcm9tIHRoZSBzcGVjICh3aGljaFxuICAgIC8vIHJlcXVpcmVzIHRoZSBhcnJheSkgdG8gcGxheSBuaWNlIGhlcmUuXG4gICAgdmFyIG5hbWVzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbmFtZXMnLCBbXSk7XG4gICAgdmFyIHNvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VSb290JywgbnVsbCk7XG4gICAgdmFyIHNvdXJjZXNDb250ZW50ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlc0NvbnRlbnQnLCBudWxsKTtcbiAgICB2YXIgbWFwcGluZ3MgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdtYXBwaW5ncycpO1xuICAgIHZhciBmaWxlID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnZmlsZScsIG51bGwpO1xuXG4gICAgLy8gT25jZSBhZ2FpbiwgU2FzcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGFuZCBzdXBwbGllcyB0aGUgdmVyc2lvbiBhcyBhXG4gICAgLy8gc3RyaW5nIHJhdGhlciB0aGFuIGEgbnVtYmVyLCBzbyB3ZSB1c2UgbG9vc2UgZXF1YWxpdHkgY2hlY2tpbmcgaGVyZS5cbiAgICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgICB9XG5cbiAgICBzb3VyY2VzID0gc291cmNlc1xuICAgICAgLy8gU29tZSBzb3VyY2UgbWFwcyBwcm9kdWNlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBsaWtlIFwiLi9mb28uanNcIiBpbnN0ZWFkIG9mXG4gICAgICAvLyBcImZvby5qc1wiLiAgTm9ybWFsaXplIHRoZXNlIGZpcnN0IHNvIHRoYXQgZnV0dXJlIGNvbXBhcmlzb25zIHdpbGwgc3VjY2VlZC5cbiAgICAgIC8vIFNlZSBidWd6aWwubGEvMTA5MDc2OC5cbiAgICAgIC5tYXAodXRpbC5ub3JtYWxpemUpXG4gICAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgYWJzb2x1dGUgc291cmNlcyBhcmUgaW50ZXJuYWxseSBzdG9yZWQgcmVsYXRpdmUgdG9cbiAgICAgIC8vIHRoZSBzb3VyY2Ugcm9vdCwgaWYgdGhlIHNvdXJjZSByb290IGlzIGFic29sdXRlLiBOb3QgZG9pbmcgdGhpcyB3b3VsZFxuICAgICAgLy8gYmUgcGFydGljdWxhcmx5IHByb2JsZW1hdGljIHdoZW4gdGhlIHNvdXJjZSByb290IGlzIGEgcHJlZml4IG9mIHRoZVxuICAgICAgLy8gc291cmNlICh2YWxpZCwgYnV0IHdoeT8/KS4gU2VlIGdpdGh1YiBpc3N1ZSAjMTk5IGFuZCBidWd6aWwubGEvMTE4ODk4Mi5cbiAgICAgIC5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlUm9vdCAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlUm9vdCkgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZSlcbiAgICAgICAgICA/IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlKVxuICAgICAgICAgIDogc291cmNlO1xuICAgICAgfSk7XG5cbiAgICAvLyBQYXNzIGB0cnVlYCBiZWxvdyB0byBhbGxvdyBkdXBsaWNhdGUgbmFtZXMgYW5kIHNvdXJjZXMuIFdoaWxlIHNvdXJjZSBtYXBzXG4gICAgLy8gYXJlIGludGVuZGVkIHRvIGJlIGNvbXByZXNzZWQgYW5kIGRlZHVwbGljYXRlZCwgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXJcbiAgICAvLyBzb21ldGltZXMgZ2VuZXJhdGVzIHNvdXJjZSBtYXBzIHdpdGggZHVwbGljYXRlcyBpbiB0aGVtLiBTZWUgR2l0aHViIGlzc3VlXG4gICAgLy8gIzcyIGFuZCBidWd6aWwubGEvODg5NDkyLlxuICAgIHRoaXMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KG5hbWVzLCB0cnVlKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KHNvdXJjZXMsIHRydWUpO1xuXG4gICAgdGhpcy5zb3VyY2VSb290ID0gc291cmNlUm9vdDtcbiAgICB0aGlzLnNvdXJjZXNDb250ZW50ID0gc291cmNlc0NvbnRlbnQ7XG4gICAgdGhpcy5fbWFwcGluZ3MgPSBtYXBwaW5ncztcbiAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICB9XG5cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAgICpcbiAgICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gICAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG4gICAqIEByZXR1cm5zIEJhc2ljU291cmNlTWFwQ29uc3VtZXJcbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwKSB7XG4gICAgICB2YXIgc21jID0gT2JqZWN0LmNyZWF0ZShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5cbiAgICAgIHZhciBuYW1lcyA9IHNtYy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fbmFtZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICAgIHZhciBzb3VyY2VzID0gc21jLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX3NvdXJjZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21jLnNvdXJjZVJvb3QpO1xuICAgICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuXG4gICAgICAvLyBCZWNhdXNlIHdlIGFyZSBtb2RpZnlpbmcgdGhlIGVudHJpZXMgKGJ5IGNvbnZlcnRpbmcgc3RyaW5nIHNvdXJjZXMgYW5kXG4gICAgICAvLyBuYW1lcyB0byBpbmRpY2VzIGludG8gdGhlIHNvdXJjZXMgYW5kIG5hbWVzIEFycmF5U2V0cyksIHdlIGhhdmUgdG8gbWFrZVxuICAgICAgLy8gYSBjb3B5IG9mIHRoZSBlbnRyeSBvciBlbHNlIGJhZCB0aGluZ3MgaGFwcGVuLiBTaGFyZWQgbXV0YWJsZSBzdGF0ZVxuICAgICAgLy8gc3RyaWtlcyBhZ2FpbiEgU2VlIGdpdGh1YiBpc3N1ZSAjMTkxLlxuXG4gICAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy50b0FycmF5KCkuc2xpY2UoKTtcbiAgICAgIHZhciBkZXN0R2VuZXJhdGVkTWFwcGluZ3MgPSBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgdmFyIGRlc3RPcmlnaW5hbE1hcHBpbmdzID0gc21jLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNyY01hcHBpbmcgPSBnZW5lcmF0ZWRNYXBwaW5nc1tpXTtcbiAgICAgICAgdmFyIGRlc3RNYXBwaW5nID0gbmV3IE1hcHBpbmc7XG4gICAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBzcmNNYXBwaW5nLmdlbmVyYXRlZExpbmU7XG4gICAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChzcmNNYXBwaW5nLnNvdXJjZSkge1xuICAgICAgICAgIGRlc3RNYXBwaW5nLnNvdXJjZSA9IHNvdXJjZXMuaW5kZXhPZihzcmNNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxMaW5lID0gc3JjTWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBzcmNNYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKHNyY01hcHBpbmcubmFtZSkge1xuICAgICAgICAgICAgZGVzdE1hcHBpbmcubmFtZSA9IG5hbWVzLmluZGV4T2Yoc3JjTWFwcGluZy5uYW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXN0T3JpZ2luYWxNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICAgIH1cblxuICAgICAgcXVpY2tTb3J0KHNtYy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgICByZXR1cm4gc21jO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCA/IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHMpIDogcztcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgdGhlIEpJVCB3aXRoIGEgbmljZSBzaGFwZSAvIGhpZGRlbiBjbGFzcy5cbiAgICovXG4gIGZ1bmN0aW9uIE1hcHBpbmcoKSB7XG4gICAgdGhpcy5nZW5lcmF0ZWRMaW5lID0gMDtcbiAgICB0aGlzLmdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAgICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gICAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgICAgdmFyIGdlbmVyYXRlZExpbmUgPSAxO1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgICB2YXIgbGVuZ3RoID0gYVN0ci5sZW5ndGg7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIGNhY2hlZFNlZ21lbnRzID0ge307XG4gICAgICB2YXIgdGVtcCA9IHt9O1xuICAgICAgdmFyIG9yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgdmFyIG1hcHBpbmcsIHN0ciwgc2VnbWVudCwgZW5kLCB2YWx1ZTtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICc7Jykge1xuICAgICAgICAgIGdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICcsJykge1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbWFwcGluZyA9IG5ldyBNYXBwaW5nKCk7XG4gICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gZ2VuZXJhdGVkTGluZTtcblxuICAgICAgICAgIC8vIEJlY2F1c2UgZWFjaCBvZmZzZXQgaXMgZW5jb2RlZCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAgIC8vIG1hbnkgc2VnbWVudHMgb2Z0ZW4gaGF2ZSB0aGUgc2FtZSBlbmNvZGluZy4gV2UgY2FuIGV4cGxvaXQgdGhpc1xuICAgICAgICAgIC8vIGZhY3QgYnkgY2FjaGluZyB0aGUgcGFyc2VkIHZhcmlhYmxlIGxlbmd0aCBmaWVsZHMgb2YgZWFjaCBzZWdtZW50LFxuICAgICAgICAgIC8vIGFsbG93aW5nIHVzIHRvIGF2b2lkIGEgc2Vjb25kIHBhcnNlIGlmIHdlIGVuY291bnRlciB0aGUgc2FtZVxuICAgICAgICAgIC8vIHNlZ21lbnQgYWdhaW4uXG4gICAgICAgICAgZm9yIChlbmQgPSBpbmRleDsgZW5kIDwgbGVuZ3RoOyBlbmQrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgZW5kKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyID0gYVN0ci5zbGljZShpbmRleCwgZW5kKTtcblxuICAgICAgICAgIHNlZ21lbnQgPSBjYWNoZWRTZWdtZW50c1tzdHJdO1xuICAgICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgICBpbmRleCArPSBzdHIubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmQpIHtcbiAgICAgICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShhU3RyLCBpbmRleCwgdGVtcCk7XG4gICAgICAgICAgICAgIHZhbHVlID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgICAgaW5kZXggPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICAgIHNlZ21lbnQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlIGFuZCBsaW5lLCBidXQgbm8gY29sdW1uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhY2hlZFNlZ21lbnRzW3N0cl0gPSBzZWdtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEdlbmVyYXRlZCBjb2x1bW4uXG4gICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiArIHNlZ21lbnRbMF07XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIHNvdXJjZS5cbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gcHJldmlvdXNTb3VyY2UgKyBzZWdtZW50WzFdO1xuICAgICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gc2VnbWVudFsxXTtcblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgbGluZS5cbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gcHJldmlvdXNPcmlnaW5hbExpbmUgKyBzZWdtZW50WzJdO1xuICAgICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAgIC8vIExpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZFxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgKz0gMTtcblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gKyBzZWdtZW50WzNdO1xuICAgICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgLy8gT3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gcHJldmlvdXNOYW1lICsgc2VnbWVudFs0XTtcbiAgICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHNlZ21lbnRbNF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgb3JpZ2luYWxNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBxdWlja1NvcnQoZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gZ2VuZXJhdGVkTWFwcGluZ3M7XG5cbiAgICAgIHF1aWNrU29ydChvcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gb3JpZ2luYWxNYXBwaW5ncztcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAgICogd2UgYXJlIHNlYXJjaGluZyBmb3IgaW4gdGhlIGdpdmVuIFwiaGF5c3RhY2tcIiBvZiBtYXBwaW5ncy5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZmluZE1hcHBpbmcoYU5lZWRsZSwgYU1hcHBpbmdzLCBhTGluZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbHVtbk5hbWUsIGFDb21wYXJhdG9yLCBhQmlhcykge1xuICAgICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgICAgLy8gbWFwcGluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgb3Bwb3NpdGUgcG9zaXRpb24gaXRcbiAgICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICAgIGlmIChhTmVlZGxlW2FMaW5lTmFtZV0gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgICAgfVxuICAgICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUNvbHVtbk5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvciwgYUJpYXMpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIGxhc3QgY29sdW1uIGZvciBlYWNoIGdlbmVyYXRlZCBtYXBwaW5nLiBUaGUgbGFzdCBjb2x1bW4gaXNcbiAgICogaW5jbHVzaXZlLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29tcHV0ZUNvbHVtblNwYW5zID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jb21wdXRlQ29sdW1uU3BhbnMoKSB7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAgIC8vIE1hcHBpbmdzIGRvIG5vdCBjb250YWluIGEgZmllbGQgZm9yIHRoZSBsYXN0IGdlbmVyYXRlZCBjb2x1bW50LiBXZVxuICAgICAgICAvLyBjYW4gY29tZSB1cCB3aXRoIGFuIG9wdGltaXN0aWMgZXN0aW1hdGUsIGhvd2V2ZXIsIGJ5IGFzc3VtaW5nIHRoYXRcbiAgICAgICAgLy8gbWFwcGluZ3MgYXJlIGNvbnRpZ3VvdXMgKGkuZS4gZ2l2ZW4gdHdvIGNvbnNlY3V0aXZlIG1hcHBpbmdzLCB0aGVcbiAgICAgICAgLy8gZmlyc3QgbWFwcGluZyBlbmRzIHdoZXJlIHRoZSBzZWNvbmQgb25lIHN0YXJ0cykuXG4gICAgICAgIGlmIChpbmRleCArIDEgPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbmV4dE1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleCArIDFdO1xuXG4gICAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC0gMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBsYXN0IG1hcHBpbmcgZm9yIGVhY2ggbGluZSBzcGFucyB0aGUgZW50aXJlIGxpbmUuXG4gICAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IEluZmluaXR5O1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICAgKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAgICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAgICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAgICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICAgKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAgICpcbiAgICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICAgIH07XG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgICBuZWVkbGUsXG4gICAgICAgIHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLFxuICAgICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgICAgXCJnZW5lcmF0ZWRDb2x1bW5cIixcbiAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCxcbiAgICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgICApO1xuXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnc291cmNlJywgbnVsbCk7XG4gICAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5hdChzb3VyY2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ25hbWUnLCBudWxsKTtcbiAgICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmF0KG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gICAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICAgIGZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnQubGVuZ3RoID49IHRoaXMuX3NvdXJjZXMuc2l6ZSgpICYmXG4gICAgICAgICF0aGlzLnNvdXJjZXNDb250ZW50LnNvbWUoZnVuY3Rpb24gKHNjKSB7IHJldHVybiBzYyA9PSBudWxsOyB9KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAgICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICAgKiBhdmFpbGFibGUuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIGFTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgYVNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zb3VyY2VzLmhhcyhhU291cmNlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoYVNvdXJjZSldO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXJsO1xuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsXG4gICAgICAgICAgJiYgKHVybCA9IHV0aWwudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpIHtcbiAgICAgICAgLy8gWFhYOiBmaWxlOi8vIFVSSXMgYW5kIGFic29sdXRlIHBhdGhzIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvciBmb3JcbiAgICAgICAgLy8gbWFueSB1c2Vycy4gV2UgY2FuIGhlbHAgdGhlbSBvdXQgd2hlbiB0aGV5IGV4cGVjdCBmaWxlOi8vIFVSSXMgdG9cbiAgICAgICAgLy8gYmVoYXZlIGxpa2UgaXQgd291bGQgaWYgdGhleSB3ZXJlIHJ1bm5pbmcgYSBsb2NhbCBIVFRQIHNlcnZlci4gU2VlXG4gICAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4NTU5Ny5cbiAgICAgICAgdmFyIGZpbGVVcmlBYnNQYXRoID0gYVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgICAgaWYgKHVybC5zY2hlbWUgPT0gXCJmaWxlXCJcbiAgICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKGZpbGVVcmlBYnNQYXRoKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKCF1cmwucGF0aCB8fCB1cmwucGF0aCA9PSBcIi9cIilcbiAgICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgYVNvdXJjZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoXCIvXCIgKyBhU291cmNlKV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IGZyb21cbiAgICAgIC8vIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvci4gSW4gdGhhdCBjYXNlLCB3ZVxuICAgICAgLy8gZG9uJ3Qgd2FudCB0byB0aHJvdyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBzb3VyY2UgLSB3ZSBqdXN0IHdhbnQgdG9cbiAgICAgIC8vIHJldHVybiBudWxsLCBzbyB3ZSBwcm92aWRlIGEgZmxhZyB0byBleGl0IGdyYWNlZnVsbHkuXG4gICAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAgICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gICAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gICAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gICAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gICAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAgICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKTtcbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWxMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICAgIH07XG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgICBuZWVkbGUsXG4gICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgICApO1xuXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gbmVlZGxlLnNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICAgIH07XG4gICAgfTtcblxuICBleHBvcnRzLkJhc2ljU291cmNlTWFwQ29uc3VtZXIgPSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyO1xuXG4gIC8qKlxuICAgKiBBbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoXG4gICAqIHdlIGNhbiBxdWVyeSBmb3IgaW5mb3JtYXRpb24uIEl0IGRpZmZlcnMgZnJvbSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluXG4gICAqIHRoYXQgaXQgdGFrZXMgXCJpbmRleGVkXCIgc291cmNlIG1hcHMgKGkuZS4gb25lcyB3aXRoIGEgXCJzZWN0aW9uc1wiIGZpZWxkKSBhc1xuICAgKiBpbnB1dC5cbiAgICpcbiAgICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIGEgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvciBhbHJlYWR5XG4gICAqIHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMgZm9yIGluZGV4ZWQgc291cmNlIG1hcHMsIHRoZXlcbiAgICogaGF2ZSB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gICAqXG4gICAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICAgKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgKiAgIC0gc2VjdGlvbnM6IEEgbGlzdCBvZiBzZWN0aW9uIGRlZmluaXRpb25zLlxuICAgKlxuICAgKiBFYWNoIHZhbHVlIHVuZGVyIHRoZSBcInNlY3Rpb25zXCIgZmllbGQgaGFzIHR3byBmaWVsZHM6XG4gICAqICAgLSBvZmZzZXQ6IFRoZSBvZmZzZXQgaW50byB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGF0IHdoaWNoIHRoaXMgc2VjdGlvblxuICAgKiAgICAgICBiZWdpbnMgdG8gYXBwbHksIGRlZmluZWQgYXMgYW4gb2JqZWN0IHdpdGggYSBcImxpbmVcIiBhbmQgXCJjb2x1bW5cIlxuICAgKiAgICAgICBmaWVsZC5cbiAgICogICAtIG1hcDogQSBzb3VyY2UgbWFwIGRlZmluaXRpb24uIFRoaXMgc291cmNlIG1hcCBjb3VsZCBhbHNvIGJlIGluZGV4ZWQsXG4gICAqICAgICAgIGJ1dCBkb2Vzbid0IGhhdmUgdG8gYmUuXG4gICAqXG4gICAqIEluc3RlYWQgb2YgdGhlIFwibWFwXCIgZmllbGQsIGl0J3MgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgXCJ1cmxcIiBmaWVsZFxuICAgKiBzcGVjaWZ5aW5nIGEgVVJMIHRvIHJldHJpZXZlIGEgc291cmNlIG1hcCBmcm9tLCBidXQgdGhhdCdzIGN1cnJlbnRseVxuICAgKiB1bnN1cHBvcnRlZC5cbiAgICpcbiAgICogSGVyZSdzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdLCBidXRcbiAgICogbW9kaWZpZWQgdG8gb21pdCBhIHNlY3Rpb24gd2hpY2ggdXNlcyB0aGUgXCJ1cmxcIiBmaWVsZC5cbiAgICpcbiAgICogIHtcbiAgICogICAgdmVyc2lvbiA6IDMsXG4gICAqICAgIGZpbGU6IFwiYXBwLmpzXCIsXG4gICAqICAgIHNlY3Rpb25zOiBbe1xuICAgKiAgICAgIG9mZnNldDoge2xpbmU6MTAwLCBjb2x1bW46MTB9LFxuICAgKiAgICAgIG1hcDoge1xuICAgKiAgICAgICAgdmVyc2lvbiA6IDMsXG4gICAqICAgICAgICBmaWxlOiBcInNlY3Rpb24uanNcIixcbiAgICogICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAgICogICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICAgKiAgICAgICAgbWFwcGluZ3M6IFwiQUFBQSxFOztBQkNERTtcIlxuICAgKiAgICAgIH1cbiAgICogICAgfV0sXG4gICAqICB9XG4gICAqXG4gICAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0I2hlYWRpbmc9aC41MzVlczN4ZXByZ3RcbiAgICovXG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gICAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gICAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgICB9XG5cbiAgICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgICB2YXIgc2VjdGlvbnMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzZWN0aW9ucycpO1xuXG4gICAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gICAgfVxuXG4gICAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICB2YXIgbGFzdE9mZnNldCA9IHtcbiAgICAgIGxpbmU6IC0xLFxuICAgICAgY29sdW1uOiAwXG4gICAgfTtcbiAgICB0aGlzLl9zZWN0aW9ucyA9IHNlY3Rpb25zLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgaWYgKHMudXJsKSB7XG4gICAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMTZcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwb3J0IGZvciB1cmwgZmllbGQgaW4gc2VjdGlvbnMgbm90IGltcGxlbWVudGVkLicpO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IHV0aWwuZ2V0QXJnKHMsICdvZmZzZXQnKTtcbiAgICAgIHZhciBvZmZzZXRMaW5lID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnbGluZScpO1xuICAgICAgdmFyIG9mZnNldENvbHVtbiA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2NvbHVtbicpO1xuXG4gICAgICBpZiAob2Zmc2V0TGluZSA8IGxhc3RPZmZzZXQubGluZSB8fFxuICAgICAgICAgIChvZmZzZXRMaW5lID09PSBsYXN0T2Zmc2V0LmxpbmUgJiYgb2Zmc2V0Q29sdW1uIDwgbGFzdE9mZnNldC5jb2x1bW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO1xuICAgICAgfVxuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2VuZXJhdGVkT2Zmc2V0OiB7XG4gICAgICAgICAgLy8gVGhlIG9mZnNldCBmaWVsZHMgYXJlIDAtYmFzZWQsIGJ1dCB3ZSB1c2UgMS1iYXNlZCBpbmRpY2VzIHdoZW5cbiAgICAgICAgICAvLyBlbmNvZGluZy9kZWNvZGluZyBmcm9tIFZMUS5cbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBvZmZzZXRMaW5lICsgMSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG9mZnNldENvbHVtbiArIDFcbiAgICAgICAgfSxcbiAgICAgICAgY29uc3VtZXI6IG5ldyBTb3VyY2VNYXBDb25zdW1lcih1dGlsLmdldEFyZyhzLCAnbWFwJykpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAgICovXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc291cmNlcy5wdXNoKHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXNbal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc291cmNlcztcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAgICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICpcbiAgICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAgICovXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICAgIH07XG5cbiAgICAgIC8vIEZpbmQgdGhlIHNlY3Rpb24gY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uIHdlJ3JlIHRyeWluZyB0byBtYXBcbiAgICAgIC8vIHRvIGFuIG9yaWdpbmFsIHBvc2l0aW9uLlxuICAgICAgdmFyIHNlY3Rpb25JbmRleCA9IGJpbmFyeVNlYXJjaC5zZWFyY2gobmVlZGxlLCB0aGlzLl9zZWN0aW9ucyxcbiAgICAgICAgZnVuY3Rpb24obmVlZGxlLCBzZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGNtcCA9IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC0gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZTtcbiAgICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAobmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICB9KTtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcblxuICAgICAgaWYgKCFzZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgIGxpbmU6IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC1cbiAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICBjb2x1bW46IG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgOiAwKSxcbiAgICAgICAgYmlhczogYUFyZ3MuYmlhc1xuICAgICAgfSk7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gICAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gICAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBzLmNvbnN1bWVyLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAgICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICAgKiBhdmFpbGFibGUuXG4gICAqL1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICAgIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgICB2YXIgY29udGVudCA9IHNlY3Rpb24uY29uc3VtZXIuc291cmNlQ29udGVudEZvcihhU291cmNlLCB0cnVlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gICAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICAgKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKi9cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgICAgLy8gT25seSBjb25zaWRlciB0aGlzIHNlY3Rpb24gaWYgdGhlIHJlcXVlc3RlZCBzb3VyY2UgaXMgaW4gdGhlIGxpc3Qgb2ZcbiAgICAgICAgLy8gc291cmNlcyBvZiB0aGUgY29uc3VtZXIuXG4gICAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZXMuaW5kZXhPZih1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpKSA9PT0gLTEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2VuZXJhdGVkUG9zaXRpb24gPSBzZWN0aW9uLmNvbnN1bWVyLmdlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKTtcbiAgICAgICAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uKSB7XG4gICAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmUgK1xuICAgICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWRQb3NpdGlvbi5jb2x1bW4gK1xuICAgICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gZ2VuZXJhdGVkUG9zaXRpb24ubGluZVxuICAgICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICAgICA6IDApXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gICAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICAgKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICAgKi9cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcbiAgICAgICAgdmFyIHNlY3Rpb25NYXBwaW5ncyA9IHNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlY3Rpb25NYXBwaW5ncy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBtYXBwaW5nID0gc2VjdGlvbk1hcHBpbmdzW2pdO1xuXG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICAgICAgICB2YXIgbmFtZSA9IHNlY3Rpb24uY29uc3VtZXIuX25hbWVzLmF0KG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuXG4gICAgICAgICAgLy8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuICAgICAgICAgIC8vIGdlbmVyYXRlZCBwb3NpdGlvbnMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBzZWN0aW9uLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gb2Zmc2V0IHRoZW0gdG8gYmUgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb25jYXRlbmF0ZWRcbiAgICAgICAgICAvLyBnZW5lcmF0ZWQgZmlsZS5cbiAgICAgICAgICB2YXIgYWRqdXN0ZWRNYXBwaW5nID0ge1xuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUgK1xuICAgICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiArXG4gICAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBtYXBwaW5nLmdlbmVyYXRlZExpbmVcbiAgICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICAgIDogMCksXG4gICAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhZGp1c3RlZE1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBxdWlja1NvcnQodGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICAgIHF1aWNrU29ydCh0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gICAgfTtcblxuICBleHBvcnRzLkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciA9IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcjtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbntcbiAgZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG4gIGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaC5cbiAgICpcbiAgICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICAgKiBAcGFyYW0gYUhpZ2ggSW5kaWNlcyBoZXJlIGFuZCBoaWdoZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAgICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgYmVpbmcgc2VhcmNoZWQgZm9yLlxuICAgKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gICAqIEBwYXJhbSBhQ29tcGFyZSBGdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gZWxlbWVudHMgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEuXG4gICAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAgICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gICAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gICAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAgICovXG4gIGZ1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHRlcm1pbmF0ZXMgd2hlbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlOlxuICAgIC8vXG4gICAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICAvL1xuICAgIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2ZcbiAgICAvLyAgICAgIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudC5cbiAgICAvL1xuICAgIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gICAgLy8gICAgICBlbGVtZW50IHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2UgcmV0dXJuIC0xLlxuICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChhSGlnaCAtIGFMb3cpIC8gMikgKyBhTG93O1xuICAgIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgLy8gRm91bmQgdGhlIGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgLy8gT3VyIG5lZWRsZSBpcyBncmVhdGVyIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7XG4gICAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGV4YWN0IG5lZWRsZSBlbGVtZW50IHdhcyBub3QgZm91bmQgaW4gdGhpcyBoYXlzdGFjay4gRGV0ZXJtaW5lIGlmXG4gICAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgICAgcmV0dXJuIGFIaWdoIDwgYUhheXN0YWNrLmxlbmd0aCA/IGFIaWdoIDogLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIE91ciBuZWVkbGUgaXMgbGVzcyB0aGFuIGFIYXlzdGFja1ttaWRdLlxuICAgICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSBsb3dlciBoYWxmLlxuICAgICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKGFMb3csIG1pZCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhTG93IDwgMCA/IC0xIDogYUxvdztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gICAqIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBlbGVtZW50IGlmIHRoZXJlIGlzIG5vIGV4YWN0IGhpdC4gVGhpcyBpcyBiZWNhdXNlXG4gICAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAgICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnNcbiAgICogdGhhdCB5b3UgYXJlbid0IG9uIHRoZSB2ZXJ5IHN0YXJ0IG9mIGEgcmVnaW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICAgKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBhcnJheSB0aGF0IGlzIGJlaW5nIHNlYXJjaGVkLlxuICAgKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICAgKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gICAqICAgICB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlciB0aGFuIHRoZSBlbGVtZW50LCByZXNwZWN0aXZlbHkuXG4gICAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAgICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gICAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gICAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAgICogICAgIERlZmF1bHRzIHRvICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICAgKi9cbiAgZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgICBpZiAoYUhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29tcGFyZSwgYUJpYXMgfHwgZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIFdlIGhhdmUgZm91bmQgZWl0aGVyIHRoZSBleGFjdCBlbGVtZW50LCBvciB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQgdGhhblxuICAgIC8vIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuIEhvd2V2ZXIsIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIHN1Y2hcbiAgICAvLyBlbGVtZW50LiBNYWtlIHN1cmUgd2UgYWx3YXlzIHJldHVybiB0aGUgc21hbGxlc3Qgb2YgdGhlc2UuXG4gICAgd2hpbGUgKGluZGV4IC0gMSA+PSAwKSB7XG4gICAgICBpZiAoYUNvbXBhcmUoYUhheXN0YWNrW2luZGV4XSwgYUhheXN0YWNrW2luZGV4IC0gMV0sIHRydWUpICE9PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLS1pbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL34vc291cmNlLW1hcC9saWIvYmluYXJ5LXNlYXJjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG57XG4gIC8vIEl0IHR1cm5zIG91dCB0aGF0IHNvbWUgKG1vc3Q/KSBKYXZhU2NyaXB0IGVuZ2luZXMgZG9uJ3Qgc2VsZi1ob3N0XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuc29ydGAuIFRoaXMgbWFrZXMgc2Vuc2UgYmVjYXVzZSBDKysgd2lsbCBsaWtlbHkgcmVtYWluXG4gIC8vIGZhc3RlciB0aGFuIEpTIHdoZW4gZG9pbmcgcmF3IENQVS1pbnRlbnNpdmUgc29ydGluZy4gSG93ZXZlciwgd2hlbiB1c2luZyBhXG4gIC8vIGN1c3RvbSBjb21wYXJhdG9yIGZ1bmN0aW9uLCBjYWxsaW5nIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gdGhlIFZNJ3MgQysrIGFuZFxuICAvLyBKSVQnZCBKUyBpcyByYXRoZXIgc2xvdyAqYW5kKiBsb3NlcyBKSVQgdHlwZSBpbmZvcm1hdGlvbiwgcmVzdWx0aW5nIGluXG4gIC8vIHdvcnNlIGdlbmVyYXRlZCBjb2RlIGZvciB0aGUgY29tcGFyYXRvciBmdW5jdGlvbiB0aGFuIHdvdWxkIGJlIG9wdGltYWwuIEluXG4gIC8vIGZhY3QsIHdoZW4gc29ydGluZyB3aXRoIGEgY29tcGFyYXRvciwgdGhlc2UgY29zdHMgb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIG9mXG4gIC8vIHNvcnRpbmcgaW4gQysrLiBCeSB1c2luZyBvdXIgb3duIEpTLWltcGxlbWVudGVkIFF1aWNrIFNvcnQgKGJlbG93KSwgd2UgZ2V0XG4gIC8vIGEgfjM1MDBtcyBtZWFuIHNwZWVkLXVwIGluIGBiZW5jaC9iZW5jaC5odG1sYC5cblxuICAvKipcbiAgICogU3dhcCB0aGUgZWxlbWVudHMgaW5kZXhlZCBieSBgeGAgYW5kIGB5YCBpbiB0aGUgYXJyYXkgYGFyeWAuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICAgKiAgICAgICAgVGhlIGFycmF5LlxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtLlxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBzZWNvbmQgaXRlbS5cbiAgICovXG4gIGZ1bmN0aW9uIHN3YXAoYXJ5LCB4LCB5KSB7XG4gICAgdmFyIHRlbXAgPSBhcnlbeF07XG4gICAgYXJ5W3hdID0gYXJ5W3ldO1xuICAgIGFyeVt5XSA9IHRlbXA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIHdpdGhpbiB0aGUgcmFuZ2UgYGxvdyAuLiBoaWdoYCBpbmNsdXNpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsb3dcbiAgICogICAgICAgIFRoZSBsb3dlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoXG4gICAqICAgICAgICBUaGUgdXBwZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmFuZG9tSW50SW5SYW5nZShsb3csIGhpZ2gpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChsb3cgKyAoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBRdWljayBTb3J0IGFsZ29yaXRobS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gICAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gICAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwXG4gICAqICAgICAgICBTdGFydCBpbmRleCBvZiB0aGUgYXJyYXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJcbiAgICogICAgICAgIEVuZCBpbmRleCBvZiB0aGUgYXJyYXlcbiAgICovXG4gIGZ1bmN0aW9uIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcikge1xuICAgIC8vIElmIG91ciBsb3dlciBib3VuZCBpcyBsZXNzIHRoYW4gb3VyIHVwcGVyIGJvdW5kLCB3ZSAoMSkgcGFydGl0aW9uIHRoZVxuICAgIC8vIGFycmF5IGludG8gdHdvIHBpZWNlcyBhbmQgKDIpIHJlY3Vyc2Ugb24gZWFjaCBoYWxmLiBJZiBpdCBpcyBub3QsIHRoaXMgaXNcbiAgICAvLyB0aGUgZW1wdHkgYXJyYXkgYW5kIG91ciBiYXNlIGNhc2UuXG5cbiAgICBpZiAocCA8IHIpIHtcbiAgICAgIC8vICgxKSBQYXJ0aXRpb25pbmcuXG4gICAgICAvL1xuICAgICAgLy8gVGhlIHBhcnRpdGlvbmluZyBjaG9vc2VzIGEgcGl2b3QgYmV0d2VlbiBgcGAgYW5kIGByYCBhbmQgbW92ZXMgYWxsXG4gICAgICAvLyBlbGVtZW50cyB0aGF0IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90IHRvIHRoZSBiZWZvcmUgaXQsIGFuZFxuICAgICAgLy8gYWxsIHRoZSBlbGVtZW50cyB0aGF0IGFyZSBncmVhdGVyIHRoYW4gaXQgYWZ0ZXIgaXQuIFRoZSBlZmZlY3QgaXMgdGhhdFxuICAgICAgLy8gb25jZSBwYXJ0aXRpb24gaXMgZG9uZSwgdGhlIHBpdm90IGlzIGluIHRoZSBleGFjdCBwbGFjZSBpdCB3aWxsIGJlIHdoZW5cbiAgICAgIC8vIHRoZSBhcnJheSBpcyBwdXQgaW4gc29ydGVkIG9yZGVyLCBhbmQgaXQgd2lsbCBub3QgbmVlZCB0byBiZSBtb3ZlZFxuICAgICAgLy8gYWdhaW4uIFRoaXMgcnVucyBpbiBPKG4pIHRpbWUuXG5cbiAgICAgIC8vIEFsd2F5cyBjaG9vc2UgYSByYW5kb20gcGl2b3Qgc28gdGhhdCBhbiBpbnB1dCBhcnJheSB3aGljaCBpcyByZXZlcnNlXG4gICAgICAvLyBzb3J0ZWQgZG9lcyBub3QgY2F1c2UgTyhuXjIpIHJ1bm5pbmcgdGltZS5cbiAgICAgIHZhciBwaXZvdEluZGV4ID0gcmFuZG9tSW50SW5SYW5nZShwLCByKTtcbiAgICAgIHZhciBpID0gcCAtIDE7XG5cbiAgICAgIHN3YXAoYXJ5LCBwaXZvdEluZGV4LCByKTtcbiAgICAgIHZhciBwaXZvdCA9IGFyeVtyXTtcblxuICAgICAgLy8gSW1tZWRpYXRlbHkgYWZ0ZXIgYGpgIGlzIGluY3JlbWVudGVkIGluIHRoaXMgbG9vcCwgdGhlIGZvbGxvd2luZyBob2xkXG4gICAgICAvLyB0cnVlOlxuICAgICAgLy9cbiAgICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbcCAuLiBpXWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdC5cbiAgICAgIC8vXG4gICAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W2krMSAuLiBqLTFdYCBpcyBncmVhdGVyIHRoYW4gdGhlIHBpdm90LlxuICAgICAgZm9yICh2YXIgaiA9IHA7IGogPCByOyBqKyspIHtcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoYXJ5W2pdLCBwaXZvdCkgPD0gMCkge1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBzd2FwKGFyeSwgaSwgaik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dhcChhcnksIGkgKyAxLCBqKTtcbiAgICAgIHZhciBxID0gaSArIDE7XG5cbiAgICAgIC8vICgyKSBSZWN1cnNlIG9uIGVhY2ggaGFsZi5cblxuICAgICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCBxIC0gMSk7XG4gICAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHEgKyAxLCByKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU29ydCB0aGUgZ2l2ZW4gYXJyYXkgaW4tcGxhY2Ugd2l0aCB0aGUgZ2l2ZW4gY29tcGFyYXRvciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gICAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gICAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gICAqL1xuICBleHBvcnRzLnF1aWNrU29ydCA9IGZ1bmN0aW9uIChhcnksIGNvbXBhcmF0b3IpIHtcbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIDAsIGFyeS5sZW5ndGggLSAxKTtcbiAgfTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvfi9zb3VyY2UtbWFwL2xpYi9xdWljay1zb3J0LmpzXG4gKiogbW9kdWxlIGlkID0gMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbntcbiAgdmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLy8gTWF0Y2hlcyBhIFdpbmRvd3Mtc3R5bGUgYFxcclxcbmAgbmV3bGluZSBvciBhIGBcXG5gIG5ld2xpbmUgdXNlZCBieSBhbGwgb3RoZXJcbiAgLy8gb3BlcmF0aW5nIHN5c3RlbXMgdGhlc2UgZGF5cyAoY2FwdHVyaW5nIHRoZSByZXN1bHQpLlxuICB2YXIgUkVHRVhfTkVXTElORSA9IC8oXFxyP1xcbikvO1xuXG4gIC8vIE5ld2xpbmUgY2hhcmFjdGVyIGNvZGUgZm9yIGNoYXJDb2RlQXQoKSBjb21wYXJpc29uc1xuICB2YXIgTkVXTElORV9DT0RFID0gMTA7XG5cbiAgLy8gUHJpdmF0ZSBzeW1ib2wgZm9yIGlkZW50aWZ5aW5nIGBTb3VyY2VOb2RlYHMgd2hlbiBtdWx0aXBsZSB2ZXJzaW9ucyBvZlxuICAvLyB0aGUgc291cmNlLW1hcCBsaWJyYXJ5IGFyZSBsb2FkZWQuIFRoaXMgTVVTVCBOT1QgQ0hBTkdFIGFjcm9zc1xuICAvLyB2ZXJzaW9ucyFcbiAgdmFyIGlzU291cmNlTm9kZSA9IFwiJCQkaXNTb3VyY2VOb2RlJCQkXCI7XG5cbiAgLyoqXG4gICAqIFNvdXJjZU5vZGVzIHByb3ZpZGUgYSB3YXkgdG8gYWJzdHJhY3Qgb3ZlciBpbnRlcnBvbGF0aW5nL2NvbmNhdGVuYXRpbmdcbiAgICogc25pcHBldHMgb2YgZ2VuZXJhdGVkIEphdmFTY3JpcHQgc291cmNlIGNvZGUgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIGxpbmUgYW5kXG4gICAqIGNvbHVtbiBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICAgKlxuICAgKiBAcGFyYW0gYUxpbmUgVGhlIG9yaWdpbmFsIGxpbmUgbnVtYmVyLlxuICAgKiBAcGFyYW0gYUNvbHVtbiBUaGUgb3JpZ2luYWwgY29sdW1uIG51bWJlci5cbiAgICogQHBhcmFtIGFTb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSdzIGZpbGVuYW1lLlxuICAgKiBAcGFyYW0gYUNodW5rcyBPcHRpb25hbC4gQW4gYXJyYXkgb2Ygc3RyaW5ncyB3aGljaCBhcmUgc25pcHBldHMgb2ZcbiAgICogICAgICAgIGdlbmVyYXRlZCBKUywgb3Igb3RoZXIgU291cmNlTm9kZXMuXG4gICAqIEBwYXJhbSBhTmFtZSBUaGUgb3JpZ2luYWwgaWRlbnRpZmllci5cbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGUoYUxpbmUsIGFDb2x1bW4sIGFTb3VyY2UsIGFDaHVua3MsIGFOYW1lKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuc291cmNlQ29udGVudHMgPSB7fTtcbiAgICB0aGlzLmxpbmUgPSBhTGluZSA9PSBudWxsID8gbnVsbCA6IGFMaW5lO1xuICAgIHRoaXMuY29sdW1uID0gYUNvbHVtbiA9PSBudWxsID8gbnVsbCA6IGFDb2x1bW47XG4gICAgdGhpcy5zb3VyY2UgPSBhU291cmNlID09IG51bGwgPyBudWxsIDogYVNvdXJjZTtcbiAgICB0aGlzLm5hbWUgPSBhTmFtZSA9PSBudWxsID8gbnVsbCA6IGFOYW1lO1xuICAgIHRoaXNbaXNTb3VyY2VOb2RlXSA9IHRydWU7XG4gICAgaWYgKGFDaHVua3MgIT0gbnVsbCkgdGhpcy5hZGQoYUNodW5rcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFNvdXJjZU5vZGUgZnJvbSBnZW5lcmF0ZWQgY29kZSBhbmQgYSBTb3VyY2VNYXBDb25zdW1lci5cbiAgICpcbiAgICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAgZm9yIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgKiBAcGFyYW0gYVJlbGF0aXZlUGF0aCBPcHRpb25hbC4gVGhlIHBhdGggdGhhdCByZWxhdGl2ZSBzb3VyY2VzIGluIHRoZVxuICAgKiAgICAgICAgU291cmNlTWFwQ29uc3VtZXIgc2hvdWxkIGJlIHJlbGF0aXZlIHRvLlxuICAgKi9cbiAgU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9XG4gICAgZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyLCBhUmVsYXRpdmVQYXRoKSB7XG4gICAgICAvLyBUaGUgU291cmNlTm9kZSB3ZSB3YW50IHRvIGZpbGwgd2l0aCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAgIC8vIGFuZCB0aGUgU291cmNlTWFwXG4gICAgICB2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKCk7XG5cbiAgICAgIC8vIEFsbCBldmVuIGluZGljZXMgb2YgdGhpcyBhcnJheSBhcmUgb25lIGxpbmUgb2YgdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAgICAgLy8gd2hpbGUgYWxsIG9kZCBpbmRpY2VzIGFyZSB0aGUgbmV3bGluZXMgYmV0d2VlbiB0d28gYWRqYWNlbnQgbGluZXNcbiAgICAgIC8vIChzaW5jZSBgUkVHRVhfTkVXTElORWAgY2FwdHVyZXMgaXRzIG1hdGNoKS5cbiAgICAgIC8vIFByb2Nlc3NlZCBmcmFnbWVudHMgYXJlIHJlbW92ZWQgZnJvbSB0aGlzIGFycmF5LCBieSBjYWxsaW5nIGBzaGlmdE5leHRMaW5lYC5cbiAgICAgIHZhciByZW1haW5pbmdMaW5lcyA9IGFHZW5lcmF0ZWRDb2RlLnNwbGl0KFJFR0VYX05FV0xJTkUpO1xuICAgICAgdmFyIHNoaWZ0TmV4dExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxpbmVDb250ZW50cyA9IHJlbWFpbmluZ0xpbmVzLnNoaWZ0KCk7XG4gICAgICAgIC8vIFRoZSBsYXN0IGxpbmUgb2YgYSBmaWxlIG1pZ2h0IG5vdCBoYXZlIGEgbmV3bGluZS5cbiAgICAgICAgdmFyIG5ld0xpbmUgPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpIHx8IFwiXCI7XG4gICAgICAgIHJldHVybiBsaW5lQ29udGVudHMgKyBuZXdMaW5lO1xuICAgICAgfTtcblxuICAgICAgLy8gV2UgbmVlZCB0byByZW1lbWJlciB0aGUgcG9zaXRpb24gb2YgXCJyZW1haW5pbmdMaW5lc1wiXG4gICAgICB2YXIgbGFzdEdlbmVyYXRlZExpbmUgPSAxLCBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcblxuICAgICAgLy8gVGhlIGdlbmVyYXRlIFNvdXJjZU5vZGVzIHdlIG5lZWQgYSBjb2RlIHJhbmdlLlxuICAgICAgLy8gVG8gZXh0cmFjdCBpdCBjdXJyZW50IGFuZCBsYXN0IG1hcHBpbmcgaXMgdXNlZC5cbiAgICAgIC8vIEhlcmUgd2Ugc3RvcmUgdGhlIGxhc3QgbWFwcGluZy5cbiAgICAgIHZhciBsYXN0TWFwcGluZyA9IG51bGw7XG5cbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICBpZiAobGFzdE1hcHBpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBhZGQgdGhlIGNvZGUgZnJvbSBcImxhc3RNYXBwaW5nXCIgdG8gXCJtYXBwaW5nXCI6XG4gICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgIGlmIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgICAgLy8gQXNzb2NpYXRlIGZpcnN0IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgY29kZSBpcyBhZGRlZCB3aXRob3V0IG1hcHBpbmdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuICAgICAgICAgICAgLy8gXCJtYXBwaW5nLmdlbmVyYXRlZENvbHVtblwiIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgICAgIHZhciBjb2RlID0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgICAgLy8gTm8gbW9yZSByZW1haW5pbmcgY29kZSwgY29udGludWVcbiAgICAgICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgYWRkIHRoZSBnZW5lcmF0ZWQgY29kZSB1bnRpbCB0aGUgZmlyc3QgbWFwcGluZ1xuICAgICAgICAvLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuICAgICAgICAvLyBFYWNoIGxpbmUgaXMgYWRkZWQgYXMgc2VwYXJhdGUgc3RyaW5nLlxuICAgICAgICB3aGlsZSAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBub2RlLmFkZChzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRDb2x1bW4gPCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikge1xuICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgIG5vZGUuYWRkKG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikpO1xuICAgICAgICAgIHJlbWFpbmluZ0xpbmVzWzBdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgfSwgdGhpcyk7XG4gICAgICAvLyBXZSBoYXZlIHByb2Nlc3NlZCBhbGwgbWFwcGluZ3MuXG4gICAgICBpZiAocmVtYWluaW5nTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAobGFzdE1hcHBpbmcpIHtcbiAgICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIHJlbWFpbmluZyBjb2RlIGluIHRoZSBjdXJyZW50IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYW5kIGFkZCB0aGUgcmVtYWluaW5nIGxpbmVzIHdpdGhvdXQgYW55IG1hcHBpbmdcbiAgICAgICAgbm9kZS5hZGQocmVtYWluaW5nTGluZXMuam9pbihcIlwiKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnQgaW50byBTb3VyY2VOb2RlXG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoYVJlbGF0aXZlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbm9kZTtcblxuICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZ1dpdGhDb2RlKG1hcHBpbmcsIGNvZGUpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcgPT09IG51bGwgfHwgbWFwcGluZy5zb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vZGUuYWRkKGNvZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBhUmVsYXRpdmVQYXRoXG4gICAgICAgICAgICA/IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICAgIDogbWFwcGluZy5zb3VyY2U7XG4gICAgICAgICAgbm9kZS5hZGQobmV3IFNvdXJjZU5vZGUobWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGlzIHNvdXJjZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAgICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2FkZChhQ2h1bmspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgICBhQ2h1bmsuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgdGhpcy5hZGQoY2h1bmspO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChhQ2h1bmspIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgc291cmNlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICAgKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3ByZXBlbmQoYUNodW5rKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgICAgZm9yICh2YXIgaSA9IGFDaHVuay5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy5wcmVwZW5kKGFDaHVua1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4udW5zaGlmdChhQ2h1bmspO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgSlMgc25pcHBldHMgaW4gdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4uIFRoZVxuICAgKiB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmNlIGZvciBlYWNoIHNuaXBwZXQgb2YgSlMgYW5kIGlzIHBhc3NlZCB0aGF0XG4gICAqIHNuaXBwZXQgYW5kIHRoZSBpdHMgb3JpZ2luYWwgYXNzb2NpYXRlZCBzb3VyY2UncyBsaW5lL2NvbHVtbiBsb2NhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2FsayhhRm4pIHtcbiAgICB2YXIgY2h1bms7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNodW5rID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaHVua1tpc1NvdXJjZU5vZGVdKSB7XG4gICAgICAgIGNodW5rLndhbGsoYUZuKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoY2h1bmsgIT09ICcnKSB7XG4gICAgICAgICAgYUZuKGNodW5rLCB7IHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAgICogZWFjaCBvZiBgdGhpcy5jaGlsZHJlbmAuXG4gICAqXG4gICAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gU291cmNlTm9kZV9qb2luKGFTZXApIHtcbiAgICB2YXIgbmV3Q2hpbGRyZW47XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICBuZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbi0xOyBpKyspIHtcbiAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChhU2VwKTtcbiAgICAgIH1cbiAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAgICogZm9yIHRyaW1taW5nIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kIG9mIGEgc291cmNlIG5vZGUsIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSBhUmVwbGFjZW1lbnQgVGhlIHRoaW5nIHRvIHJlcGxhY2UgdGhlIHBhdHRlcm4gd2l0aC5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnJlcGxhY2VSaWdodCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpIHtcbiAgICB2YXIgbGFzdENoaWxkID0gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0Q2hpbGRbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgbGFzdENoaWxkLnJlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGxhc3RDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaCgnJy5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yXG4gICAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAgICpcbiAgICogQHBhcmFtIGFTb3VyY2VGaWxlIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcbiAgICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgICAgdGhpcy5zb3VyY2VDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKGFTb3VyY2VGaWxlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgU291cmNlTm9kZXMuIFRoZSB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgZWFjaFxuICAgKiBzb3VyY2UgZmlsZSBjb250ZW50IGFuZCBpcyBwYXNzZWQgdGhlIGZpbGVuYW1lIGFuZCBzb3VyY2UgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUud2Fsa1NvdXJjZUNvbnRlbnRzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGtTb3VyY2VDb250ZW50cyhhRm4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLndhbGtTb3VyY2VDb250ZW50cyhhRm4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VzID0gT2JqZWN0LmtleXModGhpcy5zb3VyY2VDb250ZW50cyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBhRm4odXRpbC5mcm9tU2V0U3RyaW5nKHNvdXJjZXNbaV0pLCB0aGlzLnNvdXJjZUNvbnRlbnRzW3NvdXJjZXNbaV1dKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlLiBXYWxrcyBvdmVyIHRoZSB0cmVlXG4gICAqIGFuZCBjb25jYXRlbmF0ZXMgYWxsIHRoZSB2YXJpb3VzIHNuaXBwZXRzIHRvZ2V0aGVyIHRvIG9uZSBzdHJpbmcuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmcoKSB7XG4gICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgc3RyICs9IGNodW5rO1xuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlIGFsb25nIHdpdGggYSBzb3VyY2VcbiAgICogbWFwLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmdXaXRoU291cmNlTWFwID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZ1dpdGhTb3VyY2VNYXAoYUFyZ3MpIHtcbiAgICB2YXIgZ2VuZXJhdGVkID0ge1xuICAgICAgY29kZTogXCJcIixcbiAgICAgIGxpbmU6IDEsXG4gICAgICBjb2x1bW46IDBcbiAgICB9O1xuICAgIHZhciBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKTtcbiAgICB2YXIgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgIHZhciBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgICB2YXIgbGFzdE9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgICB2YXIgbGFzdE9yaWdpbmFsTmFtZSA9IG51bGw7XG4gICAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaywgb3JpZ2luYWwpIHtcbiAgICAgIGdlbmVyYXRlZC5jb2RlICs9IGNodW5rO1xuICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPT0gbnVsbFxuICAgICAgICAgICYmIG9yaWdpbmFsLmxpbmUgIT09IG51bGxcbiAgICAgICAgICAmJiBvcmlnaW5hbC5jb2x1bW4gIT09IG51bGwpIHtcbiAgICAgICAgaWYobGFzdE9yaWdpbmFsU291cmNlICE9PSBvcmlnaW5hbC5zb3VyY2VcbiAgICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTGluZSAhPT0gb3JpZ2luYWwubGluZVxuICAgICAgICAgICB8fCBsYXN0T3JpZ2luYWxDb2x1bW4gIT09IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICB8fCBsYXN0T3JpZ2luYWxOYW1lICE9PSBvcmlnaW5hbC5uYW1lKSB7XG4gICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgbGFzdE9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICAgIGxhc3RPcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgbGFzdE9yaWdpbmFsTmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaWR4ID0gMCwgbGVuZ3RoID0gY2h1bmsubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGlmIChjaHVuay5jaGFyQ29kZUF0KGlkeCkgPT09IE5FV0xJTkVfQ09ERSkge1xuICAgICAgICAgIGdlbmVyYXRlZC5saW5lKys7XG4gICAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbiA9IDA7XG4gICAgICAgICAgLy8gTWFwcGluZ3MgZW5kIGF0IGVvbFxuICAgICAgICAgIGlmIChpZHggKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZW5lcmF0ZWQuY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLndhbGtTb3VyY2VDb250ZW50cyhmdW5jdGlvbiAoc291cmNlRmlsZSwgc291cmNlQ29udGVudCkge1xuICAgICAgbWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgc291cmNlQ29udGVudCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyBjb2RlOiBnZW5lcmF0ZWQuY29kZSwgbWFwOiBtYXAgfTtcbiAgfTtcblxuICBleHBvcnRzLlNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1ub2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIFJlZ2lvbihhLGIscm9vdCx2aWV3KXtcblx0XHR0aGlzLl9hID0gYTtcblx0XHR0aGlzLl9iID0gYjtcblx0XHR0aGlzLl9yb290ID0gcm9vdDtcblx0XHR0aGlzLl92aWV3ID0gdmlldztcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdGV4cG9ydHMuUmVnaW9uID0gUmVnaW9uOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5hID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9hOyB9XG5cdFJlZ2lvbi5wcm90b3R5cGUuc2V0QSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9hID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5iID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9iOyB9XG5cdFJlZ2lvbi5wcm90b3R5cGUuc2V0QiA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9iID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0UmVnaW9uLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdFJlZ2lvbi5wcm90b3R5cGUuc2V0VmlldyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92aWV3ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yb290OyB9XG5cdFJlZ2lvbi5wcm90b3R5cGUuc2V0Um9vdCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9yb290ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHQvLyByZW1vdmUgcm9vdCBmcm9tIHJlZ2lvblxuXHRcblx0UmVnaW9uLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh2YWwsdmlldyl7XG5cdFx0dmFyIGxpbmVfO1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBSZWdpb24pIHsgcmV0dXJuIHZhbCB9O1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheSkgeyByZXR1cm4gbmV3IFJlZ2lvbih2YWxbMF0sdmFsWzFdLG51bGwsdmlldykgfTtcblx0XHRpZiAoKHR5cGVvZiB2YWw9PSdudW1iZXInfHx2YWwgaW5zdGFuY2VvZiBOdW1iZXIpKSB7IHJldHVybiBuZXcgUmVnaW9uKHZhbCx2YWwsbnVsbCx2aWV3KSB9O1xuXHRcdFxuXHRcdGlmICgodmFsIGluc3RhbmNlb2YgT2JqZWN0KSAmJiAodHlwZW9mIChsaW5lXyA9IHZhbC5saW5lKT09J251bWJlcid8fGxpbmVfIGluc3RhbmNlb2YgTnVtYmVyKSkge1xuXHRcdFx0dmFyIGxpbmVzID0gdmlldy5fYnVmZmVyLmxpbmVzKCk7XG5cdFx0XHR2YXIgbG9jID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChsaW5lcyksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRpZiAoaSA8ICh2YWwubGluZSAtIDEpKSB7XG5cdFx0XHRcdFx0bG9jICs9IGFyeVtpXS5sZW5ndGggKyAxO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0bG9jICs9ICh2YWwuY29sdW1uIHx8IDApO1xuXHRcdFx0cmV0dXJuIG5ldyBSZWdpb24obG9jLGxvYyxudWxsLHZpZXcpO1xuXHRcdH07XG5cdH07XG5cdFxuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBNYXRoLm1pbih0aGlzLl9hLHRoaXMuX2IpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gTWF0aC5tYXgodGhpcy5fYSx0aGlzLl9iKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoYWQsYmQpe1xuXHRcdGlmKGFkID09PSB1bmRlZmluZWQpIGFkID0gMDtcblx0XHRpZihiZCA9PT0gdW5kZWZpbmVkKSBiZCA9IDA7XG5cdFx0cmV0dXJuIG5ldyBSZWdpb24odGhpcy5fYSArIGFkLHRoaXMuX2IgKyBiZCx0aGlzLl9yb290LHRoaXMuX3ZpZXcpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChyZWwpe1xuXHRcdGlmIChyZWwgaW5zdGFuY2VvZiBSZWdpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLnN0YXJ0KCkgPD0gcmVsLnN0YXJ0KCkgJiYgdGhpcy5lbmQoKSA+PSByZWwuZW5kKCk7XG5cdFx0fSBlbHNlIGlmICgodHlwZW9mIHJlbD09J251bWJlcid8fHJlbCBpbnN0YW5jZW9mIE51bWJlcikpIHtcblx0XHRcdHJldHVybiB0aGlzLnN0YXJ0KCkgPD0gcmVsICYmIHRoaXMuZW5kKCkgPj0gcmVsO1xuXHRcdH07XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmFkanVzdCA9IGZ1bmN0aW9uIChyZWwsYWRkKXtcblx0XHRpZihhZGQgPT09IHVuZGVmaW5lZCkgYWRkID0gdHJ1ZTtcblx0XHRpZiAocmVsLmVuZCgpIDwgdGhpcy5zdGFydCgpKSB7XG5cdFx0XHRhZGQgPyAodGhpcy5tb3ZlKHJlbC5zaXplKCkpKSA6ICh0aGlzLm1vdmUoLXJlbC5zaXplKCkpKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24gKHJlbCl7XG5cdFx0Ly8gaXMgdGhpcyBkZWNlbnQ/XG5cdFx0cmVsID0gUmVnaW9uLm5vcm1hbGl6ZShyZWwpO1xuXHRcdHZhciBhID0gTWF0aC5tYXgodGhpcy5zdGFydCgpLHJlbC5zdGFydCgpKTtcblx0XHR2YXIgYiA9IE1hdGgubWluKHRoaXMuZW5kKCkscmVsLmVuZCgpKTtcblx0XHRyZXR1cm4gYiA+PSBhO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5yZWxhdGl2ZVRvID0gZnVuY3Rpb24gKHJlbCl7XG5cdFx0Ly8gY291bGQgdXNlIG1vdmUgaW5zdGVhZFxuXHRcdHJldHVybiBuZXcgUmVnaW9uKHRoaXMuX2EgLSByZWwuc3RhcnQoKSx0aGlzLl9iIC0gcmVsLnN0YXJ0KCksdGhpcy5fcm9vdCx0aGlzLl92aWV3KTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKHJlZ2lvbil7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChyZWdpb24pe1xuXHRcdHJldHVybiB0aGlzLnN0YXJ0KCkgPT0gcmVnaW9uLnN0YXJ0KCkgJiYgdGhpcy5lbmQoKSA9PSByZWdpb24uZW5kKCk7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnNhbWUgPSBmdW5jdGlvbiAocmVnaW9uKXtcblx0XHRyZXR1cm4gcmVnaW9uICYmIHJlZ2lvbi5hKCkgPT0gdGhpcy5hKCkgJiYgcmVnaW9uLmIoKSA9PSB0aGlzLmIoKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLmVuZCgpIC0gdGhpcy5zdGFydCgpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKG51bSl7XG5cdFx0aWYobnVtID09PSB1bmRlZmluZWQpIG51bSA9IDE7XG5cdFx0dGhpcy5fYSArPSBudW07XG5cdFx0dGhpcy5fYiArPSBudW07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLmNvbGxhcHNlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnNpemUoKSA9PSAwO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGEgPSB0aGlzLl9hLGIgPSB0aGlzLl9iO1xuXHRcdHRoaXMuX2EgPSBiO1xuXHRcdHRoaXMuX2IgPSBhO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5yZXZlcnNlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9hID4gdGhpcy5fYjtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGEgPSB0aGlzLnN0YXJ0KCk7XG5cdFx0dmFyIGIgPSB0aGlzLmVuZCgpO1xuXHRcdHRoaXMuX2EgPSBhO1xuXHRcdHRoaXMuX2IgPSBiO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5jb2xsYXBzZSA9IGZ1bmN0aW9uIChmb3J3YXJkKXtcblx0XHRpZihmb3J3YXJkID09PSB1bmRlZmluZWQpIGZvcndhcmQgPSB0cnVlO1xuXHRcdGlmIChmb3J3YXJkKSB7XG5cdFx0XHR0aGlzLl9hID0gdGhpcy5fYiA9IHRoaXMuZW5kKCk7XG5cdFx0XHQvLyBAYSA9IEBiXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2IgPSB0aGlzLl9hO1xuXHRcdFx0dGhpcy5fYSA9IHRoaXMuX2IgPSB0aGlzLnN0YXJ0KCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIGV4cGFuZCB0byBjbG9zZXN0IC9uXG5cdFJlZ2lvbi5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24gKGF0U3RhcnQsYXRFbmQpe1xuXHRcdGlmICh0aGlzLmIoKSA8IHRoaXMuYSgpKSB7XG5cdFx0XHR0aGlzLl9iICs9IGF0U3RhcnQ7XG5cdFx0XHR0aGlzLl9hICs9IGF0RW5kO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9hICs9IGF0U3RhcnQ7XG5cdFx0XHR0aGlzLl9iICs9IGF0RW5kO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy52aWV3KCkuc3Vic3RyKHRoaXMpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiAoXCJbXCIgKyAodGhpcy5fYSkgKyBcIixcIiArICh0aGlzLl9iKSArIFwiXVwiKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5ub2RlcyA9IGZ1bmN0aW9uIChpbmNsdWRlRW5kcyl7XG5cdFx0aWYoaW5jbHVkZUVuZHMgPT09IHVuZGVmaW5lZCkgaW5jbHVkZUVuZHMgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzLnZpZXcoKS5ub2Rlc0luUmVnaW9uKHRoaXMsaW5jbHVkZUVuZHMpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5wcmV2Tm9kZSA9IGZ1bmN0aW9uIChxdWVyeSl7XG5cdFx0dmFyIG5vZGVzID0gdGhpcy5ub2RlcyhmYWxzZSk7XG5cdFx0dmFyIG5vZGUgPSBub2Rlcy5sZnQ7XG5cdFx0aWYgKChxdWVyeSBpbnN0YW5jZW9mIEltYmEuU2VsZWN0b3IpIHx8ICh0eXBlb2YgcXVlcnk9PSdzdHJpbmcnfHxxdWVyeSBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdHZhciAkMTt3aGlsZSAobm9kZSl7XG5cdFx0XHRcdGlmIChub2RlLm1hdGNoZXMocXVlcnkpKSB7IHJldHVybiBub2RlIH07XG5cdFx0XHRcdG5vZGUgPSAoJDEgPSBub2RlKSAmJiAkMS5pc0xhc3QgICYmICAkMS5pc0xhc3QoKSA/IChub2RlLnBhcmVudCgpKSA6IChudWxsKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdHJldHVybiBub2RlO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5uZXh0Tm9kZSA9IGZ1bmN0aW9uIChxdWVyeSl7XG5cdFx0dmFyIG5vZGVzID0gdGhpcy5ub2RlcyhmYWxzZSk7XG5cdFx0dmFyIG5vZGUgPSBub2Rlcy5yZ3Q7XG5cdFx0aWYgKChxdWVyeSBpbnN0YW5jZW9mIEltYmEuU2VsZWN0b3IpIHx8ICh0eXBlb2YgcXVlcnk9PSdzdHJpbmcnfHxxdWVyeSBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdHZhciAkMTt3aGlsZSAobm9kZSl7XG5cdFx0XHRcdGlmIChub2RlLm1hdGNoZXMocXVlcnkpKSB7IHJldHVybiBub2RlIH07XG5cdFx0XHRcdG5vZGUgPSAoJDEgPSBub2RlKSAmJiAkMS5pc0ZpcnN0ICAmJiAgJDEuaXNGaXJzdCgpID8gKG5vZGUucGFyZW50KCkpIDogKG51bGwpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnNjb3BlID0gZnVuY3Rpb24gKHF1ZXJ5KXtcblx0XHR2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKGZhbHNlKTtcblx0XHR2YXIgbm9kZTtcblx0XHRpZiAobm9kZXMubGZ0KSB7XG5cdFx0XHRub2RlID0gbm9kZXMubGZ0LnVwKHF1ZXJ5KTtcblx0XHR9IGVsc2UgaWYgKG5vZGVzLnJndCkge1xuXHRcdFx0bm9kZSB8fCAobm9kZSA9IG5vZGVzLnJndC51cChxdWVyeSkpO1xuXHRcdH0gZWxzZSBpZiAobm9kZXNbMF0pIHtcblx0XHRcdG5vZGUgfHwgKG5vZGUgPSBub2Rlc1swXS5ub2RlLmNsb3Nlc3QocXVlcnkpKTtcblx0XHR9O1xuXHRcdHJldHVybiBub2RlO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5idWZmZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fcm9vdC5jb2RlKCk7XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnN0YXJ0QXRMaW5lID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5ub3JtYWxpemUoKTtcblx0XHR2YXIgYnVmZmVyID0gdGhpcy5idWZmZXIoKTtcblx0XHR2YXIgYSA9IHRoaXMuc3RhcnQoKTtcblx0XHRcblx0XHRpZiAoYnVmZmVyW2FdID09ICdcXG4nICYmIHRoaXMuc2l6ZSgpID09IDApIHtcblx0XHRcdGEtLTsgLy8gaWYgd2UgYXJlIGF0IHRoZSBlbmQgb2YgYSBsaW5lXG5cdFx0fTtcblx0XHRcblx0XHR3aGlsZSAoYSA+PSAwICYmIGJ1ZmZlclthXSAhPSAnXFxuJyl7XG5cdFx0XHRhLS07XG5cdFx0fTtcblx0XHR0aGlzLl9hID0gYTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuZW5kQXRMaW5lID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5ub3JtYWxpemUoKTtcblx0XHR2YXIgYnVmZmVyID0gdGhpcy5idWZmZXIoKTtcblx0XHR2YXIgYiA9ICh0aGlzLmVuZCgpIC0gMSk7XG5cdFx0d2hpbGUgKGIgPj0gMCAmJiBidWZmZXJbYl0gJiYgYnVmZmVyW2JdICE9ICdcXG4nKXtcblx0XHRcdGIrKztcblx0XHR9O1xuXHRcdHRoaXMuX2IgPSBiO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5jZWxsID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMudmlldygpLl9idWZmZXIubG9jVG9DZWxsKHRoaXMuYSgpKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUucm93ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuY2VsbCgpWzBdO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5jb2wgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5jZWxsKClbMV07XG5cdH07XG5cdFxuXHRSZWdpb24ucHJvdG90eXBlLnBlZWtiZWhpbmQgPSBmdW5jdGlvbiAobGVuKXtcblx0XHRpZihsZW4gPT09IHVuZGVmaW5lZCkgbGVuID0gMTtcblx0XHRyZXR1cm4gbGVuID09IDEgPyAodGhpcy5idWZmZXIoKVt0aGlzLnN0YXJ0KCkgLSAxXSkgOiAodGhpcy5idWZmZXIoKS5zdWJzdHJpbmcodGhpcy5zdGFydCgpIC0gbGVuLHRoaXMuc3RhcnQoKSkpO1xuXHR9O1xuXHRcblx0UmVnaW9uLnByb3RvdHlwZS5wZWVrYWhlYWQgPSBmdW5jdGlvbiAobGVuKXtcblx0XHRpZihsZW4gPT09IHVuZGVmaW5lZCkgbGVuID0gMTtcblx0XHRyZXR1cm4gbGVuID09IDEgPyAodGhpcy5idWZmZXIoKVt0aGlzLmVuZCgpXSkgOiAodGhpcy5idWZmZXIoKS5zdWJzdHIodGhpcy5lbmQoKSxsZW4pKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUuaW5kZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydEF0TGluZSgpLnRleHQoKS5tYXRjaCgvXlxcbj8oXFx0KikvKVsxXTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uIChiZWZvcmUsYWZ0ZXIpe1xuXHRcdGlmKGJlZm9yZSA9PT0gdW5kZWZpbmVkKSBiZWZvcmUgPSAwO1xuXHRcdGlmKGFmdGVyID09PSB1bmRlZmluZWQpIGFmdGVyID0gMDtcblx0XHRyZXR1cm4gdGhpcy5jbG9uZShiZWZvcmUsYWZ0ZXIpLnRleHQoKTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUubGxvYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB7c3RhcnRMaW5lOiAwLHN0YXJ0Q29sOiAyfTtcblx0fTtcblx0XG5cdFJlZ2lvbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFt0aGlzLmEoKSx0aGlzLmIoKV07XG5cdH07XG5cdHJldHVybiBSZWdpb247XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9yZWdpb24uaW1iYVxuICoqIG1vZHVsZSBpZCA9IDI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0XG5cdFxuXHR2YXIgS0VZV09SRFMgPSAndmFyIGlmIGVsaWYgZWxzZSBmb3Igd2hpbGUgZGVmIGluIGlzYSB3aGlsZSB1bnRpbCBzd2l0Y2ggd2hlbiB0aGVuIHJldHVybiBjbGFzcyB0YWcgbGV0IGRvIGFuZCBvciBwcm9wIGF0dHIgaW4gcHJvcCcuc3BsaXQoJyAnKTtcblx0dmFyIE9QUyA9ICcrIC0gKiAvID0gKysgLS0gPT0gPT09ICE9ICE9PSA+IDwgPj0gPD0gJiAmJiB8IHx8IG9yIC4gOiA/Jy5zcGxpdCgnICcpO1xuXHRcblx0dmFyIFdISVRFU1BBQ0UgPSAvXlsgXFx0XFxuXSskLztcblx0XG5cdElNLkhMID0ge1xuXHRcdG5ld2xpbmU6IFwiPGIgY2xhc3M9J19pbW5ld2xpbmUnPlxcbjwvYj5cIixcblx0XHRzcGFjZTogZnVuY3Rpb24obSkgeyByZXR1cm4gKFwiPGIgY2xhc3M9J19pbXNwYWNlJz5cIiArIG0gKyBcIjwvYj5cIik7IH0sXG5cdFx0dGFiOiBmdW5jdGlvbihtKSB7IHJldHVybiBuZXcgQXJyYXkobS5sZW5ndGggKyAxKS5qb2luKFwiPGIgY2xhc3M9J19pbXRhYic+XFx0PC9iPlwiKTsgfVxuXHR9O1xuXHRcblx0XG5cdHZhciBSZWdpb24gPSByZXF1aXJlKCcuL3JlZ2lvbicpLlJlZ2lvbjtcblx0dmFyIEhpZ2hsaWdodGVyID0gcmVxdWlyZSgnLi9jb3JlL2hpZ2hsaWdodGVyJykuSGlnaGxpZ2h0ZXI7XG5cdFxuXHR2YXIgTUFUQ0hFUlMgPSB7XG5cdFx0a2V5d29yZDogZnVuY3Rpb24odikgeyByZXR1cm4gS0VZV09SRFMuaW5kZXhPZih2KSA+PSAwOyB9LFxuXHRcdHNlbGY6IC9eKHRoaXN8c2VsZikkLyxcblx0XHRjb25zdDogZnVuY3Rpb24odikgeyByZXR1cm4gKC9eW0EtWl1bXFx3XFxfXSokLykudGVzdCh2KTsgfSxcblx0XHRpdmFyOiBmdW5jdGlvbih2KSB7IHJldHVybiAoL15AW1xcd1xcX10rJC8pLnRlc3Qodik7IH0sXG5cdFx0Ym9vbDogZnVuY3Rpb24odikgeyByZXR1cm4gKC9eKHRydWV8eWVzfGZhbHNlfG5vfG51bGx8dW5kZWZpbmVkKSQvKS50ZXN0KHYpOyB9LFxuXHRcdGlkZW50aWZpZXI6IC9eW1xcJGEtel9dW1xcd1xcX1xcJF0qKFxcLVtcXCRcXHdcXF9dKykqJC8sXG5cdFx0ZmxvYXQ6IC9eXFxkK1xcLlxcZCskLyxcblx0XHRpbnQ6IC9eXFxkKyQvLFxuXHRcdGNvbW1lbnQ6IC9eXFwjKFsgXFx0XVteXFxuXSopPyQvXG5cdH07XG5cdFxuXHR2YXIgTU9ERVMgPSB7XG5cdFx0YWxsOiBPYmplY3Qua2V5cyhNQVRDSEVSUylcblx0fTtcblx0XG5cdFxuXHRcdFxuXHRcdFN0cmluZy5wcm90b3R5cGUucmVwZWF0ID0gZnVuY3Rpb24gKG51bSl7XG5cdFx0XHRyZXR1cm4gbmV3IEFycmF5KG51bSArIDEpLmpvaW4odGhpcyk7XG5cdFx0fTtcblx0XHRcblx0XHRTdHJpbmcucHJvdG90eXBlLmlucyA9IGZ1bmN0aW9uIChzdHIscmVnaW9uKXtcblx0XHRcdHZhciB0ZXh0ID0gdGhpcy50b1N0cmluZygpO1xuXHRcdFx0aWYgKHJlZ2lvbiA9PSAnYXBwZW5kJykge1xuXHRcdFx0XHRyZXR1cm4gdGV4dCArIHN0cjtcblx0XHRcdH0gZWxzZSBpZiAocmVnaW9uID09ICdwcmVwZW5kJykge1xuXHRcdFx0XHRyZXR1cm4gXCJcIiArIHN0ciArIHRleHQ7XG5cdFx0XHR9IGVsc2UgaWYgKHJlZ2lvbiBpbnN0YW5jZW9mIFJlZ2lvbikge1xuXHRcdFx0XHRyZXR1cm4gdGV4dC5zdWJzdHIoMCxyZWdpb24uc3RhcnQoKSkgKyBzdHIgKyB0ZXh0LnNsaWNlKHJlZ2lvbi5lbmQoKSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKHN0cil7XG5cdFx0cmV0dXJuIFdISVRFU1BBQ0UudGVzdChzdHIpO1xuXHR9OyBleHBvcnRzLmlzV2hpdGVzcGFjZSA9IGlzV2hpdGVzcGFjZTtcblx0XG5cdElNLm51bSA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdHJldHVybiB0YWckLiRpbW51bSgpLmZsYWcoJ251bWJlcicpLnNldFRleHQodmFsKS5lbmQoKTtcblx0fTtcblx0XG5cdElNLnRhYiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0YWckLiRpbXRhYigpLnNldFRleHQoJ1xcdCcpLmVuZCgpO1xuXHR9O1xuXHRcblx0SU0ubmV3bGluZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0YWckLiRpbW5ld2xpbmUoKS5zZXRUZXh0KCdcXG4nKS5lbmQoKTtcblx0fTtcblx0XG5cdElNLm9wID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0cmV0dXJuIHRhZyQuJGltb3AoKS5mbGFnKCdvcCcpLnNldFRleHQodmFsKS5lbmQoKTtcblx0fTtcblx0XG5cdFxuXHRJTS50b2sgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRpZiAodmFsICYmIHZhbC5fZG9tKSB7IHJldHVybiB2YWwgfTtcblx0XHRpZiAodmFsLm1hdGNoKFdISVRFU1BBQ0UpKSB7IHJldHVybiBJTS5wYXJzZVdoaXRlc3BhY2UodmFsKSB9O1xuXHRcdGlmIChPUFMuaW5kZXhPZih2YWwpID49IDApIHsgcmV0dXJuIElNLm9wKHZhbCkgfTsgLy8gc2hvdWxkIHVzZSB0b2tlbiBkaXJlY3RseVxuXHRcdC8vIHJldHVybiBJTS5udW0odmFsKSBpZiB2YWwubWF0Y2goL15cXGQrKFxcLlxcZCspPyQvKSAjIHNob3VsZCB1c2UgdG9rZW4gZGlyZWN0bHlcblx0XHRyZXR1cm4gdGFnJC4kaW10b2soKS5zZXRUZXh0KHZhbCkuZW5kKCk7XG5cdH07XG5cdFxuXHRJTS5yYXcgPSBmdW5jdGlvbiAodmFsLGN0eCl7XG5cdFx0cmV0dXJuIHRhZyQuJGltcmF3KCkuc2V0UmF3KHZhbCkuZW5kKCk7XG5cdH07XG5cdFxuXHRJTS5pc1doaXRlc3BhY2UgPSBmdW5jdGlvbiAodmFsKXtcblx0XHRyZXR1cm4gV0hJVEVTUEFDRS50ZXN0KHZhbCk7XG5cdH07XG5cdFxuXHRJTS5pc09wID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0cmV0dXJuIE9QUy5pbmRleE9mKHZhbCkgPj0gMDtcblx0fTtcblx0XG5cdElNLnBhcnNlV2hpdGVzcGFjZSA9IGZ1bmN0aW9uICh0ZXh0LHJpY2gpe1xuXHRcdGlmKHJpY2ggPT09IHVuZGVmaW5lZCkgcmljaCA9IHRydWU7XG5cdFx0dmFyIGhsID0gSU0uSEw7XG5cdFx0XG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvKFxcbnxbIF0rfFtcXHRdKykvZyxmdW5jdGlvbihtLGwpIHtcblx0XHRcdGlmIChsID09ICdcXG4nKSB7XG5cdFx0XHRcdHJldHVybiBobC5uZXdsaW5lIHx8ICdcXG4nO1xuXHRcdFx0fSBlbHNlIGlmIChsWzBdID09ICcgJykge1xuXHRcdFx0XHRyZXR1cm4gaGwuc3BhY2UgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IChobC5zcGFjZShsKSkgOiAobCk7XG5cdFx0XHR9IGVsc2UgaWYgKGxbMF0gPT0gJ1xcdCcpIHtcblx0XHRcdFx0cmV0dXJuIGhsLnRhYiBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gKGhsLnRhYihsKSkgOiAobCk7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHRcdFxuXHRcdGlmIChyaWNoICYmIHRleHQuaW5kZXhPZignPCcpID49IDApIHtcblx0XHRcdHJldHVybiB0YWckLiRpbWZyYWdtZW50KCkuc2V0Q29udGVudCh0ZXh0LDApLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRleHQ7XG5cdH07XG5cdFxuXHRJTS5pZGVudGlmeSA9IGZ1bmN0aW9uICh2YWwsbW9kZSl7XG5cdFx0aWYobW9kZSA9PT0gdW5kZWZpbmVkKSBtb2RlID0gJ2FsbCc7XG5cdFx0dmFyIHJ1bGVzID0gTU9ERVNbbW9kZV07XG5cdFx0dmFyIHJlcztcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQocnVsZXMpLCBsZW4gPSBhcnkubGVuZ3RoLCBuYW1lOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdG5hbWUgPSBhcnlbaV07XG5cdFx0XHR2YXIgcnVsZSA9IE1BVENIRVJTW25hbWVdO1xuXHRcdFx0XG5cdFx0XHRpZiAocnVsZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRcdHJlcyA9IHJ1bGUodmFsLG1vZGUpO1xuXHRcdFx0fSBlbHNlIGlmIChydWxlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdFx0XHRcdHJlcyA9IHJ1bGUudGVzdCh2YWwpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHJlcykge1xuXHRcdFx0XHRyZXR1cm4gcmVzID09PSB0cnVlID8gKG5hbWUpIDogKHJlcyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cdFxuXHRJTS5wYXJzZSA9IGZ1bmN0aW9uIChjb2RlLGNvbnRleHQpe1xuXHRcdC8vIGRlY2lkZSBpZiBmdWxsP1xuXHRcdC8vIGNvbnNvbGUubG9nIFwicGFyc2UgY29kZSB7Y29kZTpsZW5ndGh9IHtjb2RlLnN1YnN0cigwLDIwKX1cIlxuXHRcdGlmICh0eXBlb2YgY29kZSAhPSAnc3RyaW5nJykgeyByZXR1cm4gY29kZSB9O1xuXHRcdFxuXHRcdGlmIChXSElURVNQQUNFLnRlc3QoY29kZSkpIHtcblx0XHRcdHJldHVybiBJTS5wYXJzZVdoaXRlc3BhY2UoY29kZSxmYWxzZSk7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgd3MgPSBjb2RlLm1hdGNoKC9eKFsgXFx0XSopKFteXSo/KShbIFxcdF0qKSQvKSB8fCBbJycsJycsY29kZSwnJ107XG5cdFx0dmFyIGhsO1xuXHRcdFxuXHRcdGlmICh3c1sxXSB8fCB3c1szXSkge1xuXHRcdFx0Y29kZSA9IHdzWzJdO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGlkID0gSU0uaWRlbnRpZnkoY29kZSk7XG5cdFx0XG5cdFx0aWYgKGlkKSB7XG5cdFx0XHR2YXIgdHlwID0gJ3NwYW4nO1xuXHRcdFx0dmFyIGNscyA9IEhpZ2hsaWdodGVyLk1hcHBpbmdbaWRdIHx8IGlkOyAvLyB0aGlzIGlzIHRoZSBpc3N1ZSwgbm8/XG5cdFx0XHRcblx0XHRcdGlmIChjbHMgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHR0eXAgPSBjbHNbMF07XG5cdFx0XHRcdGNscyA9IGNsc1sxXTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICghY2xzLm1hdGNoKC9cXGJfW1xcd10vKSkgeyBjbHMgPSAnX2ltdG9rICcgKyBjbHMgfTtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdwYXJzZWQgYXMgdHlwZScsaWQsY2xzXG5cdFx0XHRobCA9ICc8JyArIHR5cCArICcgY2xhc3M9XCInICsgY2xzICsgJ1wiPicgKyBjb2RlICsgJzwvJyArIHR5cCArICc+Jztcblx0XHR9O1xuXHRcdFxuXHRcdGlmICghaGwpIHtcblx0XHRcdGhsID0gSGlnaGxpZ2h0ZXIuaGlnaGxpZ2h0KGNvZGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHdzKSB7XG5cdFx0XHRobCA9IElNLnBhcnNlV2hpdGVzcGFjZSh3c1sxXSxmYWxzZSkgKyBobCArIElNLnBhcnNlV2hpdGVzcGFjZSh3c1szXSxmYWxzZSk7XG5cdFx0fTtcblx0XHRpZiAoaGwpIHtcblx0XHRcdHJldHVybiBobDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGNvZGU7XG5cdFx0fTtcblx0fTtcblx0XG5cdFxuXHRyZXR1cm4gSU0udGV4dE5vZGVzID0gZnVuY3Rpb24gKHJvb3QsbWFyayl7XG5cdFx0Ly8gY29uc29sZS50aW1lKCd0ZXh0Tm9kZXMyJylcblx0XHRpZihtYXJrID09PSB1bmRlZmluZWQpIG1hcmsgPSBmYWxzZTtcblx0XHRyb290ID0gcm9vdC5fZG9tIHx8IHJvb3Q7XG5cdFx0dmFyIGVsO1xuXHRcdHZhciBub2RlcyA9IFtdO1xuXHRcdHZhciBwb3MgPSAwO1xuXHRcdHZhciB3YWxrID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihyb290LE5vZGVGaWx0ZXIuU0hPV19URVhULG51bGwsZmFsc2UpO1xuXHRcdFxuXHRcdHdoaWxlIChlbCA9IHdhbGsubmV4dE5vZGUoKSl7XG5cdFx0XHRpZiAobWFyaykge1xuXHRcdFx0XHR2YXIgbGVuID0gZWwubGVuZ3RoO1xuXHRcdFx0XHRlbC5fbG9jID0gcG9zO1xuXHRcdFx0XHRwb3MgKz0gbGVuO1xuXHRcdFx0fTtcblx0XHRcdG5vZGVzLnB1c2goZWwpO1xuXHRcdH07XG5cdFx0cmV0dXJuIG5vZGVzO1xuXHR9O1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvaGVscGVycy5pbWJhXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHRcblx0Ly8gdmFyIGltYmFjID0gZ2xvYmFsLkltYmFjXG5cdHZhciBMZXhlciA9IHJlcXVpcmUoJ2ltYmEvc3JjL2NvbXBpbGVyL2xleGVyJykuTGV4ZXI7XG5cdFxuXHR2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXHRcblx0dmFyIE5PREVUWVBFID0gJ2InO1xuXHR2YXIgS0VZV09SRFMgPSBbXG5cdFx0J251bGwnLCd0aGlzJyxcblx0XHQnZGVsZXRlJywndHlwZW9mJywnaW4nLCdpbnN0YW5jZW9mJyxcblx0XHQndGhyb3cnLCdicmVhaycsJ2NvbnRpbnVlJywnZGVidWdnZXInLFxuXHRcdCdpZicsJ2Vsc2UnLCdzd2l0Y2gnLCdmb3InLCd3aGlsZScsJ2RvJywndHJ5JywnY2F0Y2gnLCdmaW5hbGx5Jyxcblx0XHQnY2xhc3MnLCdleHRlbmRzJywnc3VwZXInLCdyZXR1cm4nLFxuXHRcdCd1bmRlZmluZWQnLCd0aGVuJywndW5sZXNzJywndW50aWwnLCdsb29wJywnb2YnLCdieScsXG5cdFx0J3doZW4nLCdkZWYnLCd0YWcnLCdkbycsJ2VsaWYnLCdiZWdpbicsJ3ZhcicsJ2xldCcsJ3NlbGYnLCdhd2FpdCcsJ2ltcG9ydCcsXG5cdFx0J2FuZCcsJ29yJywnaXMnLCdpc250Jywnbm90JywnaXNhJywnY2FzZScsJ25pbCdcblx0XTtcblx0XG5cdHZhciBjbGFzc2VzID0ge1xuXHRcdCcrJzogJ19pbW9wIG9wIGFkZCBtYXRoJyxcblx0XHQnKysnOiAnX2ltb3Agb3AgaW5jciBtYXRoJyxcblx0XHQnLS0nOiAnX2ltb3Agb3AgZGVjciBtYXRoJyxcblx0XHQnLSc6ICdfaW1vcCBvcCBzdWIgbWF0aCcsXG5cdFx0Jz0nOiAnX2ltb3Agb3AgZXEnLFxuXHRcdCcvJzogJ19pbW9wIG9wIGRpdiBtYXRoJyxcblx0XHQnKic6ICdfaW1vcCBvcCBtdWx0IG1hdGgnLFxuXHRcdCc/JzogJ19pbW9wIG9wIHRlcm5hcnknLFxuXHRcdCcsJzogJ19pbW9wIG9wIGNvbW1hJyxcblx0XHQnOic6ICdfaW1vcCBvcCBjb2xvbicsXG5cdFx0Jy4nOiAnX2ltb3Agb3AgZG90Jyxcblx0XHQnLjonOiAnX2ltb3Agb3AgY2RvdCcsXG5cdFx0JyEnOiAnX2ltb3Agb3AgdW5hcnknLFxuXHRcdCc/Lic6ICdfaW1vcCBvcCBxZG90Jyxcblx0XHQnWyc6ICdfaW1vcGVuIHNiIHNibCcsXG5cdFx0J10nOiAnX2ltY2xvc2Ugc2Igc2JyJyxcblx0XHQnKCc6ICdfaW1vcGVuIHJiIHJibCcsXG5cdFx0JyknOiAnX2ltY2xvc2UgcmIgcmJyJyxcblx0XHQneyc6ICdfaW1vcGVuIGNiIGNibCcsXG5cdFx0J30nOiAnX2ltY2xvc2UgY2IgY2JyJyxcblx0XHQnIyc6ICdfaW1vcCBvcCBoYXNoJyxcblx0XHQnY2FsbF9zdGFydCc6ICdfaW1vcGVuIGNhbGwgcmIgcmJsJyxcblx0XHQnY2FsbF9lbmQnOiAnX2ltY2xvc2UgY2FsbCByYiByYnInLFxuXHRcdCd0YWdfc3RhcnQnOiAnX2ltb3BlbiB0YWdfb3BlbicsXG5cdFx0J3RhZ19lbmQnOiAnX2ltY2xvc2UgdGFnX2Nsb3NlJyxcblx0XHRcblx0XHQndHJ1ZSc6ICdfaW1ib29sIHRydWUnLFxuXHRcdCd5ZXMnOiAnX2ltYm9vbCB0cnVlJyxcblx0XHQnZmFsc2UnOiAnX2ltYm9vbCBmYWxzZScsXG5cdFx0J25vJzogJ19pbWJvb2wgZmFsc2UnLFxuXHRcdFxuXHRcdCd7eyc6ICdfaW1vcGVuJyxcblx0XHQnfX0nOiAnX2ltY2xvc2UnLFxuXHRcdFxuXHRcdCdcIic6ICdkb3VibGVxdW90ZScsXG5cdFx0XCInXCI6ICdzaW5nbGVxdW90ZScsXG5cdFx0XG5cdFx0J3JlZ2V4JzogJ19pbXJlZ2V4IHJlZ2V4Jyxcblx0XHQnaWRlbnRpZmllcic6ICdfaW10b2sgX2ltaWRlbnRpZmllciBpZGVudGlmaWVyJyxcblx0XHRcblx0XHQnY29tcG91bmRfYXNzaWduJzogJ29wIGFzc2lnbiBjb21wb3VuZCcsXG5cdFx0J3N0cic6ICdfaW1zdHIgc3RyaW5nJyxcblx0XHQnbnVtJzogJ19pbW51bSBudW1iZXInLFxuXHRcdCdzdHJpbmcnOiAnX2ltc3RyIHN0cmluZycsXG5cdFx0J251bWJlcic6ICdfaW1udW0gbnVtYmVyJyxcblx0XHQnbWF0aCc6ICdfaW1vcCBvcCBtYXRoJyxcblx0XHQndW5hcnknOiAnX2ltb3Agb3AgdW5hcnknLFxuXHRcdCdmb3Jpbic6ICdrZXl3b3JkIGluJyxcblx0XHQnZm9yb2YnOiAna2V5d29yZCBvZicsXG5cdFx0J293bic6ICdrZXl3b3JkIG93bicsXG5cdFx0J2NvbXBhcmUnOiAnX2ltb3Agb3AgY29tcGFyZScsXG5cdFx0J2hlcmVjb21tZW50JzogJ19oZXJlY29tbWVudCcsXG5cdFx0J3JlbGF0aW9uJzogJ2tleXdvcmQgcmVsYXRpb24nLFxuXHRcdCdleHBvcnQnOiAna2V5d29yZCBleHBvcnQnLFxuXHRcdCdnbG9iYWwnOiAna2V5d29yZCBnbG9iYWwnLFxuXHRcdCdleHRlcm4nOiAna2V5d29yZCBnbG9iYWwnLFxuXHRcdCdleHRlbmQnOiAna2V5d29yZCBleHRlbmQnLFxuXHRcdCdyZXF1aXJlJzogJ2tleXdvcmQgcmVxdWlyZScsXG5cdFx0J2Zyb20nOiAna2V5d29yZCBmcm9tJyxcblx0XHQnbG9naWMnOiAna2V5d29yZCBsb2dpYycsXG5cdFx0J3Bvc3RfaWYnOiAna2V5d29yZCBpZiBwb3N0X2lmJyxcblx0XHQncG9zdF9mb3InOiAna2V5d29yZCBmb3IgcG9zdF9mb3InLFxuXHRcdCdwcm9wJzogJ2tleXdvcmQgcHJvcCcsXG5cdFx0J2F0dHInOiAna2V5d29yZCBhdHRyJyxcblx0XHRcblx0XHQnc2VsZWN0b3Jfc3RhcnQnOiAnX2ltb3BlbiBfaW1zZWxvcGVuIHNlbGVjdG9yX3N0YXJ0Jyxcblx0XHQnc2VsZWN0b3JfZW5kJzogJ19pbWNsb3NlIF9pbXNlbGNsb3NlIHNlbGVjdG9yX2VuZCcsXG5cdFx0J2luZGV4X3N0YXJ0JzogJ19pbW9wZW4gaW5kZXhfc3RhcnQnLFxuXHRcdCdpbmRleF9lbmQnOiAnX2ltY2xvc2UgaW5kZXhfZW5kJyxcblx0XHQnYmxvY2tfcGFyYW1fc3RhcnQnOiAnX2ltb3BlbicsXG5cdFx0J2Jsb2NrX3BhcmFtX2VuZCc6ICdfaW1jbG9zZScsXG5cdFx0XG5cdFx0J3N0cmluZ19zdGFydCc6ICdfaW1zdHJzdGFydCBzdHJpbmdfc3RhcnQnLFxuXHRcdCdzdHJpbmdfZW5kJzogJ19pbXN0cmVuZCBzdHJpbmdfZW5kJyxcblx0XHQnbmVvc3RyaW5nJzogJ19pbXRvayBfaW1uZW9zdHJpbmcnXG5cdH07XG5cdFxuXHR2YXIgSU5URVJQT0xBVElORyA9ICdfaW1pc3RyaW5nJztcblx0XG5cdHZhciBPUEVOID0ge1xuXHRcdCd0YWdfc3RhcnQnOiAnX2ltdGFnbm9kZSB0YWdub2RlJyxcblx0XHQnY2FsbF9zdGFydCc6ICdfaW1wYXJlbnMgY2FsbCcsXG5cdFx0J3NlbGVjdG9yX3N0YXJ0JzogJ19pbXNlbCBzZWxlY3RvcicsXG5cdFx0J3N0cmluZ19zdGFydCc6ICdfaW1pc3RyaW5nJyxcblx0XHQnaW5kZXhfc3RhcnQnOiAnaW5kZXgnLFxuXHRcdCdibG9ja19wYXJhbV9zdGFydCc6ICdfaW1wYWlyIF9pbWJsb2NrcGFyYW1zJyxcblx0XHQvLyAnaW5kZW50JzogJ19pbmRlbnQnXG5cdFx0JygnOiAnX2ltcGFyZW5zIHBhcmVuJyxcblx0XHQne3snOiAnX2ltaWV4cHInLFxuXHRcdCd7JzogJ19pbWN1cmx5IGN1cmx5Jyxcblx0XHQnWyc6ICdfaW1zcXVhcmUgc3F1YXJlJyxcblx0XHQnKFwiJzogJ19pbWlzdHJpbmcnXG5cdH07XG5cdFxuXHRcblx0XG5cdHZhciBDTE9TRSA9IHtcblx0XHQndGFnX2VuZCc6ICd0YWcnLFxuXHRcdCdjYWxsX2VuZCc6ICdfaW1wYXJlbnMgY2FsbCcsXG5cdFx0J3N0cmluZ19lbmQnOiAnX2ltaXN0cmluZycsXG5cdFx0J3NlbGVjdG9yX2VuZCc6ICdzZWwnLFxuXHRcdCdpbmRleF9lbmQnOiAnaW5kZXgnLFxuXHRcdCdibG9ja19wYXJhbV9lbmQnOiAnX2ltcGFpciBfaW1ibG9ja3BhcmFtcycsXG5cdFx0J319JzogJ19pbWlleHByJyxcblx0XHQnKSc6ICdwYXJlbicsXG5cdFx0J10nOiAnc3F1YXJlJyxcblx0XHQnfSc6ICdjdXJseScsXG5cdFx0J1wiKSc6ICdzdHJpbmcnXG5cdH07XG5cdFxuXHR2YXIgT1BTID0gJysgLSAqIC8gPSArKyAtLSA9PSA9PT0gIT0gIT09ID4gPCA+PSA8PSAmICYmIHwgfHwgb3IgLiA6ID8nLnNwbGl0KCcgJyk7XG5cdFxuXHR2YXIgaGxvID0ge1xuXHRcdG5ld2xpbmU6IFwiPGIgY2xhc3M9J19pbW5ld2xpbmUnPlxcbjwvYj5cIixcblx0XHRzcGFjZTogZnVuY3Rpb24obSkgeyByZXR1cm4gKFwiPGIgY2xhc3M9J19pbXNwYWNlJz5cIiArIG0gKyBcIjwvYj5cIik7IH0sXG5cdFx0dGFiOiBmdW5jdGlvbihtKSB7IHJldHVybiBuZXcgQXJyYXkobS5sZW5ndGggKyAxKS5qb2luKFwiPGIgY2xhc3M9J19pbXRhYic+XFx0PC9iPlwiKTsgfVxuXHR9O1xuXHRcblx0ZnVuY3Rpb24gU3RhY2soKXtcblx0XHR0aGlzLl9zdGFjayA9IFtdO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0U3RhY2sucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodmFsKXtcblx0XHR0aGlzLl9zdGFjay5wdXNoKHZhbCk7XG5cdFx0dGhpcy5fY3VycmVudCA9IHZhbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFN0YWNrLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbGVuID0gdGhpcy5fc3RhY2sucG9wKCk7XG5cdFx0dGhpcy5fY3VycmVudCA9IHRoaXMuX3N0YWNrW2xlbiAtIDFdO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0U3RhY2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBUb2tlbih0eXBlLHZhbHVlLGxpbmUsbG9jLGxlbil7XG5cdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5fdmFsdWUgPSB2YWx1ZTtcblx0XHR0aGlzLl9tZXRhID0gbnVsbDtcblx0XHR0aGlzLl9saW5lID0gbGluZSB8fCAwO1xuXHRcdHRoaXMuX2NvbCA9IC0xO1xuXHRcdHRoaXMuX2xvYyA9IGxvYyB8fCAwO1xuXHRcdHRoaXMuX2xlbiA9IGxlbiB8fCAwO1xuXHRcdHRoaXMuZ2VuZXJhdGVkID0gZmFsc2U7XG5cdFx0dGhpcy5uZXdMaW5lID0gZmFsc2U7XG5cdFx0dGhpcy5zcGFjZWQgPSBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0ZXhwb3J0cy5Ub2tlbiA9IFRva2VuOyAvLyBleHBvcnQgY2xhc3MgXG5cdFRva2VuLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGU7XG5cdH07XG5cdFxuXHRUb2tlbi5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWU7XG5cdH07XG5cdFxuXHRUb2tlbi5wcm90b3R5cGUubG9jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYztcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS5sZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fbGVuO1xuXHR9O1xuXHRcblx0XG5cdFxuXHRmdW5jdGlvbiBIaWdobGlnaHRlcihjb2RlLHRva2Vucyxhc3Qsbyl7XG5cdFx0dmFyIGhsXztcblx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHR0aGlzLl9jb2RlID0gY29kZTtcblx0XHR0aGlzLl90b2tlbnMgPSB0b2tlbnM7XG5cdFx0dGhpcy5fYXN0ID0gYXN0O1xuXHRcdFxuXHRcdG8ucmVuZGVyIHx8IChvLnJlbmRlciA9IHt9KTtcblx0XHRvLmhsIHx8IChvLmhsID0ge30pO1xuXHRcdChobF8gPSBvLmhsKS5uZXdsaW5lIHx8IChobF8ubmV3bGluZSA9ICc8YiBjbGFzcz1cIl9uXCI+XFxuPC9iPicpO1xuXHRcdHRoaXMuX29wdGlvbnMgPSBvO1xuXHRcdFxuXHRcdHRoaXMuX29wdGlvbnMubmV4dFZhckNvdW50ZXIgfHwgKHRoaXMuX29wdGlvbnMubmV4dFZhckNvdW50ZXIgPSAwKTtcblx0XHR0aGlzLl92YXJSZWZzID0ge307XG5cdFx0XG5cdFx0aWYgKG8ubW9kZSA9PSAnZnVsbCcgJiYgIWFzdCkge1xuXHRcdFx0dGhpcy5fYXN0ID0gSW1iYWMucGFyc2UodGhpcy5fdG9rZW5zLHt9KTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0ZXhwb3J0cy5IaWdobGlnaHRlciA9IEhpZ2hsaWdodGVyOyAvLyBleHBvcnQgY2xhc3MgXG5cdEhpZ2hsaWdodGVyLk1hcHBpbmcgPSBjbGFzc2VzO1xuXHRcblx0SGlnaGxpZ2h0ZXIubG9nZ2VyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIFZJRVcubG9nZ2VyKCk7XG5cdH07XG5cdFxuXHRIaWdobGlnaHRlci50b2tlbml6ZSA9IGZ1bmN0aW9uIChjb2RlLG8pe1xuXHRcdC8vIGNvbnNvbGUubG9nICd0b2tlbml6ZSB1c2luZyBsb2NhbCBsZXhlcidcblx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRpZiAoZ2xvYmFsLkltYmFjKSB7XG5cdFx0XHRyZXR1cm4gSW1iYWMudG9rZW5pemUoY29kZSxvKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMuX2xleGVyIHx8ICh0aGlzLl9sZXhlciA9IG5ldyBMZXhlcigpKTtcblx0XHR0aGlzLl9sZXhlci5yZXNldCgpO1xuXHRcdHJldHVybiB0aGlzLl9sZXhlci50b2tlbml6ZShjb2RlLG8pO1xuXHR9O1xuXHRcblx0SGlnaGxpZ2h0ZXIucmVjbGFzc2lmeSA9IGZ1bmN0aW9uIChkb21ub2RlLHR5cGUsdG9rZW4sbmV3Q29kZSxvbGRDb2RlKXtcblx0XHRcblx0XHR0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXHRcdC8vIGNvbnNvbGUubG9nICdyZWNsYXNzaWZ5IG5vZGUgYXMgdHlwZScsZG9tbm9kZSx0eXBlLHRva2VuXG5cdFx0dmFyIGNscyA9IElNLlR5cGVzW3R5cGVdIHx8IEltYmEuVEFHU1soXCJpbVwiICsgdHlwZSldIHx8IElNLlR5cGVzLnRva2VuO1xuXHRcdFxuXHRcdHZhciBub2RlID0gdGFnJHdyYXAoZG9tbm9kZSk7XG5cdFx0XG5cdFx0aWYgKG5vZGUgaW5zdGFuY2VvZiBjbHMpIHtcblx0XHRcdHJldHVybiBub2RlLnJldXNlKHRva2VuLG5ld0NvZGUsb2xkQ29kZSk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoY2xzKSB7XG5cdFx0XHRub2RlID0gbmV3IGNscyhkb21ub2RlKS5zZXR1cCh0b2tlbixuZXdDb2RlLG9sZENvZGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH07XG5cdFxuXHRcblx0SGlnaGxpZ2h0ZXIubmVzdFRva2VucyA9IGZ1bmN0aW9uICh0b2tlbnMsb2Zmc2V0KXtcblx0XHR2YXIgcGFpcmluZyA9IHtcblx0XHRcdCdUQUdfU1RBUlQnOiAnVEFHX0VORCcsXG5cdFx0XHQnU0VMRUNUT1JfU1RBUlQnOiAnU0VMRUNUT1JfRU5EJyxcblx0XHRcdCdDQUxMX1NUQVJUJzogJ0NBTExfRU5EJyxcblx0XHRcdCdJTkRFWF9TVEFSVCc6ICdJTkRFWF9FTkQnLFxuXHRcdFx0J1NUUklOR19TVEFSVCc6ICdTVFJJTkdfRU5EJyxcblx0XHRcdCdCTE9DS19QQVJBTV9TVEFSVCc6ICdCTE9DS19QQVJBTV9FTkQnLFxuXHRcdFx0J3t7JzogJ319Jyxcblx0XHRcdCd7JzogJ30nLFxuXHRcdFx0J1snOiAnXScsXG5cdFx0XHQnKCc6ICcpJ1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIG5hbWluZyA9IHtcblx0XHRcdCdUQUdfU1RBUlQnOiAndGFnbm9kZScsXG5cdFx0XHQnU0VMRUNUT1JfU1RBUlQnOiAnc2VsZWN0b3InLFxuXHRcdFx0J1NUUklOR19TVEFSVCc6ICdpc3RyaW5nJyxcblx0XHRcdCdDQUxMX1NUQVJUJzogJ3BhcmVucycsXG5cdFx0XHQnSU5ERVhfU1RBUlQnOiAnc3F1YXJlJyxcblx0XHRcdCdCTE9DS19QQVJBTV9TVEFSVCc6ICdibG9ja3BhcmFtcycsXG5cdFx0XHQne3snOiAnaWV4cHInLFxuXHRcdFx0J3snOiAnY3VybHknLFxuXHRcdFx0J1snOiAnc3F1YXJlJyxcblx0XHRcdCcoJzogJ3BhcmVucydcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBpZHggPSAwO1xuXHRcdFxuXHRcdHZhciByb290ID0ge1xuXHRcdFx0X2xvYzogMCxcblx0XHRcdF9vZmZzZXQ6IDAsXG5cdFx0XHRfY2hpbGRyZW46IFtdXG5cdFx0fTtcblx0XHRcblx0XHR2YXIgc3RhY2sgPSBbcm9vdF07XG5cdFx0dmFyIGVuZHMgPSBbXTtcblx0XHR2YXIgb2Zmc2V0ID0gMDtcblx0XHRcblx0XHR2YXIgbG9jLHZhbCx0eXAsY3R4LHRvaztcblx0XHRcblx0XHR3aGlsZSAodG9rID0gdG9rZW5zW2lkeCsrXSl7XG5cdFx0XHRsb2MgPSB0b2suX2xvYztcblx0XHRcdHZhbCA9IHRvay5fdmFsdWU7XG5cdFx0XHR0eXAgPSB0b2suX3R5cGU7XG5cdFx0XHRcblx0XHRcdC8vIG5vcm1hbGl6aW5nIGJlY2F1c2Ugd2UgZG9udCByZXdyaXRlIHRva2VucyAoc2hvdWxkIHN0YXJ0IHdpdGggdGhhdClcblx0XHRcdGlmICh0eXAgPT0gJ0lERU5USUZJRVInICYmICh2YWwgPT0gJ3Byb3AnIHx8IHZhbCA9PSAnYXR0cicpKSB7IHR5cCA9IHRvay5fdHlwZSA9ICdLRVlXT1JEJyB9OyAvLyBub3QgYWx3YXlzXG5cdFx0XHRpZiAodHlwID09ICdJTkRFWF9TVEFSVCcpIHsgdHlwID0gdG9rLl90eXBlID0gJ1snIH07XG5cdFx0XHRpZiAodHlwID09ICdJTkRFWF9FTkQnKSB7IHR5cCA9IHRvay5fdHlwZSA9ICddJyB9O1xuXHRcdFx0aWYgKHR5cCA9PSAnQ0FMTF9TVEFSVCcpIHsgdHlwID0gdG9rLl90eXBlID0gJygnIH07XG5cdFx0XHRpZiAodHlwID09ICdDQUxMX0VORCcpIHsgdHlwID0gdG9rLl90eXBlID0gJyknIH07XG5cdFx0XHRcblx0XHRcdGN0eCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuXHRcdFx0XG5cdFx0XHRsb2MgLT0gY3R4Ll9vZmZzZXQ7XG5cdFx0XHQvLyBvZmZzZXQgcmVsYXRpdmUgdG8gY29udGV4dFxuXHRcdFx0dmFyIGNsb3NlciA9IHBhaXJpbmdbdHlwXTtcblx0XHRcdFxuXHRcdFx0aWYgKGNsb3Nlcikge1xuXHRcdFx0XHR2YXIgZ3JvdXAgPSBuZXcgVG9rZW4obmFtaW5nW3R5cF0sJycsLTEsbG9jKTtcblx0XHRcdFx0Z3JvdXAuX29mZnNldCA9IGN0eC5fb2Zmc2V0ICsgbG9jO1xuXHRcdFx0XHRvZmZzZXQgKz0gbG9jO1xuXHRcdFx0XHRncm91cC5fY2hpbGRyZW4gPSBbXTtcblx0XHRcdFx0ZW5kcy5wdXNoKGNsb3Nlcik7XG5cdFx0XHRcdHN0YWNrLnB1c2goZ3JvdXApO1xuXHRcdFx0XHRjdHguX2NoaWxkcmVuLnB1c2goZ3JvdXApO1xuXHRcdFx0XHRjdHggPSBncm91cDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRvay5fbG9jIC09IGN0eC5fb2Zmc2V0O1xuXHRcdFx0XG5cdFx0XHQvLyB1cGRhdGUgbGVuZ3RoIGF0IGFsbCB0aW1lc1xuXHRcdFx0aWYgKHRvay5fbGVuID49IDEpIHtcblx0XHRcdFx0Y3R4Ll9jaGlsZHJlbi5wdXNoKHRvayk7XG5cdFx0XHRcdGN0eC5fbGVuID0gdG9rLl9sb2MgKyB0b2suX2xlbjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChlbmRzW2VuZHMubGVuZ3RoIC0gMV0gPT0gdHlwKSB7XG5cdFx0XHRcdGVuZHMucG9wKCk7XG5cdFx0XHRcdGN0eC5fbGVuID0gdG9rLl9sb2MgKyB0b2suX2xlbjtcblx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdC8vIG9mZnNldCAtPSBjdHguQG9mZnNldFxuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nICdjaGlsZHJlbiBoZXJlJyxyb290LkBjaGlsZHJlblxuXHRcdHJldHVybiByb290Ll9jaGlsZHJlbjtcblx0fTtcblx0XG5cdEhpZ2hsaWdodGVyLm5vcm1hbGl6ZVRva2VucyA9IGZ1bmN0aW9uIChjb2RlLHRva2VucyxvZmZzZXQpe1xuXHRcdGlmKG9mZnNldCA9PT0gdW5kZWZpbmVkKSBvZmZzZXQgPSAwO1xuXHRcdHZhciBpZHggPSAwO1xuXHRcdHZhciBjYXJldCA9IDA7XG5cdFx0dmFyIG5ldyQgPSBbXTtcblx0XHR2YXIgdG9rLG5leHQsdHlwLHZhbDtcblx0XHR2YXIgbG9jID0gMDtcblx0XHRcblx0XHR2YXIgc3RhY2sgPSBuZXcgU3RhY2soKTtcblx0XHRcblx0XHR2YXIgd3MgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXd0b2sgPSBudWxsO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAobG9jID4gY2FyZXQpe1xuXHRcdFx0XHR2YXIgY2hyID0gY29kZVtjYXJldF07XG5cdFx0XHRcdGlmIChjaHIgPT0gJ1xcdCcpIHtcblx0XHRcdFx0XHRuZXd0b2sgPSBuZXcgVG9rZW4oJ3RhYicsY2hyLC0xLGNhcmV0LDEpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnXFxuJykge1xuXHRcdFx0XHRcdG5ld3RvayA9IG5ldyBUb2tlbignbmV3bGluZScsY2hyLC0xLGNhcmV0LDEpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnOycpIHtcblx0XHRcdFx0XHRuZXd0b2sgPSBuZXcgVG9rZW4oJ3NlbWljb2xvbicsY2hyLC0xLGNhcmV0LDEpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnICcpIHtcblx0XHRcdFx0XHRpZiAobmV3dG9rICYmIG5ld3Rvay5fdHlwZSA9PSAnd2hpdGVzcGFjZScpIHtcblx0XHRcdFx0XHRcdG5ld3Rvay5fdmFsdWUgKz0gJyAnO1xuXHRcdFx0XHRcdFx0bmV3dG9rLl9sZW4gKz0gMTtcblx0XHRcdFx0XHRcdGNhcmV0Kys7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdG5ld3RvayA9IG5ldyBUb2tlbignd2hpdGVzcGFjZScsY2hyLC0xLGNhcmV0LDEpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnIycpIHtcblx0XHRcdFx0XHR2YXIgc3RhcnRsb2MgPSBjYXJldDtcblx0XHRcdFx0XHR2YXIgY29tbWVudCA9ICcnO1xuXHRcdFx0XHRcdHdoaWxlIChjYXJldCA8IGxvYyAmJiBjb2RlW2NhcmV0XSAhPSAnXFxuJyl7XG5cdFx0XHRcdFx0XHRjb21tZW50ICs9IGNvZGVbY2FyZXRdO1xuXHRcdFx0XHRcdFx0Y2FyZXQrKztcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdG5ldyQucHVzaChuZXcgVG9rZW4oJ2NvbW1lbnQnLGNvbW1lbnQsLTEsc3RhcnRsb2MsY29tbWVudC5sZW5ndGgpKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuZXd0b2sgPSBudWxsO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Y2FyZXQrKztcblx0XHRcdFx0aWYgKG5ld3RvaykgeyBuZXckLnB1c2gobmV3dG9rKSB9O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybjtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBza2lwID0gWydURVJNSU5BVE9SJywnSU5ERU5UJywnT1VUREVOVCcsJyAnLCcgXFx0J107XG5cdFx0XG5cdFx0d2hpbGUgKHRvayA9IHRva2Vuc1tpZHgrK10pe1xuXHRcdFx0bmV4dCA9IHRva2Vuc1tpZHhdO1xuXHRcdFx0bG9jID0gdG9rLl9sb2M7XG5cdFx0XHR2YWwgPSB0b2suX3ZhbHVlO1xuXHRcdFx0dHlwID0gdG9rLl90eXBlO1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwID09ICcjJyAmJiBuZXh0ICYmIG5leHQuX3R5cGUgPT0gJ0lERU5USUZJRVInKSB7XG5cdFx0XHRcdG5leHQuX3R5cGUgPSAnSURSRUYnO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cCA9PSAnKCcgJiYgdmFsID09ICcoXCInKSB7XG5cdFx0XHRcdHN0YWNrLnB1c2godmFsKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChza2lwLmluZGV4T2YodHlwKSA+PSAwKSB7IGNvbnRpbnVlOyB9O1xuXHRcdFx0XG5cdFx0XHRpZiAobG9jID4gY2FyZXQpIHsgd3MoKSB9O1xuXHRcdFx0Y2FyZXQgPSB0b2suX2xvYyArIHRvay5fbGVuO1xuXHRcdFx0bmV3JC5wdXNoKHRvayk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBtb3ZlIHRvIHRoZSBlbmQgdG8gcG9zc2libHkgcGFyc2UgbW9yZSB3aGl0ZXNwYWNlXG5cdFx0bG9jID0gY29kZS5sZW5ndGg7XG5cdFx0d3MoKTtcblx0XHQvLyBub3cgbmVzdCB0aGUgdG9rZW5zXG5cdFx0bmV3JCA9IHRoaXMubmVzdFRva2VucyhuZXckKTtcblx0XHRyZXR1cm4gbmV3JDtcblx0fTtcblx0XG5cdEhpZ2hsaWdodGVyLndoaXRlc3BhY2VUb1Rva2VucyA9IGZ1bmN0aW9uIChzdHIpe1xuXHRcdHZhciB0b2s7XG5cdFx0dmFyIHRva2VucyA9IFtdO1xuXHRcdHZhciBjYXJldCA9IDA7XG5cdFx0dmFyIGxlbiA9IHN0ci5sZW5ndGg7XG5cdFx0XG5cdFx0d2hpbGUgKGxlbiA+IGNhcmV0KXtcblx0XHRcdHZhciBsb2MgPSBjYXJldDtcblx0XHRcdHZhciBjaHIgPSBzdHJbY2FyZXQrK107XG5cdFx0XHRpZiAoY2hyID09ICdcXHQnKSB7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHRvayA9IG5ldyBUb2tlbigndGFiJyxjaHIsLTEsbG9jLDEpKTtcblx0XHRcdH0gZWxzZSBpZiAoY2hyID09ICdcXG4nKSB7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHRvayA9IG5ldyBUb2tlbignbmV3bGluZScsY2hyLC0xLGxvYywxKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGNociA9PSAnICcpIHtcblx0XHRcdFx0aWYgKHRvayAmJiB0b2suX3R5cGUgPT0gJ3doaXRlc3BhY2UnKSB7XG5cdFx0XHRcdFx0dG9rLl92YWx1ZSArPSAnICc7XG5cdFx0XHRcdFx0dG9rLl9sZW4gKz0gMTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fTtcblx0XHRcdFx0dG9rZW5zLnB1c2godG9rID0gbmV3IFRva2VuKCd3aGl0ZXNwYWNlJyxjaHIsLTEsbG9jLDEpKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdG9rZW5zO1xuXHR9O1xuXHRcblx0SGlnaGxpZ2h0ZXIucmVwYXJzZSA9IGZ1bmN0aW9uIChvKXtcblx0XHRcblx0XHR2YXIgJDE7XG5cdFx0aWYgKG8gaW5zdGFuY2VvZiBFbGVtZW50KSB7XG5cdFx0XHR2YXIgZWwgPSB0YWckd3JhcChvKTtcblx0XHRcdGlmIChlbCkgeyAoJDEgPSBlbCkgJiYgJDEubXV0YXRlZCAgJiYgICQxLm11dGF0ZWQoKSB9O1xuXHRcdFx0cmV0dXJuO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIG5vZGVzID0gby5ub2Rlcztcblx0XHR2YXIgY29kZSA9IG8uY29kZTtcblx0XHR2YXIgdG9rZW5zID0gby50b2tlbnM7XG5cdFx0Ly8gc2hvdWxkIHVzZSBhIGdsb2JhbCBsb2dnZXItaW5zdGFuY2Vcblx0XHR0aGlzLmxvZ2dlcigpLmdyb3VwQ29sbGFwc2VkKCdyZXBhcnNlICVzJyxKU09OLnN0cmluZ2lmeShjb2RlKSk7XG5cdFx0XG5cdFx0aWYgKHV0aWwuaXNXaGl0ZXNwYWNlKGNvZGUpICYmICF0b2tlbnMpIHtcblx0XHRcdGNvbnNvbGUubG9nKCd1c2luZyB3aGl0ZXNwYWNlVG9Ub2tlbnMnKTtcblx0XHRcdHRva2VucyA9IHRoaXMud2hpdGVzcGFjZVRvVG9rZW5zKGNvZGUpO1xuXHRcdH07XG5cdFx0Ly8gbG9nZ2VyLmxvZyBub2Rlcy5zbGljZVxuXHRcdC8vIGJpZyBoYWNrIC0gYWRkaW5nIGEgc3BhY2UgYXQgdGhlIGVuZCB0byBjbG9zZSB1cCBzZWxlY3RvcnNcblx0XHQvLyBzaG91bGQgcmF0aGVyIGRyb3AgaW5saW5lIGFuZCBsZXQgdGhlIHBhcnNlciBwYWlyIHVwIGxvb3NlIGVuZHM/XG5cdFx0aWYgKCF0b2tlbnMpIHtcblx0XHRcdHRva2VucyA9IHRoaXMudG9rZW5pemUoY29kZSArICcgJyx7aW5saW5lOiB0cnVlLHNpbGVudDogdHJ1ZSxyZXdyaXRlOiBmYWxzZX0pO1xuXHRcdFx0dG9rZW5zID0gdGhpcy5ub3JtYWxpemVUb2tlbnMoY29kZSx0b2tlbnMpO1xuXHRcdFx0dGhpcy5sb2dnZXIoKS5sb2codG9rZW5zLnNsaWNlKCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5sb2dnZXIoKS5sb2cobm9kZXMuc2xpY2UoKSk7XG5cdFx0dGhpcy5hcHBseVRva2Vucyhjb2RlLHRva2Vucyxub2RlcyxvLm5lc3RlZCxvLnBhcmVudCk7XG5cdFx0dGhpcy5sb2dnZXIoKS5ncm91cEVuZCgpO1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdEhpZ2hsaWdodGVyLmFwcGx5VG9rZW5zID0gZnVuY3Rpb24gKGNvZGUsdG9rZW5zLG5vZGVzLG5lc3RlZCxwYXJlbnQpe1xuXHRcdC8vIHdoYXQgYWJvdXQgbGVuIGFuZCBsb2MgZm9yIGlubmVyIG5vZGVzPyBTaG91bGQgdGhpcyBiZSBzZXQgYWxyZWFkeT9cblx0XHRcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIG5vZGU7XG5cdFx0dmFyIHByZXZOb2RlO1xuXHRcdFxuXHRcdHZhciBhZGROb2RlID0gZnVuY3Rpb24obm9kZXMsaW5kZXgsYWZ0ZXIpIHtcblx0XHRcdHNlbGYubG9nZ2VyKCkubG9nKCdhZGROb2RlJyxpbmRleCk7XG5cdFx0XHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KE5PREVUWVBFKTtcblx0XHRcdFxuXHRcdFx0aWYgKGFmdGVyKSB7XG5cdFx0XHRcdGlmIChhZnRlci5uZXh0U2libGluZykge1xuXHRcdFx0XHRcdGFmdGVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLGFmdGVyLm5leHRTaWJsaW5nKTtcblx0XHRcdFx0fSBlbHNlIGlmIChhZnRlci5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdFx0YWZ0ZXIucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbCk7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKHBhcmVudCkge1xuXHRcdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0bm9kZXMuc3BsaWNlKGluZGV4LDAsZWwpO1xuXHRcdFx0cmV0dXJuIGVsO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHJlbW92ZU5vZGUgPSBmdW5jdGlvbihub2RlcyxpbmRleCkge1xuXHRcdFx0c2VsZi5sb2dnZXIoKS5sb2coJ3JlbW92ZU5vZGUnLGluZGV4KTtcblx0XHRcdHZhciBlbCA9IG5vZGVzW2luZGV4XTtcblx0XHRcdGlmIChlbCAmJiBlbC5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBub2Rlcy5zcGxpY2UoaW5kZXgsMSk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBsb29wIHRocm91Z2ggdG8gc2V0IHRoZSBsb2NhdGlvbnMgb2YgdGhlIG5vZGVzXG5cdFx0dmFyIG5sb2MgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChub2RlcyksIGxlbiA9IGFyeS5sZW5ndGgsIG5vZGUxOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdG5vZGUxID0gYXJ5W2ldO1xuXHRcdFx0bm9kZTEuX2xvYyA9IG5sb2M7XG5cdFx0XHRubG9jICs9IChub2RlMS5fbGVuID0gbm9kZTEudGV4dENvbnRlbnQubGVuZ3RoKTtcblx0XHR9O1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0b2tlbnMpLCBsZW4gPSBhcnkubGVuZ3RoLCB0b2s7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dG9rID0gYXJ5W2ldO1xuXHRcdFx0bm9kZSA9IG5vZGVzW2ldO1xuXHRcdFx0dmFyIHRsb2MgPSB0b2suX2xvYztcblx0XHRcdG5sb2MgPSBub2RlICYmIG5vZGUuX2xvYztcblx0XHRcdFxuXHRcdFx0d2hpbGUgKG5vZGUgJiYgbm9kZS5fbGVuID09IDApe1xuXHRcdFx0XHRzZWxmLmxvZ2dlcigpLmxvZygncmVtb3ZlIG5vZGUgYmVjYXVzZSBpdCBpcyBlbXB0eScsbm9kZSk7XG5cdFx0XHRcdHJlbW92ZU5vZGUobm9kZXMsaSk7XG5cdFx0XHRcdG5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICghbm9kZSkge1xuXHRcdFx0XHQvLyBuZWVkIHRvIGluc2VydCBuZXcgbm9kZSBoZXJlIC0gXG5cdFx0XHRcdG5vZGUgPSBhZGROb2RlKG5vZGVzLGkscHJldk5vZGUpO1xuXHRcdFx0fSBlbHNlIGlmIChubG9jID4gdGxvYykge1xuXHRcdFx0XHRub2RlID0gYWRkTm9kZShub2RlcyxpLHByZXZOb2RlKTtcblx0XHRcdH0gZWxzZSBpZiAodGxvYyA+IG5sb2MpIHtcblx0XHRcdFx0cmVtb3ZlTm9kZShub2RlcyxpKTtcblx0XHRcdFx0bm9kZSA9IG5vZGVzW2ldO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gbmVlZCB0byBpbnNlcnQgbmV3IG5vZGUgaGVyZSAtIFxuXHRcdFx0aWYgKCFub2RlKSB7IG5vZGUgPSBhZGROb2RlKG5vZGVzLGkscHJldk5vZGUpIH07XG5cdFx0XHRcblx0XHRcdGlmICh0b2suX3R5cGUgPT0gJ1NUUklORycgJiYgdG9rLl92YWx1ZS5tYXRjaCgvXFzCp3szfS8pKSB7XG5cdFx0XHRcdGlmIChuZXN0ZWQpIHtcblx0XHRcdFx0XHRuZXN0ZWQucG9wKCk7IC8vIHRoaXMgaXMgdGhlIG5vZGVcblx0XHRcdFx0XHRwcmV2Tm9kZSA9IG5vZGU7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyB3YW50IHRvIG1ha2Ugc3VyZSBpdCBpcyBhIHBsYWNlaG9sZGVyIGZvciB0aGUgcmlnaHQgdGhpbmdcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBjdmFsID0gY29kZS5zdWJzdHIodGxvYyx0b2suX2xlbik7XG5cdFx0XHR2YXIgY3ByZXYgPSBub2RlLnRleHRDb250ZW50O1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBzZWxmLnJlY2xhc3NpZnkobm9kZSx0b2suX3R5cGUsdG9rLGN2YWwsY3ByZXYpO1xuXHRcdFx0XG5cdFx0XHRpZiAodG9rLl9jaGlsZHJlbikge1xuXHRcdFx0XHR2YXIgY25vZGVzID0gbm9kZS5jaGlsZHJlbjtcblx0XHRcdFx0aWYgKGNub2Rlcy5sZW5ndGggJiYgY25vZGVzLmxlbmd0aCA9PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0c2VsZi5sb2dnZXIoKS5sb2coJ3JldXNlIHRoZSBjbm9kZXMoISknLGNub2Rlcyk7XG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNob3VsZCByZW1vdmUgdGhlIHRleHROb2Rlcz9cblx0XHRcdFx0XHQvLyBjb252ZXJ0IHRvIGFycmF5XG5cdFx0XHRcdFx0Y25vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY25vZGVzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLmxvZ2dlcigpLmxvZygnd3JvbmcgbGVuZ3RoJyk7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDAsIGl0ZW1zID0gaXRlciQobm9kZS5jaGlsZE5vZGVzKSwgbGVuXyA9IGl0ZW1zLmxlbmd0aDsgaiA8IGxlbl87IGorKykge1xuXHRcdFx0XHRcdFx0c2VsZi5sb2dnZXIoKS5sb2coaXRlbXNbal0pO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Ly8gc2VlIGlmIHByZXZpb3VzIHZhbHVlIGlzIHRoZSBzYW1lPyFcblx0XHRcdFx0XHRub2RlLmlubmVySFRNTCA9ICcnO1xuXHRcdFx0XHRcdGNub2RlcyA9IFtdO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gbGV0IG8gPVxuXHRcdFx0XHQvLyBcdGNvZGU6IGN2YWxcblx0XHRcdFx0Ly8gXHRub2RlczogY25vZGVzXG5cdFx0XHRcdC8vIFx0dG9rZW5zOiB0b2suQGNoaWxkcmVuICMgYWxyZWFkeSBwYXJzZWRcblx0XHRcdFx0Ly8gXHRuZXN0ZWQ6IG5lc3RlZFxuXHRcdFx0XHQvLyBcdHBhcmVudDogbm9kZVxuXHRcdFx0XHRcblx0XHRcdFx0c2VsZi5hcHBseVRva2VucyhjdmFsLHRvay5fY2hpbGRyZW4sY25vZGVzLG5lc3RlZCxub2RlKTtcblx0XHRcdH0gZWxzZSBpZiAoY3ByZXYgIT0gY3ZhbCkge1xuXHRcdFx0XHRub2RlLnRleHRDb250ZW50ID0gY3ZhbDsgLy8gdG9rLkB2YWx1ZVxuXHRcdFx0XHRlbGVtZW50LnJlcGFyc2VkKGN2YWwsY3ByZXYpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cHJldk5vZGUgPSBub2RlO1xuXHRcdFx0Ly8gdG9rLkBsZW5cblx0XHR9O1xuXHRcdFxuXHRcdC8vIGxvb3AgdGhyb3VnaCB0b2tlbnM/IG5vdCBzdXJlIGl0IHdvcmtzIGR1ZSB0byB0aGUgaXNzdWVzIHdpdGggd2hpdGVzcGFjZT9cblx0XHRcblx0XHQvLyByZW1vdmUgZXhjZXNzIG9yaWdpbmFsIG5vZGVzXG5cdFx0d2hpbGUgKG5vZGVzLmxlbmd0aCA+IHRva2Vucy5sZW5ndGgpe1xuXHRcdFx0bm9kZSA9IG5vZGVzLnBvcCgpO1xuXHRcdFx0aWYgKG5vZGUucGFyZW50Tm9kZSkgeyBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSkgfTtcblx0XHRcdC8vIG5vZGUub3JwaGFuaXplXG5cdFx0fTtcblx0XHRyZXR1cm4gc2VsZjtcblx0fTtcblx0XG5cdC8vIHNob3VsZCBsYXRlciBiZSBhYmxlIHRvIHJlaGlnaGxpZ2h0IHRoZSB0ZXh0IC8gbm9kZXMgZGlyZWN0bHkgaW5zdGVhZFxuXHQvLyBwcm9iYWJseSBtb3JlIGVmZmljaWVudFxuXHRIaWdobGlnaHRlci5oaWdobGlnaHQgPSBmdW5jdGlvbiAoY29kZSxvKXtcblx0XHQvLyBmaXJzdCB0cnkgdG8gcGFyc2UgZXRjP1xuXHRcdC8vIGNvdWxkIGhpZ2hsaWdodCBzaW5nbGUgd29yZHMgYXMgd2VsbFxuXHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdG8uaGwgfHwgKG8uaGwgPSBobG8pO1xuXHRcdHZhciB0b2tlbnMgPSBvLnRva2VucyB8fCBudWxsO1xuXHRcdFxuXHRcdGlmICghdG9rZW5zKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBzdXJlIHdlIGRvbnQgd2FudCB0byByZXdyaXRlIGFueXRoaW5nIG5vdz9cblx0XHRcdFx0aWYgKERFQlVHKSB7IGNvbnNvbGUudGltZSgndG9rZW5pemUnKSB9O1xuXHRcdFx0XHRpZiAoby5tb2RlID09ICdmdWxsJykge1xuXHRcdFx0XHRcdHRva2VucyA9IHRoaXMudG9rZW5pemUoY29kZSx7fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG9rZW5zID0gdGhpcy50b2tlbml6ZShjb2RlLHtpbmxpbmU6IHRydWUsc2lsZW50OiB0cnVlLHJld3JpdGU6IGZhbHNlfSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChERUJVRykgeyBjb25zb2xlLnRpbWVFbmQoJ3Rva2VuaXplJykgfTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0aWYgKGUuX29wdGlvbnMpIHsgdG9rZW5zID0gZS5fb3B0aW9ucy50b2tlbnMgfTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgaGwgPSBuZXcgdGhpcyhjb2RlLHRva2VucyxudWxsLG8pO1xuXHRcdHJldHVybiBobC5wcm9jZXNzKCk7XG5cdH07XG5cdFxuXHRcblx0XG5cdEhpZ2hsaWdodGVyLnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9vcHRpb25zOyB9XG5cdEhpZ2hsaWdodGVyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24odil7IHRoaXMuX29wdGlvbnMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEhpZ2hsaWdodGVyLnByb3RvdHlwZS52YXJSZWYgPSBmdW5jdGlvbiAodmFyaWFibGUpe1xuXHRcdHZhciAkMTtcblx0XHR2YXIgaSA9IHRoaXMuX29wdGlvbnMubmVzdGVkO1xuXHRcdHZhciBwZnggPSBpID8gKCdpJykgOiAoJycpO1xuXHRcdHJldHVybiB0aGlzLl92YXJSZWZzWygkMSA9IHZhcmlhYmxlLl9yZWYpXSB8fCAodGhpcy5fdmFyUmVmc1skMV0gPSAocGZ4ICsgdGhpcy5fb3B0aW9ucy5uZXh0VmFyQ291bnRlcisrKSk7XG5cdH07XG5cdFxuXHRIaWdobGlnaHRlci5wcm90b3R5cGUucGFyc2VXaGl0ZXNwYWNlID0gZnVuY3Rpb24gKHRleHQpe1xuXHRcdC8vIHBhcnNpbmcgY29tbWVudHNcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIGhsID0gdGhpcy5fb3B0aW9ucy5obDtcblx0XHR2YXIgY29tbWVudHMgPSBbXTtcblx0XHRcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oXFwjKShbXlxcbl0qKS9nLGZ1bmN0aW9uKG0scyxxKSB7XG5cdFx0XHRpZiAoc2VsZi5fb3B0aW9ucy5yZW5kZXIuY29tbWVudCkge1xuXHRcdFx0XHRtID0gc2VsZi5fb3B0aW9ucy5yZW5kZXIuY29tbWVudCgnY29tbWVudCcsbSk7XG5cdFx0XHR9O1xuXHRcdFx0dmFyIG5yID0gY29tbWVudHMucHVzaCgoXCI8XCIgKyBOT0RFVFlQRSArIFwiIGNsYXNzPSdfaW0gX2ltY29tbWVudCc+XCIgKyBtICsgXCI8L1wiICsgTk9ERVRZUEUgKyBcIj5cIikpO1xuXHRcdFx0cmV0dXJuIChcIiRcIiArIChuciAtIDEpICsgXCIkXCIpO1xuXHRcdH0pO1xuXHRcdFxuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoLyhcXG58WyBdK3xbXFx0XSspL2csZnVuY3Rpb24obSxsKSB7XG5cdFx0XHRpZiAobCA9PSAnXFxuJykge1xuXHRcdFx0XHRyZXR1cm4gaGwubmV3bGluZSB8fCAnXFxuJztcblx0XHRcdH0gZWxzZSBpZiAobFswXSA9PSAnICcpIHtcblx0XHRcdFx0cmV0dXJuIGhsLnNwYWNlIGluc3RhbmNlb2YgRnVuY3Rpb24gPyAoaGwuc3BhY2UobCkpIDogKGwpO1xuXHRcdFx0fSBlbHNlIGlmIChsWzBdID09ICdcXHQnKSB7XG5cdFx0XHRcdHJldHVybiBobC50YWIgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IChobC50YWIobCkpIDogKGwpO1xuXHRcdFx0fTtcblx0XHR9KTtcblx0XHRcblx0XHRpZiAoY29tbWVudHMubGVuZ3RoKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXCQoXFxkKylcXCQvZyxmdW5jdGlvbihtLG5yKSB7XG5cdFx0XHRcdHJldHVybiBjb21tZW50c1twYXJzZUludChucildO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGV4dDtcblx0fTtcblx0XG5cdEhpZ2hsaWdodGVyLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHRvaztcblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucygpO1xuXHRcdFxuXHRcdHZhciBzdHIgPSB0aGlzLl9jb2RlO1xuXHRcdHZhciBwb3MgPSB0aGlzLl90b2tlbnMubGVuZ3RoO1xuXHRcdFxuXHRcdHZhciBzdGFjayA9IFtdO1xuXHRcdHZhciBkZXB0aCA9IDA7XG5cdFx0dmFyIGNvbnRleHQgPSBudWxsO1xuXHRcdFxuXHRcdHZhciBwdXNoID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0XHRzdGFjay5wdXNoKGN0eCk7XG5cdFx0XHRkZXB0aCA9IHN0YWNrLmxlbmd0aDtcblx0XHRcdHJldHVybiBjb250ZXh0ID0gc3RhY2tbZGVwdGggLSAxXTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBwb3AgPSBmdW5jdGlvbihjdHgpIHtcblx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0ZGVwdGggPSBzdGFjay5sZW5ndGg7XG5cdFx0XHRyZXR1cm4gY29udGV4dCA9IHN0YWNrW2RlcHRoIC0gMV07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAodGhpcy5fYXN0ICYmIHRoaXMuX2FzdC5hbmFseXplKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGlzLl9hc3QuYW5hbHl6ZSh7fSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdG51bGw7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHJlcyA9IFwiXCI7XG5cdFx0cG9zID0gMDtcblx0XHR2YXIgY2FyZXQgPSAwO1xuXHRcdFxuXHRcdHZhciBvcGVuLGNsb3NlO1xuXHRcdFxuXHRcdHdoaWxlICh0b2sgPSB0aGlzLl90b2tlbnNbcG9zKytdKXtcblx0XHRcdHZhciBuZXh0ID0gdGhpcy5fdG9rZW5zW3Bvc107XG5cdFx0XHRcblx0XHRcdGlmIChjbG9zZSkge1xuXHRcdFx0XHRpZiAoIShvLmlubmVyICYmIGRlcHRoID09IDEpKSB7IHJlcyArPSAoXCI8L1wiICsgTk9ERVRZUEUgKyBcIj5cIikgfTtcblx0XHRcdFx0Y2xvc2UgPSBudWxsO1xuXHRcdFx0XHRwb3AoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciB0eXAgPSB0b2suX3R5cGUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHZhciBsb2MgPSB0b2suX2xvYztcblx0XHRcdHZhciB2YWwgPSB0b2suX3ZhbHVlO1xuXHRcdFx0dmFyIGxlbiA9IHRvay5fbGVuOyAvLyBvciB0b2suQHZhbHVlOmxlbmd0aFxuXHRcdFx0dmFyIG1ldGEgPSB0b2suX21ldGE7XG5cdFx0XHR2YXIgYXR0cnMgPSAnJztcblx0XHRcdFxuXHRcdFx0aWYgKGxvYyA+IGNhcmV0KSB7XG5cdFx0XHRcdHZhciBhZGQgPSBzdHIuc3Vic3RyaW5nKGNhcmV0LGxvYyk7XG5cdFx0XHRcdGlmIChjb250ZXh0ICE9IElOVEVSUE9MQVRJTkcpIHsgYWRkID0gdGhpcy5wYXJzZVdoaXRlc3BhY2UoYWRkKSB9O1xuXHRcdFx0XHRyZXMgKz0gYWRkO1xuXHRcdFx0XHRjYXJldCA9IGxvYztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNsb3NlID0gQ0xPU0VbdHlwXTtcblx0XHRcdFxuXHRcdFx0aWYgKG9wZW4gPSBPUEVOW3R5cF0pIHtcblx0XHRcdFx0Ly8gb3BlbiA9IE9QRU5bdmFsXSB8fCBvcGVuXG5cdFx0XHRcdHB1c2gob3Blbik7XG5cdFx0XHRcdGlmICghKG8uaW5uZXIgJiYgZGVwdGggPT0gMSkpIHsgcmVzICs9IChcIjxcIiArIE5PREVUWVBFICsgXCIgY2xhc3M9J1wiICsgb3BlbiArIFwiJz5cIikgfTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChsZW4gPT0gMCB8fCB0eXAgPT0gJ3Rlcm1pbmF0b3InIHx8IHR5cCA9PSAnaW5kZW50JyB8fCB0eXAgPT0gJ291dGRlbnQnKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHRvay5fY29sID09IC0xICYmIHRvay5fbG9jIDw9IDApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgbm9kZSA9IE5PREVUWVBFO1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBzdHIuc3Vic3RyKGxvYyxsZW4pO1xuXHRcdFx0Ly8gdGVtcG9yYXJ5IHdvcmthcm91bmQgdW50aWwgd2UgcmVkZWZpbmUgcmVxdWlyZSBhcyBhbiBpZGVudGlmaWVyXG5cdFx0XHRpZiAodHlwID09ICdjb25zdCcgJiYgY29udGVudCA9PSAncmVxdWlyZScpIHtcblx0XHRcdFx0dHlwID0gJ3JlcXVpcmUnO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHR2YXIgY2xzID0gY2xhc3Nlc1t0eXBdIHx8IHR5cDtcblx0XHRcdFxuXHRcdFx0aWYgKGNscyBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdG5vZGUgPSBjbHNbMF07XG5cdFx0XHRcdGNscyA9IGNsc1sxXTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNscyA9IGNscy5zcGxpdChcIiBcIik7XG5cdFx0XHRcblx0XHRcdGlmIChLRVlXT1JEUy5pbmRleE9mKHR5cCkgPj0gMCkge1xuXHRcdFx0XHRjbHMudW5zaGlmdCgna2V5d29yZCcpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y2FyZXQgPSBsb2MgKyBsZW47XG5cdFx0XHRcblx0XHRcdGlmICh0eXAgPT0gJ2lkZW50aWZpZXInKSB7XG5cdFx0XHRcdGlmIChjb250ZW50WzBdID09ICcjJykge1xuXHRcdFx0XHRcdGNscy5wdXNoKCdpZHJlZicpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG1ldGEpIHtcblx0XHRcdFx0XHRpZiAobWV0YS50eXBlID09ICdBQ0NFU1MnKSB7IGNscy5wdXNoKCdhY2Nlc3MnKSB9O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGNvbnRlbnQgPT0gJ2xvZycpIHtcblx0XHRcdFx0XHRjbHMucHVzaCgnbG9nJyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodG9rLl92YXJpYWJsZSkge1xuXHRcdFx0XHRcblx0XHRcdFx0Y2xzLnB1c2goJ2x2YXInKTtcblx0XHRcdFx0dmFyIHJlZiA9IHRoaXMudmFyUmVmKHRvay5fdmFyaWFibGUpO1xuXHRcdFx0XHRhdHRycyArPSAoXCIgZXJlZj0ndlwiICsgcmVmICsgXCInXCIpO1xuXHRcdFx0XHQvLyBjbHMucHVzaChcInJlZi1cIityZWYpXG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwID09ICdoZXJlY29tbWVudCcpIHtcblx0XHRcdFx0dmFyIGVuZCA9IChcIjxcIiArIE5PREVUWVBFICsgXCI+IyMjPC9cIiArIE5PREVUWVBFICsgXCI+XCIpO1xuXHRcdFx0XHRjb250ZW50ID0gZW5kICsgY29udGVudC5zbGljZSgzLC0zKSArIGVuZDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh0eXAgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0aWYgKGNvbnRlbnQubWF0Y2goL15bJ1wiXT9cXC4/XFwuXFwvLykpIHsgY2xzLnB1c2goJ3BhdGhuYW1lJykgfTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBjbHN0ciA9IGNscy5qb2luKFwiIFwiKTtcblx0XHRcdGlmICghY2xzdHIubWF0Y2goL1xcYlxcXy8pKSB7IGNsc3RyID0gJ19pbXRvayAnICsgY2xzdHIgfTtcblx0XHRcdHJlcyArPSAoXCI8XCIgKyBub2RlICsgXCIgY2xhc3M9J1wiICsgY2xzdHIgKyBcIidcIikgKyBhdHRycyArIFwiPlwiICsgY29udGVudCArIChcIjwvXCIgKyBub2RlICsgXCI+XCIpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gY2xvc2UgYWZ0ZXI/XG5cdFx0aWYgKGNsb3NlKSB7XG5cdFx0XHRyZXMgKz0gKFwiPC9cIiArIE5PREVUWVBFICsgXCI+XCIpO1xuXHRcdFx0Y2xvc2UgPSBudWxsO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGNhcmV0IDwgc3RyLmxlbmd0aCAtIDEpIHtcblx0XHRcdGFkZCA9IHN0ci5zbGljZShjYXJldCk7XG5cdFx0XHRpZiAoY29udGV4dCAhPSBJTlRFUlBPTEFUSU5HKSB7IGFkZCA9IHRoaXMucGFyc2VXaGl0ZXNwYWNlKGFkZCkgfTtcblx0XHRcdHJlcyArPSBhZGQ7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAodGhpcy5fdG9rZW5zLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRyZXMgPSB0aGlzLl9jb2RlO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHJlcztcblx0fTtcblx0cmV0dXJuIEhpZ2hsaWdodGVyO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvY29yZS9oaWdobGlnaHRlci5pbWJhXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpZHgkKGEsYil7XG5cdFx0cmV0dXJuIChiICYmIGIuaW5kZXhPZikgPyBiLmluZGV4T2YoYSkgOiBbXS5pbmRleE9mLmNhbGwoYSxiKTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdC8vIGhlbHBlciBmb3Igc3ViY2xhc3Npbmdcblx0ZnVuY3Rpb24gc3ViY2xhc3MkKG9iaixzdXApIHtcblx0XHRmb3IgKHZhciBrIGluIHN1cCkge1xuXHRcdFx0aWYgKHN1cC5oYXNPd25Qcm9wZXJ0eShrKSkgb2JqW2tdID0gc3VwW2tdO1xuXHRcdH07XG5cdFx0Ly8gb2JqLl9fc3VwZXJfXyA9IHN1cDtcblx0XHRvYmoucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXAucHJvdG90eXBlKTtcblx0XHRvYmouX19zdXBlcl9fID0gb2JqLnByb3RvdHlwZS5fX3N1cGVyX18gPSBzdXAucHJvdG90eXBlO1xuXHRcdG9iai5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IG9iai5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBvYmo7XG5cdH07XG5cdFxuXHR2YXIgQUxMX0tFWVdPUkRTO1xuXHRcblx0dmFyIFQgPSByZXF1aXJlKCcuL3Rva2VuJyk7XG5cdHZhciBUb2tlbiA9IFQuVG9rZW47XG5cdFxuXHR2YXIgcncgPSByZXF1aXJlKCcuL3Jld3JpdGVyJyk7XG5cdHZhciBSZXdyaXRlciA9IHJ3LlJld3JpdGVyO1xuXHR2YXIgSU5WRVJTRVMgPSBydy5JTlZFUlNFUztcblx0XG5cdHZhciBLID0gMDtcblx0XG5cdHZhciBFUlIgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXHRcblx0Ly8gQ29uc3RhbnRzXG5cdC8vIC0tLS0tLS0tLVxuXHRcblx0Ly8gS2V5d29yZHMgdGhhdCBJbWJhIHNoYXJlcyBpbiBjb21tb24gd2l0aCBKYXZhU2NyaXB0LlxuXHR2YXIgSlNfS0VZV09SRFMgPSBbXG5cdFx0J3RydWUnLCdmYWxzZScsJ251bGwnLCd0aGlzJyxcblx0XHQnZGVsZXRlJywndHlwZW9mJywnaW4nLCdpbnN0YW5jZW9mJyxcblx0XHQndGhyb3cnLCdicmVhaycsJ2NvbnRpbnVlJywnZGVidWdnZXInLFxuXHRcdCdpZicsJ2Vsc2UnLCdzd2l0Y2gnLCdmb3InLCd3aGlsZScsJ2RvJywndHJ5JywnY2F0Y2gnLCdmaW5hbGx5Jyxcblx0XHQnY2xhc3MnLCdleHRlbmRzJywnc3VwZXInLCdyZXR1cm4nXG5cdF07XG5cdFxuXHQvLyBuZXcgY2FuIGJlIHVzZWQgYXMgYSBrZXl3b3JkIGluIGltYmEsIHNpbmNlIG9iamVjdCBpbml0aW5nIGlzIGRvbmUgdGhyb3VnaFxuXHQvLyBNeU9iamVjdC5uZXcuIG5ldyBpcyBhIHZlcnkgdXNlZnVsIHZhcm5hbWUuXG5cdFxuXHQvLyBXZSB3YW50IHRvIHRyZWF0IHJldHVybiBsaWtlIGFueSByZWd1bGFyIGNhbGwgZm9yIG5vd1xuXHQvLyBNdXN0IGJlIGNhcmVmdWwgdG8gdGhyb3cgdGhlIGV4Y2VwdGlvbnMgaW4gQVNULCBzaW5jZSB0aGUgcGFyc2VyXG5cdC8vIHdvbnRcblx0XG5cdC8vIEltYmEtb25seSBrZXl3b3Jkcy4gdmFyIHNob3VsZCBtb3ZlIHRvIEpTX0tleXdvcmRzXG5cdC8vIHNvbWUgd29yZHMgKGxpa2UgdG9raWQpIHNob3VsZCBiZSBjb250ZXh0LXNwZWNpZmljXG5cdHZhciBJTUJBX0tFWVdPUkRTID0gW1xuXHRcdCd1bmRlZmluZWQnLCd0aGVuJywndW5sZXNzJywndW50aWwnLCdsb29wJywnb2YnLCdieScsXG5cdFx0J3doZW4nLCdkZWYnLCd0YWcnLCdkbycsJ2VsaWYnLCdiZWdpbicsJ3ZhcicsJ2xldCcsJ3NlbGYnLCdhd2FpdCcsJ2ltcG9ydCdcblx0XTtcblx0XG5cdHZhciBJTUJBX0NPTlRFWFRVQUxfS0VZV09SRFMgPSBbJ2V4dGVuZCcsJ3N0YXRpYycsJ2xvY2FsJywnZXhwb3J0JywnZ2xvYmFsJywncHJvcCddO1xuXHRcblx0dmFyIElNQkFfQUxJQVNfTUFQID0ge1xuXHRcdCdhbmQnOiAnJiYnLFxuXHRcdCdvcic6ICd8fCcsXG5cdFx0J2lzJzogJz09Jyxcblx0XHQnaXNudCc6ICchPScsXG5cdFx0J25vdCc6ICchJyxcblx0XHQneWVzJzogJ3RydWUnLFxuXHRcdCdubyc6ICdmYWxzZScsXG5cdFx0J2lzYSc6ICdpbnN0YW5jZW9mJyxcblx0XHQnY2FzZSc6ICdzd2l0Y2gnLFxuXHRcdCduaWwnOiAnbnVsbCdcblx0fTtcblx0XG5cdHZhciBJTUJBX0FMSUFTRVMgPSBPYmplY3Qua2V5cyhJTUJBX0FMSUFTX01BUCk7XG5cdElNQkFfS0VZV09SRFMgPSBJTUJBX0tFWVdPUkRTLmNvbmNhdChJTUJBX0FMSUFTRVMpO1xuXHRcblx0Ly8gRml4ZWRBcnJheSBmb3IgcGVyZm9ybWFuY2Vcblx0Ly8gdmFyIEFMTF9LRVlXT1JEUyA9IEpTX0tFWVdPUkRTLmNvbmNhdChJTUJBX0tFWVdPUkRTKVxuXHRtb2R1bGUuZXhwb3J0cy5BTExfS0VZV09SRFMgPSBBTExfS0VZV09SRFMgPSBbXG5cdFx0J3RydWUnLCdmYWxzZScsJ251bGwnLCd0aGlzJyxcblx0XHQnZGVsZXRlJywndHlwZW9mJywnaW4nLCdpbnN0YW5jZW9mJyxcblx0XHQndGhyb3cnLCdicmVhaycsJ2NvbnRpbnVlJywnZGVidWdnZXInLFxuXHRcdCdpZicsJ2Vsc2UnLCdzd2l0Y2gnLCdmb3InLCd3aGlsZScsJ2RvJywndHJ5JywnY2F0Y2gnLCdmaW5hbGx5Jyxcblx0XHQnY2xhc3MnLCdleHRlbmRzJywnc3VwZXInLCdyZXR1cm4nLFxuXHRcdCd1bmRlZmluZWQnLCd0aGVuJywndW5sZXNzJywndW50aWwnLCdsb29wJywnb2YnLCdieScsXG5cdFx0J3doZW4nLCdkZWYnLCd0YWcnLCdkbycsJ2VsaWYnLCdiZWdpbicsJ3ZhcicsJ2xldCcsJ3NlbGYnLCdhd2FpdCcsJ2ltcG9ydCcsXG5cdFx0J2FuZCcsJ29yJywnaXMnLCdpc250Jywnbm90JywneWVzJywnbm8nLCdpc2EnLCdjYXNlJywnbmlsJ1xuXHRdO1xuXHRcblx0Ly8gVGhlIGxpc3Qgb2Yga2V5d29yZHMgdGhhdCBhcmUgcmVzZXJ2ZWQgYnkgSmF2YVNjcmlwdCwgYnV0IG5vdCB1c2VkLCBvciBhcmVcblx0Ly8gdXNlZCBieSBJbWJhIGludGVybmFsbHkuIFdlIHRocm93IGFuIGVycm9yIHdoZW4gdGhlc2UgYXJlIGVuY291bnRlcmVkLFxuXHQvLyB0byBhdm9pZCBoYXZpbmcgYSBKYXZhU2NyaXB0IGVycm9yIGF0IHJ1bnRpbWUuICAjICd2YXInLCAnbGV0JywgLSBub3QgaW5zaWRlIGhlcmVcblx0dmFyIFJFU0VSVkVEID0gWydjYXNlJywnZGVmYXVsdCcsJ2Z1bmN0aW9uJywndm9pZCcsJ3dpdGgnLCdjb25zdCcsJ2VudW0nLCduYXRpdmUnXTtcblx0dmFyIFNUUklDVF9SRVNFUlZFRCA9IFsnY2FzZScsJ2Z1bmN0aW9uJywndm9pZCcsJ2NvbnN0J107XG5cdFxuXHQvLyBUaGUgc3VwZXJzZXQgb2YgYm90aCBKYXZhU2NyaXB0IGtleXdvcmRzIGFuZCByZXNlcnZlZCB3b3Jkcywgbm9uZSBvZiB3aGljaCBtYXlcblx0Ly8gYmUgdXNlZCBhcyBpZGVudGlmaWVycyBvciBwcm9wZXJ0aWVzLlxuXHR2YXIgSlNfRk9SQklEREVOID0gSlNfS0VZV09SRFMuY29uY2F0KFJFU0VSVkVEKTtcblx0XG5cdHZhciBNRVRIT0RfSURFTlRJRklFUiA9IC9eKCgoW1xceDIzXT9bXFwkQS1aYS16X1xceDdmLVxcdWZmZmZdWyRcXC1cXHdcXHg3Zi1cXHVmZmZmXSopKFtcXD1dPykpfCg8PT58XFx8KD8hW1xcfD1dKSkpLztcblx0Ly8gcmVtb3ZlZCB+PXx+fCB8Jig/IVsmPV0pXG5cdFxuXHQvLyBUb2tlbiBtYXRjaGluZyByZWdleGVzLlxuXHQvLyBhZGRlZCBoeXBoZW5zIHRvIGlkZW50aWZpZXJzIG5vdyAtIHRvIHRlc3Rcblx0dmFyIElERU5USUZJRVIgPSAvXigoXFwkfEBAfEB8XFwjKVtcXHdBLVphLXpfXFwtXFx4N2YtXFx1ZmZmZl1bJFxcd1xceDdmLVxcdWZmZmZdKihcXC1bJFxcd1xceDdmLVxcdWZmZmZdKykqfFskQS1aYS16X11bJFxcd1xceDdmLVxcdWZmZmZdKihcXC1bJFxcd1xceDdmLVxcdWZmZmZdKykqKShbXlxcblxcU10qOig/IVtcXCpcXD06JFxcd1xceDdmLVxcdWZmZmZdKSk/Lztcblx0XG5cdHZhciBPQkpFQ1RfS0VZID0gL14oKFxcJHxAQHxAfClbJEEtWmEtel9cXHg3Zi1cXHVmZmZmXFwtXVskXFx3XFx4N2YtXFx1ZmZmZlxcLV0qKShbXlxcblxcU1xcc10qOig/IVtcXCpcXD06JFxcd1xceDdmLVxcdWZmZmZdKSkvO1xuXHRcblx0dmFyIFRBRyA9IC9eKFxcPHwlKSg/PVtBLVphLXpcXCNcXC5cXHtcXEBcXD5dKS87XG5cdFxuXHR2YXIgVEFHX1RZUEUgPSAvXihcXHdbXFx3XFxkXSo6KT8oXFx3W1xcd1xcZF0qKSgtW1xcd1xcZF0rKSovO1xuXHR2YXIgVEFHX0lEID0gL14jKChcXHdbXFx3XFxkXSopKC1bXFx3XFxkXSspKikvO1xuXHRcblx0dmFyIFRBR19BVFRSID0gL14oW1xcLlxcOl0/W1xcd1xcX10rKFtcXC1cXDpdW1xcd10rKSopKFxccykqXFw9Lztcblx0XG5cdHZhciBTRUxFQ1RPUiA9IC9eKFslXFwkXXsxLDJ9KShbXFwoXFx3XFwjXFwuXFxbXSkvO1xuXHR2YXIgU0VMRUNUT1JfUEFSVCA9IC9eKFxcI3xcXC58Onw6Oik/KFtcXHddKyhcXC1bXFx3XSspKikvO1xuXHR2YXIgU0VMRUNUT1JfQ09NQklOQVRPUiA9IC9eIChcXCt8XFw+fFxcfikqXFxzKig/PVtcXHdcXC5cXCNcXDpcXHtcXCpcXFtdKS87XG5cdFxuXHR2YXIgU0VMRUNUT1JfUFNFVURPX0NMQVNTID0gL14oOjo/KShbXFx3XSsoXFwtW1xcd10rKSopLztcblx0dmFyIFNFTEVDVE9SX0FUVFJfT1AgPSAvXihcXCQ9fFxcfj18XFxePXxcXCo9fFxcfD18PXxcXCE9KS87XG5cdHZhciBTRUxFQ1RPUl9BVFRSID0gL15cXFsoW1xcd1xcX1xcLV0rKShcXCQ9fFxcfj18XFxePXxcXCo9fFxcfD18PXxcXCE9KS87XG5cdFxuXHR2YXIgU1lNQk9MID0gL15cXDooKChbXFwqXFxAJFxcd1xceDdmLVxcdWZmZmZdKykrKFtcXC1cXFxcL1xcXFxcXDpdW1xcd1xceDdmLVxcdWZmZmZdKykqKXw9PXxcXDw9XFw+fFxcW1xcXXxcXFtcXF1cXD18XFwqfFtcXFxcLyxcXFxcXSkvO1xuXHRcblx0XG5cdHZhciBOVU1CRVIgPSAvXjB4W1xcZGEtZl0rfF4wYlswMV0rfF5cXGQqXFwuP1xcZCsoPzplWystXT9cXGQrKT8vaTtcblx0XG5cdHZhciBIRVJFRE9DID0gL14oXCJcIlwifCcnJykoW1xcc1xcU10qPykoPzpcXG5bXlxcblxcU10qKT9cXDEvO1xuXHRcblx0dmFyIE9QRVJBVE9SID0gL14oPzpbLT1dPT58PT09fC0+fCE9PXxbLSsqXFwvJTw+JnxeIT89XT18PTx8Pj4+PT98KFstKzpdKVxcMXwoWyZ8PD5dKVxcMj0/fFxcP1xcLnxcXD9cXDp8XFwuezIsM318XFwqKD89W2EtekEtWlxcX10pKS87XG5cdFxuXHQvLyBGSVhNRSBzcGxhdCBzaG91bGQgb25seSBiZSBhbGxvd2VkIHdoZW4gdGhlIHByZXZpb3VzIHRoaW5nIGlzIHNwYWNlZCBvciBpbnNpZGUgY2FsbD9cblx0XG5cdHZhciBXSElURVNQQUNFID0gL15bXlxcblxcU10rLztcblx0XG5cdHZhciBDT01NRU5UID0gL14jIyMoW14jXVtcXHNcXFNdKj8pKD86IyMjW15cXG5cXFNdKnwoPzojIyMpPyQpLztcblx0Ly8gQ09NTUVOVCAgICA9IC9eIyMjKFteI11bXFxzXFxTXSo/KSg/OiMjI1teXFxuXFxTXSp8KD86IyMjKT8kKXxeKD86XFxzKigjXFxzLip8I1xccyokKSkrL1xuXHR2YXIgSU5MSU5FX0NPTU1FTlQgPSAvXihcXHMqKSgjWyBcXHRcXCFdKC4qKXwjWyBcXHRdPyg/PVxcbnwkKSkrLztcblx0XG5cdHZhciBDT0RFID0gL15bLT1dPT4vO1xuXHRcblx0dmFyIE1VTFRJX0RFTlQgPSAvXig/OlxcblteXFxuXFxTXSopKy87XG5cdFxuXHR2YXIgU0lNUExFU1RSID0gL14nW15cXFxcJ10qKD86XFxcXC5bXlxcXFwnXSopKicvO1xuXHRcblx0dmFyIEpTVE9LRU4gPSAvXmBbXlxcXFxgXSooPzpcXFxcLlteXFxcXGBdKikqYC87XG5cdFxuXHQvLyBSZWdleC1tYXRjaGluZy1yZWdleGVzLlxuXHR2YXIgUkVHRVggPSAvXihcXC8oPyFbXFxzPV0pW15bXFwvXFxuXFxcXF0qKD86KD86XFxcXFtcXHNcXFNdfFxcW1teXFxdXFxuXFxcXF0qKD86XFxcXFtcXHNcXFNdW15cXF1cXG5cXFxcXSopKl0pW15bXFwvXFxuXFxcXF0qKSpcXC8pKFtpbWd5XXswLDR9KSg/IVxcdykvO1xuXHRcblx0dmFyIEhFUkVHRVggPSAvXlxcL3szfShbXFxzXFxTXSs/KVxcL3szfShbaW1neV17MCw0fSkoPyFcXHcpLztcblx0XG5cdHZhciBIRVJFR0VYX09NSVQgPSAvXFxzKyg/OiMuKik/L2c7XG5cdFxuXHQvLyBUb2tlbiBjbGVhbmluZyByZWdleGVzLlxuXHR2YXIgTVVMVElMSU5FUiA9IC9cXG4vZztcblx0XG5cdHZhciBIRVJFRE9DX0lOREVOVCA9IC9cXG4rKFteXFxuXFxTXSopL2c7XG5cdFxuXHR2YXIgSEVSRURPQ19JTExFR0FMID0gL1xcKlxcLy87XG5cdFxuXHQvLyBleHBlbnNpdmU/XG5cdHZhciBMSU5FX0NPTlRJTlVFUiA9IC9eXFxzKig/Oix8XFw/P1xcLig/IVsuXFxkXSl8OjopLztcblx0XG5cdHZhciBUUkFJTElOR19TUEFDRVMgPSAvXFxzKyQvO1xuXHRcblx0dmFyIENPTlNUX0lERU5USUZJRVIgPSAvXltBLVpdLztcblx0XG5cdHZhciBBUkdWQVIgPSAvXlxcJFxcZCQvO1xuXHRcblx0Ly8gQ29tcG91bmQgYXNzaWdubWVudCB0b2tlbnMuXG5cdHZhciBDT01QT1VORF9BU1NJR04gPSBbJy09JywnKz0nLCcvPScsJyo9JywnJT0nLCd8fD0nLCcmJj0nLCc/PScsJzw8PScsJz4+PScsJz4+Pj0nLCcmPScsJ149JywnfD0nLCc9PCddO1xuXHRcblx0Ly8gVW5hcnkgdG9rZW5zLlxuXHR2YXIgVU5BUlkgPSBbJyEnLCd+JywnTkVXJywnVFlQRU9GJywnREVMRVRFJ107XG5cdFxuXHQvLyBMb2dpY2FsIHRva2Vucy5cblx0dmFyIExPR0lDID0gWycmJicsJ3x8JywnJicsJ3wnLCdeJ107XG5cdFxuXHQvLyBCaXQtc2hpZnRpbmcgdG9rZW5zLlxuXHR2YXIgU0hJRlQgPSBbJzw8JywnPj4nLCc+Pj4nXTtcblx0XG5cdC8vIENvbXBhcmlzb24gdG9rZW5zLlxuXHR2YXIgQ09NUEFSRSA9IFsnPT09JywnIT09JywnPT0nLCchPScsJzwnLCc+JywnPD0nLCc+PScsJz09PScsJyE9PSddO1xuXHRcblx0Ly8gT3ZlcmlkZWFibGUgbWV0aG9kc1xuXHR2YXIgT1BfTUVUSE9EUyA9IFsnPD0+JywnPDwnLCcuLiddO1xuXHRcblx0Ly8gTWF0aGVtYXRpY2FsIHRva2Vucy5cblx0dmFyIE1BVEggPSBbJyonLCcvJywnJScsJ+KIqicsJ+KIqScsJ+KImiddO1xuXHRcblx0Ly8gUmVsYXRpb25hbCB0b2tlbnMgdGhhdCBhcmUgbmVnYXRhYmxlIHdpdGggYG5vdGAgcHJlZml4LlxuXHR2YXIgUkVMQVRJT04gPSBbJ0lOJywnT0YnLCdJTlNUQU5DRU9GJywnSVNBJ107XG5cdFxuXHQvLyBCb29sZWFuIHRva2Vucy5cblx0dmFyIEJPT0wgPSBbJ1RSVUUnLCdGQUxTRScsJ05VTEwnLCdVTkRFRklORUQnXTtcblx0XG5cdC8vIE91ciBsaXN0IGlzIHNob3J0ZXIsIGR1ZSB0byBzYW5zLXBhcmVudGhlc2VzIG1ldGhvZCBjYWxscy5cblx0dmFyIE5PVF9SRUdFWCA9IFsnTlVNQkVSJywnUkVHRVgnLCdCT09MJywnVFJVRScsJ0ZBTFNFJywnKysnLCctLScsJ10nXTtcblx0XG5cdC8vIElmIHRoZSBwcmV2aW91cyB0b2tlbiBpcyBub3Qgc3BhY2VkLCB0aGVyZSBhcmUgbW9yZSBwcmVjZWRpbmcgdG9rZW5zIHRoYXRcblx0Ly8gZm9yY2UgYSBkaXZpc2lvbiBwYXJzZTpcblx0dmFyIE5PVF9TUEFDRURfUkVHRVggPSBbJ05VTUJFUicsJ1JFR0VYJywnQk9PTCcsJ1RSVUUnLCdGQUxTRScsJysrJywnLS0nLCddJywnKScsJ30nLCdUSElTJywnU0VMRicsJ0lERU5USUZJRVInLCdTVFJJTkcnXTtcblx0XG5cdC8vIFRva2VucyB3aGljaCBjb3VsZCBsZWdpdGltYXRlbHkgYmUgaW52b2tlZCBvciBpbmRleGVkLiBBbiBvcGVuaW5nXG5cdC8vIHBhcmVudGhlc2VzIG9yIGJyYWNrZXQgZm9sbG93aW5nIHRoZXNlIHRva2VucyB3aWxsIGJlIHJlY29yZGVkIGFzIHRoZSBzdGFydFxuXHQvLyBvZiBhIGZ1bmN0aW9uIGludm9jYXRpb24gb3IgaW5kZXhpbmcgb3BlcmF0aW9uLlxuXHQvLyByZWFsbHk/IVxuXHRcblx0dmFyIFVORklOSVNIRUQgPSBbJ1xcXFwnLCcuJywnPy4nLCc/OicsJ1VOQVJZJywnTUFUSCcsJysnLCctJywnU0hJRlQnLCdSRUxBVElPTicsJ0NPTVBBUkUnLCdMT0dJQycsJ0NPTVBPVU5EX0FTU0lHTicsJ1RIUk9XJywnRVhURU5EUyddO1xuXHRcblx0Ly8gfSBzaG91bGQgbm90IGJlIGNhbGxhYmxlIGFueW1vcmUhISEgJ30nLCAnOjonLFxuXHR2YXIgQ0FMTEFCTEUgPSBbJ0lERU5USUZJRVInLCdTVFJJTkcnLCdSRUdFWCcsJyknLCddJywnVEhJUycsJ1NVUEVSJywnVEFHX0VORCcsJ0lWQVInLCdHVkFSJywnU0VMRicsJ0NPTlNUJywnTkVXJywnQVJHVkFSJywnU1lNQk9MJywnUkVUVVJOJ107XG5cdC8vIHZhciBJTkRFWEFCTEUgPSBDQUxMQUJMRS5jb25jYXQgJ05VTUJFUicsICdCT09MJywgJ1RBR19TRUxFQ1RPUicsICdJRFJFRicsICdBUkdVTUVOVFMnLCd9JyAjIGFyZSBib29sZWFucyBpbmRleGFibGU/IHJlYWxseT9cblx0Ly8gb3B0aW1pemUgZm9yIEZpeGVkQXJyYXlcblx0dmFyIElOREVYQUJMRSA9IFtcblx0XHQnSURFTlRJRklFUicsJ1NUUklORycsJ1JFR0VYJywnKScsJ10nLCdUSElTJywnU1VQRVInLCdUQUdfRU5EJywnSVZBUicsJ0dWQVInLCdTRUxGJywnQ09OU1QnLCdORVcnLCdBUkdWQVInLCdTWU1CT0wnLCdSRVRVUk4nLFxuXHRcdCdOVU1CRVInLCdCT09MJywnVEFHX1NFTEVDVE9SJywnSURSRUYnLCdBUkdVTUVOVFMnLCd9JywnVEFHX1RZUEUnXG5cdF07XG5cdFxuXHR2YXIgR0xPQkFMX0lERU5USUZJRVJTID0gWydnbG9iYWwnLCdleHBvcnRzJywncmVxdWlyZSddO1xuXHRcblx0Ly8gVG9rZW5zIHRoYXQsIHdoZW4gaW1tZWRpYXRlbHkgcHJlY2VkaW5nIGEgYFdIRU5gLCBpbmRpY2F0ZSB0aGF0IHRoZSBgV0hFTmBcblx0Ly8gb2NjdXJzIGF0IHRoZSBzdGFydCBvZiBhIGxpbmUuIFdlIGRpc2FtYmlndWF0ZSB0aGVzZSBmcm9tIHRyYWlsaW5nIHdoZW5zIHRvXG5cdC8vIGF2b2lkIGFuIGFtYmlndWl0eSBpbiB0aGUgZ3JhbW1hci5cblx0dmFyIExJTkVfQlJFQUsgPSBbJ0lOREVOVCcsJ09VVERFTlQnLCdURVJNSU5BVE9SJ107XG5cdFxuXHRcblx0ZnVuY3Rpb24gTGV4ZXJFcnJvcihtZXNzYWdlLGZpbGUsbGluZSl7XG5cdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0XHR0aGlzLmZpbGUgPSBmaWxlO1xuXHRcdHRoaXMubGluZSA9IGxpbmU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdHN1YmNsYXNzJChMZXhlckVycm9yLFN5bnRheEVycm9yKTtcblx0ZXhwb3J0cy5MZXhlckVycm9yID0gTGV4ZXJFcnJvcjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdFxuXHRmdW5jdGlvbiBsYXN0KGFycmF5LGJhY2spe1xuXHRcdGlmKGJhY2sgPT09IHVuZGVmaW5lZCkgYmFjayA9IDA7XG5cdFx0cmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIGJhY2sgLSAxXTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIGNvdW50KHN0cixzdWJzdHIpe1xuXHRcdHJldHVybiBzdHIuc3BsaXQoc3Vic3RyKS5sZW5ndGggLSAxO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gcmVwZWF0U3RyaW5nKHN0cix0aW1lcyl7XG5cdFx0dmFyIHJlcyA9ICcnO1xuXHRcdHdoaWxlICh0aW1lcyA+IDApe1xuXHRcdFx0aWYgKHRpbWVzICUgMiA9PSAxKSB7XG5cdFx0XHRcdHJlcyArPSBzdHI7XG5cdFx0XHR9O1xuXHRcdFx0c3RyICs9IHN0cjtcblx0XHRcdHRpbWVzID4+PSAxO1xuXHRcdH07XG5cdFx0cmV0dXJuIHJlcztcblx0fTtcblx0XG5cdHZhciB0VCA9IFQudHlwO1xuXHR2YXIgdFYgPSBULnZhbDtcblx0dmFyIHRUcyA9IFQuc2V0VHlwO1xuXHR2YXIgdFZzID0gVC5zZXRWYWw7XG5cdFxuXHQvLyBUaGUgTGV4ZXIgY2xhc3MgcmVhZHMgYSBzdHJlYW0gb2YgSW1iYSBhbmQgZGl2dmllcyBpdCB1cCBpbnRvIHRva2lkZ2VkXG5cdC8vIHRva2Vucy4gU29tZSBwb3RlbnRpYWwgYW1iaWd1aXR5IGluIHRoZSBncmFtbWFyIGhhcyBiZWVuIGF2b2lkZWQgYnlcblx0Ly8gcHVzaGluZyBzb21lIGV4dHJhIHNtYXJ0cyBpbnRvIHRoZSBMZXhlci5cblx0XG5cdC8vIEJhc2VkIG9uIHRoZSBvcmlnaW5hbCBsZXhlci5jb2ZmZWUgZnJvbSBDb2ZmZWVTY3JpcHRcblx0ZnVuY3Rpb24gTGV4ZXIoKXtcblx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdGV4cG9ydHMuTGV4ZXIgPSBMZXhlcjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRMZXhlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLl9jb2RlID0gbnVsbDtcblx0XHR0aGlzLl9jaHVuayA9IG51bGw7IC8vIFRoZSByZW1haW5kZXIgb2YgdGhlIHNvdXJjZSBjb2RlLlxuXHRcdHRoaXMuX29wdHMgPSBudWxsO1xuXHRcdFxuXHRcdHRoaXMuX2luZGVudCA9IDA7IC8vIFRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsLlxuXHRcdHRoaXMuX2luZGVidCA9IDA7IC8vIFRoZSBvdmVyLWluZGVudGF0aW9uIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuXHRcdHRoaXMuX291dGRlYnQgPSAwOyAvLyBUaGUgdW5kZXItb3V0ZGVudGF0aW9uIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuXHRcdFxuXHRcdHRoaXMuX2luZGVudHMgPSBbXTsgLy8gVGhlIHN0YWNrIG9mIGFsbCBjdXJyZW50IGluZGVudGF0aW9uIGxldmVscy5cblx0XHR0aGlzLl9lbmRzID0gW107IC8vIFRoZSBzdGFjayBmb3IgcGFpcmluZyB1cCB0b2tlbnMuXG5cdFx0dGhpcy5fY29udGV4dHMgPSBbXTsgLy8gc3VwbGVtZW50cyBAZW5kc1xuXHRcdHRoaXMuX3Njb3BlcyA9IFtdO1xuXHRcdHRoaXMuX25leHRTY29wZSA9IG51bGw7IC8vIHRoZSBzY29wZSB0byBhZGQgb24gdGhlIG5leHQgaW5kZW50XG5cdFx0Ly8gc2hvdWxkIHJhdGhlciBtYWtlIGl0IGxpa2UgYSBzdGF0ZW1hY2hpbmUgdGhhdCBtb3ZlcyBmcm9tIENMQVNTX0RFRiB0byBDTEFTU19CT0RZIGV0Y1xuXHRcdC8vIFRoaW5ncyBzaG91bGQgY29tcGlsZSBkaWZmZXJlbnRseSB3aGVuIHlvdSBhcmUgaW4gYSBDTEFTU19CT0RZIHRoYW4gd2hlbiBpbiBhIERFRl9CT0RZKytcblx0XHRcblx0XHR0aGlzLl90b2tlbnMgPSBbXTsgLy8gU3RyZWFtIG9mIHBhcnNlZCB0b2tlbnMgaW4gdGhlIGZvcm0gYFsnVFlQRScsIHZhbHVlLCBsaW5lXWAuXG5cdFx0dGhpcy5fc2VlbkZvciA9IGZhbHNlO1xuXHRcdHRoaXMuX2xvYyA9IDA7XG5cdFx0dGhpcy5fbG9jT2Zmc2V0ID0gMDtcblx0XHRcblx0XHR0aGlzLl9lbmQgPSBudWxsO1xuXHRcdHRoaXMuX2NoYXIgPSBudWxsO1xuXHRcdHRoaXMuX2JyaWRnZSA9IG51bGw7XG5cdFx0dGhpcy5fbGFzdCA9IG51bGw7XG5cdFx0dGhpcy5fbGFzdFR5cCA9ICcnO1xuXHRcdHRoaXMuX2xhc3RWYWwgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLmppc29uQnJpZGdlID0gZnVuY3Rpb24gKGppc29uKXtcblx0XHRyZXR1cm4gdGhpcy5fYnJpZGdlID0ge1xuXHRcdFx0bGV4OiBULmxleCxcblx0XHRcdHNldElucHV0OiBmdW5jdGlvbih0b2tlbnMpIHtcblx0XHRcdFx0dGhpcy50b2tlbnMgPSB0b2tlbnM7XG5cdFx0XHRcdHJldHVybiB0aGlzLnBvcyA9IDA7XG5cdFx0XHR9LFxuXHRcdFx0XG5cdFx0XHR1cGNvbWluZ0lucHV0OiBmdW5jdGlvbigpIHsgcmV0dXJuIFwiXCI7IH1cblx0XHR9O1xuXHR9O1xuXHRcblx0XG5cdExleGVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uIChjb2RlLG8pe1xuXHRcdFxuXHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdGlmIChjb2RlLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoIW8uaW5saW5lKSB7XG5cdFx0XHRpZiAoV0hJVEVTUEFDRS50ZXN0KGNvZGUpKSB7XG5cdFx0XHRcdGNvZGUgPSAoXCJcXG5cIiArIGNvZGUpO1xuXHRcdFx0XHRpZiAoY29kZS5tYXRjaCgvXlxccyokL2cpKSB7IHJldHVybiBbXSB9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y29kZSA9IGNvZGUucmVwbGFjZSgvXFxyL2csJycpLnJlcGxhY2UoL1tcXHQgXSskL2csJycpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5fbGFzdCA9IG51bGw7XG5cdFx0dGhpcy5fbGFzdFR5cCA9IG51bGw7XG5cdFx0dGhpcy5fbGFzdFZhbCA9IG51bGw7XG5cdFx0XG5cdFx0dGhpcy5fY29kZSA9IGNvZGU7XG5cdFx0dGhpcy5fb3B0cyA9IG87XG5cdFx0dGhpcy5fbG9jT2Zmc2V0ID0gby5sb2MgfHwgMDtcblx0XHQvLyBhZGQgYSByZWZlcmVuY2UgdG8gdGhlIG9wdGlvbnMgb2JqZWN0XG5cdFx0by5fdG9rZW5zID0gdGhpcy5fdG9rZW5zO1xuXHRcdC8vIHdoYXQgYWJvdXQgY29sIGhlcmU/XG5cdFx0XG5cdFx0Ly8gQGluZGVudCAgPSAwICMgVGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwuXG5cdFx0Ly8gQGluZGVidCAgPSAwICMgVGhlIG92ZXItaW5kZW50YXRpb24gYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG5cdFx0Ly8gQG91dGRlYnQgPSAwICMgVGhlIHVuZGVyLW91dGRlbnRhdGlvbiBhdCB0aGUgY3VycmVudCBsZXZlbC5cblx0XHQvLyBAaW5kZW50cyA9IFtdICMgVGhlIHN0YWNrIG9mIGFsbCBjdXJyZW50IGluZGVudGF0aW9uIGxldmVscy5cblx0XHQvLyBAZW5kcyAgICA9IFtdICMgVGhlIHN0YWNrIGZvciBwYWlyaW5nIHVwIHRva2Vucy5cblx0XHQvLyBAdG9rZW5zICA9IFtdICMgU3RyZWFtIG9mIHBhcnNlZCB0b2tlbnMgaW4gdGhlIGZvcm0gYFsnVFlQRScsIHZhbHVlLCBsaW5lXWAuXG5cdFx0Ly8gQGNoYXIgPSBuaWxcblx0XHRcblx0XHRpZiAoby5wcm9maWxlKSB7IGNvbnNvbGUudGltZShcInRva2VuaXplOmxleGVyXCIpIH07XG5cdFx0dGhpcy5wYXJzZShjb2RlKTtcblx0XHRpZiAoIW8uaW5saW5lKSB0aGlzLmNsb3NlSW5kZW50YXRpb24oKTtcblx0XHRpZiAoIW8uc2lsZW50ICYmIHRoaXMuX2VuZHMubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLmVycm9yKChcIm1pc3NpbmcgXCIgKyAodGhpcy5fZW5kcy5wb3AoKSkpKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChvLnByb2ZpbGUpIHsgY29uc29sZS50aW1lRW5kKFwidG9rZW5pemU6bGV4ZXJcIikgfTtcblx0XHRpZiAoby5yZXdyaXRlID09IGZhbHNlIHx8IG8ubm9yZXdyaXRlKSB7IHJldHVybiB0aGlzLl90b2tlbnMgfTtcblx0XHRyZXR1cm4gbmV3IFJld3JpdGVyKCkucmV3cml0ZSh0aGlzLl90b2tlbnMsbyk7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHZhciBwaSA9IDA7XG5cdFx0XG5cdFx0d2hpbGUgKHRoaXMuX2NodW5rID0gY29kZS5zbGljZShpKSl7XG5cdFx0XHR0aGlzLl9sb2MgPSB0aGlzLl9sb2NPZmZzZXQgKyBpO1xuXHRcdFx0cGkgPSAodGhpcy5fZW5kID09ICdUQUcnICYmIHRoaXMudGFnRGVmQ29udGV4dFRva2VuKCkpIHx8ICh0aGlzLl9pblRhZyAmJiB0aGlzLnRhZ0NvbnRleHRUb2tlbigpKSB8fCB0aGlzLmJhc2ljQ29udGV4dCgpO1xuXHRcdFx0aSArPSBwaTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5iYXNpY0NvbnRleHQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5zZWxlY3RvclRva2VuKCkgfHwgdGhpcy5zeW1ib2xUb2tlbigpIHx8IHRoaXMubWV0aG9kTmFtZVRva2VuKCkgfHwgdGhpcy5pZGVudGlmaWVyVG9rZW4oKSB8fCB0aGlzLndoaXRlc3BhY2VUb2tlbigpIHx8IHRoaXMubGluZVRva2VuKCkgfHwgdGhpcy5jb21tZW50VG9rZW4oKSB8fCB0aGlzLmhlcmVkb2NUb2tlbigpIHx8IHRoaXMudGFnVG9rZW4oKSB8fCB0aGlzLnN0cmluZ1Rva2VuKCkgfHwgdGhpcy5udW1iZXJUb2tlbigpIHx8IHRoaXMucmVnZXhUb2tlbigpIHx8IHRoaXMuanNUb2tlbigpIHx8IHRoaXMubGl0ZXJhbFRva2VuKCkgfHwgMDtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5tb3ZlQ2FyZXQgPSBmdW5jdGlvbiAoaSl7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYyArPSBpO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLmNvbnRleHQgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fZW5kc1t0aGlzLl9lbmRzLmxlbmd0aCAtIDFdO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLmluQ29udGV4dCA9IGZ1bmN0aW9uIChrZXkpe1xuXHRcdHZhciBvID0gdGhpcy5fY29udGV4dHNbdGhpcy5fY29udGV4dHMubGVuZ3RoIC0gMV07XG5cdFx0cmV0dXJuIG8gJiYgb1trZXldO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLnB1c2hFbmQgPSBmdW5jdGlvbiAodmFsKXtcblx0XHQvLyBjb25zb2xlLmxvZyBcInB1c2hpbmcgZW5kXCIsdmFsXG5cdFx0dGhpcy5fZW5kcy5wdXNoKHZhbCk7XG5cdFx0dGhpcy5fY29udGV4dHMucHVzaChudWxsKTtcblx0XHR0aGlzLl9lbmQgPSB2YWw7XG5cdFx0dGhpcy5yZWZyZXNoU2NvcGUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5wb3BFbmQgPSBmdW5jdGlvbiAodmFsKXtcblx0XHR0aGlzLl9lbmRzLnBvcCgpO1xuXHRcdHRoaXMuX2NvbnRleHRzLnBvcCgpO1xuXHRcdHRoaXMuX2VuZCA9IHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAxXTtcblx0XHR0aGlzLnJlZnJlc2hTY29wZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLnJlZnJlc2hTY29wZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBjdHgwID0gdGhpcy5fZW5kc1t0aGlzLl9lbmRzLmxlbmd0aCAtIDFdO1xuXHRcdHZhciBjdHgxID0gdGhpcy5fZW5kc1t0aGlzLl9lbmRzLmxlbmd0aCAtIDJdO1xuXHRcdHJldHVybiB0aGlzLl9pblRhZyA9IGN0eDAgPT0gJ1RBR19FTkQnIHx8IChjdHgxID09ICdUQUdfRU5EJyAmJiBjdHgwID09ICdPVVRERU5UJyk7XG5cdH07XG5cdFxuXHRcblx0XG5cdExleGVyLnByb3RvdHlwZS5xdWV1ZVNjb3BlID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0Ly8gY29uc29sZS5sb2coXCJwdXNoaW5nIHNjb3BlIHt2YWx9IC0ge0BpbmRlbnRzfSB7QGluZGVudHM6bGVuZ3RofVwiKVxuXHRcdC8vIEBzY29wZXMucHVzaCh2YWwpICMgbm8gbm9cblx0XHR0aGlzLl9zY29wZXNbdGhpcy5faW5kZW50cy5sZW5ndGhdID0gdmFsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLnBvcFNjb3BlID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0dGhpcy5fc2NvcGVzLnBvcCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLmdldFNjb3BlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3Njb3Blc1t0aGlzLl9pbmRlbnRzLmxlbmd0aCAtIDFdO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLnNjb3BlID0gZnVuY3Rpb24gKHN5bSxvcHRzKXtcblx0XHR2YXIgbGVuID0gdGhpcy5fZW5kcy5wdXNoKHRoaXMuX2VuZCA9IHN5bSk7XG5cdFx0dGhpcy5fY29udGV4dHMucHVzaChvcHRzIHx8IG51bGwpO1xuXHRcdHJldHVybiBzeW07XG5cdH07XG5cdFxuXHRcblx0TGV4ZXIucHJvdG90eXBlLmNsb3NlU2VsZWN0b3IgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fZW5kID09ICclJykge1xuXHRcdFx0dGhpcy50b2tlbignU0VMRUNUT1JfRU5EJywnJScsMCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYWlyKCclJyk7XG5cdFx0fTtcblx0fTtcblx0XG5cdFxuXHRMZXhlci5wcm90b3R5cGUub3BlbkRlZiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnB1c2hFbmQoJ0RFRicpO1xuXHR9O1xuXHRcblx0XG5cdExleGVyLnByb3RvdHlwZS5jbG9zZURlZiA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLmNvbnRleHQoKSA9PSAnREVGJykge1xuXHRcdFx0dmFyIHByZXYgPSBsYXN0KHRoaXMuX3Rva2Vucyk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImNsb3NlIGRlZiB7cHJldn1cIlxuXHRcdFx0Ly8gY29uc29sZS5sb2coJ2Nsb3NlRGVmIHdpdGggbGFzdD4nLHByZXYpXG5cdFx0XHRpZiAodFQocHJldikgPT0gJ0RFRl9GUkFHTUVOVCcpIHtcblx0XHRcdFx0dHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAodFQocHJldikgPT0gJ1RFUk1JTkFUT1InKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiaGVyZT8hPz9cIlxuXHRcdFx0XHR2YXIgbiA9IHRoaXMuX3Rva2Vucy5wb3AoKTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgblxuXHRcdFx0XHR0aGlzLnRva2VuKCdERUZfQk9EWScsJ0RFRl9CT0RZJywwKTtcblx0XHRcdFx0Ly8gdG9rZW4oJ1RFUk1JTkFUT1InLCAnJywwKSB1bmxlc3Mgbi5AdmFsdWUuaW5kZXhPZignLy8nKSA+PSAwXG5cdFx0XHRcdHRoaXMuX3Rva2Vucy5wdXNoKG4pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy50b2tlbignREVGX0JPRFknLCdERUZfQk9EWScsMCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0aGlzLnBhaXIoJ0RFRicpO1xuXHRcdH07XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLnRhZ0NvbnRleHRUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBtYXRjaDtcblx0XHRpZiAodGhpcy5fY2h1bmtbMF0gPT0gJyMnKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZygnZm91bmQgaWQgIyBpbiB0YWdDb250ZXh0VG9rZW4nKVxuXHRcdFx0dGhpcy50b2tlbignIycsJyMnLDEpO1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAobWF0Y2ggPSBUQUdfQVRUUi5leGVjKHRoaXMuX2NodW5rKSkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ1RBR19TRERTQVRUUiBJTiB0b2tpZCcsbWF0Y2hcblx0XHRcdC8vIHZhciBwcmV2ID0gbGFzdCBAdG9rZW5zXG5cdFx0XHQvLyBpZiB0aGUgcHJldiBpcyBhIHRlcm1pbmF0b3IsIHdlIGRvbnQgcmVhbGx5IG5lZWQgdG8gY2FyZT9cblx0XHRcdGlmICh0aGlzLl9sYXN0VHlwICE9ICdUQUdfTkFNRScpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2xhc3RUeXAgPT0gJ1RFUk1JTkFUT1InKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ3ByZXYgd2FzIHRlcm1pbmF0b3IgLS0gZHJvcCBpdD8nKVxuXHRcdFx0XHRcdHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy50b2tlbihcIixcIixcIixcIik7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgbCA9IG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdFxuXHRcdFx0dGhpcy50b2tlbignVEFHX0FUVFInLG1hdGNoWzFdLGwgLSAxKTsgLy8gYWRkIHRvIGxvYz9cblx0XHRcdHRoaXMuX2xvYyArPSBsIC0gMTtcblx0XHRcdHRoaXMudG9rZW4oJz0nLCc9JywxKTtcblx0XHRcdHJldHVybiBsO1xuXHRcdH07XG5cdFx0cmV0dXJuIDA7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUudGFnRGVmQ29udGV4dFRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJ0YWdDb250ZXh0VG9rZW5cIlxuXHRcdHZhciBtYXRjaDtcblx0XHRpZiAobWF0Y2ggPSBUQUdfVFlQRS5leGVjKHRoaXMuX2NodW5rKSkge1xuXHRcdFx0dGhpcy50b2tlbignVEFHX1RZUEUnLG1hdGNoWzBdLG1hdGNoWzBdLmxlbmd0aCk7XG5cdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKG1hdGNoID0gVEFHX0lELmV4ZWModGhpcy5fY2h1bmspKSB7XG5cdFx0XHR2YXIgaW5wdXQgPSBtYXRjaFswXTtcblx0XHRcdHRoaXMudG9rZW4oJ1RBR19JRCcsaW5wdXQsaW5wdXQubGVuZ3RoKTtcblx0XHRcdHJldHVybiBpbnB1dC5sZW5ndGg7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gMDtcblx0fTtcblx0XG5cdFxuXHRMZXhlci5wcm90b3R5cGUudGFnVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbWF0Y2gsIGFyeTtcblx0XHRpZiAoIShtYXRjaCA9IFRBRy5leGVjKHRoaXMuX2NodW5rKSkpIHsgcmV0dXJuIDAgfTtcblx0XHR2YXIgYXJ5ID0gaXRlciQobWF0Y2gpO3ZhciBpbnB1dCA9IGFyeVswXSx0eXBlID0gYXJ5WzFdLGlkZW50aWZpZXIgPSBhcnlbMl07XG5cdFx0XG5cdFx0aWYgKHR5cGUgPT0gJzwnKSB7XG5cdFx0XHR0aGlzLnRva2VuKCdUQUdfU1RBUlQnLCc8JywxKTtcblx0XHRcdHRoaXMucHVzaEVuZChJTlZFUlNFUy5UQUdfU1RBUlQpO1xuXHRcdFx0XG5cdFx0XHRpZiAobWF0Y2ggPSBUQUdfVFlQRS5leGVjKHRoaXMuX2NodW5rLnN1YnN0cigxLDQwKSkpIHtcblx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIHNob3VsZCBwcm9iYWJseSBiZSBoYW5kbGVkIGluIEFTVFxuXHRcdFx0XHRpZiAobWF0Y2hbMF0gIT0gJ3NlbGYnKSB7XG5cdFx0XHRcdFx0dGhpcy50b2tlbignVEFHX1RZUEUnLG1hdGNoWzBdLG1hdGNoWzBdLmxlbmd0aCwxKTtcblx0XHRcdFx0XHRyZXR1cm4gaW5wdXQubGVuZ3RoICsgbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGlkZW50aWZpZXIpIHtcblx0XHRcdFx0aWYgKGlkZW50aWZpZXIuc3Vic3RyKDAsMSkgPT0gJ3snKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHR5cGUubGVuZ3RoO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMudG9rZW4oJ1RBR19OQU1FJyxpbnB1dC5zdWJzdHIoMSksMCk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIGlucHV0Lmxlbmd0aDtcblx0fTtcblx0XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuc2VsZWN0b3JUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBhcnksIHN0cmluZztcblx0XHR2YXIgbWF0Y2g7XG5cdFx0XG5cdFx0Ly8gc3BlY2lhbCBoYW5kbGluZyBpZiB3ZSBhcmUgaW4gdGhpcyBjb250ZXh0XG5cdFx0aWYgKHRoaXMuX2VuZCA9PSAnJScpIHtcblx0XHRcdHZhciBjaHIgPSB0aGlzLl9jaHVuay5jaGFyQXQoMCk7XG5cdFx0XHR2YXIgb3BlbiA9IHRoaXMuaW5Db250ZXh0KCdvcGVuJyk7XG5cdFx0XHRcblx0XHRcdC8vIHNob3VsZCBhZGQgZm9yICssIH4gZXRjXG5cdFx0XHQvLyBzaG91bGQgbWF5YmUgcmF0aGVyIGxvb2sgZm9yIHRoZSBjb3JyZWN0IHR5cGUgb2YgY2hhcmFjdGVyP1xuXHRcdFx0XG5cdFx0XHRpZiAob3BlbiAmJiAoY2hyID09ICcgJyB8fCBjaHIgPT0gJ1xcbicgfHwgY2hyID09ICcsJyB8fCBjaHIgPT0gJysnIHx8IGNociA9PSAnficgfHwgY2hyID09ICcpJyB8fCBjaHIgPT0gJ10nKSkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImNsb3NlIHRoaXMgc2VsZWN0b3IgZGlyZWN0bHlcIlxuXHRcdFx0XHR0aGlzLnRva2VuKCdTRUxFQ1RPUl9FTkQnLCclJywwKTtcblx0XHRcdFx0dGhpcy5wYWlyKCclJyk7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKG1hdGNoID0gU0VMRUNUT1JfQ09NQklOQVRPUi5leGVjKHRoaXMuX2NodW5rKSkge1xuXHRcdFx0XHQvLyBzcGFjZXMgYmV0d2Vlbj8gLS0gaW5jbHVkZSB0aGUgd2hvbGVcblx0XHRcdFx0dGhpcy50b2tlbignU0VMRUNUT1JfQ09NQklOQVRPUicsbWF0Y2hbMV0gfHwgXCIgXCIsbWF0Y2hbMF0ubGVuZ3RoKTtcblx0XHRcdFx0cmV0dXJuIG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdH0gZWxzZSBpZiAobWF0Y2ggPSBTRUxFQ1RPUl9QQVJULmV4ZWModGhpcy5fY2h1bmspKSB7XG5cdFx0XHRcdHZhciB0eXBlID0gbWF0Y2hbMV07XG5cdFx0XHRcdHZhciBpZCA9IG1hdGNoWzJdO1xuXHRcdFx0XHRcblx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0Y2FzZSAnLic6XG5cdFx0XHRcdFx0XHR0b2tpZCA9ICdTRUxFQ1RPUl9DTEFTUyc7YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y2FzZSAnIyc6XG5cdFx0XHRcdFx0XHR0b2tpZCA9ICdTRUxFQ1RPUl9JRCc7YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y2FzZSAnOic6XG5cdFx0XHRcdFx0XHR0b2tpZCA9ICdTRUxFQ1RPUl9QU0VVRE9fQ0xBU1MnO2JyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNhc2UgJzo6Jzpcblx0XHRcdFx0XHRcdHRva2lkID0gJ1NFTEVDVE9SX1BTRVVET19DTEFTUyc7YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHZhciB0b2tpZCA9ICdTRUxFQ1RPUl9UQUcnO1xuXHRcdFx0XHRcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMudG9rZW4odG9raWQsbWF0Y2hbMl0sbWF0Y2hbMF0ubGVuZ3RoKTtcblx0XHRcdFx0cmV0dXJuIG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdH0gZWxzZSBpZiAoY2hyID09ICdbJykge1xuXHRcdFx0XHR0aGlzLnRva2VuKCdbJywnWycsMSk7XG5cdFx0XHRcdHRoaXMucHVzaEVuZCgnXScpO1xuXHRcdFx0XHRpZiAobWF0Y2ggPSBTRUxFQ1RPUl9BVFRSLmV4ZWModGhpcy5fY2h1bmspKSB7XG5cdFx0XHRcdFx0Ly8gZnVjayB0aGlzIGxlbmd0aCBzaGl0XG5cdFx0XHRcdFx0dmFyIGlkb2Zmc2V0ID0gbWF0Y2hbMF0uaW5kZXhPZihtYXRjaFsxXSk7XG5cdFx0XHRcdFx0dmFyIG9wb2Zmc2V0ID0gbWF0Y2hbMF0uaW5kZXhPZihtYXRjaFsyXSk7XG5cdFx0XHRcdFx0dGhpcy50b2tlbignSURFTlRJRklFUicsbWF0Y2hbMV0sbWF0Y2hbMV0ubGVuZ3RoLGlkb2Zmc2V0KTtcblx0XHRcdFx0XHR0aGlzLnRva2VuKCdTRUxFQ1RPUl9BVFRSX09QJyxtYXRjaFsyXSxtYXRjaFsyXS5sZW5ndGgsb3BvZmZzZXQpO1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fSBlbHNlIGlmIChjaHIgPT0gJ3wnKSB7XG5cdFx0XHRcdHZhciB0b2sgPSB0aGlzLl90b2tlbnNbdGhpcy5fdG9rZW5zLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHR0VHModG9rLCdTRUxFQ1RPUl9OUycpO1xuXHRcdFx0XHQvLyB0b2tbMF0gPSAnU0VMRUNUT1JfTlMnICMgRklYXG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fSBlbHNlIGlmIChjaHIgPT0gJywnKSB7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ1NFTEVDVE9SX0dST1VQJywnLCcsMSk7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fSBlbHNlIGlmIChjaHIgPT0gJyonKSB7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ1VOSVZFUlNBTF9TRUxFQ1RPUicsJyonLDEpO1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH0gZWxzZSBpZiAoY2hyID09ICcpJykge1xuXHRcdFx0XHR0aGlzLnBhaXIoJyUnKTtcblx0XHRcdFx0dGhpcy50b2tlbignU0VMRUNUT1JfRU5EJywnKScsMSk7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fSBlbHNlIGlmIChpZHgkKGNocixbJyknLCd9JywnXScsJyddKSA+PSAwKSB7XG5cdFx0XHRcdHRoaXMucGFpcignJScpO1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoIShtYXRjaCA9IFNFTEVDVE9SLmV4ZWModGhpcy5fY2h1bmspKSkgeyByZXR1cm4gMCB9O1xuXHRcdHZhciBhcnkgPSBpdGVyJChtYXRjaCk7dmFyIGlucHV0ID0gYXJ5WzBdLGlkID0gYXJ5WzFdLGtpbmQgPSBhcnlbMl07XG5cdFx0XG5cdFx0Ly8gdGhpcyBpcyBhIGNsb3NlZCBzZWxlY3RvclxuXHRcdGlmIChraW5kID09ICcoJykge1xuXHRcdFx0Ly8gdG9rZW4gJygnLCcoJ1xuXHRcdFx0dGhpcy50b2tlbignU0VMRUNUT1JfU1RBUlQnLGlkLGlkLmxlbmd0aCArIDEpO1xuXHRcdFx0Ly8gc2VsZi5wdXNoRW5kKCcpJykgIyBhcmUgd2Ugc28gc3VyZSBhYm91dCB0aGlzP1xuXHRcdFx0dGhpcy5wdXNoRW5kKCclJyk7XG5cdFx0XHRcblx0XHRcdC8vIEBlbmRzLnB1c2ggJyknXG5cdFx0XHQvLyBAZW5kcy5wdXNoICclJ1xuXHRcdFx0cmV0dXJuIGlkLmxlbmd0aCArIDE7XG5cdFx0fSBlbHNlIGlmIChpZCA9PSAnJScpIHtcblx0XHRcdC8vIHdlIGFyZSBhbHJlYWR5IHNjb3BlZCBpbiBvbiBhIHNlbGVjdG9yXG5cdFx0XHRpZiAodGhpcy5jb250ZXh0KCkgPT0gJyUnKSB7IHJldHVybiAxIH07XG5cdFx0XHR0aGlzLnRva2VuKCdTRUxFQ1RPUl9TVEFSVCcsaWQsaWQubGVuZ3RoKTtcblx0XHRcdC8vIHRoaXMgaXMgYSBzZXBhcmF0ZSAtIHNjb3BlLiBGdWxsIHNlbGVjdG9yIHNob3VsZCByYXRoZXIgYmUgJCwgYW5kIGtlZXAgdGhlIHNpbmdsZSBzZWxlY3RvciBhcyAlXG5cdFx0XHRcblx0XHRcdHRoaXMuc2NvcGUoJyUnLHtvcGVuOiB0cnVlfSk7XG5cdFx0XHQvLyBAZW5kcy5wdXNoICclJ1xuXHRcdFx0Ly8gbWFrZSBzdXJlIGEgdGVybWluYXRvciBicmVha3Mgb3V0XG5cdFx0XHRyZXR1cm4gaWQubGVuZ3RoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICgoaWQgPT0gJyUnIHx8IGlkID09ICckJykgJiYgWyclJywnJCcsJ0AnLCcoJywnWyddLmluZGV4T2YoY2hyKSA+PSAwKSB7XG5cdFx0XHR2YXIgaWR4ID0gMjtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHQvLyBWRVJZIHRlbXBvcmFyeSB3YXkgb2Ygc29sdmluZyB0aGlzXG5cdFx0XHRpZiAoKGNociA9PSAnJScgfHwgY2hyID09ICckJyB8fCBjaHIgPT0gJ0AnKSkge1xuXHRcdFx0XHRpZCArPSBjaHI7XG5cdFx0XHRcdGlkeCA9IDM7XG5cdFx0XHRcdGNociA9IHRoaXMuX2NodW5rLmNoYXJBdCgyKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0aWYgKGNociA9PSAnKCcpIHtcblx0XHRcdFx0aWYgKCEoc3RyaW5nID0gdGhpcy5iYWxhbmNlZFNlbGVjdG9yKHRoaXMuX2NodW5rLCcpJykpKSB7IHJldHVybiAwIH07XG5cdFx0XHRcdGlmICgwIDwgc3RyaW5nLmluZGV4T2YoJ3snLDEpKSB7XG5cdFx0XHRcdFx0dGhpcy50b2tlbignU0VMRUNUT1InLGlkKTtcblx0XHRcdFx0XHQvLyBpcyB0aGlzIGV2ZW4gdXNlZCBhbnltb3JlPyBJZiBzbyAtIHdlIG5lZWQgdG8gZml4IGl0XG5cdFx0XHRcdFx0dGhpcy5pbnRlcnBvbGF0ZVN0cmluZyhzdHJpbmcuc2xpY2UoaWR4LC0xKSk7XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZy5sZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy50b2tlbignU0VMRUNUT1InLGlkKTtcblx0XHRcdFx0XHR0aGlzLnRva2VuKCcoJywnKCcpO1xuXHRcdFx0XHRcdHRoaXMudG9rZW4oJ1NUUklORycsJ1wiJyArIHN0cmluZy5zbGljZShpZHgsLTEpICsgJ1wiJyk7XG5cdFx0XHRcdFx0dGhpcy50b2tlbignKScsJyknKTtcblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5nLmxlbmd0aDtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAoY2hyID09ICdbJykge1xuXHRcdFx0XHR0aGlzLnRva2VuKCdTRUxFQ1RPUicsaWQpO1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdFx0Ly8gdG9rZW4gJ1snLCdbJ1xuXHRcdFx0XHQvLyBAZW5kcy5wdXNoICcnXG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHR9O1xuXHRcblx0Ly8gaXMgdGhpcyByZWFsbHkgbmVlZGVkPyBTaG91bGQgYmUgcG9zc2libGUgdG9cblx0Ly8gcGFyc2UgdGhlIGlkZW50aWZpZXJzIGFuZCA9IGV0YyBpIGppc29uP1xuXHQvLyB3aGF0IGlzIHNwZWNpYWwgYWJvdXQgbWV0aG9kTmFtZVRva2VuPyByZWFsbHk/XG5cdExleGVyLnByb3RvdHlwZS5tZXRob2ROYW1lVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHQvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyBieSBhZnRlciBhIGRlZiBzaW1wbHlcblx0XHQvLyBmZXRjaGluZyBhbGwgdGhlIHdheSBhZnRlciB0aGUgZGVmIHVudGlsIGEgc3BhY2Ugb3IgKFxuXHRcdC8vIGFuZCB0aGVuIGFkZCB0aGlzIHRvIHRoZSBkZWYtdG9rZW4gaXRzZWxmIChhcyB3aXRoIGZyYWdtZW50KVxuXHRcdGlmICh0aGlzLl9jaHVuay5jaGFyQXQoMCkgPT0gJyAnKSB7IHJldHVybiAwIH07XG5cdFx0XG5cdFx0dmFyIG1hdGNoO1xuXHRcdFxuXHRcdGlmICh0aGlzLl9lbmQgPT0gJyknKSB7XG5cdFx0XHR2YXIgb3V0ZXJjdHggPSB0aGlzLl9lbmRzW3RoaXMuX2VuZHMubGVuZ3RoIC0gMl07XG5cdFx0XHQvLyB3ZWlyZCBhc3N1bXB0aW9uLCBubz9cblx0XHRcdC8vIGNvbnNvbGUubG9nICdjb250ZXh0IGlzIGluc2lkZSEhISdcblx0XHRcdGlmIChvdXRlcmN0eCA9PSAnJScgJiYgKG1hdGNoID0gVEFHX0FUVFIuZXhlYyh0aGlzLl9jaHVuaykpKSB7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ1RBR19BVFRSX1NFVCcsbWF0Y2hbMV0pO1xuXHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICghKG1hdGNoID0gTUVUSE9EX0lERU5USUZJRVIuZXhlYyh0aGlzLl9jaHVuaykpKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHRcdC8vIHZhciBwcmV2ID0gbGFzdCBAdG9rZW5zXG5cdFx0dmFyIGxlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcblx0XHR2YXIgaWQgPSBtYXRjaFswXTtcblx0XHR2YXIgbHR5cCA9IHRoaXMuX2xhc3RUeXA7XG5cdFx0dmFyIHR5cCA9ICdJREVOVElGSUVSJztcblx0XHR2YXIgcHJlID0gaWQuY2hhckF0KDApO1xuXHRcdHZhciBzcGFjZSA9IGZhbHNlO1xuXHRcdFxuXHRcdHZhciBtNCA9IG1hdGNoWzRdOyAvLyBtaWdodCBiZSBvdXQgb2YgYm91bmRzPyBzaG91bGQgcmF0aGVyIGNoZWNrIGNoYXJBdFxuXHRcdC8vIGRyb3AgbWF0Y2ggND8/XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIHRoaXMgbm90IHF1aXQgaGVyZSBpbiBwcmFjdGljYWxseSBhbGwgY2FzZXM/XG5cdFx0aWYgKCEoKGx0eXAgPT0gJy4nIHx8IGx0eXAgPT0gJ0RFRicpIHx8IChtNCA9PSAnIScgfHwgbTQgPT0gJz8nKSB8fCBtYXRjaFs1XSkpIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gYWdhaW4sIHdoeT9cblx0XHRpZiAoaWQgPT0gJ3NlbGYnIHx8IGlkID09ICd0aGlzJyB8fCBpZCA9PSAnc3VwZXInKSB7IC8vIGluIFsnU0VMRicsJ1RISVMnXVxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoaWQgPT0gJ25ldycpIHtcblx0XHRcdHR5cCA9ICdORVcnO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGlkID09ICcuLi4nICYmIFsnLCcsJygnLCdDQUxMX1NUQVJUJywnQkxPQ0tfUEFSQU1fU1RBUlQnLCdQQVJBTV9TVEFSVCddLmluZGV4T2YobHR5cCkgPj0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoaWQgPT0gJ3wnKSB7XG5cdFx0XHQvLyBoYWNreSB3YXkgdG8gaW1wbGVtZW50IHRoaXNcblx0XHRcdC8vIHdpdGggbmV3IGxleGVyIHdlJ2xsIHVzZSB7IC4uLiB9IGluc3RlYWQsIGFuZCBhc3N1bWUgb2JqZWN0LWNvbnRleHQsXG5cdFx0XHQvLyB0aGVuIGdvIGJhY2sgYW5kIGNvcnJlY3Qgd2hlbiB3ZSBzZWUgdGhlIGNvbnRleHQgaXMgaW52YWxpZFxuXHRcdFx0aWYgKGx0eXAgPT0gJygnIHx8IGx0eXAgPT0gJ0NBTExfU1RBUlQnKSB7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ0RPJywnRE8nLDApO1xuXHRcdFx0XHR0aGlzLnB1c2hFbmQoJ3wnKTtcblx0XHRcdFx0Ly8gQGVuZHMucHVzaCAnfCdcblx0XHRcdFx0dGhpcy50b2tlbignQkxPQ0tfUEFSQU1fU1RBUlQnLGlkLDEpO1xuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoO1xuXHRcdFx0fSBlbHNlIGlmIChsdHlwID09ICdETycgfHwgbHR5cCA9PSAneycpIHtcblx0XHRcdFx0Ly8gQGVuZHMucHVzaCAnfCdcblx0XHRcdFx0dGhpcy5wdXNoRW5kKCd8Jyk7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ0JMT0NLX1BBUkFNX1NUQVJUJyxpZCwxKTtcblx0XHRcdFx0cmV0dXJuIGxlbmd0aDtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fZW5kc1t0aGlzLl9lbmRzLmxlbmd0aCAtIDFdID09ICd8Jykge1xuXHRcdFx0XHR0aGlzLnRva2VuKCdCTE9DS19QQVJBTV9FTkQnLCd8JywxKTtcblx0XHRcdFx0dGhpcy5wYWlyKCd8Jyk7XG5cdFx0XHRcdHJldHVybiBsZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHQvLyB3aGFhdD9cblx0XHQvLyBjb25zb2xlLmxvZyhcIm1ldGhvZCBpZGVudGlmaWVyXCIsaWQpXG5cdFx0aWYgKChbJyYnLCdeJywnPDwnLCc8PDwnLCc+PiddLmluZGV4T2YoaWQpID49IDAgfHwgKGlkID09ICd8JyAmJiB0aGlzLmNvbnRleHQoKSAhPSAnfCcpKSkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoT1BfTUVUSE9EUy5pbmRleE9mKGlkKSA+PSAwKSB7XG5cdFx0XHRzcGFjZSA9IHRydWU7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBub3QgZXZlbiBhbnl0aGluZyB3ZSBzaG91bGQgdXNlPyE/XG5cdFx0aWYgKHByZSA9PSAnQCcpIHtcblx0XHRcdHR5cCA9ICdJVkFSJztcblx0XHR9IGVsc2UgaWYgKHByZSA9PSAnJCcpIHtcblx0XHRcdHRydWU7XG5cdFx0XHQvLyB0eXAgPSAnR1ZBUidcblx0XHR9IGVsc2UgaWYgKHByZSA9PSAnIycpIHtcblx0XHRcdHR5cCA9ICdUQUdJRCc7XG5cdFx0fSBlbHNlIGlmIChDT05TVF9JREVOVElGSUVSLnRlc3QocHJlKSB8fCBpZCA9PSAncmVxdWlyZScgfHwgaWQgPT0gJ2dsb2JhbCcgfHwgaWQgPT0gJ2V4cG9ydHMnKSB7XG5cdFx0XHQvLyByZWFsbHk/IHNlZW1zIHZlcnkgc3RyYW5nZVxuXHRcdFx0Ly8gY29uc29sZS5sb2coJ2dsb2JhbCEhJyx0eXAsaWQpXG5cdFx0XHR0eXAgPSAnQ09OU1QnO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gd2hhdCBpcyB0aGlzIHJlYWxseSBmb3I/XG5cdFx0aWYgKG1hdGNoWzVdICYmIFsnSURFTlRJRklFUicsJ0NPTlNUJywnR1ZBUicsJ0NWQVInLCdJVkFSJywnU0VMRicsJ1RISVMnLCddJywnfScsJyknLCdOVU1CRVInLCdTVFJJTkcnLCdJRFJFRiddLmluZGV4T2YobHR5cCkgPj0gMCkge1xuXHRcdFx0dGhpcy50b2tlbignLicsJy4nLDApO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy50b2tlbih0eXAsaWQsbGVuZ3RoKTtcblx0XHRcblx0XHRpZiAoc3BhY2UpIHtcblx0XHRcdHRoaXMuX2xhc3Quc3BhY2VkID0gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBsZW5ndGg7XG5cdH07XG5cdFxuXHRcblx0TGV4ZXIucHJvdG90eXBlLmluVGFnID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGxlbiA9IHRoaXMuX2VuZHMubGVuZ3RoO1xuXHRcdGlmIChsZW4gPiAwKSB7XG5cdFx0XHR2YXIgY3R4MCA9IHRoaXMuX2VuZHNbbGVuIC0gMV07XG5cdFx0XHR2YXIgY3R4MSA9IGxlbiA+IDEgPyAodGhpcy5fZW5kc1tsZW4gLSAyXSkgOiAoY3R4MCk7XG5cdFx0XHRyZXR1cm4gY3R4MCA9PSAnVEFHX0VORCcgfHwgKGN0eDEgPT0gJ1RBR19FTkQnICYmIGN0eDAgPT0gJ09VVERFTlQnKTtcblx0XHR9O1xuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5pc0tleXdvcmQgPSBmdW5jdGlvbiAoaWQpe1xuXHRcdGlmICgoaWQgPT0gJ2F0dHInIHx8IGlkID09ICdwcm9wJykpIHtcblx0XHRcdHZhciBzY29wID0gdGhpcy5nZXRTY29wZSgpO1xuXHRcdFx0dmFyIGluY2xzID0gc2NvcCA9PSAnQ0xBU1MnIHx8IHNjb3AgPT0gJ1RBRyc7XG5cdFx0XHQvLyB2YXIgc2NvcGVzID0gQGluZGVudHMubWFwKHxpbmQsaXwgQHNjb3Blc1tpXSBvciAnTk9ORScpXG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImlkIGlzIHByb3A6IHtzY29wZXMuam9pbihcIiAtPiBcIil9IHwge0BpbmRlbnRzLmpvaW4oXCIgLT4gXCIpfVwiXG5cdFx0XHRpZiAoaW5jbHMpIHsgcmV0dXJuIHRydWUgfTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBBTExfS0VZV09SRFMuaW5kZXhPZihpZCkgPj0gMDtcblx0fTtcblx0XG5cdC8vIE1hdGNoZXMgaWRlbnRpZnlpbmcgbGl0ZXJhbHM6IHZhcmlhYmxlcywga2V5d29yZHMsIG1ldGhvZCBuYW1lcywgZXRjLlxuXHQvLyBDaGVjayB0byBlbnN1cmUgdGhhdCBKYXZhU2NyaXB0IHJlc2VydmVkIHdvcmRzIGFyZW4ndCBiZWluZyB1c2VkIGFzXG5cdC8vIGlkZW50aWZpZXJzLiBCZWNhdXNlIEltYmEgcmVzZXJ2ZXMgYSBoYW5kZnVsIG9mIGtleXdvcmRzIHRoYXQgYXJlXG5cdC8vIGFsbG93ZWQgaW4gSmF2YVNjcmlwdCwgd2UncmUgY2FyZWZ1bCBub3QgdG8gdG9raWQgdGhlbSBhcyBrZXl3b3JkcyB3aGVuXG5cdC8vIHJlZmVyZW5jZWQgYXMgcHJvcGVydHkgbmFtZXMgaGVyZSwgc28geW91IGNhbiBzdGlsbCBkbyBgalF1ZXJ5LmlzKClgIGV2ZW5cblx0Ly8gdGhvdWdoIGBpc2AgbWVhbnMgYD09PWAgb3RoZXJ3aXNlLlxuXHRMZXhlci5wcm90b3R5cGUuaWRlbnRpZmllclRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGFyeTtcblx0XHR2YXIgbWF0Y2g7XG5cdFx0XG5cdFx0dmFyIGN0eDAgPSB0aGlzLl9lbmRzW3RoaXMuX2VuZHMubGVuZ3RoIC0gMV07XG5cdFx0dmFyIGN0eDEgPSB0aGlzLl9lbmRzW3RoaXMuX2VuZHMubGVuZ3RoIC0gMl07XG5cdFx0dmFyIGlubmVyY3R4ID0gY3R4MDtcblx0XHR2YXIgdHlwO1xuXHRcdHZhciByZXNlcnZlZCA9IGZhbHNlO1xuXHRcdFxuXHRcdHZhciBhZGRMb2MgPSBmYWxzZTtcblx0XHR2YXIgaW5UYWcgPSBjdHgwID09ICdUQUdfRU5EJyB8fCAoY3R4MSA9PSAnVEFHX0VORCcgJiYgY3R4MCA9PSAnT1VUREVOVCcpO1xuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nIGN0eDEsY3R4MFxuXHRcdFxuXHRcdGlmIChpblRhZyAmJiAobWF0Y2ggPSBUQUdfQVRUUi5leGVjKHRoaXMuX2NodW5rKSkpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdUQUdfQVRUUiBJTiB0b2tpZCcsbWF0Y2hcblx0XHRcdC8vIHZhciBwcmV2ID0gbGFzdCBAdG9rZW5zXG5cdFx0XHQvLyBpZiB0aGUgcHJldiBpcyBhIHRlcm1pbmF0b3IsIHdlIGRvbnQgcmVhbGx5IG5lZWQgdG8gY2FyZT9cblx0XHRcdGlmICh0aGlzLl9sYXN0VHlwICE9ICdUQUdfTkFNRScpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2xhc3RUeXAgPT0gJ1RFUk1JTkFUT1InKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ3ByZXYgd2FzIHRlcm1pbmF0b3IgLS0gZHJvcCBpdD8nKVxuXHRcdFx0XHRcdHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy50b2tlbihcIixcIixcIixcIik7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgbCA9IG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdFxuXHRcdFx0dGhpcy50b2tlbignVEFHX0FUVFInLG1hdGNoWzFdLGwgLSAxKTsgLy8gYWRkIHRvIGxvYz9cblx0XHRcdHRoaXMuX2xvYyArPSBsIC0gMTtcblx0XHRcdHRoaXMudG9rZW4oJz0nLCc9JywxKTtcblx0XHRcdHJldHVybiBsO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gc2VlIGlmIHRoaXMgaXMgYSBwbGFpbiBvYmplY3Qta2V5XG5cdFx0Ly8gd2F5IHRvbyBtdWNoIGxvZ2ljIGdvaW5nIG9uIGhlcmU/XG5cdFx0Ly8gdGhlIGFzdCBzaG91bGQgbm9ybWFsaXplIHdoZXRoZXIga2V5c1xuXHRcdC8vIGFyZSBhY2Nlc3NhYmxlIGFzIGtleXMgb3Igc3RyaW5ncyBldGNcblx0XHRpZiAobWF0Y2ggPSBPQkpFQ1RfS0VZLmV4ZWModGhpcy5fY2h1bmspKSB7XG5cdFx0XHR2YXIgaWQgPSBtYXRjaFsxXTtcblx0XHRcdHR5cCA9ICdJREVOVElGSUVSJztcblx0XHRcdFxuXHRcdFx0Ly8gRklYTUUgbG9jIG9mIGtleSBpbmNsdWRlcyBjb2xvblxuXHRcdFx0Ly8gbW92ZUNhcmV0KGlkOmxlbmd0aClcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwib2tcIlxuXHRcdFx0aWYgKHRydWUpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJnb3QgaGVyZT8ge21hdGNofVwiXG5cdFx0XHRcdHRoaXMudG9rZW4odHlwLGlkLGlkLmxlbmd0aCk7XG5cdFx0XHRcdHRoaXMubW92ZUNhcmV0KGlkLmxlbmd0aCk7XG5cdFx0XHRcdHRoaXMudG9rZW4oJzonLCc6JyxtYXRjaFszXS5sZW5ndGgpO1xuXHRcdFx0XHR0aGlzLm1vdmVDYXJldCgtaWQubGVuZ3RoKTtcblx0XHRcdFx0Ly8gbW92ZUNhcmV0KG1hdGNoWzNdOmxlbmd0aClcblx0XHRcdFx0cmV0dXJuIG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIG1vdmVDYXJldChtYXRjaFsyXTpsZW5ndGgpXG5cdFx0XHQvLyByZXR1cm4gMFxuXHRcdFx0Y29uc29sZS5sb2cobWF0Y2hbM10ubGVuZ3RoKTtcblx0XHRcdHRoaXMudG9rZW4odHlwLGlkLG1hdGNoWzBdLmxlbmd0aCk7XG5cdFx0XHR0aGlzLnRva2VuKCc6JywnOicsMSk7XG5cdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKCEobWF0Y2ggPSBJREVOVElGSUVSLmV4ZWModGhpcy5fY2h1bmspKSkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgYXJ5ID0gaXRlciQobWF0Y2gpO3ZhciBpbnB1dCA9IGFyeVswXSxpZCA9IGFyeVsxXSx0eXAgPSBhcnlbMl0sbTMgPSBhcnlbM10sbTQgPSBhcnlbNF0sY29sb24gPSBhcnlbNV07XG5cdFx0dmFyIGlkbGVuID0gaWQubGVuZ3RoO1xuXHRcdFxuXHRcdC8vIFdoYXQgaXMgdGhlIGxvZ2ljIGhlcmU/XG5cdFx0aWYgKGlkID09ICdvd24nICYmIHRoaXMubGFzdFRva2VuVHlwZSgpID09ICdGT1InKSB7XG5cdFx0XHR0aGlzLnRva2VuKCdPV04nLGlkLGlkLmxlbmd0aCk7XG5cdFx0XHRyZXR1cm4gaWQubGVuZ3RoO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHByZXYgPSBsYXN0KHRoaXMuX3Rva2Vucyk7XG5cdFx0dmFyIGxhc3RUeXAgPSB0aGlzLl9sYXN0VHlwO1xuXHRcdFxuXHRcdC8vIHNob3VsZCB3ZSBmb3JjZSB0aGlzIHRvIGJlIGFuIGlkZW50aWZpZXIgZXZlbiBpZiBpdCBpcyBhIHJlc2VydmVkIHdvcmQ/XG5cdFx0Ly8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gZm9yIHdoZW4gcGFydCBvZiBvYmplY3QgZXRjXG5cdFx0Ly8gd2lsbCBwcmV2IGV2ZXIgYmUgQD8/P1xuXHRcdHZhciBmb3JjZWRJZGVudGlmaWVyO1xuXHRcdFxuXHRcdC8vIGFnYWluXG5cdFx0Zm9yY2VkSWRlbnRpZmllciA9IGNvbG9uIHx8IGxhc3RUeXAgPT0gJy4nIHx8IGxhc3RUeXAgPT0gJz8uJzsgLy8gaW4gWycuJywgJz8uJ1xuXHRcdFxuXHRcdFxuXHRcdC8vIHRlbXAgaGFjayEgbmVlZCB0byBzb2x2ZSBmb3Igb3RoZXIga2V5d29yZHMgZXRjIGFzIHdlbGxcblx0XHQvLyBwcm9ibGVtIGFwcGVhcnMgd2l0aCB0ZXJuYXJ5IGNvbmRpdGlvbnMuXG5cdFx0XG5cdFx0Ly8gd2VsbCAtLSBpdCBzaG91bGQgc3RpbGwgYmUgYW4gaW5kZW50aWZpZXIgaWYgaW4gb2JqZWN0P1xuXHRcdC8vIGZvcmNlZElkZW50aWZpZXIgPSBubyBpZiBpZCBpbiBbJ3VuZGVmaW5lZCcsJ2JyZWFrJ11cblx0XHRcblx0XHRpZiAoY29sb24gJiYgbGFzdFR5cCA9PSAnPycpIHsgZm9yY2VkSWRlbnRpZmllciA9IGZhbHNlIH07IC8vIGZvciB0ZXJuYXJ5XG5cdFx0XG5cdFx0Ly8gaWYgd2UgYXJlIG5vdCBhdCB0aGUgdG9wIGxldmVsPyAtLSBoYWNreVxuXHRcdGlmIChpZCA9PSAndGFnJyAmJiB0aGlzLl9jaHVuay5pbmRleE9mKFwidGFnKFwiKSA9PSAwKSB7IC8vIEBjaHVuay5tYXRjaCgvXnRva2lkXFwoLylcblx0XHRcdGZvcmNlZElkZW50aWZpZXIgPSB0cnVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGlzS2V5d29yZCA9IGZhbHNlO1xuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nIFwibWF0Y2hcIixtYXRjaFxuXHRcdC8vIGNvbnNvbGUubG9nIFwidHlwIGlzIHt0eXB9XCJcblx0XHQvLyBsaXR0bGUgcmVhc29uIHRvIGNoZWNrIGZvciB0aGlzIHJpZ2h0IGhlcmU/IGJ1dCBJIGd1ZXNzIGl0IGlzIG9ubHkgYSBzaW1wbGUgY2hlY2tcblx0XHRpZiAodHlwID09ICckJyAmJiBBUkdWQVIudGVzdChpZCkpIHsgLy8gaWQubWF0Y2goL15cXCRcXGQkLylcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiVFlQICRcIlxuXHRcdFx0aWYgKGlkID09ICckMCcpIHtcblx0XHRcdFx0dHlwID0gJ0FSR1VNRU5UUyc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0eXAgPSAnQVJHVkFSJztcblx0XHRcdFx0aWQgPSBpZC5zdWJzdHIoMSk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAodHlwID09ICdAJykge1xuXHRcdFx0dHlwID0gJ0lWQVInO1xuXHRcdFx0XG5cdFx0XHQvLyBpZDpyZXNlcnZlZCA9IHllcyBpZiBjb2xvblxuXHRcdH0gZWxzZSBpZiAodHlwID09ICcjJykge1xuXHRcdFx0Ly8gd2UgYXJlIHRyeWluZyB0byBtb3ZlIHRvIGdlbmVyaWMgdG9rZW5zLFxuXHRcdFx0Ly8gc28gd2UgYXJlIHN0YXJ0aW5nIHRvIHNwbGl0dGluZyB1cCB0aGUgc3ltYm9scyBhbmQgdGhlIGl0ZW1zXG5cdFx0XHQvLyB3ZSdsbCBzZWUgaWYgdGhhdCB3b3Jrc1xuXHRcdFx0dHlwID0gJ0lERU5USUZJRVInO1xuXHRcdFx0dGhpcy50b2tlbignIycsJyMnKTtcblx0XHRcdGlkID0gaWQuc3Vic3RyKDEpO1xuXHRcdH0gZWxzZSBpZiAodHlwID09ICdAQCcpIHtcblx0XHRcdHR5cCA9ICdDVkFSJztcblx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnJCcgJiYgIWNvbG9uKSB7XG5cdFx0XHR0eXAgPSAnSURFTlRJRklFUic7XG5cdFx0XHQvLyB0eXAgPSAnR1ZBUidcblx0XHR9IGVsc2UgaWYgKENPTlNUX0lERU5USUZJRVIudGVzdChpZCkgfHwgaWQgPT0gJ3JlcXVpcmUnIHx8IGlkID09ICdnbG9iYWwnIHx8IGlkID09ICdleHBvcnRzJykge1xuXHRcdFx0Ly8gdGhvdXMgc2hvdWxkIHJlYWxseSBiZSBoYW5kbGVkIGJ5IHRoZSBhc3QgaW5zdGVhZFxuXHRcdFx0dHlwID0gJ0NPTlNUJztcblx0XHR9IGVsc2UgaWYgKGlkID09ICdlbGlmJykge1xuXHRcdFx0dGhpcy50b2tlbignRUxTRScsJ2VsaWYnLGlkLmxlbmd0aCk7XG5cdFx0XHR0aGlzLnRva2VuKCdJRicsJ2lmJyk7XG5cdFx0XHRyZXR1cm4gaWQubGVuZ3RoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0eXAgPSAnSURFTlRJRklFUic7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRcblx0XHQvLyB0aGlzIGNhdGNoZXMgYWxsIFxuXHRcdGlmICghZm9yY2VkSWRlbnRpZmllciAmJiAoaXNLZXl3b3JkID0gdGhpcy5pc0tleXdvcmQoaWQpKSkge1xuXHRcdFx0Ly8gKGlkIGluIEpTX0tFWVdPUkRTIG9yIGlkIGluIElNQkFfS0VZV09SRFMpXG5cdFx0XHR0eXAgPSBpZC50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0YWRkTG9jID0gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0Ly8gY2x1bXN5IC0gYnV0IHRlc3RpbmcgcGVyZm9ybWFuY2Vcblx0XHRcdGlmICh0eXAgPT0gJ1lFUycpIHtcblx0XHRcdFx0dHlwID0gJ1RSVUUnO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ05PJykge1xuXHRcdFx0XHR0eXAgPSAnRkFMU0UnO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ05JTCcpIHtcblx0XHRcdFx0dHlwID0gJ05VTEwnO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ1ZBUicpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2xhc3RWYWwgPT0gJ2V4cG9ydCcpIHtcblx0XHRcdFx0XHR0VHMocHJldiwnRVhQT1JUJyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnSUYnIHx8IHR5cCA9PSAnRUxTRScgfHwgdHlwID09ICdUUlVFJyB8fCB0eXAgPT0gJ0ZBTFNFJyB8fCB0eXAgPT0gJ05VTEwnKSB7XG5cdFx0XHRcdHRydWU7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnVEFHJykge1xuXHRcdFx0XHR0aGlzLnB1c2hFbmQoJ1RBRycpO1xuXHRcdFx0XHQvLyBAZW5kcy5wdXNoKCdUQUcnKVxuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ0RFRicpIHtcblx0XHRcdFx0Ly8gc2hvdWxkIHByb2JhYmx5IHNoaWZ0IGNvbnRleHQgYW5kIG9wdGltaXplIHRoaXNcblx0XHRcdFx0dGhpcy5vcGVuRGVmKCk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnRE8nKSB7XG5cdFx0XHRcdGlmICh0aGlzLmNvbnRleHQoKSA9PSAnREVGJykgdGhpcy5jbG9zZURlZigpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ1dIRU4nICYmIExJTkVfQlJFQUsuaW5kZXhPZih0aGlzLmxhc3RUb2tlblR5cGUoKSkgPj0gMCkge1xuXHRcdFx0XHR0eXAgPSAnTEVBRElOR19XSEVOJztcblx0XHRcdH0gZWxzZSBpZiAodHlwID09ICdGT1InKSB7XG5cdFx0XHRcdHRoaXMuX3NlZW5Gb3IgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmICh0eXAgPT0gJ1VOTEVTUycpIHtcblx0XHRcdFx0dHlwID0gJ0lGJzsgLy8gV0FSTlxuXHRcdFx0fSBlbHNlIGlmIChVTkFSWS5pbmRleE9mKHR5cCkgPj0gMCkge1xuXHRcdFx0XHR0eXAgPSAnVU5BUlknO1xuXHRcdFx0fSBlbHNlIGlmIChSRUxBVElPTi5pbmRleE9mKHR5cCkgPj0gMCkge1xuXHRcdFx0XHRpZiAodHlwICE9ICdJTlNUQU5DRU9GJyAmJiB0eXAgIT0gJ0lTQScgJiYgdGhpcy5fc2VlbkZvcikge1xuXHRcdFx0XHRcdHR5cCA9ICdGT1InICsgdHlwOyAvLyA/XG5cdFx0XHRcdFx0dGhpcy5fc2VlbkZvciA9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHR5cCA9ICdSRUxBVElPTic7XG5cdFx0XHRcdFx0aWYgKFN0cmluZyh0aGlzLnZhbHVlKCkpID09ICchJykge1xuXHRcdFx0XHRcdFx0dGhpcy5fdG9rZW5zLnBvcCgpOyAvLyBpcyBmdWNrZWQgdXA/PyFcblx0XHRcdFx0XHRcdC8vIFdBUk4gd2UgbmVlZCB0byBrZWVwIHRoZSBsb2MsIG5vP1xuXHRcdFx0XHRcdFx0aWQgPSAnIScgKyBpZDtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmIChpZCA9PSAnc3VwZXInKSB7XG5cdFx0XHR0eXAgPSAnU1VQRVInO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gZG8gd2UgcmVhbGx5IHdhbnQgdG8gY2hlY2sgdGhpcyBoZXJlXG5cdFx0aWYgKCFmb3JjZWRJZGVudGlmaWVyKSB7XG5cdFx0XHQvLyBzaG91bGQgYWxyZWFkeSBoYXZlIGRlYWx0IHdpdGggdGhpc1xuXHRcdFx0XG5cdFx0XHRpZiAoaXNLZXl3b3JkICYmIElNQkFfQUxJQVNFUy5pbmRleE9mKGlkKSA+PSAwKSB7IGlkID0gSU1CQV9BTElBU19NQVBbaWRdIH07XG5cdFx0XHQvLyB0aGVzZSByZWFsbHkgc2hvdWxkIG5vdCBnbyBoZXJlPyE/XG5cdFx0XHRzd2l0Y2ggKGlkKSB7XG5cdFx0XHRcdGNhc2UgJyEnOlxuXHRcdFx0XHRcdHR5cCA9ICdVTkFSWSc7YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRjYXNlICc9PSc6XG5cdFx0XHRcdGNhc2UgJyE9Jzpcblx0XHRcdFx0Y2FzZSAnPT09Jzpcblx0XHRcdFx0Y2FzZSAnIT09Jzpcblx0XHRcdFx0XHR0eXAgPSAnQ09NUEFSRSc7YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRjYXNlICcmJic6XG5cdFx0XHRcdGNhc2UgJ3x8Jzpcblx0XHRcdFx0XHR0eXAgPSAnTE9HSUMnO2JyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0Y2FzZSAnYnJlYWsnOlxuXHRcdFx0XHRjYXNlICdjb250aW51ZSc6XG5cdFx0XHRcdGNhc2UgJ2RlYnVnZ2VyJzpcblx0XHRcdFx0Y2FzZSAnYXJndW1lbnRzJzpcblx0XHRcdFx0XHR0eXAgPSBpZC50b1VwcGVyQ2FzZSgpO2JyZWFrO1xuXHRcdFx0XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gcHJldiA9IGxhc3QgQHRva2Vuc1xuXHRcdHZhciBsZW4gPSBpbnB1dC5sZW5ndGg7XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIGJlIHN0cmljdCBhYm91dCB0aGUgb3JkZXIsIGNoZWNrIHRoaXMgbWFudWFsbHkgaW5zdGVhZFxuXHRcdGlmICh0eXAgPT0gJ0NMQVNTJyB8fCB0eXAgPT0gJ0RFRicgfHwgdHlwID09ICdUQUcnKSB7XG5cdFx0XHR0aGlzLnF1ZXVlU2NvcGUodHlwKTtcblx0XHRcdFxuXHRcdFx0dmFyIGkgPSB0aGlzLl90b2tlbnMubGVuZ3RoO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAoaSl7XG5cdFx0XHRcdHByZXYgPSB0aGlzLl90b2tlbnNbLS1pXTtcblx0XHRcdFx0dmFyIGN0cmwgPSBcIlwiICsgdFYocHJldik7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiY3RybCBpcyB7Y3RybH1cIilcblx0XHRcdFx0Ly8gbmVlZCB0byBjb2VyY2UgdG8gc3RyaW5nIGJlY2F1c2Ugb2Ygc3R1cGlkIENTID09PVxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcInByZXYgaXNcIixwcmV2WzBdLHByZXZbMV0pXG5cdFx0XHRcdGlmIChpZHgkKGN0cmwsSU1CQV9DT05URVhUVUFMX0tFWVdPUkRTKSA+PSAwKSB7XG5cdFx0XHRcdFx0dFRzKHByZXYsY3RybC50b1VwcGVyQ2FzZSgpKTtcblx0XHRcdFx0XHQvLyBwcmV2WzBdID0gY3RybC50b1VwcGVyQ2FzZSAjIEZJWFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnSUYnKSB7XG5cdFx0XHR0aGlzLnF1ZXVlU2NvcGUodHlwKTtcblx0XHR9IGVsc2UgaWYgKHR5cCA9PSAnSU1QT1JUJykge1xuXHRcdFx0Ly8gY291bGQgbWFudWFsbHkgcGFyc2UgdGhlIHdob2xlIHRpbmcgaGVyZT9cblx0XHRcdHRoaXMucHVzaEVuZCgnSU1QT1JUJyk7XG5cdFx0XHQvLyBAZW5kcy5wdXNoICdJTVBPUlQnXG5cdFx0fSBlbHNlIGlmIChpZCA9PSAnZnJvbScgJiYgY3R4MCA9PSAnSU1QT1JUJykge1xuXHRcdFx0dHlwID0gJ0ZST00nO1xuXHRcdFx0dGhpcy5wYWlyKCdJTVBPUlQnKTtcblx0XHR9IGVsc2UgaWYgKGlkID09ICdhcycgJiYgY3R4MCA9PSAnSU1QT1JUJykge1xuXHRcdFx0dHlwID0gJ0FTJztcblx0XHRcdHRoaXMucGFpcignSU1QT1JUJyk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAodHlwID09ICdJREVOVElGSUVSJykge1xuXHRcdFx0Ly8gc2VlIGlmIHByZXZpb3VzIHdhcyBjYXRjaCAtLSBiZWxvbmdzIGluIHJld3JpdGVyP1xuXHRcdFx0aWYgKGxhc3RUeXAgPT0gJ0NBVENIJykge1xuXHRcdFx0XHR0eXAgPSAnQ0FUQ0hfVkFSJztcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoY29sb24pIHtcblx0XHRcdHRoaXMudG9rZW4odHlwLGlkLGlkbGVuKTtcblx0XHRcdHRoaXMubW92ZUNhcmV0KGlkbGVuKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiYWRkIGNvbG9uP1wiXG5cdFx0XHR0aGlzLnRva2VuKCc6JywnOicsY29sb24ubGVuZ3RoKTtcblx0XHRcdHRoaXMubW92ZUNhcmV0KC1pZGxlbik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudG9rZW4odHlwLGlkLGlkbGVuKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBsZW47XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIG51bWJlcnMsIGluY2x1ZGluZyBkZWNpbWFscywgaGV4LCBhbmQgZXhwb25lbnRpYWwgbm90YXRpb24uXG5cdC8vIEJlIGNhcmVmdWwgbm90IHRvIGludGVyZmVyZSB3aXRoIHJhbmdlcy1pbi1wcm9ncmVzcy5cblx0TGV4ZXIucHJvdG90eXBlLm51bWJlclRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGJpbmFyeUxpdGVyYWw7XG5cdFx0dmFyIG1hdGNoLG51bWJlcixsZXhlZExlbmd0aDtcblx0XHRcblx0XHRpZiAoIShtYXRjaCA9IE5VTUJFUi5leGVjKHRoaXMuX2NodW5rKSkpIHsgcmV0dXJuIDAgfTtcblx0XHRcblx0XHRudW1iZXIgPSBtYXRjaFswXTtcblx0XHRsZXhlZExlbmd0aCA9IG51bWJlci5sZW5ndGg7XG5cdFx0XG5cdFx0aWYgKGJpbmFyeUxpdGVyYWwgPSAvMGIoWzAxXSspLy5leGVjKG51bWJlcikpIHtcblx0XHRcdFxuXHRcdFx0bnVtYmVyID0gXCJcIiArIHBhcnNlSW50KGJpbmFyeUxpdGVyYWxbMV0sMik7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgcHJldiA9IGxhc3QodGhpcy5fdG9rZW5zKTtcblx0XHRcblx0XHRpZiAobWF0Y2hbMF1bMF0gPT0gJy4nICYmIHByZXYgJiYgIXByZXYuc3BhY2VkICYmIFsnSURFTlRJRklFUicsJyknLCd9JywnXScsJ05VTUJFUiddLmluZGV4T2YodFQocHJldikpID49IDApIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwiZ290IGhlcmVcIlxuXHRcdFx0dGhpcy50b2tlbihcIi5cIixcIi5cIik7XG5cdFx0XHRudW1iZXIgPSBudW1iZXIuc3Vic3RyKDEpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0dGhpcy50b2tlbignTlVNQkVSJyxudW1iZXIsbGV4ZWRMZW5ndGgpO1xuXHRcdHJldHVybiBsZXhlZExlbmd0aDtcblx0fTtcblx0XG5cdExleGVyLnByb3RvdHlwZS5zeW1ib2xUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBtYXRjaCxzeW1ib2wscHJldjtcblx0XHRcblx0XHRpZiAoIShtYXRjaCA9IFNZTUJPTC5leGVjKHRoaXMuX2NodW5rKSkpIHsgcmV0dXJuIDAgfTtcblx0XHRzeW1ib2wgPSBtYXRjaFswXS5zdWJzdHIoMSk7XG5cdFx0cHJldiA9IGxhc3QodGhpcy5fdG9rZW5zKTtcblx0XHRcblx0XHQvLyBpcyB0aGlzIGEgcHJvcGVydHktYWNjZXNzP1xuXHRcdC8vIHNob3VsZCBpbnZlcnQgdGhpcyAtLSBvbmx5IGFsbG93IHdoZW4gcHJldiBJUyAuLiBcblx0XHRcblx0XHQvLyA6IHNob3VsZCBiZSBhIHRva2VuIGl0c2VsZiwgd2l0aCBhIHNwZWNpZmljYXRpb24gb2Ygc3BhY2luZyAoTFIsUixMLE5PTkUpXG5cdFx0XG5cdFx0Ly8gRklYXG5cdFx0aWYgKHByZXYgJiYgIXByZXYuc3BhY2VkICYmIGlkeCQodFQocHJldiksWycoJywneycsJ1snLCcuJywnQ0FMTF9TVEFSVCcsJ0lOREVYX1NUQVJUJywnLCcsJz0nLCdJTkRFTlQnLCdURVJNSU5BVE9SJ10pID09IC0xKSB7XG5cdFx0XHR0aGlzLnRva2VuKCcuOicsJzonLDEpO1xuXHRcdFx0dmFyIHN5bSA9IHN5bWJvbC5zcGxpdCgvW1xcOlxcXFxcXC9dLylbMF07IC8vIHJlYWxseT9cblx0XHRcdC8vIHRva2VuICdTWU1CT0wnLCBcIicje3N5bWJvbH0nXCJcblx0XHRcdHRoaXMudG9rZW4oJ0lERU5USUZJRVInLHN5bSxzeW0ubGVuZ3RoLDEpO1xuXHRcdFx0cmV0dXJuIChzeW0ubGVuZ3RoICsgMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHRva2VuICdTWU1CT0wnLCBcIicje3N5bWJvbH0nXCJcblx0XHRcdHRoaXMudG9rZW4oJ1NZTUJPTCcsc3ltYm9sLG1hdGNoWzBdLmxlbmd0aCk7XG5cdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdH07XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuZXNjYXBlU3RyID0gZnVuY3Rpb24gKHN0cixoZXJlZG9jLHEpe1xuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKE1VTFRJTElORVIsKGhlcmVkb2MgPyAoJ1xcXFxuJykgOiAoJycpKSk7XG5cdFx0aWYgKHEpIHtcblx0XHRcdHZhciByID0gUmVnRXhwKChcIlxcXFxcXFxcW1wiICsgcSArIFwiXVwiKSxcImdcIik7XG5cdFx0XHRzdHIgPSBzdHIucmVwbGFjZShyLHEpO1xuXHRcdFx0c3RyID0gc3RyLnJlcGxhY2UoUmVnRXhwKChcIlwiICsgcSksXCJnXCIpLCdcXFxcJCYnKTtcblx0XHR9O1xuXHRcdHJldHVybiBzdHI7XG5cdFx0XG5cdFx0Ly8gc3RyID0gc3RyLnJlcGxhY2UoTVVMVElMSU5FUiwgJ1xcXFxuJylcblx0XHQvLyBzdHIgPSBzdHIucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpXG5cdH07XG5cdC8vIE1hdGNoZXMgc3RyaW5ncywgaW5jbHVkaW5nIG11bHRpLWxpbmUgc3RyaW5ncy4gRW5zdXJlcyB0aGF0IHF1b3RhdGlvbiBtYXJrc1xuXHQvLyBhcmUgYmFsYW5jZWQgd2l0aGluIHRoZSBzdHJpbmcncyBjb250ZW50cywgYW5kIHdpdGhpbiBuZXN0ZWQgaW50ZXJwb2xhdGlvbnMuXG5cdExleGVyLnByb3RvdHlwZS5zdHJpbmdUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBtYXRjaCxzdHJpbmc7XG5cdFx0XG5cdFx0c3dpdGNoICh0aGlzLl9jaHVuay5jaGFyQXQoMCkpIHtcblx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdGlmICghKG1hdGNoID0gU0lNUExFU1RSLmV4ZWModGhpcy5fY2h1bmspKSkgeyByZXR1cm4gMCB9O1xuXHRcdFx0XHRzdHJpbmcgPSBtYXRjaFswXTtcblx0XHRcdFx0dGhpcy50b2tlbignU1RSSU5HJyx0aGlzLmVzY2FwZVN0cihzdHJpbmcpLHN0cmluZy5sZW5ndGgpO1xuXHRcdFx0XHQvLyB0b2tlbiAnU1RSSU5HJywgKHN0cmluZyA9IG1hdGNoWzBdKS5yZXBsYWNlKE1VTFRJTElORVIsICdcXFxcXFxuJyksIHN0cmluZzpsZW5ndGhcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcblx0XHRcdGNhc2UgJ1wiJzpcblx0XHRcdFx0aWYgKCEoc3RyaW5nID0gdGhpcy5iYWxhbmNlZFN0cmluZyh0aGlzLl9jaHVuaywnXCInKSkpIHsgcmV0dXJuIDAgfTtcblx0XHRcdFx0Ly8gd2hhdCBhYm91dCB0cmlwZSBxdW90ZWQgc3RyaW5ncz9cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChzdHJpbmcuaW5kZXhPZigneycpID49IDApIHtcblx0XHRcdFx0XHR2YXIgbGVuID0gc3RyaW5nLmxlbmd0aDtcblx0XHRcdFx0XHQvLyBpZiB0aGlzIGhhcyBubyBpbnRlcnBvbGF0aW9uP1xuXHRcdFx0XHRcdC8vIHdlIGFyZSBub3cgbWVzc2luZyB3aXRoIGxvY2F0aW9ucyAtIGJld2FyZVxuXHRcdFx0XHRcdHRoaXMudG9rZW4oJ1NUUklOR19TVEFSVCcsc3RyaW5nLmNoYXJBdCgwKSwxKTtcblx0XHRcdFx0XHR0aGlzLmludGVycG9sYXRlU3RyaW5nKHN0cmluZy5zbGljZSgxLC0xKSk7XG5cdFx0XHRcdFx0dGhpcy50b2tlbignU1RSSU5HX0VORCcsc3RyaW5nLmNoYXJBdChsZW4gLSAxKSwxLHN0cmluZy5sZW5ndGggLSAxKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsZW4gPSBzdHJpbmcubGVuZ3RoO1xuXHRcdFx0XHRcdC8vIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKE1VTFRJTElORVIsICdcXFxcXFxuJylcblx0XHRcdFx0XHR0aGlzLnRva2VuKCdTVFJJTkcnLHRoaXMuZXNjYXBlU3RyKHN0cmluZyksbGVuKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLm1vdmVIZWFkKHN0cmluZyk7XG5cdFx0cmV0dXJuIHN0cmluZy5sZW5ndGg7XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIGhlcmVkb2NzLCBhZGp1c3RpbmcgaW5kZW50YXRpb24gdG8gdGhlIGNvcnJlY3QgbGV2ZWwsIGFzIGhlcmVkb2NzXG5cdC8vIHByZXNlcnZlIHdoaXRlc3BhY2UsIGJ1dCBpZ25vcmUgaW5kZW50YXRpb24gdG8gdGhlIGxlZnQuXG5cdExleGVyLnByb3RvdHlwZS5oZXJlZG9jVG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbWF0Y2gsaGVyZWRvYyxxdW90ZSxkb2M7XG5cdFx0XG5cdFx0aWYgKCEobWF0Y2ggPSBIRVJFRE9DLmV4ZWModGhpcy5fY2h1bmspKSkgeyByZXR1cm4gMCB9O1xuXHRcdFxuXHRcdGhlcmVkb2MgPSBtYXRjaFswXTtcblx0XHRxdW90ZSA9IGhlcmVkb2MuY2hhckF0KDApO1xuXHRcdGRvYyA9IHRoaXMuc2FuaXRpemVIZXJlZG9jKG1hdGNoWzJdLHtxdW90ZTogcXVvdGUsaW5kZW50OiBudWxsfSk7XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJmb3VuZCBoZXJlZG9jIHttYXRjaFswXTpsZW5ndGh9IHtkb2M6bGVuZ3RofVwiXG5cdFx0XG5cdFx0aWYgKHF1b3RlID09ICdcIicgJiYgZG9jLmluZGV4T2YoJ3snKSA+PSAwKSB7XG5cdFx0XHR2YXIgb3BlbiA9IG1hdGNoWzFdO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgZG9jLnN1YnN0cigwLDMpLG1hdGNoWzFdXG5cdFx0XHR0aGlzLnRva2VuKCdTVFJJTkdfU1RBUlQnLG9wZW4sb3Blbi5sZW5ndGgpO1xuXHRcdFx0dGhpcy5pbnRlcnBvbGF0ZVN0cmluZyhkb2Mse2hlcmVkb2M6IHRydWUsb2Zmc2V0OiBvcGVuLmxlbmd0aCxxdW90ZTogcXVvdGV9KTtcblx0XHRcdHRoaXMudG9rZW4oJ1NUUklOR19FTkQnLG9wZW4sb3Blbi5sZW5ndGgsaGVyZWRvYy5sZW5ndGggLSBvcGVuLmxlbmd0aCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudG9rZW4oJ1NUUklORycsdGhpcy5tYWtlU3RyaW5nKGRvYyxxdW90ZSx0cnVlKSwwKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMubW92ZUhlYWQoaGVyZWRvYyk7XG5cdFx0cmV0dXJuIGhlcmVkb2MubGVuZ3RoO1xuXHR9O1xuXHRcblx0Ly8gTWF0Y2hlcyBhbmQgY29uc3VtZXMgY29tbWVudHMuXG5cdExleGVyLnByb3RvdHlwZS5jb21tZW50VG9rZW4gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbWF0Y2gsbGVuZ3RoLGNvbW1lbnQsaW5kZW50LHByZXY7XG5cdFx0XG5cdFx0dmFyIHR5cCA9ICdIRVJFQ09NTUVOVCc7XG5cdFx0XG5cdFx0aWYgKG1hdGNoID0gSU5MSU5FX0NPTU1FTlQuZXhlYyh0aGlzLl9jaHVuaykpIHsgLy8gLm1hdGNoKElOTElORV9DT01NRU5UKVxuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJtYXRjaCBpbmxpbmUgY29tbWVudFwiXG5cdFx0XHRsZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XHRpbmRlbnQgPSBtYXRjaFsxXTtcblx0XHRcdGNvbW1lbnQgPSBtYXRjaFsyXTtcblx0XHRcdFxuXHRcdFx0cHJldiA9IGxhc3QodGhpcy5fdG9rZW5zKTtcblx0XHRcdHZhciBwdCA9IHByZXYgJiYgdFQocHJldik7XG5cdFx0XHR2YXIgbm90ZSA9ICcvLycgKyBjb21tZW50LnN1YnN0cigxKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuX2xhc3QgJiYgdGhpcy5fbGFzdC5zcGFjZWQpIHtcblx0XHRcdFx0bm90ZSA9ICcgJyArIG5vdGU7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwidGhlIHByZXZpb3VzIG5vZGUgd2FzIFNQQUNFRFwiXG5cdFx0XHR9O1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJjb21tZW50IHtub3RlfSAtIGluZGVudCh7aW5kZW50fSkgLSB7bGVuZ3RofSB7Y29tbWVudDpsZW5ndGh9XCJcblx0XHRcdFxuXHRcdFx0aWYgKChwdCAmJiBwdCAhPSAnSU5ERU5UJyAmJiBwdCAhPSAnVEVSTUlOQVRPUicpIHx8ICFwdCkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcInNraXAgY29tbWVudFwiXG5cdFx0XHRcdC8vIHRva2VuICdJTkxJTkVDT01NRU5UJywgY29tbWVudC5zdWJzdHIoMilcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJhZGRpbmcgYXMgdGVybWluYXRvclwiXG5cdFx0XHRcdHRoaXMudG9rZW4oJ1RFUk1JTkFUT1InLG5vdGUsbGVuZ3RoKTsgLy8gKyAnXFxuJ1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJhZGQgY29tbWVudCAoe25vdGV9KVwiXG5cdFx0XHRcdGlmIChwdCA9PSAnVEVSTUlOQVRPUicpIHtcblx0XHRcdFx0XHR0VnMocHJldix0VihwcmV2KSArIG5vdGUpO1xuXHRcdFx0XHRcdC8vIHByZXZbMV0gKz0gbm90ZVxuXHRcdFx0XHR9IGVsc2UgaWYgKHB0ID09ICdJTkRFTlQnKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJhZGRpbmcgY29tbWVudCB0byBJTkRFTlQ6IHtub3RlfVwiICMgd2h5IG5vdCBhZGQgZGlyZWN0bHkgaGVyZT9cblx0XHRcdFx0XHR0aGlzLmFkZExpbmVicmVha3MoMSxub3RlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcImNvbW1lbnQgaGVyZVwiXG5cdFx0XHRcdFx0Ly8gc2hvdWxkIHdlIGV2ZXIgZ2V0IGhlcmU/XG5cdFx0XHRcdFx0dGhpcy50b2tlbih0eXAsY29tbWVudC5zdWJzdHIoMiksbGVuZ3RoKTsgLy8gYXJlIHdlIHN1cmU/XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbGVuZ3RoOyAvLyBkaXNhYmxlIG5vdyB3aGlsZSBjb21waWxpbmdcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHNob3VsZCB1c2UgZXhlYz9cblx0XHRpZiAoIShtYXRjaCA9IENPTU1FTlQuZXhlYyh0aGlzLl9jaHVuaykpKSB7IHJldHVybiAwIH07XG5cdFx0XG5cdFx0Y29tbWVudCA9IG1hdGNoWzBdO1xuXHRcdHZhciBoZXJlID0gbWF0Y2hbMV07XG5cdFx0XG5cdFx0aWYgKGhlcmUpIHtcblx0XHRcdHRoaXMudG9rZW4oJ0hFUkVDT01NRU5UJyx0aGlzLnNhbml0aXplSGVyZWRvYyhoZXJlLHtoZXJlY29tbWVudDogdHJ1ZSxpbmRlbnQ6IEFycmF5KHRoaXMuX2luZGVudCArIDEpLmpvaW4oJyAnKX0pLGNvbW1lbnQubGVuZ3RoKTtcblx0XHRcdHRoaXMudG9rZW4oJ1RFUk1JTkFUT1InLCdcXG4nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy50b2tlbignSEVSRUNPTU1FTlQnLGNvbW1lbnQsY29tbWVudC5sZW5ndGgpO1xuXHRcdFx0dGhpcy50b2tlbignVEVSTUlOQVRPUicsJ1xcbicpOyAvLyBhdXRvPyByZWFsbHk/XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLm1vdmVIZWFkKGNvbW1lbnQpO1xuXHRcdHJldHVybiBjb21tZW50Lmxlbmd0aDtcblx0fTtcblx0XG5cdC8vIE1hdGNoZXMgSmF2YVNjcmlwdCBpbnRlcnBvbGF0ZWQgZGlyZWN0bHkgaW50byB0aGUgc291cmNlIHZpYSBiYWNrdGlja3MuXG5cdExleGVyLnByb3RvdHlwZS5qc1Rva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG1hdGNoLHNjcmlwdDtcblx0XHRcblx0XHRpZiAoISh0aGlzLl9jaHVuay5jaGFyQXQoMCkgPT0gJ2AnICYmIChtYXRjaCA9IEpTVE9LRU4uZXhlYyh0aGlzLl9jaHVuaykpKSkgeyByZXR1cm4gMCB9O1xuXHRcdHRoaXMudG9rZW4oJ0pTJywoc2NyaXB0ID0gbWF0Y2hbMF0pLnNsaWNlKDEsLTEpKTtcblx0XHRyZXR1cm4gc2NyaXB0Lmxlbmd0aDtcblx0fTtcblx0XG5cdC8vIE1hdGNoZXMgcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWxzLiBMZXhpbmcgcmVndWxhciBleHByZXNzaW9ucyBpcyBkaWZmaWN1bHRcblx0Ly8gdG8gZGlzdGluZ3Vpc2ggZnJvbSBkaXZpc2lvbiwgc28gd2UgYm9ycm93IHNvbWUgYmFzaWMgaGV1cmlzdGljcyBmcm9tXG5cdC8vIEphdmFTY3JpcHQgYW5kIFJ1YnkuXG5cdExleGVyLnByb3RvdHlwZS5yZWdleFRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGFyeTtcblx0XHR2YXIgbWF0Y2gsbGVuZ3RoLHByZXY7XG5cdFx0XG5cdFx0aWYgKHRoaXMuX2NodW5rLmNoYXJBdCgwKSAhPSAnLycpIHsgcmV0dXJuIDAgfTtcblx0XHRpZiAobWF0Y2ggPSBIRVJFR0VYLmV4ZWModGhpcy5fY2h1bmspKSB7XG5cdFx0XHRsZW5ndGggPSB0aGlzLmhlcmVnZXhUb2tlbihtYXRjaCk7XG5cdFx0XHR0aGlzLm1vdmVIZWFkKG1hdGNoWzBdKTtcblx0XHRcdHJldHVybiBsZW5ndGg7XG5cdFx0fTtcblx0XHRcblx0XHRwcmV2ID0gbGFzdCh0aGlzLl90b2tlbnMpO1xuXHRcdC8vIEZJWFxuXHRcdGlmIChwcmV2ICYmIChpZHgkKHRUKHByZXYpLChwcmV2LnNwYWNlZCA/IChcblx0XHRcdE5PVF9SRUdFWFxuXHRcdCkgOiAoXG5cdFx0XHROT1RfU1BBQ0VEX1JFR0VYXG5cdFx0KSkpID49IDApKSB7IHJldHVybiAwIH07XG5cdFx0aWYgKCEobWF0Y2ggPSBSRUdFWC5leGVjKHRoaXMuX2NodW5rKSkpIHsgcmV0dXJuIDAgfTtcblx0XHR2YXIgYXJ5ID0gaXRlciQobWF0Y2gpO3ZhciBtID0gYXJ5WzBdLHJlZ2V4ID0gYXJ5WzFdLGZsYWdzID0gYXJ5WzJdO1xuXHRcdFxuXHRcdC8vIEZJWE1FXG5cdFx0Ly8gaWYgcmVnZXhbLi4xXSBpcyAnLyonXG5cdFx0Ly9cdGVycm9yICdyZWd1bGFyIGV4cHJlc3Npb25zIGNhbm5vdCBiZWdpbiB3aXRoIGAqYCdcblx0XHRcblx0XHRpZiAocmVnZXggPT0gJy8vJykge1xuXHRcdFx0cmVnZXggPSAnLyg/OikvJztcblx0XHR9O1xuXHRcdFxuXHRcdHRoaXMudG9rZW4oJ1JFR0VYJywoXCJcIiArIHJlZ2V4ICsgZmxhZ3MpLG0ubGVuZ3RoKTtcblx0XHRyZXR1cm4gbS5sZW5ndGg7XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIG11bHRpbGluZSBleHRlbmRlZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuXHQvLyBUaGUgZXNjYXBpbmcgc2hvdWxkIHJhdGhlciBoYXBwZW4gaW4gQVNUIC0gcG9zc2libHkgYXMgYW4gYWRkaXRpb25hbCBmbGFnP1xuXHRMZXhlci5wcm90b3R5cGUuaGVyZWdleFRva2VuID0gZnVuY3Rpb24gKG1hdGNoKXtcblx0XHR2YXIgYXJ5O1xuXHRcdHZhciBhcnkgPSBpdGVyJChtYXRjaCk7dmFyIGhlcmVnZXggPSBhcnlbMF0sYm9keSA9IGFyeVsxXSxmbGFncyA9IGFyeVsyXTtcblx0XHRcblx0XHRpZiAoMCA+IGJvZHkuaW5kZXhPZignI3snKSkge1xuXHRcdFx0XG5cdFx0XHR2YXIgcmUgPSBib2R5LnJlcGxhY2UoSEVSRUdFWF9PTUlULCcnKS5yZXBsYWNlKC9cXC8vZywnXFxcXC8nKTtcblx0XHRcdFxuXHRcdFx0aWYgKHJlLm1hdGNoKC9eXFwqLykpIHtcblx0XHRcdFx0dGhpcy5lcnJvcigncmVndWxhciBleHByZXNzaW9ucyBjYW5ub3QgYmVnaW4gd2l0aCBgKmAnKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRoaXMudG9rZW4oJ1JFR0VYJywoXCIvXCIgKyAocmUgfHwgJyg/OiknKSArIFwiL1wiICsgZmxhZ3MpLGhlcmVnZXgubGVuZ3RoKTtcblx0XHRcdHJldHVybiBoZXJlZ2V4Lmxlbmd0aDtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIHVzZSBtb3JlIGJhc2ljIHJlZ2V4IHR5cGVcblx0XHRcblx0XHR0aGlzLnRva2VuKCdDT05TVCcsJ1JlZ0V4cCcpO1xuXHRcdHRoaXMuX3Rva2Vucy5wdXNoKFQudG9rZW4oJ0NBTExfU1RBUlQnLCcoJywwKSk7XG5cdFx0dmFyIHRva2VucyA9IFtdO1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwLCBpdGVtcyA9IGl0ZXIkKHRoaXMuaW50ZXJwb2xhdGVTdHJpbmcoYm9keSx7cmVnZXg6IHRydWV9KSksIGxlbiA9IGl0ZW1zLmxlbmd0aCwgcGFpcjsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcblx0XHRcdHBhaXIgPSBpdGVtc1tpXTtcblx0XHRcdHZhciB0b2sgPSB0VChwYWlyKTsgLy8gRklYXG5cdFx0XHR2YXIgdmFsdWUgPSB0VihwYWlyKTsgLy8gRklYXG5cdFx0XHRcblx0XHRcdGlmICh0b2sgPT0gJ1RPS0VOUycpIHtcblx0XHRcdFx0Ly8gRklYTUUgd2hhdCBpcyB0aGlzP1xuXHRcdFx0XHR0b2tlbnMucHVzaC5hcHBseSh0b2tlbnMsdmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCF2YWx1ZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwid2hhdD8/XCIpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCEodmFsdWUgPSB2YWx1ZS5yZXBsYWNlKEhFUkVHRVhfT01JVCwnJykpKSB7IGNvbnRpbnVlOyB9O1xuXHRcdFx0XHRcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csJ1xcXFxcXFxcJyk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKFQudG9rZW4oJ1NUUklORycsdGhpcy5tYWtlU3RyaW5nKHZhbHVlLCdcIicsdHJ1ZSksMCkpOyAvLyBGSVhcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRva2Vucy5wdXNoKFQudG9rZW4oJysnLCcrJywwKSk7IC8vIEZJWFxuXHRcdH07XG5cdFx0XG5cdFx0dG9rZW5zLnBvcCgpO1xuXHRcdFxuXHRcdC8vIEZJWFxuXHRcdGlmICghKHRva2Vuc1swXSAmJiB0VCh0b2tlbnNbMF0pID09ICdTVFJJTkcnKSkge1xuXHRcdFx0Ly8gRklYXG5cdFx0XHR0aGlzLl90b2tlbnMucHVzaChULnRva2VuKCdTVFJJTkcnLCdcIlwiJyksVC50b2tlbignKycsJysnKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLl90b2tlbnMucHVzaC5hcHBseSh0aGlzLl90b2tlbnMsdG9rZW5zKTsgLy8gd2hhdCBpcyB0aGlzP1xuXHRcdC8vIEZJWFxuXHRcdFxuXHRcdGlmIChmbGFncykge1xuXHRcdFx0dGhpcy5fdG9rZW5zLnB1c2goVC50b2tlbignLCcsJywnLDApKTtcblx0XHRcdHRoaXMuX3Rva2Vucy5wdXNoKFQudG9rZW4oJ1NUUklORycsJ1wiJyArIGZsYWdzICsgJ1wiJywwKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLnRva2VuKCcpJywnKScsMCk7XG5cdFx0XG5cdFx0cmV0dXJuIGhlcmVnZXgubGVuZ3RoO1xuXHR9O1xuXHRcblx0Ly8gTWF0Y2hlcyBuZXdsaW5lcywgaW5kZW50cywgYW5kIG91dGRlbnRzLCBhbmQgZGV0ZXJtaW5lcyB3aGljaCBpcyB3aGljaC5cblx0Ly8gSWYgd2UgY2FuIGRldGVjdCB0aGF0IHRoZSBjdXJyZW50IGxpbmUgaXMgY29udGludWVkIG9udG8gdGhlIHRoZSBuZXh0IGxpbmUsXG5cdC8vIHRoZW4gdGhlIG5ld2xpbmUgaXMgc3VwcHJlc3NlZDpcblx0Ly9cblx0Ly8gICAgIGVsZW1lbnRzXG5cdC8vICAgICAgIC5lYWNoKCAuLi4gKVxuXHQvLyAgICAgICAubWFwKCAuLi4gKVxuXHQvL1xuXHQvLyBLZWVwcyB0cmFjayBvZiB0aGUgbGV2ZWwgb2YgaW5kZW50YXRpb24sIGJlY2F1c2UgYSBzaW5nbGUgb3V0ZGVudCB0b2tlblxuXHQvLyBjYW4gY2xvc2UgbXVsdGlwbGUgaW5kZW50cywgc28gd2UgbmVlZCB0byBrbm93IGhvdyBmYXIgaW4gd2UgaGFwcGVuIHRvIGJlLlxuXHRMZXhlci5wcm90b3R5cGUubGluZVRva2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG1hdGNoO1xuXHRcdFxuXHRcdGlmICghKG1hdGNoID0gTVVMVElfREVOVC5leGVjKHRoaXMuX2NodW5rKSkpIHsgcmV0dXJuIDAgfTtcblx0XHQvLyBzaG91bGQgaXQgbm90IHBhaXIgYnkgaXRzZWxmIHRva2VuKCdTRUxFQ1RPUl9FTkQnLCclJywwKVxuXHRcdC8vIGlmIEBlbmQgPT0gJyUnXG5cdFx0Ly8gXHRjb25zb2xlLmxvZyBcInBhaXJpbmcgc2VsZWN0b3IgaW4gbGluZVRva2VuIHtAY2h1bmsuc3Vic3RyKDAsMTApfVwiXG5cdFx0Ly8gXHQjIHNob3VsZCBub3QgbmVlZCB0byBhZGQgYW55dGhpbmcgaGVyZT9cblx0XHQvLyBcdHBhaXIoJyUnKVxuXHRcdFxuXHRcdHZhciBpbmRlbnQgPSBtYXRjaFswXTtcblx0XHQvLyB2YXIgYnJDb3VudCA9IGNvdW50IGluZGVudCwgJ1xcbidcblx0XHR2YXIgYnJDb3VudCA9IHRoaXMubW92ZUhlYWQoaW5kZW50KTtcblx0XHR0aGlzLl9zZWVuRm9yID0gZmFsc2U7XG5cdFx0Ly8gcmVzZXQgY29sdW1uIGFzIHdlbGw/XG5cdFx0XG5cdFx0dmFyIHByZXYgPSBsYXN0KHRoaXMuX3Rva2VucywxKTtcblx0XHR2YXIgc2l6ZSA9IGluZGVudC5sZW5ndGggLSAxIC0gaW5kZW50Lmxhc3RJbmRleE9mKCdcXG4nKTtcblx0XHR2YXIgbm9OZXdsaW5lcyA9IHRoaXMudW5maW5pc2hlZCgpO1xuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nIFwibm9OZXdsaW5lc1wiLG5vTmV3bGluZXNcblx0XHQvLyBjb25zb2xlLmxvZyBcImxpbmVUb2tlbiAtLSBcIixAY2h1bmsuc3Vic3RyKDAsMTApLFwiLS1cIlxuXHRcdGlmICgoL15cXG4jXFxzLykudGVzdCh0aGlzLl9jaHVuaykpIHtcblx0XHRcdHRoaXMuYWRkTGluZWJyZWFrcygxKTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHNpemUgLSB0aGlzLl9pbmRlYnQgPT0gdGhpcy5faW5kZW50KSB7XG5cdFx0XHRpZiAobm9OZXdsaW5lcykge1xuXHRcdFx0XHR0aGlzLnN1cHByZXNzTmV3bGluZXMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubmV3bGluZVRva2VuKGJyQ291bnQpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBpbmRlbnQubGVuZ3RoO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHNpemUgPiB0aGlzLl9pbmRlbnQpIHtcblx0XHRcdGlmIChub05ld2xpbmVzKSB7XG5cdFx0XHRcdHRoaXMuX2luZGVidCA9IHNpemUgLSB0aGlzLl9pbmRlbnQ7XG5cdFx0XHRcdHRoaXMuc3VwcHJlc3NOZXdsaW5lcygpO1xuXHRcdFx0XHRyZXR1cm4gaW5kZW50Lmxlbmd0aDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmluVGFnKCkpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJpbmRlbnQgaW5zaWRlIHRva2lkPyE/XCJcblx0XHRcdFx0Ly8gQGluZGVidCA9IHNpemUgLSBAaW5kZW50XG5cdFx0XHRcdC8vIHN1cHByZXNzTmV3bGluZXMoKVxuXHRcdFx0XHRyZXR1cm4gaW5kZW50Lmxlbmd0aDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0dmFyIGRpZmYgPSBzaXplIC0gdGhpcy5faW5kZW50ICsgdGhpcy5fb3V0ZGVidDtcblx0XHRcdHRoaXMuY2xvc2VEZWYoKTtcblx0XHRcdFxuXHRcdFx0dmFyIGltbWVkaWF0ZSA9IGxhc3QodGhpcy5fdG9rZW5zKTtcblx0XHRcdFxuXHRcdFx0aWYgKGltbWVkaWF0ZSAmJiB0VChpbW1lZGlhdGUpID09ICdURVJNSU5BVE9SJykge1xuXHRcdFx0XHR0VHMoaW1tZWRpYXRlLCdJTkRFTlQnKTtcblx0XHRcdFx0aW1tZWRpYXRlLl9tZXRhIHx8IChpbW1lZGlhdGUuX21ldGEgPSB7cHJlOiB0VihpbW1lZGlhdGUpLHBvc3Q6ICcnfSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBzaG91bGQgcmF0aGVyIGFkZCB0byBtZXRhIHNvbWVob3c/IT9cblx0XHRcdFx0Ly8gdFZzKGltbWVkaWF0ZSx0VihpbW1lZGlhdGUpICsgJyV8JScpICMgY3Jhenlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudG9rZW4oJ0lOREVOVCcsXCJcIiArIGRpZmYsMCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImluZGVudGluZ1wiLCBwcmV2LCBsYXN0KEB0b2tlbnMsMSlcblx0XHRcdC8vIGlmIHByZXYgYW5kIHByZXZbMF0gPT0gJ1RFUk1JTkFUT1InXG5cdFx0XHQvLyAgIGNvbnNvbGUubG9nIFwidGVybWluYXRvciBiZWZvcmUgaW5kZW50Pz9cIlxuXHRcdFx0XG5cdFx0XHQvLyBjaGVjayBmb3IgY29tbWVudHMgYXMgd2VsbCA/XG5cdFx0XHRcblx0XHRcdHRoaXMuX2luZGVudHMucHVzaChkaWZmKTtcblx0XHRcdHRoaXMucHVzaEVuZCgnT1VUREVOVCcpO1xuXHRcdFx0Ly8gQGVuZHMucHVzaCAnT1VUREVOVCdcblx0XHRcdHRoaXMuX291dGRlYnQgPSB0aGlzLl9pbmRlYnQgPSAwO1xuXHRcdFx0dGhpcy5hZGRMaW5lYnJlYWtzKGJyQ291bnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9pbmRlYnQgPSAwO1xuXHRcdFx0dGhpcy5vdXRkZW50VG9rZW4odGhpcy5faW5kZW50IC0gc2l6ZSxub05ld2xpbmVzLGJyQ291bnQpO1xuXHRcdFx0dGhpcy5hZGRMaW5lYnJlYWtzKGJyQ291bnQgLSAxKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nIFwib3V0ZGVudFwiLG5vTmV3bGluZXMsdG9raWQoKVxuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5faW5kZW50ID0gc2l6ZTtcblx0XHRyZXR1cm4gaW5kZW50Lmxlbmd0aDtcblx0fTtcblx0XG5cdC8vIFJlY29yZCBhbiBvdXRkZW50IHRva2VuIG9yIG11bHRpcGxlIHRva2VucywgaWYgd2UgaGFwcGVuIHRvIGJlIG1vdmluZyBiYWNrXG5cdC8vIGlud2FyZHMgcGFzdCBzZXZlcmFsIHJlY29yZGVkIGluZGVudHMuXG5cdExleGVyLnByb3RvdHlwZS5vdXRkZW50VG9rZW4gPSBmdW5jdGlvbiAobW92ZU91dCxub05ld2xpbmVzLG5ld2xpbmVDb3VudCl7XG5cdFx0Ly8gaGVyZSB3ZSBzaG91bGQgYWxzbyB0YWtlIGNhcmUgdG8gcG9wIC8gcmVzZXQgdGhlIHNjb3BlLWJvZHlcblx0XHQvLyBvciBjb250ZXh0LXR5cGUgZm9yIGluZGVudGF0aW9uIFxuXHRcdHZhciBkZW50ID0gMDtcblx0XHR3aGlsZSAobW92ZU91dCA+IDApe1xuXHRcdFx0dmFyIGxlbiA9IHRoaXMuX2luZGVudHMubGVuZ3RoIC0gMTtcblx0XHRcdGlmICh0aGlzLl9pbmRlbnRzW2xlbl0gPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG1vdmVPdXQgPSAwO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9pbmRlbnRzW2xlbl0gPT0gdGhpcy5fb3V0ZGVidCkge1xuXHRcdFx0XHRtb3ZlT3V0IC09IHRoaXMuX291dGRlYnQ7XG5cdFx0XHRcdHRoaXMuX291dGRlYnQgPSAwO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9pbmRlbnRzW2xlbl0gPCB0aGlzLl9vdXRkZWJ0KSB7XG5cdFx0XHRcdHRoaXMuX291dGRlYnQgLT0gdGhpcy5faW5kZW50c1tsZW5dO1xuXHRcdFx0XHRtb3ZlT3V0IC09IHRoaXMuX2luZGVudHNbbGVuXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbnQgPSB0aGlzLl9pbmRlbnRzLnBvcCgpIC0gdGhpcy5fb3V0ZGVidDtcblx0XHRcdFx0bW92ZU91dCAtPSBkZW50O1xuXHRcdFx0XHR0aGlzLl9vdXRkZWJ0ID0gMDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghbm9OZXdsaW5lcykgeyB0aGlzLmFkZExpbmVicmVha3MoMSkgfTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMucGFpcignT1VUREVOVCcpO1xuXHRcdFx0XHR0aGlzLnRva2VuKCdPVVRERU5UJyxcIlwiICsgZGVudCwwKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoZGVudCkgeyB0aGlzLl9vdXRkZWJ0IC09IG1vdmVPdXQgfTtcblx0XHRcblx0XHR3aGlsZSAodGhpcy5sYXN0VG9rZW5WYWx1ZSgpID09ICc7Jyl7XG5cdFx0XHR0aGlzLl90b2tlbnMucG9wKCk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoISh0aGlzLmxhc3RUb2tlblR5cGUoKSA9PSAnVEVSTUlOQVRPUicgfHwgbm9OZXdsaW5lcykpIHsgdGhpcy50b2tlbignVEVSTUlOQVRPUicsJ1xcbicsMCkgfTtcblx0XHRcblx0XHQvLyBjYXBwaW5nIHNjb3BlcyBzbyB0aGV5IGRvbnQgaGFuZyBhcm91bmQgXG5cdFx0dGhpcy5fc2NvcGVzLmxlbmd0aCA9IHRoaXMuX2luZGVudHMubGVuZ3RoO1xuXHRcdFxuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQoKTtcblx0XHRpZiAoY3R4ID09ICclJyB8fCBjdHggPT0gJ1RBRycpIHsgdGhpcy5wYWlyKGN0eCkgfTsgLy8gcmVhbGx5P1xuXHRcdHRoaXMuY2xvc2VEZWYoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8vIE1hdGNoZXMgYW5kIGNvbnN1bWVzIG5vbi1tZWFuaW5nZnVsIHdoaXRlc3BhY2UuIHRva2lkIHRoZSBwcmV2aW91cyB0b2tlblxuXHQvLyBhcyBiZWluZyBcInNwYWNlZFwiLCBiZWNhdXNlIHRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZXJlIGl0IG1ha2VzIGEgZGlmZmVyZW5jZS5cblx0TGV4ZXIucHJvdG90eXBlLndoaXRlc3BhY2VUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBtYXRjaCxubGluZSxwcmV2O1xuXHRcdGlmICghKChtYXRjaCA9IFdISVRFU1BBQ0UuZXhlYyh0aGlzLl9jaHVuaykpIHx8IChubGluZSA9IHRoaXMuX2NodW5rLmNoYXJBdCgwKSA9PSAnXFxuJykpKSB7IHJldHVybiAwIH07XG5cdFx0cHJldiA9IGxhc3QodGhpcy5fdG9rZW5zKTtcblx0XHRcblx0XHQvLyBGSVggLSB3aHkgb2ggd2h5P1xuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0cHJldi5zcGFjZWQgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHJldi5uZXdMaW5lID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuYWRkTmV3bGluZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLnRva2VuKCdURVJNSU5BVE9SJywnXFxuJyk7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUubW92ZUhlYWQgPSBmdW5jdGlvbiAoc3RyKXtcblx0XHR2YXIgYnIgPSBjb3VudChzdHIsJ1xcbicpO1xuXHRcdHJldHVybiBicjtcblx0fTtcblx0XG5cdFxuXHRMZXhlci5wcm90b3R5cGUuYWRkTGluZWJyZWFrcyA9IGZ1bmN0aW9uIChjb3VudCxyYXcpe1xuXHRcdHZhciBicjtcblx0XHRcblx0XHRpZiAoIXJhdyAmJiBjb3VudCA9PSAwKSB7IHJldHVybiB0aGlzIH07IC8vIG5vIHRlcm1pbmF0b3JzP1xuXHRcdFxuXHRcdHZhciBwcmV2ID0gdGhpcy5fbGFzdDtcblx0XHRcblx0XHRpZiAoIXJhdykge1xuXHRcdFx0aWYgKGNvdW50ID09IDEpIHtcblx0XHRcdFx0YnIgPSAnXFxuJztcblx0XHRcdH0gZWxzZSBpZiAoY291bnQgPT0gMikge1xuXHRcdFx0XHRiciA9ICdcXG5cXG4nO1xuXHRcdFx0fSBlbHNlIGlmIChjb3VudCA9PSAzKSB7XG5cdFx0XHRcdGJyID0gJ1xcblxcblxcbic7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRiciA9IHJlcGVhdFN0cmluZygnXFxuJyxjb3VudCk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0Ly8gRklYXG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHZhciB0ID0gcHJldi5fdHlwZTsgLy8gQGxhc3RUeXBcblx0XHRcdHZhciB2ID0gdFYocHJldik7XG5cdFx0XHRcblx0XHRcdC8vIHdlIHJlYWxseSB3YW50IHRvIGFkZCB0aGlzXG5cdFx0XHRpZiAodCA9PSAnSU5ERU5UJykge1xuXHRcdFx0XHQvLyBUT0RPIHdlIHdhbnQgdG8gYWRkIHRvIHRoZSBpbmRlbnRcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJhZGQgdGhlIGNvbW1lbnQgdG8gdGhlIGluZGVudCAtLSBwcmU/IHtyYXd9IHticn1cIlxuXHRcdFx0XHRcblx0XHRcdFx0dmFyIG1ldGEgPSBwcmV2Ll9tZXRhIHx8IChwcmV2Ll9tZXRhID0ge3ByZTogJycscG9zdDogJyd9KTtcblx0XHRcdFx0bWV0YS5wb3N0ICs9IChyYXcgfHwgYnIpO1xuXHRcdFx0XHQvLyB0VnModiArIChyYXcgb3IgYnIpKVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0gZWxzZSBpZiAodCA9PSAnVEVSTUlOQVRPUicpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJhbHJlYWR5IGV4aXN0cyB0ZXJtaW5hdG9yIHticn0ge3Jhd31cIlxuXHRcdFx0XHR0VnMocHJldix2ICsgKHJhdyB8fCBicikpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLnRva2VuKCdURVJNSU5BVE9SJyxiciwwKTtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHQvLyBHZW5lcmF0ZSBhIG5ld2xpbmUgdG9rZW4uIENvbnNlY3V0aXZlIG5ld2xpbmVzIGdldCBtZXJnZWQgdG9nZXRoZXIuXG5cdExleGVyLnByb3RvdHlwZS5uZXdsaW5lVG9rZW4gPSBmdW5jdGlvbiAobGluZXMpe1xuXHRcdC8vIGNvbnNvbGUubG9nIFwibmV3bGluZVRva2VuXCJcblx0XHR3aGlsZSAodGhpcy5sYXN0VG9rZW5WYWx1ZSgpID09ICc7Jyl7XG5cdFx0XHRjb25zb2xlLmxvZyhcInBvcCB0b2tlblwiLHRoaXMuX3Rva2Vuc1t0aGlzLl90b2tlbnMubGVuZ3RoIC0gMV0pO1xuXHRcdFx0dGhpcy5fdG9rZW5zLnBvcCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGhpcy5hZGRMaW5lYnJlYWtzKGxpbmVzKTtcblx0XHRcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0KCk7XG5cdFx0Ly8gV0FSTiBub3cgaW1wb3J0IGNhbm5vdCBnbyBvdmVyIG11bHRpcGxlIGxpbmVzXG5cdFx0aWYgKGN0eCA9PSAnVEFHJyB8fCBjdHggPT0gJ0lNUE9SVCcpIHsgdGhpcy5wYWlyKGN0eCkgfTtcblx0XHR0aGlzLmNsb3NlRGVmKCk7IC8vIGNsb3NlIGRlZiAtLSByZWFsbHk/XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBVc2UgYSBgXFxgIGF0IGEgbGluZS1lbmRpbmcgdG8gc3VwcHJlc3MgdGhlIG5ld2xpbmUuXG5cdC8vIFRoZSBzbGFzaCBpcyByZW1vdmVkIGhlcmUgb25jZSBpdHMgam9iIGlzIGRvbmUuXG5cdExleGVyLnByb3RvdHlwZS5zdXBwcmVzc05ld2xpbmVzID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMudmFsdWUoKSA9PSAnXFxcXCcpIHsgdGhpcy5fdG9rZW5zLnBvcCgpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBXZSB0cmVhdCBhbGwgb3RoZXIgc2luZ2xlIGNoYXJhY3RlcnMgYXMgYSB0b2tlbi4gRS5nLjogYCggKSAsIC4gIWBcblx0Ly8gTXVsdGktY2hhcmFjdGVyIG9wZXJhdG9ycyBhcmUgYWxzbyBsaXRlcmFsIHRva2Vucywgc28gdGhhdCBKaXNvbiBjYW4gYXNzaWduXG5cdC8vIHRoZSBwcm9wZXIgb3JkZXIgb2Ygb3BlcmF0aW9ucy4gVGhlcmUgYXJlIHNvbWUgc3ltYm9scyB0aGF0IHdlIHRva2lkIHNwZWNpYWxseVxuXHQvLyBoZXJlLiBgO2AgYW5kIG5ld2xpbmVzIGFyZSBib3RoIHRyZWF0ZWQgYXMgYSBgVEVSTUlOQVRPUmAsIHdlIGRpc3Rpbmd1aXNoXG5cdC8vIHBhcmVudGhlc2VzIHRoYXQgaW5kaWNhdGUgYSBtZXRob2QgY2FsbCBmcm9tIHJlZ3VsYXIgcGFyZW50aGVzZXMsIGFuZCBzbyBvbi5cblx0TGV4ZXIucHJvdG90eXBlLmxpdGVyYWxUb2tlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBtYXRjaCx2YWx1ZTtcblx0XHRpZiAobWF0Y2ggPSBPUEVSQVRPUi5leGVjKHRoaXMuX2NodW5rKSkge1xuXHRcdFx0dmFsdWUgPSBtYXRjaFswXTtcblx0XHRcdGlmIChDT0RFLnRlc3QodmFsdWUpKSB0aGlzLnRhZ1BhcmFtZXRlcnMoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsdWUgPSB0aGlzLl9jaHVuay5jaGFyQXQoMCk7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgZW5kMSA9IHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAxXTtcblx0XHR2YXIgZW5kMiA9IHRoaXMuX2VuZHNbdGhpcy5fZW5kcy5sZW5ndGggLSAyXTtcblx0XHRcblx0XHR2YXIgaW5UYWcgPSBlbmQxID09ICdUQUdfRU5EJyB8fCBlbmQxID09ICdPVVRERU5UJyAmJiBlbmQyID09ICdUQUdfRU5EJztcblx0XHRcblx0XHR2YXIgdG9raWQgPSB2YWx1ZTtcblx0XHR2YXIgcHJldiA9IGxhc3QodGhpcy5fdG9rZW5zKTtcblx0XHR2YXIgcHQgPSBwcmV2ICYmIHRUKHByZXYpO1xuXHRcdHZhciBwdiA9IHByZXYgJiYgdFYocHJldik7XG5cdFx0dmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0XHRcblx0XHQvLyBpcyB0aGlzIG5lZWRlZD9cblx0XHRpZiAodmFsdWUgPT0gJz0nICYmIHByZXYpIHtcblx0XHRcdFxuXHRcdFx0aWYgKHB2ID09ICd8fCcgfHwgcHYgPT0gJyYmJykgeyAvLyBpbiBbJ3x8JywgJyYmJ11cblx0XHRcdFx0dFRzKHByZXYsJ0NPTVBPVU5EX0FTU0lHTicpO1xuXHRcdFx0XHR0VnMocHJldixwdiArICc9Jyk7XG5cdFx0XHRcdC8vIHByZXZbMF0gPSAnQ09NUE9VTkRfQVNTSUdOJ1xuXHRcdFx0XHQvLyBwcmV2WzFdICs9ICc9J1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUubGVuZ3RoO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh2YWx1ZSA9PSAnOycpIHtcblx0XHRcdHRoaXMuX3NlZW5Gb3IgPSBmYWxzZTtcblx0XHRcdHRva2lkID0gJ1RFUk1JTkFUT1InO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJygnICYmIGluVGFnICYmIHB0ICE9ICc9JyAmJiBwcmV2LnNwYWNlZCkgeyAvLyBGSVhlZFxuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ3NwYWNlZCBiZWZvcmUgKCBpbiB0b2tpZCdcblx0XHRcdC8vIEZJWE1FIC0gc2hvdWxkIHJhdGhlciBhZGQgYSBzcGVjaWFsIHRva2VuIGxpa2UgVEFHX1BBUkFNU19TVEFSVFxuXHRcdFx0dGhpcy50b2tlbignLCcsJywnKTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICctPicgJiYgaW5UYWcpIHtcblx0XHRcdHRva2lkID0gJ1RBR19FTkQnO1xuXHRcdFx0dGhpcy5wYWlyKCdUQUdfRU5EJyk7XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSAnLz4nICYmIGluVGFnKSB7XG5cdFx0XHR0b2tpZCA9ICdUQUdfRU5EJztcblx0XHRcdHRoaXMucGFpcignVEFHX0VORCcpO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJz4nICYmIGluVGFnKSB7XG5cdFx0XHR0b2tpZCA9ICdUQUdfRU5EJztcblx0XHRcdHRoaXMucGFpcignVEFHX0VORCcpO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJz4nICYmIHRoaXMuY29udGV4dCgpID09ICdERUYnKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZygncGlja2VkIHVwID4hIScpXG5cdFx0XHR0b2tpZCA9ICdERUZfRlJBR01FTlQnO1xuXHRcdFx0XG5cdFx0XHQvLyBlbGlmIHZhbHVlIGlzICdURVJNSU5BVE9SJyBhbmQgZW5kMSBpcyAnJScgXG5cdFx0XHQvLyBcdGNsb3NlU2VsZWN0b3IoKVxuXHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJ1RFUk1JTkFUT1InICYmIGVuZDEgPT0gJ0RFRicpIHtcblx0XHRcdHRoaXMuY2xvc2VEZWYoKTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlID09ICcmJyAmJiB0aGlzLmNvbnRleHQoKSA9PSAnREVGJykge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coXCJva2F5IVwiKVxuXHRcdFx0dG9raWQgPSAnQkxPQ0tfQVJHJztcblx0XHRcdC8vIGNoYW5nZSB0aGUgbmV4dCBpZGVudGlmaWVyIGluc3RlYWQ/XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSAnKicgJiYgdGhpcy5fY2h1bmsuY2hhckF0KDEpLm1hdGNoKC9bQS1aYS16XFxfXFxAXFxbXS8pICYmIChwcmV2LnNwYWNlZCB8fCBbJywnLCcoJywnWycsJ3snLCd8JywnXFxuJywnXFx0J10uaW5kZXhPZihwdikgPj0gMCkpIHtcblx0XHRcdHRva2lkID0gXCJTUExBVFwiO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJ+KImicpIHtcblx0XHRcdHRva2lkID0gJ1NRUlQnO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJ8aSJykge1xuXHRcdFx0dG9raWQgPSAnRlVOQyc7XG5cdFx0fSBlbHNlIGlmIChpZHgkKHZhbHVlLE1BVEgpID49IDApIHtcblx0XHRcdHRva2lkID0gJ01BVEgnO1xuXHRcdH0gZWxzZSBpZiAoaWR4JCh2YWx1ZSxDT01QQVJFKSA+PSAwKSB7XG5cdFx0XHR0b2tpZCA9ICdDT01QQVJFJztcblx0XHR9IGVsc2UgaWYgKGlkeCQodmFsdWUsQ09NUE9VTkRfQVNTSUdOKSA+PSAwKSB7XG5cdFx0XHR0b2tpZCA9ICdDT01QT1VORF9BU1NJR04nO1xuXHRcdH0gZWxzZSBpZiAoaWR4JCh2YWx1ZSxVTkFSWSkgPj0gMCkge1xuXHRcdFx0dG9raWQgPSAnVU5BUlknO1xuXHRcdH0gZWxzZSBpZiAoaWR4JCh2YWx1ZSxTSElGVCkgPj0gMCkge1xuXHRcdFx0dG9raWQgPSAnU0hJRlQnO1xuXHRcdH0gZWxzZSBpZiAoaWR4JCh2YWx1ZSxMT0dJQykgPj0gMCkge1xuXHRcdFx0dG9raWQgPSAnTE9HSUMnOyAvLyBvciB2YWx1ZSBpcyAnPycgYW5kIHByZXY/OnNwYWNlZCBcblx0XHR9IGVsc2UgaWYgKHByZXYgJiYgIXByZXYuc3BhY2VkKSB7XG5cdFx0XHQvLyBuZWVkIGEgYmV0dGVyIHdheSB0byBkbyB0aGVzZVxuXHRcdFx0aWYgKHZhbHVlID09ICcoJyAmJiBlbmQxID09ICclJykge1xuXHRcdFx0XHR0b2tpZCA9ICdUQUdfQVRUUlNfU1RBUlQnO1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSAnKCcgJiYgaWR4JChwdCxDQUxMQUJMRSkgPj0gMCkge1xuXHRcdFx0XHQvLyBub3QgdXNpbmcgdGhpcyA/Pz9cblx0XHRcdFx0Ly8gcHJldlswXSA9ICdGVU5DX0VYSVNUJyBpZiBwcmV2WzBdIGlzICc/J1xuXHRcdFx0XHR0b2tpZCA9ICdDQUxMX1NUQVJUJztcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gJ1snICYmIGlkeCQocHQsSU5ERVhBQkxFKSA+PSAwKSB7XG5cdFx0XHRcdHRva2lkID0gJ0lOREVYX1NUQVJUJztcblx0XHRcdFx0aWYgKHB0ID09ICc/JykgeyB0VHMocHJldiwnSU5ERVhfU09BSycpIH07XG5cdFx0XHRcdC8vIHByZXZbMF0gPSAnSU5ERVhfU09BSycgaWYgcHJldlswXSA9PSAnPydcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRzd2l0Y2ggKHZhbHVlKSB7XG5cdFx0XHRjYXNlICcoJzpcblx0XHRcdGNhc2UgJ3snOlxuXHRcdFx0Y2FzZSAnWyc6XG5cdFx0XHRcdHRoaXMucHVzaEVuZChJTlZFUlNFU1t2YWx1ZV0pO2JyZWFrO1xuXHRcdFx0XG5cdFx0XHRjYXNlICcpJzpcblx0XHRcdGNhc2UgJ30nOlxuXHRcdFx0Y2FzZSAnXSc6XG5cdFx0XHRcdHRoaXMucGFpcih2YWx1ZSk7YnJlYWs7XG5cdFx0XG5cdFx0fTtcblx0XHRcblx0XHQvLyBoYWNreSBydWxlIHRvIHRyeSB0byBhbGxvdyBmb3IgdHVwbGUtYXNzaWdubWVudHMgaW4gYmxvY2tzXG5cdFx0Ly8gaWYgdmFsdWUgaXMgJywnIGFuZCBwcmV2WzBdIGlzICdJREVOVElGSUVSJyBhbmQgQHRva2Vuc1tAdG9rZW5zOmxlbmd0aCAtIDJdWzBdIGluIFsnVEVSTUlOQVRPUicsJ0lOREVOVCddXG5cdFx0Ly8gICAjIHRva2VuIFwiVFVQTEVcIiwgXCJ0dXBsZVwiICMgc2hvdWxkIHJhdGhlciBpbnNlcnQgaXQgc29tZXdoZXJlIGVsc2UsIG5vP1xuXHRcdC8vICAgY29uc29sZS5sb2coXCJmb3VuZCBjb21tYVwiKVxuXHRcdFxuXHRcdHRoaXMudG9rZW4odG9raWQsdmFsdWUsdmFsdWUubGVuZ3RoKTtcblx0XHRyZXR1cm4gdmFsdWUubGVuZ3RoO1xuXHR9O1xuXHRcblx0Ly8gVG9rZW4gTWFuaXB1bGF0b3JzXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcblx0Ly8gU2FuaXRpemUgYSBoZXJlZG9jIG9yIGhlcmVjb21tZW50IGJ5XG5cdC8vIGVyYXNpbmcgYWxsIGV4dGVybmFsIGluZGVudGF0aW9uIG9uIHRoZSBsZWZ0LWhhbmQgc2lkZS5cblx0TGV4ZXIucHJvdG90eXBlLnNhbml0aXplSGVyZWRvYyA9IGZ1bmN0aW9uIChkb2Msb3B0aW9ucyl7XG5cdFx0dmFyIG1hdGNoO1xuXHRcdHZhciBpbmRlbnQgPSBvcHRpb25zLmluZGVudDtcblx0XHR2YXIgaGVyZWNvbW1lbnQgPSBvcHRpb25zLmhlcmVjb21tZW50O1xuXHRcdFxuXHRcdGlmIChoZXJlY29tbWVudCkge1xuXHRcdFx0aWYgKEhFUkVET0NfSUxMRUdBTC50ZXN0KGRvYykpIHtcblx0XHRcdFx0dGhpcy5lcnJvcihcImJsb2NrIGNvbW1lbnQgY2Fubm90IGNvbnRhaW4gJyovJyBzdGFydGluZ1wiKTtcblx0XHRcdH07XG5cdFx0XHRpZiAoZG9jLmluZGV4T2YoJ1xcbicpIDw9IDApIHsgcmV0dXJuIGRvYyB9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbGVuZ3RoXzt3aGlsZSAobWF0Y2ggPSBIRVJFRE9DX0lOREVOVC5leGVjKGRvYykpe1xuXHRcdFx0XHR2YXIgYXR0ZW1wdCA9IG1hdGNoWzFdO1xuXHRcdFx0XHRpZiAoaW5kZW50ID09IG51bGwgfHwgMCA8IChsZW5ndGhfID0gYXR0ZW1wdC5sZW5ndGgpICYmIGxlbmd0aF8gPCBpbmRlbnQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0aW5kZW50ID0gYXR0ZW1wdDtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoaW5kZW50KSB7IGRvYyA9IGRvYy5yZXBsYWNlKFJlZ0V4cCgoXCJcXFxcblwiICsgaW5kZW50KSxcImdcIiksJ1xcbicpIH07XG5cdFx0aWYgKCFoZXJlY29tbWVudCkgeyBkb2MgPSBkb2MucmVwbGFjZSgvXlxcbi8sJycpIH07XG5cdFx0cmV0dXJuIGRvYztcblx0fTtcblx0XG5cdC8vIEEgc291cmNlIG9mIGFtYmlndWl0eSBpbiBvdXIgZ3JhbW1hciB1c2VkIHRvIGJlIHBhcmFtZXRlciBsaXN0cyBpbiBmdW5jdGlvblxuXHQvLyBkZWZpbml0aW9ucyB2ZXJzdXMgYXJndW1lbnQgbGlzdHMgaW4gZnVuY3Rpb24gY2FsbHMuIFdhbGsgYmFja3dhcmRzLCB0b2tpZGdpbmdcblx0Ly8gcGFyYW1ldGVycyBzcGVjaWFsbHkgaW4gb3JkZXIgdG8gbWFrZSB0aGluZ3MgZWFzaWVyIGZvciB0aGUgcGFyc2VyLlxuXHRMZXhlci5wcm90b3R5cGUudGFnUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciB0b2s7XG5cdFx0aWYgKHRoaXMubGFzdFRva2VuVHlwZSgpICE9ICcpJykgeyByZXR1cm4gdGhpcyB9O1xuXHRcdHZhciBzdGFjayA9IFtdO1xuXHRcdHZhciB0b2tlbnMgPSB0aGlzLl90b2tlbnM7XG5cdFx0dmFyIGkgPSB0b2tlbnMubGVuZ3RoO1xuXHRcdFxuXHRcdHRUcyh0b2tlbnNbLS1pXSwnUEFSQU1fRU5EJyk7XG5cdFx0XG5cdFx0d2hpbGUgKHRvayA9IHRva2Vuc1stLWldKXtcblx0XHRcdHZhciB0ID0gdFQodG9rKTtcblx0XHRcdHN3aXRjaCAodCkge1xuXHRcdFx0XHRjYXNlICcpJzpcblx0XHRcdFx0XHRzdGFjay5wdXNoKHRvayk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRjYXNlICcoJzpcblx0XHRcdFx0Y2FzZSAnQ0FMTF9TVEFSVCc6XG5cdFx0XHRcdFx0aWYgKHN0YWNrLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0ID09ICcoJykge1xuXHRcdFx0XHRcdFx0dFRzKHRvaywnUEFSQU1fU1RBUlQnKTtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvLyBDbG9zZSB1cCBhbGwgcmVtYWluaW5nIG9wZW4gYmxvY2tzIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuXG5cdExleGVyLnByb3RvdHlwZS5jbG9zZUluZGVudGF0aW9uID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gY3R4ID0gY29udGV4dFxuXHRcdC8vIHBhaXIoY3R4KSBpZiBjdHggaW4gWyclJywnREVGJ11cblx0XHR0aGlzLmNsb3NlRGVmKCk7XG5cdFx0dGhpcy5jbG9zZVNlbGVjdG9yKCk7XG5cdFx0cmV0dXJuIHRoaXMub3V0ZGVudFRva2VuKHRoaXMuX2luZGVudCxmYWxzZSwwKTtcblx0fTtcblx0XG5cdC8vIE1hdGNoZXMgYSBiYWxhbmNlZCBncm91cCBzdWNoIGFzIGEgc2luZ2xlIG9yIGRvdWJsZS1xdW90ZWQgc3RyaW5nLiBQYXNzIGluXG5cdC8vIGEgc2VyaWVzIG9mIGRlbGltaXRlcnMsIGFsbCBvZiB3aGljaCBtdXN0IGJlIG5lc3RlZCBjb3JyZWN0bHkgd2l0aGluIHRoZVxuXHQvLyBjb250ZW50cyBvZiB0aGUgc3RyaW5nLiBUaGlzIG1ldGhvZCBhbGxvd3MgdXMgdG8gaGF2ZSBzdHJpbmdzIHdpdGhpblxuXHQvLyBpbnRlcnBvbGF0aW9ucyB3aXRoaW4gc3RyaW5ncywgYWQgaW5maW5pdHVtLlxuXHRMZXhlci5wcm90b3R5cGUuYmFsYW5jZWRTdHJpbmcgPSBmdW5jdGlvbiAoc3RyLGVuZCl7XG5cdFx0dmFyIG1hdGNoLGxldHRlcixwcmV2O1xuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nICdiYWxhbmNpbmcgc3RyaW5nIScsIHN0ciwgZW5kXG5cdFx0dmFyIHN0YWNrID0gW2VuZF07XG5cdFx0dmFyIGkgPSAwO1xuXHRcdFxuXHRcdC8vIGNvdWxkIGl0IG5vdCBoYXBwZW4gaGVyZT9cblx0XHR3aGlsZSAoaSA8IChzdHIubGVuZ3RoIC0gMSkpe1xuXHRcdFx0aSsrO1xuXHRcdFx0bGV0dGVyID0gc3RyLmNoYXJBdChpKTtcblx0XHRcdHN3aXRjaCAobGV0dGVyKSB7XG5cdFx0XHRcdGNhc2UgJ1xcXFwnOlxuXHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdGNhc2UgZW5kOlxuXHRcdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdGlmICghc3RhY2subGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR2YXIgdiA9IHN0ci5zbGljZSgwLGkgKyAxKTtcblx0XHRcdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0ZW5kID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChlbmQgPT0gJ30nICYmIChsZXR0ZXIgPT0gJ1wiJyB8fCBsZXR0ZXIgPT0gXCInXCIpKSB7XG5cdFx0XHRcdHN0YWNrLnB1c2goZW5kID0gbGV0dGVyKTtcblx0XHRcdH0gZWxzZSBpZiAoZW5kID09ICd9JyAmJiBsZXR0ZXIgPT0gJy8nICYmIChtYXRjaCA9IChIRVJFR0VYLmV4ZWMoc3RyLnNsaWNlKGkpKSB8fCBSRUdFWC5leGVjKHN0ci5zbGljZShpKSkpKSkge1xuXHRcdFx0XHRpICs9IG1hdGNoWzBdLmxlbmd0aCAtIDE7XG5cdFx0XHR9IGVsc2UgaWYgKGVuZCA9PSAnfScgJiYgbGV0dGVyID09ICd7Jykge1xuXHRcdFx0XHRzdGFjay5wdXNoKGVuZCA9ICd9Jyk7XG5cdFx0XHR9IGVsc2UgaWYgKGVuZCA9PSAnXCInICYmIGxldHRlciA9PSAneycpIHtcblx0XHRcdFx0c3RhY2sucHVzaChlbmQgPSAnfScpO1xuXHRcdFx0fTtcblx0XHRcdHByZXYgPSBsZXR0ZXI7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoIXRoaXMuX29wdHMuc2lsZW50KSB7IHJldHVybiB0aGlzLmVycm9yKChcIm1pc3NpbmcgXCIgKyAoc3RhY2sucG9wKCkpICsgXCIsIHN0YXJ0aW5nXCIpKSB9O1xuXHR9O1xuXHRcblx0Ly8gRXhwYW5kIHZhcmlhYmxlcyBhbmQgZXhwcmVzc2lvbnMgaW5zaWRlIGRvdWJsZS1xdW90ZWQgc3RyaW5ncyB1c2luZ1xuXHQvLyBSdWJ5LWxpa2Ugbm90YXRpb24gZm9yIHN1YnN0aXR1dGlvbiBvZiBhcmJpdHJhcnkgZXhwcmVzc2lvbnMuXG5cdC8vXG5cdC8vICAgICBcIkhlbGxvICN7bmFtZS5jYXBpdGFsaXplKCl9LlwiXG5cdC8vXG5cdC8vIElmIGl0IGVuY291bnRlcnMgYW4gaW50ZXJwb2xhdGlvbiwgdGhpcyBtZXRob2Qgd2lsbCByZWN1cnNpdmVseSBjcmVhdGUgYVxuXHQvLyBuZXcgTGV4ZXIsIHRva2VuaXplIHRoZSBpbnRlcnBvbGF0ZWQgY29udGVudHMsIGFuZCBtZXJnZSB0aGVtIGludG8gdGhlXG5cdC8vIHRva2VuIHN0cmVhbS5cblx0TGV4ZXIucHJvdG90eXBlLmludGVycG9sYXRlU3RyaW5nID0gZnVuY3Rpb24gKHN0cixvcHRpb25zKXtcblx0XHQvLyBjb25zb2xlLmxvZyBcImludGVycG9sYXRlIHN0cmluZ1wiXG5cdFx0aWYob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSBvcHRpb25zID0ge307XG5cdFx0dmFyIGhlcmVkb2MgPSBvcHRpb25zLmhlcmVkb2M7XG5cdFx0dmFyIHF1b3RlID0gb3B0aW9ucy5xdW90ZTtcblx0XHR2YXIgcmVnZXggPSBvcHRpb25zLnJlZ2V4O1xuXHRcdHZhciBwcmVmaXggPSBvcHRpb25zLnByZWZpeDtcblx0XHRcblx0XHR2YXIgc3RhcnRMb2MgPSB0aGlzLl9sb2M7XG5cdFx0dmFyIHRva2VucyA9IFtdO1xuXHRcdHZhciBwaSA9IDA7XG5cdFx0dmFyIGkgPSAtMTtcblx0XHR2YXIgbG9jT2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQgfHwgMTtcblx0XHR2YXIgc3RybGVuID0gc3RyLmxlbmd0aDtcblx0XHR2YXIgbGV0dGVyO1xuXHRcdHZhciBleHByO1xuXHRcdFxuXHRcdHZhciBpc0ludGVycG9sYXRlZCA9IGZhbHNlO1xuXHRcdC8vIG91dCBvZiBib3VuZHNcblx0XHR3aGlsZSAobGV0dGVyID0gc3RyLmNoYXJBdChpICs9IDEpKXtcblx0XHRcdGlmIChsZXR0ZXIgPT0gJ1xcXFwnKSB7XG5cdFx0XHRcdGkgKz0gMTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoIShzdHIuY2hhckF0KGkpID09ICd7JyAmJiAoZXhwciA9IHRoaXMuYmFsYW5jZWRTdHJpbmcoc3RyLnNsaWNlKGkpLCd9JykpKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlzSW50ZXJwb2xhdGVkID0gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0Ly8gdGhlc2UgaGF2ZSBubyByZWFsIHNlbnNlIG9mIGxvY2F0aW9uIG9yIGFueXRoaW5nP1xuXHRcdFx0aWYgKHBpIDwgaSkge1xuXHRcdFx0XHQvLyB0aGlzIGlzIHRoZSBwcmVmaXgtc3RyaW5nIC0gYmVmb3JlIGFueSBpdGVtXG5cdFx0XHRcdHZhciB0b2sgPSBuZXcgVG9rZW4oJ05FT1NUUklORycsdGhpcy5lc2NhcGVTdHIoc3RyLnNsaWNlKHBpLGkpLGhlcmVkb2MscXVvdGUpLHRoaXMuX2xvYyArIHBpICsgbG9jT2Zmc2V0LGkgLSBwaSk7XG5cdFx0XHRcdC8vIHRvay5AbG9jID0gQGxvYyArIHBpXG5cdFx0XHRcdC8vIHRvay5AbGVuID0gaSAtIHBpICsgMlxuXHRcdFx0XHR0b2tlbnMucHVzaCh0b2spO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dG9rZW5zLnB1c2gobmV3IFRva2VuKCd7eycsJ3snLHRoaXMuX2xvYyArIGkgKyBsb2NPZmZzZXQsMSkpO1xuXHRcdFx0XG5cdFx0XHR2YXIgaW5uZXIgPSBleHByLnNsaWNlKDEsLTEpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2lubmVyIGlzJyxpbm5lclxuXHRcdFx0Ly8gcmVtb3ZlIGxlYWRpbmcgc3BhY2VzIFxuXHRcdFx0Ly8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIGhvdyBtdWNoIHdoaXRlc3BhY2Ugd2UgZHJvcHBlZCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0aW5uZXIgPSBpbm5lci5yZXBsYWNlKC9eW15cXG5cXFNdKy8sJycpO1xuXHRcdFx0XG5cdFx0XHRpZiAoaW5uZXIubGVuZ3RoKSB7XG5cdFx0XHRcdC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIGxvYyB3ZSBzdGFydCBhdFxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnaW50ZXJwb2xhdGUgZnJvbSBsb2MnLEBsb2MsaSlcblx0XHRcdFx0Ly8gcmVhbGx5PyB3aHkgbm90IGp1c3QgYWRkIHRvIHRoZSBzdGFjaz8/XG5cdFx0XHRcdC8vIHdoYXQgYWJvdXQgdGhlIGFkZGVkIFxuXHRcdFx0XHQvLyBzaG91bGQgc2hhcmUgd2l0aCB0aGUgc2VsZWN0b3Igbm8/XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwidG9rZW5pemUgaW5uZXIgcGFydHMgb2Ygc3RyaW5nXCIsaW5uZXJcblx0XHRcdFx0dmFyIHNwYWNlcyA9IDA7XG5cdFx0XHRcdHZhciBvZmZzZXQgPSB0aGlzLl9sb2MgKyBpICsgKGV4cHIubGVuZ3RoIC0gaW5uZXIubGVuZ3RoKSAtIDE7XG5cdFx0XHRcdC8vIHdoeSBjcmVhdGUgYSB3aG9sZSBuZXcgbGV4ZXI/IFNob3VsZCByYXRoZXIgcmV1c2Ugb25lXG5cdFx0XHRcdC8vIG11Y2ggYmV0dGVyIHRvIHNpbXBseSBtb3ZlIGludG8gaW50ZXJwb2xhdGlvbiBtb2RlIHdoZXJlXG5cdFx0XHRcdC8vIHdlIGNvbnRpbnVlIHBhcnNpbmcgdW50aWwgd2UgbWVldCB1bnBhaXJlZCB9XG5cdFx0XHRcdHZhciBuZXN0ZWQgPSBuZXcgTGV4ZXIoKS50b2tlbml6ZShpbm5lcix7aW5saW5lOiB0cnVlLHJld3JpdGU6IGZhbHNlLGxvYzogb2Zmc2V0ICsgbG9jT2Zmc2V0fSk7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIG5lc3RlZC5wb3Bcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChuZXN0ZWRbMF0gJiYgdFQobmVzdGVkWzBdKSA9PSAnVEVSTUlOQVRPUicpIHtcblx0XHRcdFx0XHRuZXN0ZWQuc2hpZnQoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChuZXN0ZWQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dG9rZW5zLnB1c2guYXBwbHkodG9rZW5zLG5lc3RlZCk7IC8vIFQudG9rZW4oJ1RPS0VOUycsbmVzdGVkLDApXG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBzaG91bGQgcmF0aGVyIGFkZCB0aGUgYW1vdW50IGJ5IHdoaWNoIG91ciBsZXhlciBoYXMgbW92ZWQ/XG5cdFx0XHRpICs9IGV4cHIubGVuZ3RoIC0gMTtcblx0XHRcdHRva2Vucy5wdXNoKG5ldyBUb2tlbignfX0nLCd9Jyx0aGlzLl9sb2MgKyBpICsgbG9jT2Zmc2V0LDEpKTtcblx0XHRcdHBpID0gaSArIDE7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBhZGRpbmcgdGhlIGxhc3QgcGFydCBvZiB0aGUgc3RyaW5nIGhlcmVcblx0XHRpZiAoaSA+PSBwaSAmJiBwaSA8IHN0ci5sZW5ndGgpIHtcblx0XHRcdC8vIHNldCB0aGUgbGVuZ3RoIGFzIHdlbGwgLSBvcj9cblx0XHRcdC8vIHRoZSBzdHJpbmcgYWZ0ZXI/XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAncHVzaCBuZW9zdHJpbmcnXG5cdFx0XHR0b2tlbnMucHVzaChuZXcgVG9rZW4oJ05FT1NUUklORycsdGhpcy5lc2NhcGVTdHIoc3RyLnNsaWNlKHBpKSxoZXJlZG9jLHF1b3RlKSx0aGlzLl9sb2MgKyBwaSArIGxvY09mZnNldCxzdHIubGVuZ3RoIC0gcGkpKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nIHRva2VuczpsZW5ndGhcblx0XHRpZiAocmVnZXgpIHsgcmV0dXJuIHRva2VucyB9O1xuXHRcdFxuXHRcdGlmICghdG9rZW5zLmxlbmd0aCkgeyByZXR1cm4gdGhpcy50b2tlbignTkVPU1RSSU5HJywnXCJcIicpIH07XG5cdFx0XG5cdFx0Zm9yICh2YXIgaiA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuXHRcdFx0dGhpcy5fdG9rZW5zLnB1c2godG9rZW5zW2pdKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0b2tlbnM7XG5cdH07XG5cdFxuXHQvLyBNYXRjaGVzIGEgYmFsYW5jZWQgZ3JvdXAgc3VjaCBhcyBhIHNpbmdsZSBvciBkb3VibGUtcXVvdGVkIHN0cmluZy4gUGFzcyBpblxuXHQvLyBhIHNlcmllcyBvZiBkZWxpbWl0ZXJzLCBhbGwgb2Ygd2hpY2ggbXVzdCBiZSBuZXN0ZWQgY29ycmVjdGx5IHdpdGhpbiB0aGVcblx0Ly8gY29udGVudHMgb2YgdGhlIHN0cmluZy4gVGhpcyBtZXRob2QgYWxsb3dzIHVzIHRvIGhhdmUgc3RyaW5ncyB3aXRoaW5cblx0Ly8gaW50ZXJwb2xhdGlvbnMgd2l0aGluIHN0cmluZ3MsIGFkIGluZmluaXR1bS5cblx0TGV4ZXIucHJvdG90eXBlLmJhbGFuY2VkU2VsZWN0b3IgPSBmdW5jdGlvbiAoc3RyLGVuZCl7XG5cdFx0dmFyIHByZXY7XG5cdFx0dmFyIGxldHRlcjtcblx0XHR2YXIgc3RhY2sgPSBbZW5kXTtcblx0XHQvLyBGSVhNRVxuXHRcdGZvciAodmFyIGxlbiA9IHN0ci5sZW5ndGgsIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHN3aXRjaCAobGV0dGVyID0gc3RyLmNoYXJBdChpKSkge1xuXHRcdFx0XHRjYXNlICdcXFxcJzpcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFxuXHRcdFx0XHRjYXNlIGVuZDpcblx0XHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0XHRpZiAoIXN0YWNrLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHN0ci5zbGljZSgwLGkgKyAxKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGVuZCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XG5cdFx0XHR9O1xuXHRcdFx0aWYgKGVuZCA9PSAnfScgJiYgbGV0dGVyID09IFsnKSddKSB7XG5cdFx0XHRcdHN0YWNrLnB1c2goZW5kID0gbGV0dGVyKTtcblx0XHRcdH0gZWxzZSBpZiAoZW5kID09ICd9JyAmJiBsZXR0ZXIgPT0gJ3snKSB7XG5cdFx0XHRcdHN0YWNrLnB1c2goZW5kID0gJ30nKTtcblx0XHRcdH0gZWxzZSBpZiAoZW5kID09ICcpJyAmJiBsZXR0ZXIgPT0gJ3snKSB7XG5cdFx0XHRcdHN0YWNrLnB1c2goZW5kID0gJ30nKTtcblx0XHRcdH07XG5cdFx0XHRwcmV2ID0gbGV0dGVyOyAvLyB3aGF0LCB3aHk/XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcy5lcnJvcigoXCJtaXNzaW5nIFwiICsgKHN0YWNrLnBvcCgpKSArIFwiLCBzdGFydGluZ1wiKSk7XG5cdH07XG5cdFxuXHQvLyBQYWlycyB1cCBhIGNsb3NpbmcgdG9rZW4sIGVuc3VyaW5nIHRoYXQgYWxsIGxpc3RlZCBwYWlycyBvZiB0b2tlbnMgYXJlXG5cdC8vIGNvcnJlY3RseSBiYWxhbmNlZCB0aHJvdWdob3V0IHRoZSBjb3Vyc2Ugb2YgdGhlIHRva2VuIHN0cmVhbS5cblx0TGV4ZXIucHJvdG90eXBlLnBhaXIgPSBmdW5jdGlvbiAodG9rKXtcblx0XHR2YXIgd2FudGVkID0gbGFzdCh0aGlzLl9lbmRzKTtcblx0XHRpZiAodG9rICE9IHdhbnRlZCkge1xuXHRcdFx0aWYgKCdPVVRERU5UJyAhPSB3YW50ZWQpIHsgdGhpcy5lcnJvcigoXCJ1bm1hdGNoZWQgXCIgKyB0b2spKSB9O1xuXHRcdFx0dmFyIHNpemUgPSBsYXN0KHRoaXMuX2luZGVudHMpO1xuXHRcdFx0dGhpcy5faW5kZW50IC09IHNpemU7XG5cdFx0XHR0aGlzLm91dGRlbnRUb2tlbihzaXplLHRydWUsMCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYWlyKHRvayk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcy5wb3BFbmQoKTtcblx0fTtcblx0XG5cdFxuXHQvLyBIZWxwZXJzXG5cdC8vIC0tLS0tLS1cblx0XG5cdC8vIEFkZCBhIHRva2VuIHRvIHRoZSByZXN1bHRzLCB0YWtpbmcgbm90ZSBvZiB0aGUgbGluZSBudW1iZXIuXG5cdExleGVyLnByb3RvdHlwZS50b2tlbiA9IGZ1bmN0aW9uIChpZCx2YWx1ZSxsZW4sb2Zmc2V0KXtcblx0XHR0aGlzLl9sYXN0VHlwID0gaWQ7XG5cdFx0dGhpcy5fbGFzdFZhbCA9IHZhbHVlO1xuXHRcdHZhciB0b2sgPSB0aGlzLl9sYXN0ID0gbmV3IFRva2VuKGlkLHZhbHVlLHRoaXMuX2xvYyArIChvZmZzZXQgfHwgMCksbGVuIHx8IDApO1xuXHRcdHRoaXMuX3Rva2Vucy5wdXNoKHRvayk7XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0TGV4ZXIucHJvdG90eXBlLmxhc3RUb2tlblR5cGUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdG9rZW4gPSB0aGlzLl90b2tlbnNbdGhpcy5fdG9rZW5zLmxlbmd0aCAtIDFdO1xuXHRcdHJldHVybiB0b2tlbiA/ICh0VCh0b2tlbikpIDogKCdOT05FJyk7XG5cdH07XG5cdFxuXHRMZXhlci5wcm90b3R5cGUubGFzdFRva2VuVmFsdWUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdG9rZW4gPSB0aGlzLl90b2tlbnNbdGhpcy5fdG9rZW5zLmxlbmd0aCAtIDFdO1xuXHRcdHJldHVybiB0b2tlbiA/ICh0b2tlbi5fdmFsdWUpIDogKCcnKTtcblx0fTtcblx0XG5cdC8vIFBlZWsgYXQgYSB0b2tpZCBpbiB0aGUgY3VycmVudCB0b2tlbiBzdHJlYW0uXG5cdExleGVyLnByb3RvdHlwZS50b2tpZCA9IGZ1bmN0aW9uIChpbmRleCx2YWwpe1xuXHRcdHZhciB0b2s7XG5cdFx0aWYgKHRvayA9IGxhc3QodGhpcy5fdG9rZW5zLGluZGV4KSkge1xuXHRcdFx0aWYgKHZhbCkgeyB0VHModG9rLHZhbCkgfTtcblx0XHRcdHJldHVybiB0VCh0b2spO1xuXHRcdFx0Ly8gdG9rLkB0eXBlID0gdG9raWQgaWYgdG9raWQgIyB3aHk/XG5cdFx0XHQvLyB0b2suQHR5cGVcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fTtcblx0XG5cdC8vIFBlZWsgYXQgYSB2YWx1ZSBpbiB0aGUgY3VycmVudCB0b2tlbiBzdHJlYW0uXG5cdExleGVyLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uIChpbmRleCx2YWwpe1xuXHRcdHZhciB0b2s7XG5cdFx0aWYgKHRvayA9IGxhc3QodGhpcy5fdG9rZW5zLGluZGV4KSkge1xuXHRcdFx0aWYgKHZhbCkgeyB0VnModG9rLHZhbCkgfTtcblx0XHRcdHJldHVybiB0Vih0b2spO1xuXHRcdFx0Ly8gdG9rLkB2YWx1ZSA9IHZhbCBpZiB2YWwgIyB3aHk/XG5cdFx0XHQvLyB0b2suQHZhbHVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdH07XG5cdFxuXHRcblx0Ly8gQXJlIHdlIGluIHRoZSBtaWRzdCBvZiBhbiB1bmZpbmlzaGVkIGV4cHJlc3Npb24/XG5cdExleGVyLnByb3RvdHlwZS51bmZpbmlzaGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKExJTkVfQ09OVElOVUVSLnRlc3QodGhpcy5fY2h1bmspKSB7IHJldHVybiB0cnVlIH07XG5cdFx0cmV0dXJuIFVORklOSVNIRUQuaW5kZXhPZih0aGlzLl9sYXN0VHlwKSA+PSAwO1xuXHR9O1xuXHRcblx0Ly8gdmFyIHRva2VucyA9IFsnXFxcXCcsJy4nLCAnPy4nLCAnVU5BUlknLCAnTUFUSCcsICcrJywgJy0nLCAnU0hJRlQnLCAnUkVMQVRJT04nLCAnQ09NUEFSRScsICdMT0dJQycsICdDT01QT1VORF9BU1NJR04nLCAnVEhST1cnLCAnRVhURU5EUyddXG5cdFxuXHQvLyBDb252ZXJ0cyBuZXdsaW5lcyBmb3Igc3RyaW5nIGxpdGVyYWxzLlxuXHRMZXhlci5wcm90b3R5cGUuZXNjYXBlTGluZXMgPSBmdW5jdGlvbiAoc3RyLGhlcmVkb2Mpe1xuXHRcdHJldHVybiBzdHIucmVwbGFjZShNVUxUSUxJTkVSLChoZXJlZG9jID8gKCdcXFxcbicpIDogKCcnKSkpO1xuXHR9O1xuXHRcblx0Ly8gQ29uc3RydWN0cyBhIHN0cmluZyB0b2tlbiBieSBlc2NhcGluZyBxdW90ZXMgYW5kIG5ld2xpbmVzLlxuXHRMZXhlci5wcm90b3R5cGUubWFrZVN0cmluZyA9IGZ1bmN0aW9uIChib2R5LHF1b3RlLGhlcmVkb2Mpe1xuXHRcdGlmICghYm9keSkgeyByZXR1cm4gcXVvdGUgKyBxdW90ZSB9O1xuXHRcdGJvZHkgPSBib2R5LnJlcGxhY2UoL1xcXFwoW1xcc1xcU10pL2csZnVuY3Rpb24obWF0Y2gsY29udGVudHMpIHtcblx0XHRcdHJldHVybiAoY29udGVudHMgPT0gJ1xcbicgfHwgY29udGVudHMgPT0gcXVvdGUpID8gKGNvbnRlbnRzKSA6IChtYXRjaCk7XG5cdFx0fSk7XG5cdFx0Ly8gRG9lcyBub3Qgd29yayBub3dcblx0XHRib2R5ID0gYm9keS5yZXBsYWNlKFJlZ0V4cCgoXCJcIiArIHF1b3RlKSxcImdcIiksJ1xcXFwkJicpO1xuXHRcdHJldHVybiBxdW90ZSArIHRoaXMuZXNjYXBlTGluZXMoYm9keSxoZXJlZG9jKSArIHF1b3RlO1xuXHR9O1xuXHRcblx0Ly8gVGhyb3dzIGEgc3ludGF4IGVycm9yIG9uIHRoZSBjdXJyZW50IGBAbGluZWAuXG5cdExleGVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLGxlbil7XG5cdFx0aWYgKCh0eXBlb2YgdGhpcy5fbGluZT09J251bWJlcid8fHRoaXMuX2xpbmUgaW5zdGFuY2VvZiBOdW1iZXIpKSB7IG1lc3NhZ2UgPSAoXCJcIiArIG1lc3NhZ2UgKyBcIiBvbiBsaW5lIFwiICsgKHRoaXMuX2xpbmUpKSB9O1xuXHRcdFxuXHRcdGlmIChsZW4pIHtcblx0XHRcdG1lc3NhZ2UgKz0gKFwiIFtcIiArICh0aGlzLl9sb2MpICsgXCI6XCIgKyAodGhpcy5fbG9jICsgbGVuKSArIFwiXVwiKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBlcnIgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSk7XG5cdFx0ZXJyLmxpbmUgPSB0aGlzLl9saW5lO1xuXHRcdC8vIGVycjpjb2x1bW5OdW1iZXJcblx0XHRlcnIgPSBuZXcgRVJSLkltYmFQYXJzZUVycm9yKGVycix7dG9rZW5zOiB0aGlzLl90b2tlbnMscG9zOiB0aGlzLl90b2tlbnMubGVuZ3RofSk7XG5cdFx0ZXJyLnJlZ2lvbiA9IFt0aGlzLl9sb2MsdGhpcy5fbG9jICsgKGxlbiB8fCAwKV07XG5cdFx0dGhyb3cgZXJyO1xuXHR9O1xuXHRyZXR1cm4gTGV4ZXI7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL34vaW1iYS9zcmMvY29tcGlsZXIvbGV4ZXIuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0dmFyIFRPSywgTEJSQUNLRVQsIFJCUkFDS0VULCBMUEFSRU4sIFJQQVJFTiwgSU5ERU5ULCBPVVRERU5UO1xuXHRcblx0XG5cdG1vZHVsZS5leHBvcnRzLlRPSyA9IFRPSyA9IHt9O1xuXHR2YXIgVFRFUk1JTkFUT1IgPSBUT0suVEVSTUlOQVRPUiA9IDE7XG5cdHZhciBUSURFTlRJRklFUiA9IFRPSy5JREVOVElGSUVSID0gMjtcblx0VElERU5USUZJRVIgPSBUT0suSVZBUiA9IDI7XG5cdHZhciBDT05TVCA9IFRPSy5DT05TVCA9IDM7XG5cdHZhciBWQVIgPSBUT0suVkFSID0gNDtcblx0dmFyIElGID0gVE9LLklGID0gNTtcblx0dmFyIEVMU0UgPSBUT0suRUxTRSA9IDY7XG5cdHZhciBERUYgPSBUT0suREVGID0gNztcblx0XG5cdFxuXHRcblx0ZnVuY3Rpb24gVG9rZW4odHlwZSx2YWx1ZSxsb2MsbGVuKXtcblx0XHR0aGlzLl90eXBlID0gdHlwZTtcblx0XHR0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXHRcdHRoaXMuX2xvYyA9IGxvYyAhPSBudWxsID8gKGxvYykgOiAoLTEpO1xuXHRcdHRoaXMuX2xlbiA9IGxlbiB8fCAwO1xuXHRcdHRoaXMuX21ldGEgPSBudWxsO1xuXHRcdHRoaXMuZ2VuZXJhdGVkID0gZmFsc2U7XG5cdFx0dGhpcy5uZXdMaW5lID0gZmFsc2U7XG5cdFx0dGhpcy5zcGFjZWQgPSBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdGV4cG9ydHMuVG9rZW4gPSBUb2tlbjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRUb2tlbi5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl90eXBlO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gXCJcIiArIHRoaXMuX3ZhbHVlO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLmNoYXJBdCA9IGZ1bmN0aW9uIChpKXtcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWUuY2hhckF0KGkpO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGkpe1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZS5zbGljZShpKTtcblx0fTtcblx0XG5cdFRva2VuLnByb3RvdHlwZS5yZWdpb24gPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gW3RoaXMuX2xvYyx0aGlzLl9sb2MgKyAodGhpcy5fbGVuIHx8IHRoaXMuX3ZhbHVlLmxlbmd0aCldO1xuXHR9O1xuXHRcblx0VG9rZW4ucHJvdG90eXBlLnNvdXJjZU1hcE1hcmtlciA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9sb2MgPT0gLTEgPyAoJzonKSA6ICgoXCIlJFwiICsgKHRoaXMuX2xvYykgKyBcIiQlXCIpKTtcblx0XHQvLyBAY29sID09IC0xID8gJycgOiBcIiUle0BsaW5lfSR7QGNvbH0lJVwiXG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gbGV4KCl7XG5cdFx0dmFyIHRva2VuID0gdGhpcy50b2tlbnNbdGhpcy5wb3MrK107XG5cdFx0dmFyIHR0YWc7XG5cdFx0XG5cdFx0aWYgKHRva2VuKSB7XG5cdFx0XHR0dGFnID0gdG9rZW4uX3R5cGU7XG5cdFx0XHR0aGlzLnl5dGV4dCA9IHRva2VuO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0dGFnID0gJyc7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdHRhZztcblx0fTsgZXhwb3J0cy5sZXggPSBsZXg7XG5cdFxuXHRcblx0Ly8gZXhwb3J0IGRlZiB0b2tlbiB0eXAsIHZhbCwgbGluZSwgY29sLCBsZW4gZG8gVG9rZW4ubmV3KHR5cCx2YWwsbGluZSwgY29sIG9yIDAsIGxlbiBvciAwKSAjIFtudWxsLHR5cCx2YWwsbG9jXVxuXHRmdW5jdGlvbiB0b2tlbih0eXAsdmFsKXtcblx0XHRyZXR1cm4gbmV3IFRva2VuKHR5cCx2YWwsLTEsMCk7XG5cdH07IGV4cG9ydHMudG9rZW4gPSB0b2tlbjtcblx0XG5cdGZ1bmN0aW9uIHR5cCh0b2spe1xuXHRcdHJldHVybiB0b2suX3R5cGU7XG5cdH07IGV4cG9ydHMudHlwID0gdHlwO1xuXHRmdW5jdGlvbiB2YWwodG9rKXtcblx0XHRyZXR1cm4gdG9rLl92YWx1ZTtcblx0fTsgZXhwb3J0cy52YWwgPSB2YWw7IC8vIHRva1tvZmZzZXQgKyAxXVxuXHRmdW5jdGlvbiBsaW5lKHRvayl7XG5cdFx0cmV0dXJuIHRvay5fbGluZTtcblx0fTsgZXhwb3J0cy5saW5lID0gbGluZTsgLy8gdG9rW29mZnNldCArIDJdXG5cdGZ1bmN0aW9uIGxvYyh0b2spe1xuXHRcdHJldHVybiB0b2suX2xvYztcblx0fTsgZXhwb3J0cy5sb2MgPSBsb2M7IC8vIHRva1tvZmZzZXQgKyAyXVxuXHRcblx0ZnVuY3Rpb24gc2V0VHlwKHRvayx2KXtcblx0XHRyZXR1cm4gdG9rLl90eXBlID0gdjtcblx0fTsgZXhwb3J0cy5zZXRUeXAgPSBzZXRUeXA7XG5cdGZ1bmN0aW9uIHNldFZhbCh0b2ssdil7XG5cdFx0cmV0dXJuIHRvay5fdmFsdWUgPSB2O1xuXHR9OyBleHBvcnRzLnNldFZhbCA9IHNldFZhbDtcblx0ZnVuY3Rpb24gc2V0TGluZSh0b2ssdil7XG5cdFx0cmV0dXJuIHRvay5fbGluZSA9IHY7XG5cdH07IGV4cG9ydHMuc2V0TGluZSA9IHNldExpbmU7XG5cdGZ1bmN0aW9uIHNldExvYyh0b2ssdil7XG5cdFx0cmV0dXJuIHRvay5fbG9jID0gdjtcblx0fTsgZXhwb3J0cy5zZXRMb2MgPSBzZXRMb2M7XG5cdFxuXHRcblx0bW9kdWxlLmV4cG9ydHMuTEJSQUNLRVQgPSBMQlJBQ0tFVCA9IG5ldyBUb2tlbigneycsJ3snLDAsMCwwKTtcblx0bW9kdWxlLmV4cG9ydHMuUkJSQUNLRVQgPSBSQlJBQ0tFVCA9IG5ldyBUb2tlbignfScsJ30nLDAsMCwwKTtcblx0XG5cdG1vZHVsZS5leHBvcnRzLkxQQVJFTiA9IExQQVJFTiA9IG5ldyBUb2tlbignKCcsJygnLDAsMCwwKTtcblx0bW9kdWxlLmV4cG9ydHMuUlBBUkVOID0gUlBBUkVOID0gbmV3IFRva2VuKCcpJywnKScsMCwwLDApO1xuXHRcblx0TEJSQUNLRVQuZ2VuZXJhdGVkID0gdHJ1ZTtcblx0UkJSQUNLRVQuZ2VuZXJhdGVkID0gdHJ1ZTtcblx0TFBBUkVOLmdlbmVyYXRlZCA9IHRydWU7XG5cdFJQQVJFTi5nZW5lcmF0ZWQgPSB0cnVlO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMuSU5ERU5UID0gSU5ERU5UID0gbmV3IFRva2VuKCdJTkRFTlQnLCcyJywwLDAsMCk7XG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cy5PVVRERU5UID0gT1VUREVOVCA9IG5ldyBUb2tlbignT1VUREVOVCcsJzInLDAsMCwwKTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvfi9pbWJhL3NyYy9jb21waWxlci90b2tlbi5pbWJhXG4gKiogbW9kdWxlIGlkID0gMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpZHgkKGEsYil7XG5cdFx0cmV0dXJuIChiICYmIGIuaW5kZXhPZikgPyBiLmluZGV4T2YoYSkgOiBbXS5pbmRleE9mLmNhbGwoYSxiKTtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdHZhciBJTlZFUlNFUywgTElORUJSRUFLUztcblx0XG5cdC8vIFRoZSBJbWJhIGxhbmd1YWdlIGhhcyBhIGdvb2QgZGVhbCBvZiBvcHRpb25hbCBzeW50YXgsIGltcGxpY2l0IHN5bnRheCxcblx0Ly8gYW5kIHNob3J0aGFuZCBzeW50YXguIFRoaXMgY2FuIGdyZWF0bHkgY29tcGxpY2F0ZSBhIGdyYW1tYXIgYW5kIGJsb2F0XG5cdC8vIHRoZSByZXN1bHRpbmcgcGFyc2UgdGFibGUuIEluc3RlYWQgb2YgbWFraW5nIHRoZSBwYXJzZXIgaGFuZGxlIGl0IGFsbCwgd2UgdGFrZVxuXHQvLyBhIHNlcmllcyBvZiBwYXNzZXMgb3ZlciB0aGUgdG9rZW4gc3RyZWFtLCB1c2luZyB0aGlzICoqUmV3cml0ZXIqKiB0byBjb252ZXJ0XG5cdC8vIHNob3J0aGFuZCBpbnRvIHRoZSB1bmFtYmlndW91cyBsb25nIGZvcm0sIGFkZCBpbXBsaWNpdCBpbmRlbnRhdGlvbiBhbmRcblx0Ly8gcGFyZW50aGVzZXMsIGFuZCBnZW5lcmFsbHkgY2xlYW4gdGhpbmdzIHVwLlxuXHRcblx0dmFyIFQgPSByZXF1aXJlKCcuL3Rva2VuJyk7XG5cdHZhciBUb2tlbiA9IFQuVG9rZW47XG5cdFxuXHQvLyBCYXNlZCBvbiB0aGUgb3JpZ2luYWwgcmV3cml0ZXIuY29mZmVlIGZyb20gQ29mZmVlU2NyaXB0XG5cdGZ1bmN0aW9uIFJld3JpdGVyKCl7IH07XG5cdFxuXHRleHBvcnRzLlJld3JpdGVyID0gUmV3cml0ZXI7IC8vIGV4cG9ydCBjbGFzcyBcblx0UmV3cml0ZXIucHJvdG90eXBlLnRva2VucyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl90b2tlbnM7XG5cdH07XG5cdFxuXHQvLyBIZWxwZnVsIHNuaXBwZXQgZm9yIGRlYnVnZ2luZzpcblx0Ly8gICAgIGNvbnNvbGUubG9nICh0WzBdICsgJy8nICsgdFsxXSBmb3IgdCBpbiBAdG9rZW5zKS5qb2luICcgJ1xuXHQvLyBSZXdyaXRlIHRoZSB0b2tlbiBzdHJlYW0gaW4gbXVsdGlwbGUgcGFzc2VzLCBvbmUgbG9naWNhbCBmaWx0ZXIgYXRcblx0Ly8gYSB0aW1lLiBUaGlzIGNvdWxkIGNlcnRhaW5seSBiZSBjaGFuZ2VkIGludG8gYSBzaW5nbGUgcGFzcyB0aHJvdWdoIHRoZVxuXHQvLyBzdHJlYW0sIHdpdGggYSBiaWcgb2wnIGVmZmljaWVudCBzd2l0Y2gsIGJ1dCBpdCdzIG11Y2ggbmljZXIgdG8gd29yayB3aXRoXG5cdC8vIGxpa2UgdGhpcy4gVGhlIG9yZGVyIG9mIHRoZXNlIHBhc3NlcyBtYXR0ZXJzIC0tIGluZGVudGF0aW9uIG11c3QgYmVcblx0Ly8gY29ycmVjdGVkIGJlZm9yZSBpbXBsaWNpdCBwYXJlbnRoZXNlcyBjYW4gYmUgd3JhcHBlZCBhcm91bmQgYmxvY2tzIG9mIGNvZGUuXG5cdFJld3JpdGVyLnByb3RvdHlwZS5yZXdyaXRlID0gZnVuY3Rpb24gKHRva2VucyxvcHRzKXtcblx0XHR2YXIgdG9rZW47XG5cdFx0aWYob3B0cyA9PT0gdW5kZWZpbmVkKSBvcHRzID0ge307XG5cdFx0dGhpcy5fdG9rZW5zID0gdG9rZW5zO1xuXHRcdHRoaXMuX29wdGlvbnMgPSBvcHRzO1xuXHRcdFxuXHRcdC8vIGNvbnNvbGUubG9nIFwidG9rZW5zIGluOiBcIiArIHRva2VuczpsZW5ndGhcblx0XHRpZiAob3B0cy5wcm9maWxlKSB7IGNvbnNvbGUudGltZShcInRva2VuaXplOnJld3JpdGVcIikgfTtcblx0XHRcblx0XHR2YXIgaSA9IDA7XG5cdFx0Ly8gZmxhZyBlbXB0eSBtZXRob2RzXG5cdFx0d2hpbGUgKHRva2VuID0gdG9rZW5zW2ldKXtcblx0XHRcdHZhciBuZXh0ID0gdG9rZW5zW2kgKyAxXTtcblx0XHRcdGlmICh0b2tlbi5fdHlwZSA9PSAnREVGX0JPRFknICYmIG5leHQgJiYgbmV4dC5fdHlwZSA9PSAnVEVSTUlOQVRPUicpIHtcblx0XHRcdFx0dG9rZW4uX3R5cGUgPSAnREVGX0VNUFRZJztcblx0XHRcdH07XG5cdFx0XHRpKys7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLnN0ZXAoXCJlbnN1cmVGaXJzdExpbmVcIik7XG5cdFx0dGhpcy5zdGVwKFwicmVtb3ZlTGVhZGluZ05ld2xpbmVzXCIpO1xuXHRcdHRoaXMuc3RlcChcInJlbW92ZU1pZEV4cHJlc3Npb25OZXdsaW5lc1wiKTtcblx0XHR0aGlzLnN0ZXAoXCJ0YWdEZWZBcmd1bWVudHNcIik7XG5cdFx0dGhpcy5zdGVwKFwiY2xvc2VPcGVuQ2FsbHNcIik7XG5cdFx0dGhpcy5zdGVwKFwiY2xvc2VPcGVuSW5kZXhlc1wiKTtcblx0XHR0aGlzLnN0ZXAoXCJjbG9zZU9wZW5UYWdzXCIpO1xuXHRcdHRoaXMuc3RlcChcImNsb3NlT3BlblRhZ0F0dHJMaXN0c1wiKTtcblx0XHR0aGlzLnN0ZXAoXCJhZGRJbXBsaWNpdEluZGVudGF0aW9uXCIpO1xuXHRcdHRoaXMuc3RlcChcInRhZ1Bvc3RmaXhDb25kaXRpb25hbHNcIik7XG5cdFx0dGhpcy5zdGVwKFwiYWRkSW1wbGljaXRCcmFjZXNcIik7XG5cdFx0dGhpcy5zdGVwKFwiYWRkSW1wbGljaXRQYXJlbnRoZXNlc1wiKTtcblx0XHRcblx0XHRpZiAob3B0cy5wcm9maWxlKSB7IGNvbnNvbGUudGltZUVuZChcInRva2VuaXplOnJld3JpdGVcIikgfTtcblx0XHQvLyBjb25zb2xlLmxvZyBcInRva2VucyBvdXQ6IFwiICsgQHRva2VuczpsZW5ndGhcblx0XHRyZXR1cm4gdGhpcy5fdG9rZW5zO1xuXHR9O1xuXHRcblx0UmV3cml0ZXIucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiAoZm4pe1xuXHRcdGlmICh0aGlzLl9vcHRpb25zLnByb2ZpbGUpIHtcblx0XHRcdGNvbnNvbGUubG9nKChcIi0tLS0gc3RhcnRpbmcgXCIgKyBmbiArIFwiIC0tLS0gXCIpKTtcblx0XHRcdGNvbnNvbGUudGltZShmbik7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzW2ZuXSgpO1xuXHRcdFxuXHRcdGlmICh0aGlzLl9vcHRpb25zLnByb2ZpbGUpIHtcblx0XHRcdGNvbnNvbGUudGltZUVuZChmbik7XG5cdFx0XHRjb25zb2xlLmxvZyhcIlxcblxcblwiKTtcblx0XHR9O1xuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdC8vIFJld3JpdGUgdGhlIHRva2VuIHN0cmVhbSwgbG9va2luZyBvbmUgdG9rZW4gYWhlYWQgYW5kIGJlaGluZC5cblx0Ly8gQWxsb3cgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgYmxvY2sgdG8gdGVsbCB1cyBob3cgbWFueSB0b2tlbnMgdG8gbW92ZVxuXHQvLyBmb3J3YXJkcyAob3IgYmFja3dhcmRzKSBpbiB0aGUgc3RyZWFtLCB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgbWlzcyBhbnl0aGluZ1xuXHQvLyBhcyB0b2tlbnMgYXJlIGluc2VydGVkIGFuZCByZW1vdmVkLCBhbmQgdGhlIHN0cmVhbSBjaGFuZ2VzIGxlbmd0aCB1bmRlclxuXHQvLyBvdXIgZmVldC5cblx0UmV3cml0ZXIucHJvdG90eXBlLnNjYW5Ub2tlbnMgPSBmdW5jdGlvbiAoYmxvY2spe1xuXHRcdHZhciB0b2tlbjtcblx0XHR2YXIgdG9rZW5zID0gdGhpcy5fdG9rZW5zO1xuXHRcdFxuXHRcdHZhciBpID0gMDtcblx0XHR3aGlsZSAodG9rZW4gPSB0b2tlbnNbaV0pe1xuXHRcdFx0aSArPSBibG9jay5jYWxsKHRoaXMsdG9rZW4saSx0b2tlbnMpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHRSZXdyaXRlci5wcm90b3R5cGUuZGV0ZWN0RW5kID0gZnVuY3Rpb24gKGksY29uZGl0aW9uLGFjdGlvbil7XG5cdFx0dmFyIHRva2VucyA9IHRoaXMuX3Rva2Vucztcblx0XHR2YXIgbGV2ZWxzID0gMDtcblx0XHR2YXIgc3RhcnRzID0gW107XG5cdFx0dmFyIHRva2VuO1xuXHRcdHZhciB0LHY7XG5cdFx0XG5cdFx0d2hpbGUgKHRva2VuID0gdG9rZW5zW2ldKXtcblx0XHRcdGlmIChsZXZlbHMgPT0gMCAmJiBjb25kaXRpb24uY2FsbCh0aGlzLHRva2VuLGksc3RhcnRzKSkge1xuXHRcdFx0XHRyZXR1cm4gYWN0aW9uLmNhbGwodGhpcyx0b2tlbixpKTtcblx0XHRcdH07XG5cdFx0XHRpZiAoIXRva2VuIHx8IGxldmVscyA8IDApIHtcblx0XHRcdFx0cmV0dXJuIGFjdGlvbi5jYWxsKHRoaXMsdG9rZW4saSAtIDEpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dCA9IFQudHlwKHRva2VuKTtcblx0XHRcdFxuXHRcdFx0aWYgKEVYUFJFU1NJT05fU1RBUlQuaW5kZXhPZih0KSA+PSAwKSB7XG5cdFx0XHRcdGlmIChsZXZlbHMgPT0gMCkgeyBzdGFydHMucHVzaChpKSB9O1xuXHRcdFx0XHRsZXZlbHMgKz0gMTtcblx0XHRcdH0gZWxzZSBpZiAoRVhQUkVTU0lPTl9FTkQuaW5kZXhPZih0KSA+PSAwKSB7XG5cdFx0XHRcdGxldmVscyAtPSAxO1xuXHRcdFx0fTtcblx0XHRcdGkgKz0gMTtcblx0XHR9O1xuXHRcdHJldHVybiBpIC0gMTtcblx0fTtcblx0XG5cdFJld3JpdGVyLnByb3RvdHlwZS5lbnN1cmVGaXJzdExpbmUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdG9rID0gdGhpcy5fdG9rZW5zWzBdO1xuXHRcdFxuXHRcdGlmIChULnR5cCh0b2spID09ICdURVJNSU5BVE9SJykge1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJhZGRpbmcgYm9keXN0YXJ0XCJcblx0XHRcdHRoaXMuX3Rva2VucyA9IFtULnRva2VuKCdCT0RZU1RBUlQnLCdCT0RZU1RBUlQnKV0uY29uY2F0KHRoaXMuX3Rva2Vucyk7XG5cdFx0XHQvLyBULnNldFR5cCh0b2ssJ0hFQURFUicpXG5cdFx0fTtcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHQvLyBMZWFkaW5nIG5ld2xpbmVzIHdvdWxkIGludHJvZHVjZSBhbiBhbWJpZ3VpdHkgaW4gdGhlIGdyYW1tYXIsIHNvIHdlXG5cdC8vIGRpc3BhdGNoIHRoZW0gaGVyZS5cblx0UmV3cml0ZXIucHJvdG90eXBlLnJlbW92ZUxlYWRpbmdOZXdsaW5lcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBhdCA9IDA7XG5cdFx0XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMuX3Rva2VucyksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKFQudHlwKGFyeVtpXSkgIT0gJ1RFUk1JTkFUT1InKSB7XG5cdFx0XHRcdGF0ID0gaTticmVhaztcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoYXQpIHsgdGhpcy5fdG9rZW5zLnNwbGljZSgwLGF0KSB9O1xuXHRcdFxuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdC8vIFNvbWUgYmxvY2tzIG9jY3VyIGluIHRoZSBtaWRkbGUgb2YgZXhwcmVzc2lvbnMgLS0gd2hlbiB3ZSdyZSBleHBlY3Rpbmdcblx0Ly8gdGhpcywgcmVtb3ZlIHRoZWlyIHRyYWlsaW5nIG5ld2xpbmVzLlxuXHRSZXdyaXRlci5wcm90b3R5cGUucmVtb3ZlTWlkRXhwcmVzc2lvbk5ld2xpbmVzID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHJldHVybiBzZWxmLnNjYW5Ub2tlbnMoZnVuY3Rpb24odG9rZW4saSx0b2tlbnMpIHsgLy8gZG8gfHRva2VuLGksdG9rZW5zfFxuXHRcdFx0dmFyIG5leHQgPSBzZWxmLnRva2VuVHlwZShpICsgMSk7XG5cdFx0XHRcblx0XHRcdGlmICghKFQudHlwKHRva2VuKSA9PSAnVEVSTUlOQVRPUicgJiYgRVhQUkVTU0lPTl9DTE9TRS5pbmRleE9mKG5leHQpID49IDApKSB7IHJldHVybiAxIH07XG5cdFx0XHRpZiAobmV4dCA9PSAnT1VUREVOVCcpIHsgcmV0dXJuIDEgfTtcblx0XHRcdHRva2Vucy5zcGxpY2UoaSwxKTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH0pO1xuXHR9O1xuXHRcblx0XG5cdFJld3JpdGVyLnByb3RvdHlwZS50YWdEZWZBcmd1bWVudHMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdC8vIFRoZSBsZXhlciBoYXMgdGFnZ2VkIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzIG9mIGEgbWV0aG9kIGNhbGwuIE1hdGNoIGl0IHdpdGhcblx0Ly8gaXRzIHBhaXJlZCBjbG9zZS4gV2UgaGF2ZSB0aGUgbWlzLW5lc3RlZCBvdXRkZW50IGNhc2UgaW5jbHVkZWQgaGVyZSBmb3Jcblx0Ly8gY2FsbHMgdGhhdCBjbG9zZSBvbiB0aGUgc2FtZSBsaW5lLCBqdXN0IGJlZm9yZSB0aGVpciBvdXRkZW50LlxuXHRSZXdyaXRlci5wcm90b3R5cGUuY2xvc2VPcGVuQ2FsbHMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIGNvbmRpdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdHZhciB0ID0gVC50eXAodG9rZW4pO1xuXHRcdFx0cmV0dXJuICh0ID09ICcpJyB8fCB0ID09ICdDQUxMX0VORCcpIHx8IHQgPT0gJ09VVERFTlQnICYmIHNlbGYudG9rZW5UeXBlKGkgLSAxKSA9PSAnKSc7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgYWN0aW9uID0gZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0dmFyIHQgPSBULnR5cCh0b2tlbik7XG5cdFx0XHR2YXIgdG9rID0gc2VsZi5fdG9rZW5zW3QgPT0gJ09VVERFTlQnID8gKGkgLSAxKSA6IChpKV07XG5cdFx0XHRyZXR1cm4gVC5zZXRUeXAodG9rLCdDQUxMX0VORCcpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHNlbGYuc2NhblRva2VucyhmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRpZiAoVC50eXAodG9rZW4pID09ICdDQUxMX1NUQVJUJykgeyBzZWxmLmRldGVjdEVuZChpICsgMSxjb25kaXRpb24sYWN0aW9uKSB9O1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fSk7XG5cdH07XG5cdFxuXHQvLyBUaGUgbGV4ZXIgaGFzIHRhZ2dlZCB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyBvZiBhbiBpbmRleGluZyBvcGVyYXRpb24gY2FsbC5cblx0Ly8gTWF0Y2ggaXQgd2l0aCBpdHMgcGFpcmVkIGNsb3NlLlxuXHRSZXdyaXRlci5wcm90b3R5cGUuY2xvc2VPcGVuSW5kZXhlcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgY29uZGl0aW9uID0gZnVuY3Rpb24odG9rZW4saSkgeyByZXR1cm4gaWR4JChULnR5cCh0b2tlbiksWyddJywnSU5ERVhfRU5EJ10pID49IDA7IH07XG5cdFx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHsgcmV0dXJuIFQuc2V0VHlwKHRva2VuLCdJTkRFWF9FTkQnKTsgfTtcblx0XHRcblx0XHRyZXR1cm4gc2VsZi5zY2FuVG9rZW5zKGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdGlmIChULnR5cCh0b2tlbikgPT0gJ0lOREVYX1NUQVJUJykgeyBzZWxmLmRldGVjdEVuZChpICsgMSxjb25kaXRpb24sYWN0aW9uKSB9O1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fSk7XG5cdH07XG5cdFxuXHRcblx0UmV3cml0ZXIucHJvdG90eXBlLmNsb3NlT3BlblRhZ0F0dHJMaXN0cyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgY29uZGl0aW9uID0gZnVuY3Rpb24odG9rZW4saSkgeyByZXR1cm4gaWR4JChULnR5cCh0b2tlbiksWycpJywnVEFHX0FUVFJTX0VORCddKSA+PSAwOyB9O1xuXHRcdHZhciBhY3Rpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7IHJldHVybiBULnNldFR5cCh0b2tlbiwnVEFHX0FUVFJTX0VORCcpOyB9OyAvLyAnVEFHX0FUVFJTX0VORCdcblx0XHRcblx0XHRyZXR1cm4gc2VsZi5zY2FuVG9rZW5zKGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdGlmIChULnR5cCh0b2tlbikgPT0gJ1RBR19BVFRSU19TVEFSVCcpIHsgc2VsZi5kZXRlY3RFbmQoaSArIDEsY29uZGl0aW9uLGFjdGlvbikgfTtcblx0XHRcdHJldHVybiAxO1xuXHRcdH0pO1xuXHR9O1xuXHRcblx0Ly8gVGhlIGxleGVyIGhhcyB0YWdnZWQgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMgb2YgYW4gaW5kZXhpbmcgb3BlcmF0aW9uIGNhbGwuXG5cdC8vIE1hdGNoIGl0IHdpdGggaXRzIHBhaXJlZCBjbG9zZS4gU2hvdWxkIGJlIGRvbmUgaW4gbGV4ZXIgZGlyZWN0bHlcblx0UmV3cml0ZXIucHJvdG90eXBlLmNsb3NlT3BlblRhZ3MgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIGNvbmRpdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHsgcmV0dXJuIGlkeCQoVC50eXAodG9rZW4pLFsnPicsJ1RBR19FTkQnXSkgPj0gMDsgfTtcblx0XHR2YXIgYWN0aW9uID0gZnVuY3Rpb24odG9rZW4saSkgeyByZXR1cm4gVC5zZXRUeXAodG9rZW4sJ1RBR19FTkQnKTsgfTsgLy8gdG9rZW5bMF0gPSAnVEFHX0VORCdcblx0XHRcblx0XHRyZXR1cm4gc2VsZi5zY2FuVG9rZW5zKGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdGlmIChULnR5cCh0b2tlbikgPT0gJ1RBR19TVEFSVCcpIHsgc2VsZi5kZXRlY3RFbmQoaSArIDEsY29uZGl0aW9uLGFjdGlvbikgfTtcblx0XHRcdHJldHVybiAxO1xuXHRcdH0pO1xuXHR9O1xuXHRcblx0UmV3cml0ZXIucHJvdG90eXBlLmFkZEltcGxpY2l0Q29tbWFzID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0UmV3cml0ZXIucHJvdG90eXBlLmFkZEltcGxpY2l0QmxvY2tDYWxscyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciB0b2tlbjtcblx0XHR2YXIgaSA9IDE7XG5cdFx0dmFyIHRva2VucyA9IHRoaXMuX3Rva2Vucztcblx0XHRcblx0XHR3aGlsZSAodG9rZW4gPSB0b2tlbnNbaV0pe1xuXHRcdFx0dmFyIHQgPSB0b2tlbi5fdHlwZTtcblx0XHRcdHZhciB2ID0gdG9rZW4uX3ZhbHVlO1xuXHRcdFx0Ly8gaG1tXG5cdFx0XHRpZiAodCA9PSAnRE8nICYmICh2ID09ICdJTkRFWF9FTkQnIHx8IHYgPT0gJ0lERU5USUZJRVInIHx8IHYgPT0gJ05FVycpKSB7XG5cdFx0XHRcdHRva2Vucy5zcGxpY2UoaSArIDEsMCxULnRva2VuKCdDQUxMX0VORCcsJyknKSk7XG5cdFx0XHRcdHRva2Vucy5zcGxpY2UoaSArIDEsMCxULnRva2VuKCdDQUxMX1NUQVJUJywnKCcpKTtcblx0XHRcdFx0aSsrO1xuXHRcdFx0fTtcblx0XHRcdGkrKztcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybjtcblx0fTtcblx0XG5cdC8vIE9iamVjdCBsaXRlcmFscyBtYXkgYmUgd3JpdHRlbiB3aXRoIGltcGxpY2l0IGJyYWNlcywgZm9yIHNpbXBsZSBjYXNlcy5cblx0Ly8gSW5zZXJ0IHRoZSBtaXNzaW5nIGJyYWNlcyBoZXJlLCBzbyB0aGF0IHRoZSBwYXJzZXIgZG9lc24ndCBoYXZlIHRvLlxuXHRSZXdyaXRlci5wcm90b3R5cGUuYWRkSW1wbGljaXRCcmFjZXMgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIHN0YWNrID0gW107XG5cdFx0dmFyIHN0YXJ0ID0gbnVsbDtcblx0XHR2YXIgc3RhcnRJbmRlbnQgPSAwO1xuXHRcdHZhciBzdGFydElkeCA9IG51bGw7XG5cdFx0XG5cdFx0dmFyIG5vQnJhY2VUYWcgPSBbJ0NMQVNTJywnSUYnLCdVTkxFU1MnLCdUQUcnLCdXSElMRScsJ0ZPUicsJ1VOVElMJywnQ0FUQ0gnLCdGSU5BTExZJywnTU9EVUxFJywnTEVBRElOR19XSEVOJ107XG5cdFx0dmFyIG5vQnJhY2VDb250ZXh0ID0gWydJRicsJ1RFUk5BUlknLCdGT1InXTtcblx0XHRcblx0XHR2YXIgbm9CcmFjZSA9IGZhbHNlO1xuXHRcdFxuXHRcdHZhciBzY29wZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdIHx8IFtdO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdHJldHVybiBzZWxmLl90b2tlbnMuc3BsaWNlKGksMCxULlJCUkFDS0VUKTtcblx0XHR9O1xuXHRcdFxuXHRcdHZhciBvcGVuID0gZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0cmV0dXJuIHNlbGYuX3Rva2Vucy5zcGxpY2UoaSwwLFQuTEJSQUNLRVQpO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGNsb3NlID0gZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0cmV0dXJuIHNlbGYuX3Rva2Vucy5zcGxpY2UoaSwwLFQuUkJSQUNLRVQpO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHN0YWNrVG9rZW4gPSBmdW5jdGlvbihhLGIpIHtcblx0XHRcdHJldHVybiBbYSxiXTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBzZWxmLnNjYW5Ub2tlbnMoZnVuY3Rpb24odG9rZW4saSx0b2tlbnMpIHtcblx0XHRcdHZhciB0eXBlID0gVC50eXAodG9rZW4pO1xuXHRcdFx0dmFyIHYgPSBULnZhbCh0b2tlbik7XG5cdFx0XHR2YXIgY3R4ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gfHwgW107XG5cdFx0XHR2YXIgaWR4O1xuXHRcdFx0XG5cdFx0XHRpZiAobm9CcmFjZUNvbnRleHQuaW5kZXhPZih0eXBlKSA+PSAwKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiZm91bmQgbm9CcmFjZVRhZyB7dHlwZX1cIlxuXHRcdFx0XHRzdGFjay5wdXNoKHN0YWNrVG9rZW4odHlwZSxpKSk7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHYgPT0gJz8nKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdURVJOQVJZIE9QRVJBVE9SIScpXG5cdFx0XHRcdHN0YWNrLnB1c2goc3RhY2tUb2tlbignVEVSTkFSWScsaSkpO1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIG5vIG5lZWQgdG8gdGVzdCBmb3IgdGhpcyBoZXJlIGFzIHdlbGwgYXMgaW5cblx0XHRcdGlmIChFWFBSRVNTSU9OX1NUQVJULmluZGV4T2YodHlwZSkgPj0gMCkge1xuXHRcdFx0XHRpZiAodHlwZSA9PSAnSU5ERU5UJyAmJiBub0JyYWNlQ29udGV4dC5pbmRleE9mKGN0eFswXSkgPj0gMCkge1xuXHRcdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ2V4cHJlc3Npb24gc3RhcnQnLHR5cGUsY3R4WzBdKVxuXHRcdFx0XHRpZiAodHlwZSA9PSAnSU5ERU5UJyAmJiBzZWxmLnRva2VuVHlwZShpIC0gMSkgPT0gJ3snKSB7XG5cdFx0XHRcdFx0Ly8gc3RhY2sgPyE/IG5vIHRva2VuXG5cdFx0XHRcdFx0c3RhY2sucHVzaChzdGFja1Rva2VuKCd7JyxpKSk7IC8vIHNob3VsZCBub3QgYXV0b2dlbmVyYXRlIGFub3RoZXI/XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhY2sucHVzaChzdGFja1Rva2VuKHR5cGUsaSkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChFWFBSRVNTSU9OX0VORC5pbmRleE9mKHR5cGUpID49IDApIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgXCJFWFBSRVNTSU9OX0VORCBhdCB7dHlwZX0gLSBzdGFjayBpcyB7Y3R4WzBdfVwiXG5cdFx0XHRcdGlmIChjdHhbMF0gPT0gJ1RFUk5BUlknKSB7IC8vIEZJWD9cblx0XHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHN0YXJ0ID0gc3RhY2sucG9wKCk7XG5cdFx0XHRcdGlmICghc3RhcnQpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIk5PIFNUQUNLISFcIik7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHN0YXJ0WzJdID0gaTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIHNlZW1zIGxpa2UgdGhlIHN0YWNrIHNob3VsZCB1c2UgdG9rZW5zLCBubz8pXG5cdFx0XHRcdGlmIChzdGFydFswXSA9PSAneycgJiYgc3RhcnQuZ2VuZXJhdGVkKSB7IC8vICAjIHR5cGUgIT0gJ30nICMgYW5kIHN0YXJ0OmdlbmVyYXRlZFxuXHRcdFx0XHRcdGNsb3NlKHRva2VuLGkpO1xuXHRcdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBpcyB0aGlzIGNvcnJlY3Q/IHNhbWUgZm9yIGlmL2NsYXNzIGV0Yz9cblx0XHRcdGlmIChjdHhbMF0gPT0gJ1RFUk5BUlknICYmICh0eXBlID09ICdURVJNSU5BVE9SJyB8fCB0eXBlID09ICdPVVRERU5UJykpIHtcblx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKG5vQnJhY2VDb250ZXh0LmluZGV4T2YoY3R4WzBdKSA+PSAwICYmIHR5cGUgPT0gJ0lOREVOVCcpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJwb3BwaW5nIG5vQnJhY2VDb250ZXh0XCIpO1xuXHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdGlmICh0eXBlID09ICcsJykge1xuXHRcdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGFkZCBhbiBlbmRpbmcgaGVyZSBpZiBpbnNpZGU6Z2VuZXJhdGVkIHNjb3BlP1xuXHRcdFx0XHQvLyBpdCBpcyBpbXBvcnRhbnQgdGhhdCB0aGlzIGlzOmdlbmVyYXRlZCghKVxuXHRcdFx0XHRpZiAoY3R4WzBdID09ICd7JyAmJiBjdHguZ2VuZXJhdGVkKSB7XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZShpLDAsVC5SQlJBQ0tFVCk7XG5cdFx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRydWU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBmb3VuZCBhIHR5cGVcblx0XHRcdGlmICh0eXBlID09ICc6JyAmJiBjdHhbMF0gIT0gJ3snICYmIGN0eFswXSAhPSAnVEVSTkFSWScgJiYgKG5vQnJhY2VDb250ZXh0LmluZGV4T2YoY3R4WzBdKSA9PSAtMSkpIHtcblx0XHRcdFx0Ly8gY291bGQganVzdCBjaGVjayBpZiB0aGUgZW5kIHdhcyByaWdodCBiZWZvcmUgdGhpcz9cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChzdGFydCAmJiBzdGFydFsyXSA9PSBpIC0gMSkge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCd0aGlzIGV4cHJlc3Npb24gd2FzIGp1c3QgZW5kaW5nIGJlZm9yZSBjb2xvbiEnKVxuXHRcdFx0XHRcdGlkeCA9IHN0YXJ0WzFdIC0gMTsgLy8gdGhlc2UgYXJlIHRoZSBzdGFja1Rva2Vuc1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwicmV3cml0ZSBoZXJlPyAje2l9XCJcblx0XHRcdFx0XHRpZHggPSBpIC0gMjsgLy8gaWYgc3RhcnQgdGhlbiBzdGFydFsxXSAtIDEgZWxzZSBpIC0gMlxuXHRcdFx0XHRcdC8vIGlkeCA9IGlkeCAtIDEgaWYgdG9rZW5UeXBlKGlkeCkgaXMgJ1RFUk1JTkFUT1InXG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAoc2VsZi50b2tlblR5cGUoaWR4IC0gMSkgPT0gJ0hFUkVDT01NRU5UJyl7XG5cdFx0XHRcdFx0aWR4IC09IDI7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgdDAgPSB0b2tlbnNbaWR4IC0gMV07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodDAgJiYgVC50eXAodDApID09ICd9JyAmJiB0MC5nZW5lcmF0ZWQpIHtcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKGlkeCAtIDEsMSk7XG5cdFx0XHRcdFx0dmFyIHMgPSBzdGFja1Rva2VuKCd7Jyk7XG5cdFx0XHRcdFx0cy5nZW5lcmF0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHN0YWNrLnB1c2gocyk7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH0gZWxzZSBpZiAodDAgJiYgVC50eXAodDApID09ICcsJyAmJiBzZWxmLnRva2VuVHlwZShpZHggLSAyKSA9PSAnfScpIHtcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKGlkeCAtIDIsMSk7XG5cdFx0XHRcdFx0cyA9IHN0YWNrVG9rZW4oJ3snKTtcblx0XHRcdFx0XHRzLmdlbmVyYXRlZCA9IHRydWU7XG5cdFx0XHRcdFx0c3RhY2sucHVzaChzKTtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzID0gc3RhY2tUb2tlbigneycpO1xuXHRcdFx0XHRcdHMuZ2VuZXJhdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRzdGFjay5wdXNoKHMpO1xuXHRcdFx0XHRcdG9wZW4odG9rZW4saWR4ICsgMSk7XG5cdFx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyB3ZSBwcm9iYWJseSBuZWVkIHRvIHJ1biB0aHJvdWdoIGF1dG9jYWxsIGZpcnN0PyFcblx0XHRcdFxuXHRcdFx0aWYgKHR5cGUgPT0gJ0RPJykgeyAvLyBhbmQgY3R4OmdlbmVyYXRlZFxuXHRcdFx0XHR2YXIgcHJldiA9IFQudHlwKHRva2Vuc1tpIC0gMV0pOyAvLyBbMF1cblx0XHRcdFx0aWYgKFsnTlVNQkVSJywnU1RSSU5HJywnUkVHRVgnLCdTWU1CT0wnLCddJywnfScsJyknLCdTVFJJTkdfRU5EJ10uaW5kZXhPZihwcmV2KSA+PSAwKSB7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dmFyIHRvayA9IFQudG9rZW4oJywnLCcsJyk7XG5cdFx0XHRcdFx0dG9rLmdlbmVyYXRlZCA9IHRydWU7XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZShpLDAsdG9rKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoY3R4LmdlbmVyYXRlZCkge1xuXHRcdFx0XHRcdFx0Y2xvc2UodG9rZW4saSk7XG5cdFx0XHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoKHR5cGUgPT0gJ1RFUk1JTkFUT1InIHx8IHR5cGUgPT0gJ09VVERFTlQnIHx8IHR5cGUgPT0gJ0RFRl9CT0RZJykgJiYgY3R4LmdlbmVyYXRlZCkge1xuXHRcdFx0XHRjbG9zZSh0b2tlbixpKTtcblx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fSk7XG5cdH07XG5cdFxuXHQvLyBNZXRob2RzIG1heSBiZSBvcHRpb25hbGx5IGNhbGxlZCB3aXRob3V0IHBhcmVudGhlc2VzLCBmb3Igc2ltcGxlIGNhc2VzLlxuXHQvLyBJbnNlcnQgdGhlIGltcGxpY2l0IHBhcmVudGhlc2VzIGhlcmUsIHNvIHRoYXQgdGhlIHBhcnNlciBkb2Vzbid0IGhhdmUgdG9cblx0Ly8gZGVhbCB3aXRoIHRoZW0uXG5cdC8vIFByYWN0aWNhbGx5IGV2ZXJ5dGhpbmcgd2lsbCBub3cgYmUgY2FsbGFibGUgdGhpcyB3YXkgKGV2ZXJ5IGlkZW50aWZpZXIpXG5cdFJld3JpdGVyLnByb3RvdHlwZS5hZGRJbXBsaWNpdFBhcmVudGhlc2VzID0gZnVuY3Rpb24gKCl7XG5cdFx0XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCB0b2tlbjtcblx0XHR2YXIgbm9DYWxsVGFnID0gWydDTEFTUycsJ0lGJywnVU5MRVNTJywnVEFHJywnV0hJTEUnLCdGT1InLCdVTlRJTCcsJ0NBVENIJywnRklOQUxMWScsJ01PRFVMRScsJ0xFQURJTkdfV0hFTiddO1xuXHRcdFxuXHRcdHZhciBhY3Rpb24gPSBmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5fdG9rZW5zLnNwbGljZShpLDAsVC50b2tlbignQ0FMTF9FTkQnLCcpJykpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gY29uc29sZS5sb2cgXCJhZGRpbmcgaW1wbGljaXQgcGFyZW50aGVzaXNcIiAjICxzZWxmOnNjYW5Ub2tlbnNcblx0XHR2YXIgdG9rZW5zID0gc2VsZi5fdG9rZW5zO1xuXHRcdFxuXHRcdHZhciBub0NhbGwgPSBmYWxzZTtcblx0XHR2YXIgc2VlbkZvciA9IGZhbHNlO1xuXHRcdHZhciBlbmRDYWxsQXRUZXJtaW5hdG9yID0gZmFsc2U7XG5cdFx0XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHdoaWxlICh0b2tlbiA9IHRva2Vuc1tpXSl7XG5cdFx0XHRcblx0XHRcdC8vIHRvIGhhbmRsZSBjYXNlcyBsaWtlOlxuXHRcdFx0Ly8gaWYgYShkbyB5ZXMpLnRlc3Rcblx0XHRcdC8vIFx0eWVzXG5cdFx0XHQvLyB3ZSBuZWVkIHRvIGtlZXAgYSBzdGFjayBmb3IgYmFsYW5jZWQgcGFpcnNcblx0XHRcdC8vIHVudGlsIHRoZW4geW91IG11c3QgZXhwbGljaXRseSBlbmQgdGhlIGNhbGwgbGlrZVxuXHRcdFx0Ly8gaWYgYShkbyB5ZXMpLnRlc3QoKVxuXHRcdFx0Ly8gXHR5ZXNcblx0XHRcdFxuXHRcdFx0dmFyIHR5cGUgPSB0b2tlbi5fdHlwZTtcblx0XHRcdFxuXHRcdFx0dmFyIHByZXYgPSB0b2tlbnNbaSAtIDFdO1xuXHRcdFx0dmFyIGN1cnJlbnQgPSB0b2tlbnNbaV07XG5cdFx0XHR2YXIgbmV4dCA9IHRva2Vuc1tpICsgMV07XG5cdFx0XHRcblx0XHRcdHZhciBwdCA9IHByZXYgJiYgcHJldi5fdHlwZTtcblx0XHRcdHZhciBudCA9IG5leHQgJiYgbmV4dC5fdHlwZTtcblx0XHRcdFxuXHRcdFx0Ly8gaWYgcHQgPT0gJ1dIRU4nXG5cdFx0XHQvLyBOZXZlciBtYWtlIHRoZXNlIHRhZ3MgaW1wbGljaXRseSBjYWxsXG5cdFx0XHQvLyBzaG91bGQgd2Ugbm90IGp1c3QgcmVtb3ZlIHRoZXNlIGZyb20gSU1QTElDSVRfRlVOQz9cblx0XHRcdGlmICgocHQgPT0gJyknIHx8IHB0ID09ICddJykgJiYgdHlwZSA9PSAnSU5ERU5UJykge1xuXHRcdFx0XHRub0NhbGwgPSB0cnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKG5vQ2FsbFRhZy5pbmRleE9mKHB0KSA+PSAwKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwic2VlbiBub2NhbGwgdGFnIHtwdH0gKHtwdH0ge3R5cGV9IHtudH0pXCIpXG5cdFx0XHRcdGVuZENhbGxBdFRlcm1pbmF0b3IgPSB0cnVlO1xuXHRcdFx0XHRub0NhbGwgPSB0cnVlO1xuXHRcdFx0XHRpZiAocHQgPT0gJ0ZPUicpIHsgc2VlbkZvciA9IHRydWUgfTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0dmFyIGNhbGxPYmplY3QgPSBmYWxzZTtcblx0XHRcdHZhciBjYWxsSW5kZW50ID0gZmFsc2U7XG5cdFx0XHRcblx0XHRcdC8vIFtwcmV2LCBjdXJyZW50LCBuZXh0XSA9IHRva2Vuc1tpIC0gMSAuLiBpICsgMV1cblx0XHRcdFxuXHRcdFx0Ly8gY2hlY2sgZm9yIGNvbW1lbnRzXG5cdFx0XHQvLyBjb25zb2xlLmxvZyBcImRldGVjdCBlbmQ/P1wiXG5cdFx0XHRpZiAoIW5vQ2FsbCAmJiB0eXBlID09ICdJTkRFTlQnICYmIG5leHQpIHtcblx0XHRcdFx0dmFyIHByZXZJbXBGdW5jID0gcHQgJiYgSU1QTElDSVRfRlVOQy5pbmRleE9mKHB0KSA+PSAwO1xuXHRcdFx0XHR2YXIgbmV4dEltcENhbGwgPSBudCAmJiBJTVBMSUNJVF9DQUxMLmluZGV4T2YobnQpID49IDA7XG5cdFx0XHRcdGNhbGxPYmplY3QgPSAoKG5leHQuZ2VuZXJhdGVkICYmIG50ID09ICd7JykgfHwgbmV4dEltcENhbGwpICYmIHByZXZJbXBGdW5jO1xuXHRcdFx0XHRjYWxsSW5kZW50ID0gbmV4dEltcENhbGwgJiYgcHJldkltcEZ1bmM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgc2VlblNpbmdsZSA9IGZhbHNlO1xuXHRcdFx0dmFyIHNlZW5Db250cm9sID0gZmFsc2U7XG5cdFx0XHQvLyBIbW0gP1xuXHRcdFx0XG5cdFx0XHQvLyB0aGlzIGlzIG5vdCBjb3JyZWN0IGlmIHRoaXMgaXMgaW5zaWRlIGEgYmxvY2ssbm8/XG5cdFx0XHRpZiAoKHR5cGUgPT0gJ1RFUk1JTkFUT1InIHx8IHR5cGUgPT0gJ09VVERFTlQnIHx8IHR5cGUgPT0gJ0lOREVOVCcpKSB7XG5cdFx0XHRcdGVuZENhbGxBdFRlcm1pbmF0b3IgPSBmYWxzZTtcblx0XHRcdFx0bm9DYWxsID0gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwZSA9PSAnPycgJiYgcHJldiAmJiAhcHJldi5zcGFjZWQpIHsgdG9rZW4uY2FsbCA9IHRydWUgfTtcblx0XHRcdFxuXHRcdFx0Ly8gd2hlcmUgZG9lcyBmcm9tVGhlbSBjb21lIGZyb20/XG5cdFx0XHRpZiAodG9rZW4uZnJvbVRoZW4pIHtcblx0XHRcdFx0aSArPSAxO2NvbnRpbnVlO1xuXHRcdFx0fTtcblx0XHRcdC8vIGhlcmUgd2UgZGVhbCB3aXRoIDpzcGFjZWQgYW5kIDpuZXdMaW5lXG5cdFx0XHRpZiAoIShjYWxsT2JqZWN0IHx8IGNhbGxJbmRlbnQgfHwgKHByZXYgJiYgcHJldi5zcGFjZWQpICYmIChwcmV2LmNhbGwgfHwgSU1QTElDSVRfRlVOQy5pbmRleE9mKHB0KSA+PSAwKSAmJiAoSU1QTElDSVRfQ0FMTC5pbmRleE9mKHR5cGUpID49IDAgfHwgISh0b2tlbi5zcGFjZWQgfHwgdG9rZW4ubmV3TGluZSkgJiYgSU1QTElDSVRfVU5TUEFDRURfQ0FMTC5pbmRleE9mKHR5cGUpID49IDApKSkge1xuXHRcdFx0XHRpICs9IDE7Y29udGludWU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdHRva2Vucy5zcGxpY2UoaSwwLFQudG9rZW4oJ0NBTExfU1RBUlQnLCcoJykpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJhZGRlZCAoIHtwcmV2fVwiXG5cdFx0XHR2YXIgY29uZCA9IGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdFx0dmFyIHR5cGUgPSBULnR5cCh0b2tlbik7XG5cdFx0XHRcdGlmICghc2VlblNpbmdsZSAmJiB0b2tlbi5mcm9tVGhlbikgeyByZXR1cm4gdHJ1ZSB9O1xuXHRcdFx0XHR2YXIgaWZlbHNlID0gdHlwZSA9PSAnSUYnIHx8IHR5cGUgPT0gJ1VOTEVTUycgfHwgdHlwZSA9PSAnRUxTRSc7XG5cdFx0XHRcdGlmIChpZmVsc2UgfHwgdHlwZSA9PSAnQ0FUQ0gnKSB7IHNlZW5TaW5nbGUgPSB0cnVlIH07XG5cdFx0XHRcdGlmIChpZmVsc2UgfHwgdHlwZSA9PSAnU1dJVENIJyB8fCB0eXBlID09ICdUUlknKSB7IHNlZW5Db250cm9sID0gdHJ1ZSB9O1xuXHRcdFx0XHR2YXIgcHJldiA9IHNlbGYudG9rZW5UeXBlKGkgLSAxKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICgodHlwZSA9PSAnLicgfHwgdHlwZSA9PSAnPy4nIHx8IHR5cGUgPT0gJzo6JykgJiYgcHJldiA9PSAnT1VUREVOVCcpIHsgcmV0dXJuIHRydWUgfTtcblx0XHRcdFx0aWYgKGVuZENhbGxBdFRlcm1pbmF0b3IgJiYgKHR5cGUgPT0gJ0lOREVOVCcgfHwgdHlwZSA9PSAnVEVSTUlOQVRPUicpKSB7IHJldHVybiB0cnVlIH07XG5cdFx0XHRcdGlmICgodHlwZSA9PSAnV0hFTicgfHwgdHlwZSA9PSAnQlknKSAmJiAhc2VlbkZvcikge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwiZG9udCBjbG9zZSBpbXBsaWNpdCBjYWxsIG91dHNpZGUgZm9yXCJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgcG9zdCA9IHRva2Vuc1tpICsgMV07XG5cdFx0XHRcdHZhciBwb3N0VHlwID0gcG9zdCAmJiBULnR5cChwb3N0KTtcblx0XHRcdFx0Ly8gV1RGXG5cdFx0XHRcdHJldHVybiAhdG9rZW4uZ2VuZXJhdGVkICYmIHByZXYgIT0gJywnICYmIChJTVBMSUNJVF9FTkQuaW5kZXhPZih0eXBlKSA+PSAwIHx8ICh0eXBlID09ICdJTkRFTlQnICYmICFzZWVuQ29udHJvbCkgfHwgKHR5cGUgPT0gJ0RPUycgJiYgcHJldiAhPSAnPScpKSAmJiAodHlwZSAhPSAnSU5ERU5UJyB8fCAoc2VsZi50b2tlblR5cGUoaSAtIDIpICE9ICdDTEFTUycgJiYgSU1QTElDSVRfQkxPQ0suaW5kZXhPZihwcmV2KSA9PSAtMSAmJiAhKHBvc3QgJiYgKChwb3N0LmdlbmVyYXRlZCAmJiBwb3N0VHlwID09ICd7JykgfHwgSU1QTElDSVRfQ0FMTC5pbmRleE9mKHBvc3RUeXApID49IDApKSkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gVGhlIGFjdGlvbiBmb3IgZGV0ZWN0aW5nIHdoZW4gdGhlIGNhbGwgc2hvdWxkIGVuZFxuXHRcdFx0Ly8gY29uc29sZS5sb2cgXCJkZXRlY3QgZW5kPz9cIlxuXHRcdFx0c2VsZi5kZXRlY3RFbmQoaSArIDEsY29uZCxhY3Rpb24pO1xuXHRcdFx0aWYgKFQudHlwKHByZXYpID09ICc/JykgeyBULnNldFR5cChwcmV2LCdGVU5DX0VYSVNUJykgfTtcblx0XHRcdGkgKz0gMjtcblx0XHRcdC8vIG5lZWQgdG8gcmVzZXQgYWZ0ZXIgYSBtYXRjaFxuXHRcdFx0ZW5kQ2FsbEF0VGVybWluYXRvciA9IGZhbHNlO1xuXHRcdFx0bm9DYWxsID0gZmFsc2U7XG5cdFx0XHRzZWVuRm9yID0gZmFsc2U7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRyZXR1cm47XG5cdH07XG5cdFxuXHQvLyBCZWNhdXNlIG91ciBncmFtbWFyIGlzIExBTFIoMSksIGl0IGNhbid0IGhhbmRsZSBzb21lIHNpbmdsZS1saW5lXG5cdC8vIGV4cHJlc3Npb25zIHRoYXQgbGFjayBlbmRpbmcgZGVsaW1pdGVycy4gVGhlICoqUmV3cml0ZXIqKiBhZGRzIHRoZSBpbXBsaWNpdFxuXHQvLyBibG9ja3MsIHNvIGl0IGRvZXNuJ3QgbmVlZCB0by4gJyknIGNhbiBjbG9zZSBhIHNpbmdsZS1saW5lIGJsb2NrLFxuXHQvLyBidXQgd2UgbmVlZCB0byBtYWtlIHN1cmUgaXQncyBiYWxhbmNlZC5cblx0UmV3cml0ZXIucHJvdG90eXBlLmFkZEltcGxpY2l0SW5kZW50YXRpb24gPSBmdW5jdGlvbiAoKXtcblx0XHRcblx0XHRcblx0XHR2YXIgc2VsZiA9IHRoaXMsIHRva2VuO1xuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgdG9rZW5zID0gc2VsZi5fdG9rZW5zO1xuXHRcdHdoaWxlICh0b2tlbiA9IHRva2Vuc1tpXSl7XG5cdFx0XHR2YXIgdHlwZSA9IFQudHlwKHRva2VuKTtcblx0XHRcdHZhciBuZXh0ID0gc2VsZi50b2tlblR5cGUoaSArIDEpO1xuXHRcdFx0XG5cdFx0XHQvLyB3aHkgYXJlIHdlIHJlbW92aW5nIHRlcm1pbmF0b3JzIGFmdGVyIHRoZW4/IHNob3VsZCBiZSBhYmxlIHRvIGhhbmRsZVxuXHRcdFx0aWYgKHR5cGUgPT0gJ1RFUk1JTkFUT1InICYmIG5leHQgPT0gJ1RIRU4nKSB7XG5cdFx0XHRcdHRva2Vucy5zcGxpY2UoaSwxKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwZSA9PSAnQ0FUQ0gnICYmIGlkeCQoc2VsZi50b2tlblR5cGUoaSArIDIpLFsnT1VUREVOVCcsJ1RFUk1JTkFUT1InLCdGSU5BTExZJ10pID49IDApIHtcblx0XHRcdFx0dG9rZW5zLnNwbGljZS5hcHBseSh0b2tlbnMsW10uY29uY2F0KFtpICsgMiwwXSwgW10uc2xpY2UuY2FsbChzZWxmLmluZGVudGF0aW9uKHRva2VuKSkpKTtcblx0XHRcdFx0aSArPSA0O2NvbnRpbnVlO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKFNJTkdMRV9MSU5FUlMuaW5kZXhPZih0eXBlKSA+PSAwICYmIChuZXh0ICE9ICdJTkRFTlQnICYmIG5leHQgIT0gJ0JMT0NLX1BBUkFNX1NUQVJUJykgJiYgISh0eXBlID09ICdFTFNFJyAmJiBuZXh0ID09ICdJRicpICYmIHR5cGUgIT0gJ0VMSUYnKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgc3RhcnRlciA9IHR5cGU7XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgaW5kZW50ID0gVC50b2tlbignSU5ERU5UJywnMicpO1xuXHRcdFx0XHR2YXIgb3V0ZGVudCA9IFQuT1VUREVOVDtcblx0XHRcdFx0Ly8gdmFyIGluZGVudCwgb3V0ZGVudCA9IGluZGVudGF0aW9uKHRva2VuKVxuXHRcdFx0XHRpZiAoc3RhcnRlciA9PSAnVEhFTicpIHsgaW5kZW50LmZyb21UaGVuID0gdHJ1ZSB9OyAvLyBzZXR0aW5nIHNwZWNpYWwgdmFsdWVzIGZvciB0aGVzZSAtLSBjYW5ub3QgcmVhbGx5IHJldXNlP1xuXHRcdFx0XHRpbmRlbnQuZ2VuZXJhdGVkID0gdHJ1ZTtcblx0XHRcdFx0Ly8gb3V0ZGVudDpnZW5lcmF0ZWQgPSB0cnVlXG5cdFx0XHRcdHRva2Vucy5zcGxpY2UoaSArIDEsMCxpbmRlbnQpO1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGNvbmRpdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdFx0XHR2YXIgdCA9IFQudHlwKHRva2VuKTtcblx0XHRcdFx0XHRyZXR1cm4gVC52YWwodG9rZW4pICE9ICc7JyAmJiBTSU5HTEVfQ0xPU0VSUy5pbmRleE9mKHQpID49IDAgJiYgISh0ID09ICdFTFNFJyAmJiBzdGFydGVyICE9ICdJRicgJiYgc3RhcnRlciAhPSAnVEhFTicpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uKHRva2VuLGkpIHtcblx0XHRcdFx0XHR2YXIgaWR4ID0gc2VsZi50b2tlblR5cGUoaSAtIDEpID09ICcsJyA/IChpIC0gMSkgOiAoaSk7XG5cdFx0XHRcdFx0cmV0dXJuIHRva2Vucy5zcGxpY2UoaWR4LDAsb3V0ZGVudCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRzZWxmLmRldGVjdEVuZChpICsgMixjb25kaXRpb24sYWN0aW9uKTtcblx0XHRcdFx0aWYgKHR5cGUgPT0gJ1RIRU4nKSB7IHRva2Vucy5zcGxpY2UoaSwxKSB9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aSsrO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuO1xuXHR9O1xuXHRcblx0Ly8gVGFnIHBvc3RmaXggY29uZGl0aW9uYWxzIGFzIHN1Y2gsIHNvIHRoYXQgd2UgY2FuIHBhcnNlIHRoZW0gd2l0aCBhXG5cdC8vIGRpZmZlcmVudCBwcmVjZWRlbmNlLlxuXHRSZXdyaXRlci5wcm90b3R5cGUudGFnUG9zdGZpeENvbmRpdGlvbmFscyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgY29uZGl0aW9uID0gZnVuY3Rpb24odG9rZW4saSkgeyByZXR1cm4gaWR4JChULnR5cCh0b2tlbiksWydURVJNSU5BVE9SJywnSU5ERU5UJ10pID49IDA7IH07XG5cdFx0XG5cdFx0cmV0dXJuIHNlbGYuc2NhblRva2VucyhmdW5jdGlvbih0b2tlbixpKSB7XG5cdFx0XHR2YXIgdHlwID0gVC50eXAodG9rZW4pO1xuXHRcdFx0aWYgKCEodHlwID09ICdJRicgfHwgdHlwID09ICdGT1InKSkgeyByZXR1cm4gMSB9O1xuXHRcdFx0dmFyIG9yaWdpbmFsID0gdG9rZW47XG5cdFx0XHRzZWxmLmRldGVjdEVuZChpICsgMSxjb25kaXRpb24sZnVuY3Rpb24odG9rZW4saSkge1xuXHRcdFx0XHRpZiAoVC50eXAodG9rZW4pICE9ICdJTkRFTlQnKSB7IHJldHVybiBULnNldFR5cChvcmlnaW5hbCwnUE9TVF8nICsgVC50eXAob3JpZ2luYWwpKSB9O1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9KTtcblx0fTtcblx0XG5cdC8vIEdlbmVyYXRlIHRoZSBpbmRlbnRhdGlvbiB0b2tlbnMsIGJhc2VkIG9uIGFub3RoZXIgdG9rZW4gb24gdGhlIHNhbWUgbGluZS5cblx0UmV3cml0ZXIucHJvdG90eXBlLmluZGVudGF0aW9uID0gZnVuY3Rpb24gKHRva2VuKXtcblx0XHRyZXR1cm4gW1QudG9rZW4oJ0lOREVOVCcsJzInKSxULnRva2VuKCdPVVRERU5UJywnMicpXTtcblx0fTtcblx0XG5cdC8vIExvb2sgdXAgYSB0eXBlIGJ5IHRva2VuIGluZGV4LlxuXHRSZXdyaXRlci5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uIChpKXtcblx0XHQvLyBpZiBpIDwgMCB0aGVuIHJldHVybiBudWxsXG5cdFx0dmFyIHRvayA9IHRoaXMuX3Rva2Vuc1tpXTtcblx0XHRyZXR1cm4gdG9rICYmIFQudHlwKHRvayk7XG5cdFx0Ly8gaWYgdG9rIHRoZW4gdG9rWzBdIGVsc2UgbnVsbFxuXHR9O1xuXHRcblx0UmV3cml0ZXIucHJvdG90eXBlLnRva2VuVHlwZSA9IGZ1bmN0aW9uIChpKXtcblx0XHR2YXIgdG9rID0gdGhpcy5fdG9rZW5zW2ldO1xuXHRcdHJldHVybiB0b2sgJiYgVC50eXAodG9rKTtcblx0XHQvLyByZXR1cm4gdG9rIGFuZCB0b2tbMF1cblx0fTtcblx0XG5cdC8vIENvbnN0YW50c1xuXHQvLyAtLS0tLS0tLS1cblx0XG5cdC8vIExpc3Qgb2YgdGhlIHRva2VuIHBhaXJzIHRoYXQgbXVzdCBiZSBiYWxhbmNlZC5cblx0dmFyIEJBTEFOQ0VEX1BBSVJTID0gW1xuXHRcdFsnKCcsJyknXSxcblx0XHRbJ1snLCddJ10sXG5cdFx0Wyd7JywnfSddLFxuXHRcdFsne3snLCd9fSddLFxuXHRcdFsnSU5ERU5UJywnT1VUREVOVCddLFxuXHRcdFsnQ0FMTF9TVEFSVCcsJ0NBTExfRU5EJ10sXG5cdFx0WydQQVJBTV9TVEFSVCcsJ1BBUkFNX0VORCddLFxuXHRcdFsnSU5ERVhfU1RBUlQnLCdJTkRFWF9FTkQnXSxcblx0XHRbJ1RBR19TVEFSVCcsJ1RBR19FTkQnXSxcblx0XHRbJ1RBR19QQVJBTV9TVEFSVCcsJ1RBR19QQVJBTV9FTkQnXSxcblx0XHRbJ1RBR19BVFRSU19TVEFSVCcsJ1RBR19BVFRSU19FTkQnXSxcblx0XHRbJ0JMT0NLX1BBUkFNX1NUQVJUJywnQkxPQ0tfUEFSQU1fRU5EJ11cblx0XTtcblx0XG5cdC8vIFRoZSBpbnZlcnNlIG1hcHBpbmdzIG9mIGBCQUxBTkNFRF9QQUlSU2Agd2UncmUgdHJ5aW5nIHRvIGZpeCB1cCwgc28gd2UgY2FuXG5cdC8vIGxvb2sgdGhpbmdzIHVwIGZyb20gZWl0aGVyIGVuZC5cblx0bW9kdWxlLmV4cG9ydHMuSU5WRVJTRVMgPSBJTlZFUlNFUyA9IHt9O1xuXHRcblx0Ly8gVGhlIHRva2VucyB0aGF0IHNpZ25hbCB0aGUgc3RhcnQvZW5kIG9mIGEgYmFsYW5jZWQgcGFpci5cblx0Ly8gdmFyIEVYUFJFU1NJT05fU1RBUlQgPSBbXVxuXHQvLyB2YXIgRVhQUkVTU0lPTl9FTkQgICA9IFtdXG5cdFxuXHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoQkFMQU5DRURfUEFJUlMpLCBsZW4gPSBhcnkubGVuZ3RoLCBwYWlyOyBpIDwgbGVuOyBpKyspIHtcblx0XHRwYWlyID0gYXJ5W2ldO1xuXHRcdHZhciBsZWZ0ID0gcGFpclswXTtcblx0XHR2YXIgcml0ZSA9IHBhaXJbMV07XG5cdFx0SU5WRVJTRVNbcml0ZV0gPSBsZWZ0O1xuXHRcdElOVkVSU0VTW2xlZnRdID0gcml0ZTtcblx0fTtcblx0XG5cdHZhciBFWFBSRVNTSU9OX1NUQVJUID0gWycoJywnWycsJ3snLCdJTkRFTlQnLCdDQUxMX1NUQVJUJywnUEFSQU1fU1RBUlQnLCdJTkRFWF9TVEFSVCcsJ1RBR19QQVJBTV9TVEFSVCcsJ0JMT0NLX1BBUkFNX1NUQVJUJywnU1RSSU5HX1NUQVJUJywne3snLCdUQUdfU1RBUlQnXTtcblx0dmFyIEVYUFJFU1NJT05fRU5EID0gWycpJywnXScsJ30nLCdPVVRERU5UJywnQ0FMTF9FTkQnLCdQQVJBTV9FTkQnLCdJTkRFWF9FTkQnLCdUQUdfUEFSQU1fRU5EJywnQkxPQ0tfUEFSQU1fRU5EJywnU1RSSU5HX0VORCcsJ319JywnVEFHX0VORCddO1xuXHRcblx0dmFyIElERU5USUZJRVJTID0gWydJREVOVElGSUVSJywnR1ZBUicsJ0lWQVInLCdDVkFSJywnQ09OU1QnLCdBUkdWQVInXTtcblx0XG5cdC8vIFRva2VucyB0aGF0IGluZGljYXRlIHRoZSBjbG9zZSBvZiBhIGNsYXVzZSBvZiBhbiBleHByZXNzaW9uLlxuXHR2YXIgRVhQUkVTU0lPTl9DTE9TRSA9IFsnQ0FUQ0gnLCdXSEVOJywnRUxTRScsJ0ZJTkFMTFknXS5jb25jYXQoRVhQUkVTU0lPTl9FTkQpO1xuXHRcblx0Ly8gVG9rZW5zIHRoYXQsIGlmIGZvbGxvd2VkIGJ5IGFuIGBJTVBMSUNJVF9DQUxMYCwgaW5kaWNhdGUgYSBmdW5jdGlvbiBpbnZvY2F0aW9uLlxuXHR2YXIgSU1QTElDSVRfRlVOQyA9IFsnSURFTlRJRklFUicsJ1NVUEVSJywnQCcsJ1RISVMnLCdTRUxGJywnRVZFTlQnLCdUUklHR0VSJywnVEFHX0VORCcsJ0lWQVInLFxuXHQnR1ZBUicsJ0NPTlNUJywnQVJHVkFSJywnTkVXJywnQlJFQUsnLCdDT05USU5VRScsJ1JFVFVSTiddO1xuXHRcblx0Ly8gSWYgcHJlY2VkZWQgYnkgYW4gYElNUExJQ0lUX0ZVTkNgLCBpbmRpY2F0ZXMgYSBmdW5jdGlvbiBpbnZvY2F0aW9uLlxuXHR2YXIgSU1QTElDSVRfQ0FMTCA9IFtcblx0XHQnU0VMRUNUT1InLCdJREVOVElGSUVSJywnTlVNQkVSJywnU1RSSU5HJywnU1lNQk9MJywnSlMnLCdSRUdFWCcsJ05FVycsJ1BBUkFNX1NUQVJUJywnQ0xBU1MnLFxuXHRcdCdJRicsJ1VOTEVTUycsJ1RSWScsJ1NXSVRDSCcsJ1RISVMnLCdCT09MJywnVFJVRScsJ0ZBTFNFJywnTlVMTCcsJ1VOREVGSU5FRCcsJ1VOQVJZJywnU1VQRVInLCdJVkFSJywnR1ZBUicsJ0NPTlNUJywnQVJHVkFSJywnU0VMRicsXG5cdFx0J0AnLCdbJywnKCcsJ3snLCctLScsJysrJywnU0VMRUNUT1InLCdUQUdfU1RBUlQnLCdUQUdJRCcsJyMnLCdTRUxFQ1RPUl9TVEFSVCcsJ0lEUkVGJywnU1BMQVQnLCdETycsJ0JMT0NLX0FSRycsXG5cdFx0J0ZPUicsJ1NUUklOR19TVEFSVCcsJ0NPTlRJTlVFJywnQlJFQUsnXG5cdF07IC8vICctPicsICc9PicsIHdoeSBkb2VzIGl0IG5vdCB3b3JrIHdpdGggc3ltYm9sP1xuXHRcblx0dmFyIElNUExJQ0lUX0lOREVOVF9DQUxMID0gW1xuXHRcdCdGT1InXG5cdF07XG5cdC8vIGlzIG5vdCBkbyBhbiBpbXBsaWNpdCBjYWxsPz9cblx0XG5cdHZhciBJTVBMSUNJVF9VTlNQQUNFRF9DQUxMID0gWycrJywnLSddO1xuXHRcblx0Ly8gVG9rZW5zIGluZGljYXRpbmcgdGhhdCB0aGUgaW1wbGljaXQgY2FsbCBtdXN0IGVuY2xvc2UgYSBibG9jayBvZiBleHByZXNzaW9ucy5cblx0dmFyIElNUExJQ0lUX0JMT0NLID0gWyd7JywnWycsJywnLCdCTE9DS19QQVJBTV9FTkQnLCdETyddOyAvLyAnLT4nLCAnPT4nLCBcblx0XG5cdHZhciBDT05ESVRJT05BTF9BU1NJR04gPSBbJ3x8PScsJyYmPScsJz89JywnJj0nLCd8PSddO1xuXHR2YXIgQ09NUE9VTkRfQVNTSUdOID0gWyctPScsJys9JywnLz0nLCcqPScsJyU9JywnfHw9JywnJiY9JywnPz0nLCc8PD0nLCc+Pj0nLCc+Pj49JywnJj0nLCdePScsJ3w9J107XG5cdHZhciBVTkFSWSA9IFsnIScsJ34nLCdORVcnLCdUWVBFT0YnLCdERUxFVEUnXTtcblx0dmFyIExPR0lDID0gWycmJicsJ3x8JywnJicsJ3wnLCdeJ107XG5cdFxuXHQvLyBvcHRpbWl6ZSBmb3IgZml4ZWQgYXJyYXlzXG5cdHZhciBOT19JTVBMSUNJVF9CTE9DS19DQUxMID0gW1xuXHRcdCdDQUxMX0VORCcsJz0nLCdERUZfQk9EWScsJygnLCdDQUxMX1NUQVJUJywnLCcsJzonLCdSRVRVUk4nLFxuXHRcdCctPScsJys9JywnLz0nLCcqPScsJyU9JywnfHw9JywnJiY9JywnPz0nLCc8PD0nLCc+Pj0nLCc+Pj49JywnJj0nLCdePScsJ3w9J1xuXHRdOyAvLyAuY29uY2F0KENPTVBPVU5EX0FTU0lHTilcblx0XG5cdFxuXHQvLyBjb25zb2xlLmxvZyBOT19JTVBMSUNJVF9CTE9DS19DQUxMOmxlbmd0aFxuXHQvLyBOT19JTVBMSUNJVF9CTE9DS19DQUxMXG5cdC8vIElNUExJQ0lUX0NPTU1BID0gWyctPicsICc9PicsICd7JywgJ1snLCAnTlVNQkVSJywgJ1NUUklORycsICdTWU1CT0wnLCAnSURFTlRJRklFUicsJ0RPJ11cblx0XG5cdHZhciBJTVBMSUNJVF9DT01NQSA9IFsnRE8nXTtcblx0XG5cdC8vIFRva2VucyB0aGF0IGFsd2F5cyBtYXJrIHRoZSBlbmQgb2YgYW4gaW1wbGljaXQgY2FsbCBmb3Igc2luZ2xlLWxpbmVycy5cblx0dmFyIElNUExJQ0lUX0VORCA9IFsnUE9TVF9JRicsJ1BPU1RfVU5MRVNTJywnUE9TVF9GT1InLCdXSElMRScsJ1VOVElMJywnV0hFTicsJ0JZJywnTE9PUCcsJ1RFUk1JTkFUT1InLCdERUZfQk9EWScsJ0RFRl9GUkFHTUVOVCddO1xuXHRcblx0Ly8gU2luZ2xlLWxpbmUgZmxhdm9ycyBvZiBibG9jayBleHByZXNzaW9ucyB0aGF0IGhhdmUgdW5jbG9zZWQgZW5kaW5ncy5cblx0Ly8gVGhlIGdyYW1tYXIgY2FuJ3QgZGlzYW1iaWd1YXRlIHRoZW0sIHNvIHdlIGluc2VydCB0aGUgaW1wbGljaXQgaW5kZW50YXRpb24uXG5cdHZhciBTSU5HTEVfTElORVJTID0gWydFTFNFJywnVFJZJywnRklOQUxMWScsJ1RIRU4nLCdCTE9DS19QQVJBTV9FTkQnLCdETycsJ0JFR0lOJywnQ0FUQ0hfVkFSJ107IC8vICctPicsICc9PicsIHJlYWxseT9cblx0dmFyIFNJTkdMRV9DTE9TRVJTID0gWydURVJNSU5BVE9SJywnQ0FUQ0gnLCdGSU5BTExZJywnRUxTRScsJ09VVERFTlQnLCdMRUFESU5HX1dIRU4nXTtcblx0XG5cdC8vIFRva2VucyB0aGF0IGVuZCBhIGxpbmUuXG5cdHJldHVybiBMSU5FQlJFQUtTID0gWydURVJNSU5BVE9SJywnSU5ERU5UJywnT1VUREVOVCddO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9+L2ltYmEvc3JjL2NvbXBpbGVyL3Jld3JpdGVyLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdC8vIGhlbHBlciBmb3Igc3ViY2xhc3Npbmdcblx0ZnVuY3Rpb24gc3ViY2xhc3MkKG9iaixzdXApIHtcblx0XHRmb3IgKHZhciBrIGluIHN1cCkge1xuXHRcdFx0aWYgKHN1cC5oYXNPd25Qcm9wZXJ0eShrKSkgb2JqW2tdID0gc3VwW2tdO1xuXHRcdH07XG5cdFx0Ly8gb2JqLl9fc3VwZXJfXyA9IHN1cDtcblx0XHRvYmoucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXAucHJvdG90eXBlKTtcblx0XHRvYmouX19zdXBlcl9fID0gb2JqLnByb3RvdHlwZS5fX3N1cGVyX18gPSBzdXAucHJvdG90eXBlO1xuXHRcdG9iai5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IG9iai5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBvYmo7XG5cdH07XG5cdFxuXHQvLyBjcmVhdGUgc2VwYXJhdGUgZXJyb3ItdHlwZXMgd2l0aCBhbGwgdGhlIGxvZ2ljXG5cdFxuXHRmdW5jdGlvbiBJbWJhUGFyc2VFcnJvcihlLG8pe1xuXHRcdHRoaXMuZXJyb3IgPSBlO1xuXHRcdHRoaXMubWVzc2FnZSA9IGUubWVzc2FnZTtcblx0XHR0aGlzLmZpbGVuYW1lID0gZS5maWxlbmFtZTtcblx0XHR0aGlzLmxpbmUgPSBlLmxpbmU7XG5cdFx0dGhpcy5fb3B0aW9ucyA9IG8gfHwge307XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdHN1YmNsYXNzJChJbWJhUGFyc2VFcnJvcixFcnJvcik7XG5cdGV4cG9ydHMuSW1iYVBhcnNlRXJyb3IgPSBJbWJhUGFyc2VFcnJvcjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRJbWJhUGFyc2VFcnJvci53cmFwID0gZnVuY3Rpb24gKGVycil7XG5cdFx0Ly8gd2hhdCBhYm91dCB0aGUgc3RhY2t0cmFjZT9cblx0XHRyZXR1cm4gbmV3IEltYmFQYXJzZUVycm9yKGVycik7XG5cdH07XG5cdFxuXHRJbWJhUGFyc2VFcnJvci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9wdHMpe1xuXHRcdHRoaXMuX29wdGlvbnMgfHwgKHRoaXMuX29wdGlvbnMgPSB7fSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhvcHRzKSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKXtcblx0XHRcdHRoaXMuX29wdGlvbnNba2V5c1tpXV0gPSBvcHRzW2tleXNbaV1dO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRJbWJhUGFyc2VFcnJvci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbyA9IHRoaXMuX29wdGlvbnM7XG5cdFx0dmFyIGlkeCA9IG8ucG9zIC0gMTtcblx0XHR2YXIgdG9rID0gby50b2tlbnMgJiYgby50b2tlbnNbaWR4XTtcblx0XHR3aGlsZSAodG9rICYmIHRvay5fbG9jID09IC0xKXtcblx0XHRcdHRvayA9IG8udG9rZW5zWy0taWR4XTtcblx0XHR9O1xuXHRcdHJldHVybiB0b2s7XG5cdH07XG5cdFxuXHRJbWJhUGFyc2VFcnJvci5wcm90b3R5cGUuZGVzYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBvID0gdGhpcy5fb3B0aW9ucztcblx0XHR2YXIgbXNnID0gdGhpcy5tZXNzYWdlO1xuXHRcdGlmIChvLnRva2VuICYmIG8udG9rZW4uX2xvYyA9PSAtMSkge1xuXHRcdFx0cmV0dXJuICdTeW50YXggRXJyb3InO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbXNnO1xuXHRcdH07XG5cdH07XG5cdFxuXHRJbWJhUGFyc2VFcnJvci5wcm90b3R5cGUubG9jID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHN0YXJ0Xztcblx0XHRyZXR1cm4gKHN0YXJ0XyA9IHRoaXMuc3RhcnQoKSkgJiYgc3RhcnRfLnJlZ2lvbiAgJiYgIHN0YXJ0Xy5yZWdpb24oKTtcblx0fTtcblx0XG5cdEltYmFQYXJzZUVycm9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgbyA9IHRoaXMuX29wdGlvbnM7XG5cdFx0dmFyIHRvayA9IHRoaXMuc3RhcnQoKTtcblx0XHQvLyB2YXIgdG9rID0gbzp0b2tlbnMgYW5kIG86dG9rZW5zW286cG9zIC0gMV1cblx0XHQvLyB2YXIgbG9jID0gdG9rIGFuZCBbdG9rLkBsb2MsdG9rLkBsb2MgKyAodG9rLkBsZW4gb3IgdG9rLkB2YWx1ZTpsZW5ndGgpXSBvciBbMCwwXVxuXHRcdC8vICwgY29sOiB0b2suQGNvbCwgbGluZTogdG9rLkBsaW5lXG5cdFx0Ly8gZ2V0IHRoZSB0b2tlbiBpdHNlbGY/XG5cdFx0cmV0dXJuIHt3YXJuOiB0cnVlLG1lc3NhZ2U6IHRoaXMuZGVzYygpLGxvYzogdGhpcy5sb2MoKX07XG5cdH07XG5cdHJldHVybiBJbWJhUGFyc2VFcnJvcjtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvfi9pbWJhL3NyYy9jb21waWxlci9lcnJvcnMuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0dmFyIFJlZ2lvbiA9IHJlcXVpcmUoJy4uL3JlZ2lvbicpLlJlZ2lvbjtcblx0XG5cdFxuXHRmdW5jdGlvbiBpc1doaXRlc3BhY2Uoc3RyKXtcblx0XHRyZXR1cm4gKC9eW1xcblxcdFxcIF0rJC8pLnRlc3Qoc3RyKTtcblx0fTsgZXhwb3J0cy5pc1doaXRlc3BhY2UgPSBpc1doaXRlc3BhY2U7XG5cdFxuXHRmdW5jdGlvbiBjb21tb25BbmNlc3RvcihhLGIpe1xuXHRcdGlmIChhIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdHZhciBhcnIgPSBhLnNsaWNlKCk7XG5cdFx0XHRyZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbihwcmV2LGN1cnIsaSkge1xuXHRcdFx0XHRyZXR1cm4gY29tbW9uQW5jZXN0b3IocHJldixjdXJyKTtcblx0XHRcdH0sYXJyLnNoaWZ0KCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKCFhIHx8ICFiKSB7IHJldHVybiAoYSB8fCBiKSB9O1xuXHRcdFxuXHRcdGEgPSBhLl9kb20gfHwgYTtcblx0XHRiID0gYi5fZG9tIHx8IGI7XG5cdFx0XG5cdFx0d2hpbGUgKCFhLmNvbnRhaW5zKGIpKXtcblx0XHRcdGEgPSBhLnBhcmVudE5vZGU7XG5cdFx0fTtcblx0XHR3aGlsZSAoIWIuY29udGFpbnMoYSkpe1xuXHRcdFx0YiA9IGIucGFyZW50Tm9kZTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0YWckd3JhcChhKTtcblx0fTsgZXhwb3J0cy5jb21tb25BbmNlc3RvciA9IGNvbW1vbkFuY2VzdG9yO1xuXHRcblx0XG5cdHZhciBwYWlycyA9IHtcblx0XHQnXCInOiAnXCInLFxuXHRcdFwiJ1wiOiBcIidcIixcblx0XHQnKCc6ICcpJyxcblx0XHQnPCc6ICc+Jyxcblx0XHQnWyc6ICddJyxcblx0XHQneyc6ICd9J1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gd3JhcFRleHQodGV4dCxvcGVuLGNsb3NlKXtcblx0XHRjbG9zZSB8fCAoY2xvc2UgPSBwYWlyc1tvcGVuXSk7XG5cdFx0aWYgKG9wZW4gPT0gXCInXCIpIHsgdGV4dCA9IHRleHQucmVwbGFjZSgvXFwnL2csXCJcXFxcJ1wiKSB9O1xuXHRcdHJldHVybiAob3BlbiB8fCAnJykgKyB0ZXh0ICsgKGNsb3NlIHx8ICcnKTtcblx0fTsgZXhwb3J0cy53cmFwVGV4dCA9IHdyYXBUZXh0O1xuXHRcblx0XG5cdGZ1bmN0aW9uIHN0cmluZ0lzQmFsYW5jZWQoc3RyKXtcblx0XHR2YXIgb3BlbnMgPSAnW3soXCJcXCcnO1xuXHRcdHZhciBjbG9zZXMgPSAnXX0pXCJcXCcnO1xuXHRcdHZhciBzdGFjayA9IFtdO1xuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgcyxlbmQ7XG5cdFx0XG5cdFx0d2hpbGUgKHMgPSBzdHJbaSsrXSl7XG5cdFx0XHR2YXIgb2lkID0gb3BlbnMuaW5kZXhPZihzKTtcblx0XHRcdFxuXHRcdFx0aWYgKHMgPT0gZW5kKSB7XG5cdFx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRlbmQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcblx0XHRcdH0gZWxzZSBpZiAob2lkID49IDApIHtcblx0XHRcdFx0c3RhY2sucHVzaChlbmQgPSBjbG9zZXNbb2lkXSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHN0YWNrLmxlbmd0aCA9PSAwID8gKHRydWUpIDogKGZhbHNlKTtcblx0fTsgZXhwb3J0cy5zdHJpbmdJc0JhbGFuY2VkID0gc3RyaW5nSXNCYWxhbmNlZDtcblx0XG5cdGZ1bmN0aW9uIGNvbFRvTG9jKGxpbmUsY29sLHRhYnNpemUpe1xuXHRcdGlmKHRhYnNpemUgPT09IHVuZGVmaW5lZCkgdGFic2l6ZSA9IDQ7XG5cdFx0dmFyIGNpID0gMDtcblx0XHR2YXIgcmNpID0gMDsgLy8gcmVhbCBjb2x1bW5cblx0XHR2YXIgY2hhciQ7XG5cdFx0XG5cdFx0aWYgKGNvbCA9PSAwKSB7IHJldHVybiAwIH07XG5cdFx0XG5cdFx0d2hpbGUgKGNoYXIkID0gbGluZVtjaSsrXSl7XG5cdFx0XHRpZiAoY2hhciQgPT0gJ1xcdCcpIHtcblx0XHRcdFx0dmFyIHJlc3QgPSB0YWJzaXplIC0gcmNpICUgdGFic2l6ZTtcblx0XHRcdFx0cmNpICs9IHJlc3Q7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyY2kgKz0gMTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChyY2kgPj0gY29sKSB7XG5cdFx0XHRcdHJldHVybiBjaTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gbGluZS5sZW5ndGg7XG5cdH07IGV4cG9ydHMuY29sVG9Mb2MgPSBjb2xUb0xvYztcblx0XG5cdGZ1bmN0aW9uIGNvbFRvVmlld0NvbChsaW5lLGNvbCx0YWJzaXplKXtcblx0XHRpZih0YWJzaXplID09PSB1bmRlZmluZWQpIHRhYnNpemUgPSA0O1xuXHRcdHZhciBjaSA9IDA7XG5cdFx0dmFyIHJjaSA9IDA7IC8vIHJlYWwgY29sdW1uXG5cdFx0dmFyIGNoYXIkO1xuXHRcdFxuXHRcdGlmIChjb2wgPT0gMCkgeyByZXR1cm4gMCB9O1xuXHRcdFxuXHRcdHdoaWxlIChjaGFyJCA9IGxpbmVbY2krK10pe1xuXHRcdFx0aWYgKGNoYXIkID09ICdcXHQnKSB7XG5cdFx0XHRcdHZhciByZXN0ID0gdGFic2l6ZSAtIHJjaSAlIHRhYnNpemU7XG5cdFx0XHRcdGlmIChyZXN0ID4gMyAmJiBjb2wgPD0gcmNpICsgMikgeyBicmVhazsgfTtcblx0XHRcdFx0cmNpICs9IHJlc3Q7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyY2kgKz0gMTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChjb2wgPD0gcmNpKSB7IGJyZWFrOyB9O1xuXHRcdH07XG5cdFx0cmV0dXJuIHJjaTtcblx0fTsgZXhwb3J0cy5jb2xUb1ZpZXdDb2wgPSBjb2xUb1ZpZXdDb2w7XG5cdFxuXHRmdW5jdGlvbiBjb2xzRm9yTGluZShsaW5lLHRhYnNpemUpe1xuXHRcdGlmKHRhYnNpemUgPT09IHVuZGVmaW5lZCkgdGFic2l6ZSA9IDQ7XG5cdFx0dmFyIGNvbCA9IDA7XG5cdFx0dmFyIGlkeCA9IDA7XG5cdFx0dmFyIGNoYXIkO1xuXHRcdHdoaWxlIChjaGFyJCA9IGxpbmVbaWR4KytdKXtcblx0XHRcdGlmIChjaGFyJCA9PSAnXFx0Jykge1xuXHRcdFx0XHR2YXIgcmVzdCA9IHRhYnNpemUgLSBjb2wgJSB0YWJzaXplO1xuXHRcdFx0XHRjb2wgKz0gcmVzdDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbCArPSAxO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdHJldHVybiBjb2w7XG5cdH07IGV4cG9ydHMuY29sc0ZvckxpbmUgPSBjb2xzRm9yTGluZTtcblx0XG5cdGZ1bmN0aW9uIHJvd2NvbChidWYsbG9jLHRhYnNpemUpe1xuXHRcdGlmKHRhYnNpemUgPT09IHVuZGVmaW5lZCkgdGFic2l6ZSA9IDQ7XG5cdFx0YnVmID0gYnVmLnRvU3RyaW5nKCk7XG5cdFx0dmFyIHBvcyA9IGxvYztcblx0XHR2YXIgY29sID0gMDtcblx0XHR2YXIgbGluZSA9IDA7XG5cdFx0dmFyIGNoYXIkO1xuXHRcdFxuXHRcdC8vIGdvIGJhY2sgdG8gc3RhcnQgb2YgbGluZVxuXHRcdHdoaWxlIChjaGFyJCA9IGJ1Zltwb3MgLSAxXSl7XG5cdFx0XHRpZiAoY2hhciQgPT0gJ1xcbicpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9O1xuXHRcdFx0cG9zLS07XG5cdFx0fTtcblx0XHRcblx0XHQvLyBnZXQgY29sdW1uIGZvciBzbGljZVxuXHRcdHdoaWxlICgocG9zIDwgbG9jKSAmJiAoY2hhciQgPSBidWZbcG9zXSkpe1xuXHRcdFx0aWYgKGNoYXIkID09ICdcXHQnKSB7XG5cdFx0XHRcdHZhciByZXN0ID0gdGFic2l6ZSAtIChjb2wgJSB0YWJzaXplKTtcblx0XHRcdFx0Y29sICs9IHJlc3Q7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb2wgKz0gMTtcblx0XHRcdH07XG5cdFx0XHRwb3MrKztcblx0XHR9O1xuXHRcdFxuXHRcdHdoaWxlIChjaGFyJCA9IGJ1Zltwb3MgLSAxXSl7XG5cdFx0XHRpZiAoY2hhciQgPT0gJ1xcbicpIHtcblx0XHRcdFx0bGluZSsrO1xuXHRcdFx0fTtcblx0XHRcdHBvcy0tO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIFtsaW5lLGNvbF07XG5cdH07IGV4cG9ydHMucm93Y29sID0gcm93Y29sO1xuXHRcblx0ZnVuY3Rpb24gaW5jcmVhc2VJbmRlbnQoc3RyKXtcblx0XHR2YXIgcmVnID0gL14oXFxzKiguKlxcPVxccyopPyhleHBvcnQgfGdsb2JhbCB8ZXh0ZW5kICk/KGNsYXNzfGRlZnx0YWd8dW5sZXNzfGlmfGVsc2V8ZWxpZnxzd2l0Y2h8dHJ5fGNhdGNofGZpbmFsbHl8Zm9yfHdoaWxlfHVudGlsfGRvKSkvO1xuXHRcdHZhciBvdGhlciA9IC9cXGIoZG8pXFxiLztcblx0XHRyZXR1cm4gcmVnLnRlc3Qoc3RyKSB8fCBvdGhlci50ZXN0KHN0cik7XG5cdH07IGV4cG9ydHMuaW5jcmVhc2VJbmRlbnQgPSBpbmNyZWFzZUluZGVudDtcblx0XG5cdFxuXHRmdW5jdGlvbiByZXBlYXRTdHJpbmcoc3RyLGNvdW50KXtcblx0XHRyZXR1cm4gbmV3IEFycmF5KGNvdW50ICsgMSkuam9pbihzdHIpO1xuXHR9OyBleHBvcnRzLnJlcGVhdFN0cmluZyA9IHJlcGVhdFN0cmluZztcblx0XG5cdFxuXHRmdW5jdGlvbiBwYXRjaFN0cmluZyhvcmlnLHN0cixtb2RlKXtcblx0XHR2YXIgcmVnaW9uO1xuXHRcdHZhciB0ZXh0ID0gb3JpZy50b1N0cmluZygpO1xuXHRcdFxuXHRcdGlmIChtb2RlID09ICdhcHBlbmQnKSB7XG5cdFx0XHRyZXR1cm4gdGV4dCArIHN0cjtcblx0XHR9IGVsc2UgaWYgKG1vZGUgPT0gJ3ByZXBlbmQnKSB7XG5cdFx0XHRyZXR1cm4gXCJcIiArIHN0ciArIHRleHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChyZWdpb24gPSBSZWdpb24ubm9ybWFsaXplKG1vZGUpKSB7XG5cdFx0XHRcdC8vIGxldCByZWdpb24gPSBSZWdpb24ubm9ybWFsaXplKClcblx0XHRcdFx0cmV0dXJuIHRleHQuc3Vic3RyKDAscmVnaW9uLnN0YXJ0KCkpICsgc3RyICsgdGV4dC5zbGljZShyZWdpb24uZW5kKCkpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9OyBleHBvcnRzLnBhdGNoU3RyaW5nID0gcGF0Y2hTdHJpbmc7OyByZXR1cm4gcGF0Y2hTdHJpbmc7XG5cdFxuXHRcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvdXRpbC5pbWJhXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHQvLyBoZWxwZXIgZm9yIHN1YmNsYXNzaW5nXG5cdGZ1bmN0aW9uIHN1YmNsYXNzJChvYmosc3VwKSB7XG5cdFx0Zm9yICh2YXIgayBpbiBzdXApIHtcblx0XHRcdGlmIChzdXAuaGFzT3duUHJvcGVydHkoaykpIG9ialtrXSA9IHN1cFtrXTtcblx0XHR9O1xuXHRcdC8vIG9iai5fX3N1cGVyX18gPSBzdXA7XG5cdFx0b2JqLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwLnByb3RvdHlwZSk7XG5cdFx0b2JqLl9fc3VwZXJfXyA9IG9iai5wcm90b3R5cGUuX19zdXBlcl9fID0gc3VwLnByb3RvdHlwZTtcblx0XHRvYmoucHJvdG90eXBlLmluaXRpYWxpemUgPSBvYmoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gb2JqO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gSGlzdG9yeVN0YXRlKGRhdGEpe1xuXHRcdGlmKGRhdGEgPT09IHVuZGVmaW5lZCkgZGF0YSA9IHt9O1xuXHRcdHRoaXMuX3RpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG5cdFx0dGhpcy5fZGF0YSA9IGRhdGE7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdFxuXHRcblx0SGlzdG9yeVN0YXRlLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9kYXRhOyB9XG5cdEhpc3RvcnlTdGF0ZS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9kYXRhID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SGlzdG9yeVN0YXRlLnByb3RvdHlwZS50aW1lc3RhbXAgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3RpbWVzdGFtcDsgfVxuXHRIaXN0b3J5U3RhdGUucHJvdG90eXBlLnNldFRpbWVzdGFtcCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl90aW1lc3RhbXAgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEhpc3RvcnlTdGF0ZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAodmlldyl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRIaXN0b3J5U3RhdGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKXtcblx0XHR0aGlzLl9kYXRhID0gZGF0YTtcblx0XHR0aGlzLl90aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIEZ1bGxIaXN0b3J5U3RhdGUoKXsgcmV0dXJuIEhpc3RvcnlTdGF0ZS5hcHBseSh0aGlzLGFyZ3VtZW50cykgfTtcblx0XG5cdHN1YmNsYXNzJChGdWxsSGlzdG9yeVN0YXRlLEhpc3RvcnlTdGF0ZSk7XG5cdEZ1bGxIaXN0b3J5U3RhdGUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHZpZXcpe1xuXHRcdHZpZXcubG9hZFN0YXRlKHRoaXMuX2RhdGEpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gRGlmZkhpc3RvcnlTdGF0ZSgpeyByZXR1cm4gSGlzdG9yeVN0YXRlLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKERpZmZIaXN0b3J5U3RhdGUsSGlzdG9yeVN0YXRlKTtcblx0XG5cdFxuXHR2YXIgdHlwZXMgPSB7fTtcblx0XG5cdGZ1bmN0aW9uIENvbW1hbmQocGFyYW1zKXtcblx0XHR0aGlzLl9wYXJhbXMgPSBwYXJhbXM7XG5cdH07XG5cdFxuXHRcblx0XG5cdENvbW1hbmQucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ByZXY7IH1cblx0Q29tbWFuZC5wcm90b3R5cGUuc2V0UHJldiA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9wcmV2ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0Q29tbWFuZC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fbmV4dDsgfVxuXHRDb21tYW5kLnByb3RvdHlwZS5zZXROZXh0ID0gZnVuY3Rpb24odil7IHRoaXMuX25leHQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRDb21tYW5kLnByb3RvdHlwZS5mcmFtZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZnJhbWU7IH1cblx0Q29tbWFuZC5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbih2KXsgdGhpcy5fZnJhbWUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdENvbW1hbmQuc3ltID0gZnVuY3Rpb24gKHN5bSl7XG5cdFx0dmFyICQwID0gYXJndW1lbnRzLCBpID0gJDAubGVuZ3RoO1xuXHRcdHZhciBwYXJzID0gbmV3IEFycmF5KGk+MSA/IGktMSA6IDApO1xuXHRcdHdoaWxlKGk+MSkgcGFyc1stLWkgLSAxXSA9ICQwW2ldO1xuXHRcdHRoaXMucHJvdG90eXBlLl9zeW1ib2wgPSBzeW07XG5cdFx0dGhpcy5wcm90b3R5cGUuX3NpZ25hdHVyZSA9IHBhcnM7XG5cdFx0dHlwZXNbc3ltXSA9IHRoaXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRDb21tYW5kLmxvYWQgPSBmdW5jdGlvbiAobyl7XG5cdFx0dmFyIHR5cCA9IHR5cGVzW29bMF1dO1xuXHRcdHZhciBmcmFtZSA9IG9bMV07XG5cdFx0dmFyIGNtZCA9IHR5cC5idWlsZChvWzJdKTtcblx0XHRjbWQuc2V0RnJhbWUoZnJhbWUpO1xuXHRcdHJldHVybiBjbWQ7XG5cdH07XG5cdFxuXHRDb21tYW5kLmJ1aWxkID0gZnVuY3Rpb24gKHBhcmFtcyl7XG5cdFx0cmV0dXJuIG5ldyB0aGlzKHBhcmFtcyk7XG5cdH07XG5cdFxuXHRDb21tYW5kLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGE7XG5cdH07XG5cdFxuXHRDb21tYW5kLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fcGFyYW1zO1xuXHR9O1xuXHRcblx0Q29tbWFuZC5wcm90b3R5cGUudW5kbyA9IGZ1bmN0aW9uICh2aWV3KXtcblx0XHRyZXR1cm4gdGhpcy5wcmV2KCk7XG5cdH07XG5cdFxuXHRDb21tYW5kLnByb3RvdHlwZS5yZWRvID0gZnVuY3Rpb24gKHZpZXcpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Q29tbWFuZC5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiAodmlldyl7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRDb21tYW5kLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgdl87XG5cdFx0aWYgKHRoaXMucHJldigpKSB7ICh0aGlzLnByZXYoKS5zZXROZXh0KHZfID0gdGhpcy5uZXh0KCkpLHZfKSB9O1xuXHRcdGlmICh0aGlzLm5leHQoKSkgeyAodGhpcy5uZXh0KCkuc2V0UHJldih2XyA9IHRoaXMucHJldigpKSx2XykgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdENvbW1hbmQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBbdGhpcy5fc3ltYm9sLHRoaXMuX2ZyYW1lIHx8IDAsdGhpcy5wYXJhbXMoKSB8fCBbXV07XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBNYXJrKCl7IHJldHVybiBDb21tYW5kLmFwcGx5KHRoaXMsYXJndW1lbnRzKSB9O1xuXHRcblx0c3ViY2xhc3MkKE1hcmssQ29tbWFuZCk7XG5cdE1hcmsuc3ltKCdNJywndmFsdWUnKTtcblx0XG5cdFxuXHRmdW5jdGlvbiBTbmFwc2hvdChwYXJhbXMpe1xuXHRcdHRoaXMuX2NvZGUgPSBwYXJhbXNbMF07XG5cdH07XG5cdFxuXHRzdWJjbGFzcyQoU25hcHNob3QsTWFyayk7XG5cdFNuYXBzaG90LnN5bSgnUycsJ2NvZGUnKTtcblx0XG5cdFNuYXBzaG90LnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gW3RoaXMuX2NvZGVdO1xuXHR9O1xuXHRcblx0U25hcHNob3QucHJvdG90eXBlLnJlZG8gPSBmdW5jdGlvbiAodmlldyl7XG5cdFx0Y29uc29sZS5sb2coJ2xvYWQnLHRoaXMuX2NvZGUpO1xuXHRcdHZpZXcubG9hZCh0aGlzLl9jb2RlKTtcblx0XHQvLyBtdXN0IHJlcGFpcj8gd2hhdCBhYm91dCBhbm5vdGF0aW9ucz9cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdGZ1bmN0aW9uIFNlbGVjdGlvbihwYXJhbXMpe1xuXHRcdHRoaXMuX29sZCA9IHBhcmFtc1swXTtcblx0XHR0aGlzLl9uZXcgPSBwYXJhbXNbMV07XG5cdH07XG5cdFxuXHRzdWJjbGFzcyQoU2VsZWN0aW9uLENvbW1hbmQpO1xuXHRTZWxlY3Rpb24uc3ltKCd8Jywnb2xkJywnbmV3Jyk7XG5cdFxuXHRTZWxlY3Rpb24ubG9hZCA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdHJldHVybiBuZXcgdGhpcyh2YWwpO1xuXHR9O1xuXHRcblx0U2VsZWN0aW9uLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gW3RoaXMuX29sZCx0aGlzLl9uZXddO1xuXHR9O1xuXHRcblx0U2VsZWN0aW9uLnByb3RvdHlwZS5yZWRvID0gZnVuY3Rpb24gKHZpZXcpe1xuXHRcdHZpZXcuY2FyZXQoKS5zZXQoSlNPTi5wYXJzZSh0aGlzLl9uZXcpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFNlbGVjdGlvbi5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiAodmlldyl7XG5cdFx0dGhpcy5yZWRvKHZpZXcpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0U2VsZWN0aW9uLnByb3RvdHlwZS51bmRvID0gZnVuY3Rpb24gKHZpZXcpe1xuXHRcdC8vIHdlIG5lZWQgdG8ga25vdyBhYm91dCB0aGUgcHJldmlvdXMgc2VsZWN0aW9uIGZvciB0aGlzP1xuXHRcdC8vIGNhbiBlaXRoZXIgc3RvcmUgYm90aCAtIG9yIHRyYXZlcnNlIGJhY2t3YXJkcyB0byB0aGUgcHJldmlvdXNcblx0XHQvLyBjb21tYW5kIGxpa2UgdGhpc1xuXHRcdHZhciBvbGQgPSBKU09OLnBhcnNlKHRoaXMuX29sZCk7XG5cdFx0Y29uc29sZS5sb2coJ21vdmUgc2VsZWN0aW9uIGJhY2sgdG8gb2xkJyxvbGQsdGhpcy5kYXRhKCkpO1xuXHRcdHZpZXcuY2FyZXQoKS5zZXQob2xkKTtcblx0XHRyZXR1cm4gdGhpcy5wcmV2KCk7XG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gSW5zZXJ0KHBhcnMpe1xuXHRcdHRoaXMuX3BvaW50ID0gcGFyc1swXTtcblx0XHR0aGlzLl9zdHIgPSBwYXJzWzFdO1xuXHR9O1xuXHRcblx0c3ViY2xhc3MkKEluc2VydCxDb21tYW5kKTtcblx0SW5zZXJ0LnN5bSgnKycsJ3BvaW50Jywnc3RyJyk7XG5cdFxuXHRJbnNlcnQucHJvdG90eXBlLnBhcmFtcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBbdGhpcy5fcG9pbnQsdGhpcy5fc3RyXTtcblx0fTtcblx0XG5cdEluc2VydC5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uICh2aWV3KXtcblx0XHRjb25zb2xlLmxvZygncmVkbyBJbnNlcnQnKTtcblx0XHRyZXR1cm4gdmlldy5pbnNlcnQodGhpcy5fcG9pbnQsdGhpcy5fc3RyKTtcblx0fTtcblx0XG5cdEluc2VydC5wcm90b3R5cGUudW5kbyA9IGZ1bmN0aW9uICh2aWV3KXtcblx0XHRjb25zb2xlLmxvZygndW5kbyBJbnNlcnQnKTtcblx0XHR2aWV3LmVyYXNlKFt0aGlzLl9wb2ludCx0aGlzLl9wb2ludCArIHRoaXMuX3N0ci5sZW5ndGhdKTtcblx0XHRyZXR1cm4gdGhpcy5wcmV2KCk7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBFcmFzZShwYXJhbXMpe1xuXHRcdHRoaXMuX3JlZ2lvbiA9IHBhcmFtc1swXTtcblx0XHR0aGlzLl9zdHIgPSBwYXJhbXNbMV07XG5cdH07XG5cdFxuXHRzdWJjbGFzcyQoRXJhc2UsQ29tbWFuZCk7XG5cdEVyYXNlLnN5bSgnLScsJ3JlZ2lvbicsJ3N0cicpO1xuXHRcblx0RXJhc2UucHJvdG90eXBlLnBhcmFtcyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBbdGhpcy5fcmVnaW9uLHRoaXMuX3N0cl07XG5cdH07XG5cdFxuXHRFcmFzZS5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uICh2aWV3KXtcblx0XHRjb25zb2xlLmxvZygncmVkbyBFcmFzZScpO1xuXHRcdHJldHVybiB2aWV3LmVyYXNlKHRoaXMuX3JlZ2lvbik7XG5cdH07XG5cdFxuXHRFcmFzZS5wcm90b3R5cGUudW5kbyA9IGZ1bmN0aW9uICh2aWV3KXtcblx0XHQvLyBpZiB3ZSBkb250IGtub3cgdGhlIHRleHQgdG8gXG5cdFx0Y29uc29sZS5sb2coJ3VuZG8gRXJhc2UnKTtcblx0XHR2aWV3Lmluc2VydCh0aGlzLl9yZWdpb24uc3RhcnQoKSx0aGlzLl9zdHIpO1xuXHRcdHJldHVybiB0aGlzLnByZXYoKTtcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiBIaXN0b3J5KHZpZXcpe1xuXHRcdHRoaXMuX21vZGUgPSAnbm9ybWFsJztcblx0XHR0aGlzLl92aWV3ID0gdmlldztcblx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcblx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHR0aGlzLnNldEN1cnJlbnQodGhpcy5fc2VlZCA9IG5ldyBNYXJrKCkpO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLkhpc3RvcnkgPSBIaXN0b3J5OyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUubW9kZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fbW9kZTsgfVxuXHRIaXN0b3J5LnByb3RvdHlwZS5zZXRNb2RlID0gZnVuY3Rpb24odil7IHRoaXMuX21vZGUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdEhpc3RvcnkucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLmVuYWJsZWQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7IH1cblx0SGlzdG9yeS5wcm90b3R5cGUuc2V0RW5hYmxlZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9lbmFibGVkID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fY3VycmVudDsgfVxuXHRIaXN0b3J5LnByb3RvdHlwZS5zZXRDdXJyZW50ID0gZnVuY3Rpb24odil7IHRoaXMuX2N1cnJlbnQgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5zZWVkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9zZWVkOyB9XG5cdEhpc3RvcnkucHJvdG90eXBlLnNldFNlZWQgPSBmdW5jdGlvbih2KXsgdGhpcy5fc2VlZCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLnRhaWwgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3RhaWw7IH1cblx0SGlzdG9yeS5wcm90b3R5cGUuc2V0VGFpbCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl90YWlsID0gdjsgcmV0dXJuIHRoaXM7IH07IC8vIGlzIHRoaXMgYmVoaW5kIG9yIGluIHRoZSB2ZXJ5IGZyb250P1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGl0ZW0sbW92ZSxmcmFtZSl7XG5cdFx0aWYobW92ZSA9PT0gdW5kZWZpbmVkKSBtb3ZlID0gdHJ1ZTtcblx0XHRpZihmcmFtZSA9PT0gdW5kZWZpbmVkKSBmcmFtZSA9IHRoaXMudmlldygpLmZyYW1lcygpO1xuXHRcdGl0ZW0uc2V0RnJhbWUoZnJhbWUpO1xuXHRcdFxuXHRcdGlmICh0aGlzLmN1cnJlbnQoKSkge1xuXHRcdFx0Ly8gaWYgY3VycmVudCBoYXMgYSBuZXh0IGV2ZW50XG5cdFx0XHQvLyB0aGlzIHNob3VsZCBiZSBkZXRhY2hlZCBoZXJlP1xuXHRcdFx0aXRlbS5zZXRQcmV2KHRoaXMuY3VycmVudCgpKTtcblx0XHRcdHRoaXMuY3VycmVudCgpLnNldE5leHQoaXRlbSk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAobW92ZSkgeyAodGhpcy5zZXRDdXJyZW50KGl0ZW0pLGl0ZW0pIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGN1cnJlbnRfO1xuXHRcdHJldHVybiAoY3VycmVudF8gPSB0aGlzLmN1cnJlbnQoKSkgJiYgY3VycmVudF8ubmV4dCAgJiYgIGN1cnJlbnRfLm5leHQoKTtcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKXtcblx0XHR2YXIgY3VycmVudF87XG5cdFx0cmV0dXJuIChjdXJyZW50XyA9IHRoaXMuY3VycmVudCgpKSAmJiBjdXJyZW50Xy5wcmV2ICAmJiAgY3VycmVudF8ucHJldigpO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG8pe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uIChkaXIpe1xuXHRcdGlmKGRpciA9PT0gdW5kZWZpbmVkKSBkaXIgPSAxO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzZWxmLmFwcGx5KGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlcyA9IFtdO3doaWxlIChzZWxmLm5leHQoKSl7XG5cdFx0XHRcdHNlbGYubmV4dCgpLnJlZG8oc2VsZi52aWV3KCksc2VsZik7XG5cdFx0XHRcdHNlbGYuc2V0Q3VycmVudChzZWxmLm5leHQoKSk7XG5cdFx0XHRcdGlmIChzZWxmLmN1cnJlbnQoKSBpbnN0YW5jZW9mIE1hcmspIHsgYnJlYWs7IH07XG5cdFx0XHR9O3JldHVybiByZXM7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHNlbGY7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS51bmRvID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHNlbGYuYXBwbHkoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBzaG91bGQgYmUgcG9zc2libGUgdG8gdW5kbyBcblx0XHRcdHZhciByZXMgPSBbXSwgdl8sIGN1cnJlbnRfO3doaWxlIChzZWxmLmN1cnJlbnQoKSl7XG5cdFx0XHRcdGlmIChzZWxmLnByZXYoKSkgeyAoc2VsZi5zZXRDdXJyZW50KHZfID0gc2VsZi5jdXJyZW50KCkudW5kbyhzZWxmLnZpZXcoKSxzZWxmKSksdl8pIH07XG5cdFx0XHRcdChjdXJyZW50XyA9IHNlbGYuY3VycmVudCgpKSAmJiBjdXJyZW50Xy5lbnRlciAgJiYgIGN1cnJlbnRfLmVudGVyKHNlbGYudmlldygpLHNlbGYpO1xuXHRcdFx0XHRpZiAoc2VsZi5jdXJyZW50KCkgaW5zdGFuY2VvZiBNYXJrKSB7IGJyZWFrOyB9O1xuXHRcdFx0fTtyZXR1cm4gcmVzO1xuXHRcdH0pO1xuXHRcdFxuXHRcdHJldHVybiBzZWxmO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoY2Ipe1xuXHRcdHRoaXMuX2FjdGl2ZSA9IHRydWU7XG5cdFx0Y2IgJiYgY2IoKTtcblx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLmJhdGNoID0gZnVuY3Rpb24gKGNiKXtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24gKHN0YXRlKXtcblx0XHRzdGF0ZS5hcHBseSh0aGlzLnZpZXcoKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5vbmVyYXNlID0gZnVuY3Rpb24gKHJlZyxzdHIsZWRpdCl7XG5cdFx0aWYgKHRoaXMuX2FjdGl2ZSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdHJldHVybiB0aGlzLmFkZChuZXcgRXJhc2UoW3JlZyxzdHJdKSk7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5vbmluc2VydCA9IGZ1bmN0aW9uIChsb2Msc3RyLGVkaXQpe1xuXHRcdGlmICh0aGlzLl9hY3RpdmUpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRyZXR1cm4gdGhpcy5hZGQobmV3IEluc2VydChbbG9jLHN0cl0pKTtcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLm9uY2FyZXQgPSBmdW5jdGlvbiAob2xkLG5ldyQpe1xuXHRcdGlmICh0aGlzLl9hY3RpdmUpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRyZXR1cm4gdGhpcy5hZGQobmV3IFNlbGVjdGlvbihbb2xkLG5ldyRdKSk7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5vbmxvYWQgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0aWYgKHRoaXMuX2FjdGl2ZSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdHZhciBtYXJrID0gbmV3IFNuYXBzaG90KFtjb2RlXSk7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKG1hcmspO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUubWFyayA9IGZ1bmN0aW9uICh2YWx1ZSl7XG5cdFx0aWYgKHRoaXMuX2FjdGl2ZSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdHZhciBtYXJrID0gbmV3IE1hcmsoW3ZhbHVlXSk7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKG1hcmspO1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpe1xuXHRcdFxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRpZiAoc2VsZi5fbW9kZSA9PSAncGxheScpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdwbHlhaW5nJ1xuXHRcdFx0dmFyIGZyYW1lID0gc2VsZi52aWV3KCkuZnJhbWVzKCkgLSBzZWxmLl9vZmZzZXQ7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnaGlzdG9yeS50aWNrIHdpbGwgcGxheScsZnJhbWUsbmV4dCxjdXJyZW50XG5cdFx0XHRzZWxmLmFwcGx5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcmVzID0gW10sIHZfO3doaWxlIChzZWxmLm5leHQoKSAmJiBzZWxmLm5leHQoKS5mcmFtZSgpIDw9IGZyYW1lKXtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnaGlzdG9yeS50aWNrIHBsYXknLGZyYW1lLG5leHQsY3VycmVudFxuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nICdyZXBsYXkgZnJhbWUhJ1xuXHRcdFx0XHRcdHNlbGYubmV4dCgpLnJlZG8oc2VsZi52aWV3KCksc2VsZik7XG5cdFx0XHRcdFx0cmVzLnB1c2goKChzZWxmLnNldEN1cnJlbnQodl8gPSBzZWxmLm5leHQoKSksdl8pKSk7XG5cdFx0XHRcdH07cmV0dXJuIHJlcztcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRpZiAoIShzZWxmLm5leHQoKSkpIHtcblx0XHRcdFx0c2VsZi5zZXRNb2RlKCdsaXZlJyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0cmV0dXJuIHNlbGY7XG5cdH07XG5cdFxuXHRIaXN0b3J5LnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gc2hvdWxkIHByb2JhYmx5IGhhcHBlbiBpbiBhIGRpZmZlcmVudCBtYW5hZ2VyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBzbmFwID0gc2VsZi5zZWVkKCk7XG5cdFx0d2hpbGUgKCEoIXNuYXAgfHwgKHNuYXAgaW5zdGFuY2VvZiBTbmFwc2hvdCkpKXtcblx0XHRcdHNuYXAgPSBzbmFwLm5leHQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHNlbGYuX29mZnNldCA9IHNlbGYudmlldygpLmZyYW1lcygpIC0gc25hcC5mcmFtZSgpO1xuXHRcdGNvbnNvbGUubG9nKFwicGxheWluZyBmcm9tIHNlZWRcIixzbmFwLHNlbGYuX29mZnNldCk7XG5cdFx0Ly8gY29uc29sZS5sb2cgJ2ZvdW5kIHNuYXBzaG90PyE/IC0tIG9mZnNldCBmcmFtZScsQG9mZnNldFxuXHRcdHNlbGYuYXBwbHkoZnVuY3Rpb24oKSB7IHZhciB2Xztcblx0XHRyZXR1cm4gKHNlbGYuc2V0Q3VycmVudCh2XyA9IHNuYXAucmVkbyhzZWxmLnZpZXcoKSxzZWxmKSksdl8pOyB9KTtcblx0XHRzZWxmLnNldE1vZGUoJ3BsYXknKTtcblx0XHRyZXR1cm4gc2VsZjtcblx0fTtcblx0XG5cdEhpc3RvcnkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBkYXRhID0gW107XG5cdFx0dmFyIHN0ZXAgPSB0aGlzLl9zZWVkO1xuXHRcdFxuXHRcdHdoaWxlIChzdGVwKXtcblx0XHRcdGRhdGEucHVzaChzdGVwLnRvSlNPTigpKTtcblx0XHRcdHN0ZXAgPSBzdGVwLm5leHQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB7Y29tbWFuZHM6IGRhdGF9O1xuXHR9O1xuXHRcblx0SGlzdG9yeS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChkYXRhKXtcblx0XHR2YXIgc3RlcCA9IHRoaXMuc2VlZCgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChkYXRhLmNvbW1hbmRzKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IENvbW1hbmQubG9hZChhcnlbaV0pO1xuXHRcdFx0aXRlbS5zZXRQcmV2KHN0ZXApO1xuXHRcdFx0c3RlcC5zZXROZXh0KGl0ZW0pO1xuXHRcdFx0c3RlcCA9IGl0ZW07XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnbG9hZCBpdGVtJyxpdGVtXG5cdFx0fTtcblx0XHQvLyBjb25zb2xlLmxvZyAnbG9hZGVkJ1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRyZXR1cm4gSGlzdG9yeTtcblx0XG5cdFxuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvY29yZS9oaXN0b3J5LmltYmFcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHRmdW5jdGlvbiBMb2dnZXIodmlldyl7XG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5fdmlldyA9IHZpZXc7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdGV4cG9ydHMuTG9nZ2VyID0gTG9nZ2VyOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0TG9nZ2VyLnByb3RvdHlwZS5lbmFibGVkID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9lbmFibGVkOyB9XG5cdExvZ2dlci5wcm90b3R5cGUuc2V0RW5hYmxlZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9lbmFibGVkID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0TG9nZ2VyLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdExvZ2dlci5wcm90b3R5cGUuc2V0VmlldyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92aWV3ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRMb2dnZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uICgpe1xuXHRcdGlmICh0aGlzLl9lbmFibGVkIHx8IERFQlVHKSB7IGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsYXJndW1lbnRzKSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0TG9nZ2VyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQgfHwgREVCVUcpIHsgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSxhcmd1bWVudHMpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRMb2dnZXIucHJvdG90eXBlLmdyb3VwID0gZnVuY3Rpb24gKG5hbWUpe1xuXHRcdGlmICh0aGlzLl9lbmFibGVkIHx8IERFQlVHKSB7IGNvbnNvbGUuZ3JvdXAuYXBwbHkoY29uc29sZSxhcmd1bWVudHMpIH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRMb2dnZXIucHJvdG90eXBlLmdyb3VwQ29sbGFwc2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQgfHwgREVCVUcpIHsgY29uc29sZS5ncm91cENvbGxhcHNlZC5hcHBseShjb25zb2xlLGFyZ3VtZW50cykgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdExvZ2dlci5wcm90b3R5cGUuZ3JvdXBFbmQgPSBmdW5jdGlvbiAoKXtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCB8fCBERUJVRykgeyBjb25zb2xlLmdyb3VwRW5kKCkgfTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0cmV0dXJuIExvZ2dlcjtcblx0XG5cdFxuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvY29yZS9sb2dnZXIuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0ZnVuY3Rpb24gaWR4JChhLGIpe1xuXHRcdHJldHVybiAoYiAmJiBiLmluZGV4T2YpID8gYi5pbmRleE9mKGEpIDogW10uaW5kZXhPZi5jYWxsKGEsYik7XG5cdH07XG5cdFxuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cdFxuXHR2YXIgc3BlY2lhbEtleXMgPSB7XG5cdFx0ODogXCJiYWNrc3BhY2VcIixcblx0XHQ5OiBcInRhYlwiLFxuXHRcdDEwOiBcInJldHVyblwiLFxuXHRcdDEzOiBcInJldHVyblwiLFxuXHRcdDE2OiBcInNoaWZ0XCIsXG5cdFx0MTc6IFwiY3RybFwiLFxuXHRcdDE4OiBcImFsdFwiLFxuXHRcdDE5OiBcInBhdXNlXCIsXG5cdFx0MjA6IFwiY2Fwc2xvY2tcIixcblx0XHQyNzogXCJlc2NcIixcblx0XHQzMjogXCJzcGFjZVwiLFxuXHRcdDMzOiBcInBhZ2V1cFwiLFxuXHRcdDM0OiBcInBhZ2Vkb3duXCIsXG5cdFx0MzU6IFwiZW5kXCIsXG5cdFx0MzY6IFwiaG9tZVwiLFxuXHRcdDM3OiBcImxlZnRcIixcblx0XHQzODogXCJ1cFwiLFxuXHRcdDM5OiBcInJpZ2h0XCIsXG5cdFx0NDA6IFwiZG93blwiLFxuXHRcdDQ1OiBcImluc2VydFwiLFxuXHRcdDQ2OiBcImRlbFwiLFxuXHRcdDU5OiBcIjtcIixcblx0XHQ2MTogXCI9XCIsXG5cdFx0OTY6IFwiMFwiLFxuXHRcdDk3OiBcIjFcIixcblx0XHQ5ODogXCIyXCIsXG5cdFx0OTk6IFwiM1wiLFxuXHRcdDEwMDogXCI0XCIsXG5cdFx0MTAxOiBcIjVcIixcblx0XHQxMDI6IFwiNlwiLFxuXHRcdDEwMzogXCI3XCIsXG5cdFx0MTA0OiBcIjhcIixcblx0XHQxMDU6IFwiOVwiLFxuXHRcdDEwNjogXCIqXCIsXG5cdFx0MTA3OiBcIitcIixcblx0XHQxMDk6IFwiLVwiLFxuXHRcdDExMDogXCIuXCIsXG5cdFx0MTExOiBcIi9cIixcblx0XHQxMTI6IFwiZjFcIixcblx0XHQxMTM6IFwiZjJcIixcblx0XHQxMTQ6IFwiZjNcIixcblx0XHQxMTU6IFwiZjRcIixcblx0XHQxMTY6IFwiZjVcIixcblx0XHQxMTc6IFwiZjZcIixcblx0XHQxMTg6IFwiZjdcIixcblx0XHQxMTk6IFwiZjhcIixcblx0XHQxMjA6IFwiZjlcIixcblx0XHQxMjE6IFwiZjEwXCIsXG5cdFx0MTIyOiBcImYxMVwiLFxuXHRcdDEyMzogXCJmMTJcIixcblx0XHQxNDQ6IFwibnVtbG9ja1wiLFxuXHRcdDE0NTogXCJzY3JvbGxcIixcblx0XHQxNzM6IFwiLVwiLFxuXHRcdDE4NjogXCI7XCIsXG5cdFx0MTg3OiBcIj1cIixcblx0XHQxODg6IFwiLFwiLFxuXHRcdDE4OTogXCItXCIsXG5cdFx0MTkwOiBcIi5cIixcblx0XHQxOTE6IFwiL1wiLFxuXHRcdDE5MjogXCJgXCIsXG5cdFx0MjE5OiBcIltcIixcblx0XHQyMjA6IFwiXFxcXFwiLFxuXHRcdDIyMTogXCJdXCIsXG5cdFx0MjIyOiBcIidcIlxuXHR9O1xuXHRcblx0dmFyIHNoaWZ0TnVtcyA9IHtcblx0XHRcImBcIjogXCJ+XCIsXG5cdFx0XCIxXCI6IFwiIVwiLFxuXHRcdFwiMlwiOiBcIkBcIixcblx0XHRcIjNcIjogXCIjXCIsXG5cdFx0XCI0XCI6IFwiJFwiLFxuXHRcdFwiNVwiOiBcIiVcIixcblx0XHRcIjZcIjogXCJeXCIsXG5cdFx0XCI3XCI6IFwiJlwiLFxuXHRcdFwiOFwiOiBcIipcIixcblx0XHRcIjlcIjogXCIoXCIsXG5cdFx0XCIwXCI6IFwiKVwiLFxuXHRcdFwiLVwiOiBcIl9cIixcblx0XHRcIj1cIjogXCIrXCIsXG5cdFx0XCI7XCI6IFwiOiBcIixcblx0XHRcIidcIjogJ1wiJyxcblx0XHRcIixcIjogXCI8XCIsXG5cdFx0XCIuXCI6IFwiPlwiLFxuXHRcdFwiL1wiOiBcIj9cIixcblx0XHRcIlxcXFxcIjogXCJ8XCJcblx0fTtcblx0XG5cdGZ1bmN0aW9uIHRyaWdnZXIoa2V5LG8pe1xuXHRcdGlmIChvIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdG8gPSB7Y29tbWFuZDogb307XG5cdFx0fTtcblx0XHRvLnRyaWdnZXIgPSBrZXk7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBjb21ibyhrZXlzLG8pe1xuXHRcdGlmIChvIGluc3RhbmNlb2YgRnVuY3Rpb24pIHsgbyA9IHtjb21tYW5kOiBvfSB9O1xuXHRcdG8ua2V5cyA9IGtleXM7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cdFxuXHRJTS5LZXlCaW5kaW5ncyA9IFtcblx0XHRcblx0XHRjb21ibyhbJ3N1cGVyK3onXSxmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC52aWV3KCkuaGlzdG9yeSgpLnVuZG8oKTsgfSksXG5cdFx0Y29tYm8oW1wic3VwZXIrc2hpZnQrelwiXSxmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC52aWV3KCkuaGlzdG9yeSgpLnJlZG8oKTsgfSksXG5cdFx0Y29tYm8oW1wiYWx0K3N1cGVyK3BcIl0sZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwudmlldygpLmhpc3RvcnkoKS5wbGF5KCk7IH0pLFxuXHRcdC8vIGNvbWJvIFtcImFsdCtzaGlmdCtyXCJdIGRvIHxzZWx8IHNlbC52aWV3Lmhpc3RvcnkucGxheVxuXHRcdFxuXHRcdGNvbWJvKFtcInN1cGVyK3NcIl0se2NvbW1hbmQ6IFwic2F2ZVwifSksXG5cdFx0Y29tYm8oW1wic3VwZXIrYlwiXSx7Y29tbWFuZDogXCJydW5cIn0pLFxuXHRcdGNvbWJvKFtcImFsdCtzdXBlcitzXCJdLHtjb21tYW5kOiBcInNhdmVTZXNzaW9uXCJ9KSxcblx0XHRjb21ibyhbXCJhbHQrc2hpZnQrbFwiXSx7Y29tbWFuZDogXCJyZXBhcnNlXCJ9KSxcblx0XHRjb21ibyhbXCJhbHQrc2hpZnQra1wiXSx7Y29tbWFuZDogXCJyZXBhcnNlRXh0ZW50XCJ9KSxcblx0XHRcblx0XHRjb21ibyhbXCJzdXBlcithXCJdLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLnNlbGVjdEFsbCgpOyB9KSxcblx0XHRcblx0XHRcblx0XHRjb21ibyhbJ3RhYiddLHtjb250ZXh0OiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC50ZXh0KCkuaW5kZXhPZignXFxuJykgPj0gMDsgfSxcblx0XHRjb21tYW5kOiBmdW5jdGlvbihzZWwpIHtcblx0XHRcdHNlbC5leHBhbmRUb0xpbmVzKCk7XG5cdFx0XHR2YXIgcmVnaW9uID0gc2VsLnJlZ2lvbigpO1xuXHRcdFx0dmFyIG5vZGVzID0gc2VsLnZpZXcoKS5ub2Rlc0luUmVnaW9uKHJlZ2lvbik7XG5cdFx0XHRcblx0XHRcdG5vZGVzLm1hcChmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHRpZiAobWF0Y2gubm9kZS5tYXRjaGVzKCcuX2ltbmV3bGluZScpKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ2ZvdW5kIHRhYiBpbiBzZWxlY3Rpb24nLG1hdGNoKTtcblx0XHRcdFx0XHRpZiAobWF0Y2gubW9kZSAhPSAnc3RhcnQnKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbWF0Y2gubm9kZS5pbmRlbnQoKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gc2VsLmRpcnR5KCk7XG5cdFx0fX0pLFxuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdGNvbWJvKFtcInNoaWZ0K3RhYlwiXSx7Y29udGV4dDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwudGV4dCgpLmluZGV4T2YoJ1xcbicpID49IDA7IH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7XG5cdFx0XHRzZWwuZXhwYW5kVG9MaW5lcygpO1xuXHRcdFx0dmFyIHJlZ2lvbiA9IHNlbC5yZWdpb24oKTtcblx0XHRcdHZhciBub2RlcyA9IHNlbC52aWV3KCkubm9kZXNJblJlZ2lvbihyZWdpb24pO1xuXHRcdFx0XG5cdFx0XHRub2Rlcy5tYXAoZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0aWYgKG1hdGNoLm5vZGUubWF0Y2hlcygnLl9pbW5ld2xpbmUnKSAmJiBtYXRjaC5tb2RlICE9ICdzdGFydCcpIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2gubm9kZS51bmRlbnQoKTtcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHNlbC5kaXJ0eSgpO1xuXHRcdH19KSxcblx0XHRcblx0XHRjb21ibyhbXCJzaGlmdCt0YWJcIl0se2NvbnRleHQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHJldHVybiB0cnVlOyAvLyBTdHJpbmcoZS52aWV3LnNlbGVjdGlvbikuaW5kZXhPZignXFxuJykgPj0gMFxuXHRcdH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7XG5cdFx0XHRjb25zb2xlLmxvZygndHJ5IHVuZGVudCcpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fX0pLFxuXHRcdFxuXHRcdGNvbWJvKFtcImFsdCtzaGlmdCtyZXR1cm5cIl0sZnVuY3Rpb24oc2VsKSB7IHJldHVybiBjb25zb2xlLmxvZygncHJldHRpZnknKTsgfSksXG5cdFx0XG5cdFx0Y29tYm8oW1wiYmFja3NwYWNlXCJdLHtjb250ZXh0OiBmdW5jdGlvbihlKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnZGVsZXRlTGVmdFJpZ2h0IGJhY2tzcGFjZT8hPycsZS5yZWdpb24oKSxlLnJlZ2lvbigpLnBlZWsoLTEsMSkpO1xuXHRcdFx0cmV0dXJuIGlkeCQoZS5yZWdpb24oKS5wZWVrKC0xLDEpLFsnW10nLCd7fScsJzw+JywnKCknLCdcIlwiJyxcIicnXCJdKSA+PSAwO1xuXHRcdH0sXG5cdFx0XG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnbW92aW5nISEnKTtcblx0XHRcdHNlbC5leHBhbmQoLTEsMSk7XG5cdFx0XHRyZXR1cm4gc2VsLmVyYXNlKCk7XG5cdFx0fX0pLFxuXHRcdFxuXHRcdGNvbWJvKFtcImJhY2tzcGFjZVwiXSx7Y29udGV4dDogZnVuY3Rpb24oc2VsLG8pIHtcblx0XHRcdHZhciByZWcgPSBzZWwucmVnaW9uKCk7XG5cdFx0XHRpZiAocmVnLnNpemUoKSA9PSAwKSB7XG5cdFx0XHRcdGlmIChvLm5vZGUgPSByZWcucHJldk5vZGUoJy5faW1wYWlyLC5faW1zdHInKSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdFxuXHRcdGNvbW1hbmQ6IGZ1bmN0aW9uKHNlbCxvKSB7IHZhciB2Xztcblx0XHRyZXR1cm4gKHNlbC5zZXRSZWdpb24odl8gPSBvLm5vZGUucmVnaW9uKCkuY2xvbmUoKS5yZXZlcnNlKCkpLHZfKTsgfX0pLFxuXHRcdFxuXHRcdGNvbWJvKFtcImJhY2tzcGFjZVwiXSx7Y29udGV4dDogZnVuY3Rpb24oc2VsLG8pIHtcblx0XHRcdGlmIChzZWwudGV4dCgpICYmICF1dGlsLnN0cmluZ0lzQmFsYW5jZWQoc2VsLnRleHQoKSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsLG8pIHsgcmV0dXJuIHRydWU7IH19KSxcblx0XHRcblx0XHRjb21ibyhbXCJiYWNrc3BhY2VcIl0sZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuZXJhc2UoKTsgfSksXG5cdFx0Y29tYm8oW1wic2hpZnQrYmFja3NwYWNlXCJdLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLmVyYXNlKCk7IH0pLFxuXHRcdGNvbWJvKFtcImFsdCtiYWNrc3BhY2VcIl0sZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuZXJhc2UoSU0uV09SRF9TVEFSVCk7IH0pLFxuXHRcdGNvbWJvKFtcInN1cGVyK2JhY2tzcGFjZVwiXSxmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5lcmFzZShJTS5MSU5FX1NUQVJUKTsgfSksXG5cdFx0XG5cdFx0Y29tYm8oW1wicmV0dXJuXCIsJ3NoaWZ0K3JldHVybicsJ3N1cGVyK3JldHVybiddLGZ1bmN0aW9uKHNlbCkge1xuXHRcdFx0dmFyIGluZCA9IHNlbC5pbmRlbnQoKTtcblx0XHRcdGlmICh1dGlsLmluY3JlYXNlSW5kZW50KHNlbC5oZWFkKCkucGVla2JlaGluZCgpKSkgeyBpbmQgKz0gJ1xcdCcgfTtcblx0XHRcdFxuXHRcdFx0Ly8gc2hvdWxkIG5vdCBoYXBwZW4gaW4gc3RyaW5nXG5cdFx0XHRpZiAoaWR4JChzZWwucmVnaW9uKCkucGVlaygtMSwxKSxbJ1tdJywne30nLCcoKSddKSA+PSAwKSB7XG5cdFx0XHRcdHNlbC5pbnNlcnQoJ1xcblxcdCcgKyBpbmQpO1xuXHRcdFx0XHRzZWwudmlldygpLmluc2VydChzZWwuaGVhZCgpLmxvYygpLCdcXG4nICsgaW5kKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbC5pbnNlcnQoJ1xcbicgKyBpbmQpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSksXG5cdFx0XG5cdFx0XG5cdFx0Y29tYm8oWydzcGFjZScsJ3NoaWZ0K3NwYWNlJ10sZnVuY3Rpb24oc2VsKSB7XG5cdFx0XHRpZiAoc2VsLnJlZ2lvbigpLnBlZWsoLTEsMSkgPT0gJzw+Jykge1xuXHRcdFx0XHRzZWwubW92ZSgxKS5lcmFzZSgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHNlbC5pbnNlcnQoJyAnKTtcblx0XHR9KSxcblx0XHRcblx0XHRjb21ibyhbJ3RhYiddLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLmluc2VydCgnXFx0Jyk7IH0pLFxuXHRcdFxuXHRcdFxuXHRcdGNvbWJvKFsnc3VwZXIrdXAnXSxmdW5jdGlvbihzZWwpIHtcblx0XHRcdHNlbC5jb2xsYXBzZSgpLmhlYWQoKS5zZXQoMCwwKS5ub3JtYWxpemUoKTtcblx0XHRcdHJldHVybiBzZWwuZGlydHkoKTtcblx0XHR9KSxcblx0XHRcblx0XHRjb21ibyhbJ3N1cGVyK2Rvd24nXSxmdW5jdGlvbihzZWwpIHtcblx0XHRcdHNlbC5jb2xsYXBzZSgpLmhlYWQoKS5zZXQoMTAwMDAwLDApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0cmV0dXJuIHNlbC5kaXJ0eSgpO1xuXHRcdH0pLFxuXHRcdFxuXHRcdGNvbWJvKFsnc3VwZXIrdSddLGZ1bmN0aW9uKHNlbCxvKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhzZWwudGFyZ2V0KCksXCJmb3VuZCB1dCEhIVwiKTtcblx0XHRcdHJldHVybiBjb25zb2xlLmxvZyhzZWwudGFyZ2V0KCkuYnViYmxlKCd1bndyYXAnLHt9KSk7XG5cdFx0fSksXG5cdFx0XG5cdFx0Y29tYm8oWydhbHQrc3VwZXIrciddLGZ1bmN0aW9uKCkgeyByZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpOyB9KVxuXHRdO1xuXHRcblx0SU0uVHJpZ2dlcnMgPSBbXG5cdFx0XG5cdFx0dHJpZ2dlcignfCcse2NvbnRleHQ6IGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLnJlZ2lvbigpLnBlZWsoLTEsMSkgPT0gJ3x8JzsgfSxcblx0XHRjb21tYW5kOiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5tb3ZlKDEpOyB9fSksXG5cdFx0XG5cdFx0dHJpZ2dlcignWycsZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuaW5zZXJ0KCdbJDBdJyk7IH0pLFxuXHRcdHRyaWdnZXIoJ3wnLGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLmluc2VydCgnfCQwfCcpOyB9KSxcblx0XHR0cmlnZ2VyKCcoJyxmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5pbnNlcnQoJygkMCknKTsgfSksXG5cdFx0dHJpZ2dlcigneycsZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuaW5zZXJ0KCd7JDB9Jyk7IH0pLFxuXHRcdFxuXHRcdHRyaWdnZXIoJzwnLHtjb250ZXh0OiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuICFzZWwucGVla2JlaGluZCgvKFxcYih0YWd8aWZ8Y2xhc3MpIHxcXGRcXHMqJCkvKTsgfSxcblx0XHRjb21tYW5kOiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5pbnNlcnQoJzwkMD4nKTsgfX0pLFxuXHRcdFxuXHRcdHRyaWdnZXIoJ1wiJyx7Y29udGV4dDogZnVuY3Rpb24oc2VsLG8pIHtcblx0XHRcdGlmIChzZWwucmVnaW9uKCkucGVlaygtMSwwKSA9PSAnXFxcXCcgJiYgKG8ubm9kZSA9IHNlbC5yZWdpb24oKS5zY29wZShxJCgnLl9pbXN0cicsc2VsZikpKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH07XG5cdFx0fSxcblx0XHRjb21tYW5kOiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5pbnNlcnQoJ1wiJyk7IH19KSxcblx0XHRcblx0XHR0cmlnZ2VyKFwiJ1wiLHtjb250ZXh0OiBmdW5jdGlvbihzZWwsbykgeyByZXR1cm4gc2VsLnJlZ2lvbigpLnBlZWsoLTEsMSkgPT0gXCInJ1wiOyB9LFxuXHRcdGNvbW1hbmQ6IGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLm1vdmUoMSk7IH19KSxcblx0XHRcblx0XHR0cmlnZ2VyKFwiJ1wiLHtjb250ZXh0OiBmdW5jdGlvbihzZWwsbykgeyByZXR1cm4gby5ub2RlID0gc2VsLnJlZ2lvbigpLnNjb3BlKHEkKCcuX2ltc3RyJyxzZWxmKSk7IH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuaW5zZXJ0KFwiXFxcXCdcIik7IH19KSxcblx0XHRcblx0XHR0cmlnZ2VyKCdcIicsZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwuaW5zZXJ0KCdcIiQwXCInKTsgfSksXG5cdFx0dHJpZ2dlcihcIidcIixmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5pbnNlcnQoXCInJDAnXCIpOyB9KSxcblx0XHRcblx0XHR0cmlnZ2VyKCddJyx7Y29udGV4dDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwucmVnaW9uKCkucGVlaygwLDEpID09ICddJzsgfSxcblx0XHRjb21tYW5kOiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5tb3ZlKDEpOyB9fSksXG5cdFx0XG5cdFx0dHJpZ2dlcignfScse2NvbnRleHQ6IGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLnJlZ2lvbigpLnBlZWsoMCwxKSA9PSAnfSc7IH0sXG5cdFx0Y29tbWFuZDogZnVuY3Rpb24oc2VsKSB7IHJldHVybiBzZWwubW92ZSgxKTsgfX0pLFxuXHRcdFxuXHRcdHRyaWdnZXIoJyknLHtjb250ZXh0OiBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbC5yZWdpb24oKS5wZWVrKDAsMSkgPT0gJyknOyB9LFxuXHRcdGNvbW1hbmQ6IGZ1bmN0aW9uKHNlbCkgeyByZXR1cm4gc2VsLm1vdmUoMSk7IH19KVxuXHRdO1xuXHRcblx0ZnVuY3Rpb24gU2hvcnRjdXRNYW5hZ2VyKHZpZXcsYmluZGluZ3Mpe1xuXHRcdHRoaXMuX3ZpZXcgPSB2aWV3O1xuXHRcdHRoaXMuX2JpbmRpbmdzID0gYmluZGluZ3MgfHwgSU0uS2V5QmluZGluZ3M7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdGdsb2JhbC5TaG9ydGN1dE1hbmFnZXIgPSBTaG9ydGN1dE1hbmFnZXI7IC8vIGdsb2JhbCBjbGFzcyBcblx0U2hvcnRjdXRNYW5hZ2VyLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3ZpZXc7XG5cdH07XG5cdFxuXHRTaG9ydGN1dE1hbmFnZXIucHJvdG90eXBlLmtleXNGb3JFdmVudCA9IGZ1bmN0aW9uIChlKXtcblx0XHR2YXIgY29tYm8gPSBbXTtcblx0XHR2YXIgc3BlY2lhbCA9IHNwZWNpYWxLZXlzW2Uud2hpY2hdO1xuXHRcdHZhciBjaHIgPSBzcGVjaWFsIHx8IFN0cmluZy5mcm9tQ2hhckNvZGUoZS53aGljaCk7XG5cdFx0XG5cdFx0Y2hyID0gY2hyLnRvTG93ZXJDYXNlKCk7IC8vIHVubGVzcyBlOnNoaWZ0S2V5XG5cdFx0XG5cdFx0aWYgKGUuY3RybEtleSAmJiBzcGVjaWFsICE9ICdjdHJsJykgeyBjb21iby5wdXNoKCdjdHJsJykgfTtcblx0XHRpZiAoZS5hbHRLZXkgJiYgc3BlY2lhbCAhPSAnYWx0JykgeyBjb21iby5wdXNoKCdhbHQnKSB9O1xuXHRcdGlmIChlLm1ldGFLZXkgJiYgIWUuY3RybEtleSAmJiBzcGVjaWFsICE9PSAnbWV0YScpIHsgY29tYm8ucHVzaCgnc3VwZXInKSB9O1xuXHRcdGlmIChlLnNoaWZ0S2V5ICYmIHNwZWNpYWwgIT0gJ3NoaWZ0JykgeyBjb21iby5wdXNoKCdzaGlmdCcpIH07XG5cdFx0aWYgKGNvbWJvLmluZGV4T2YoY2hyKSA8IDApIHsgY29tYm8ucHVzaChjaHIpIH07XG5cdFx0XG5cdFx0cmV0dXJuIGNvbWJvLmpvaW4oJysnKTtcblx0fTtcblx0XG5cdFNob3J0Y3V0TWFuYWdlci5wcm90b3R5cGUuY29tbWFuZHNGb3JLZXlzID0gZnVuY3Rpb24gKGNvbWJvKXtcblx0XHRyZXR1cm4gdGhpcy5fYmluZGluZ3MuZmlsdGVyKGZ1bmN0aW9uKGJpbmRpbmcpIHsgcmV0dXJuIGJpbmRpbmcua2V5cyA9PSBjb21ibzsgfSk7XG5cdH07XG5cdFxuXHRTaG9ydGN1dE1hbmFnZXIucHJvdG90eXBlLmdldFNob3J0Y3V0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdHZhciBjb21ibyA9IHRoaXMua2V5c0ZvckV2ZW50KGUuZXZlbnQoKSk7XG5cdFx0Y29uc29sZS5sb2coY29tYm8pO1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLl9iaW5kaW5ncyksIGxlbiA9IGFyeS5sZW5ndGgsIGNtZDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRjbWQgPSBhcnlbaV07XG5cdFx0XHRpZiAoY21kLmtleXMuaW5kZXhPZihjb21ibykgPj0gMCkge1xuXHRcdFx0XHR2YXIgbyA9IHt9O1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnZm91bmQgc2hvcnRjdXQnLGNvbWJvLGNtZDprZXlzXG5cdFx0XHRcdGlmICghY21kLmNvbnRleHQgfHwgY21kLmNvbnRleHQuY2FsbCh0aGlzLnZpZXcoKSx0aGlzLnZpZXcoKS5jYXJldCgpLG8sZSx0aGlzLnZpZXcoKSkpIHtcblx0XHRcdFx0XHRjbWQuZGF0YSA9IG87XG5cdFx0XHRcdFx0cmV0dXJuIGNtZDtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblx0XG5cdFNob3J0Y3V0TWFuYWdlci5wcm90b3R5cGUuZ2V0VHJpZ2dlciA9IGZ1bmN0aW9uICh2aWV3LHRleHQpe1xuXHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChJTS5UcmlnZ2VycyksIGxlbiA9IGFyeS5sZW5ndGgsIGNtZDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRjbWQgPSBhcnlbaV07XG5cdFx0XHRpZiAoY21kLnRyaWdnZXIgPT0gdGV4dCkge1xuXHRcdFx0XHR2YXIgcmVzID0gY21kLmNvbnRleHQgPyAoY21kLmNvbnRleHQuY2FsbCh2aWV3LHZpZXcuY2FyZXQoKSx2aWV3LHRleHQpKSA6ICh0cnVlKTtcblx0XHRcdFx0aWYgKHJlcykgeyByZXR1cm4gY21kIH07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cdHJldHVybiBTaG9ydGN1dE1hbmFnZXI7XG5cdFxuXHRcblx0XG5cdFxuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvY29yZS9zaG9ydGN1dHMuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdpbWNhcHRvcicsICdpbnB1dCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGlmICghdGhpcy5kb20oKS52YWx1ZSkge1xuXHRcdFx0XHR0aGlzLmRvbSgpLnZhbHVlID0gJ3gnO1xuXHRcdFx0fTtcblx0XHRcdHRoaXMuZG9tKCkuc2VsZWN0KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHRhZy5fX3N1cGVyX18uYnVpbGQuYXBwbHkoc2VsZixhcmd1bWVudHMpO1xuXHRcdFx0c2VsZi5kb20oKS5vbmZvY3VzID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnZG9tIG9uZm9jdXMhISEhJyk7XG5cdFx0XHRcdHZhciBldmVudCA9IEltYmEuRXZlbnQud3JhcCh7dHlwZTogJ2lucHV0Zm9jdXMnLHRhcmdldDogc2VsZi5kb20oKX0pO1xuXHRcdFx0XHRyZXR1cm4gZXZlbnQucHJvY2VzcygpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0c2VsZi5kb20oKS5vbmJsdXIgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdkb20gb25ibHVyISEhIScsZSk7XG5cdFx0XHRcdHZhciBldmVudCA9IEltYmEuRXZlbnQud3JhcCh7dHlwZTogJ2lucHV0Ymx1cicsdGFyZ2V0OiBzZWxmLmRvbSgpLHJlbGF0ZWRUYXJnZXQ6IGUucmVsYXRlZFRhcmdldH0pO1xuXHRcdFx0XHRyZXR1cm4gZXZlbnQucHJvY2VzcygpO1xuXHRcdFx0XHQvLyBJbWJhLkV2ZW50cy50cmlnZ2VyKCdpbnB1dGJsdXInLGRvbSlcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvdmlld3MvY2FwdG9yLmltYmFcbiAqKiBtb2R1bGUgaWQgPSAzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdC8vIGRpc2FibGluZyBsb2dzIGZvciBub3dcblx0Ly8gY29uc29sZTpsb2cgPSBkbyB0cnVlXG5cdC8vIGV4dGVybnM7XG5cdFxuXHR2YXIgT1BFTiA9IFsnXCInLFwiJ1wiLCcoJywnWycsJ3snLCc8J107XG5cdHZhciBDTE9TRSA9IFsnXCInLFwiJ1wiLCcpJywnXScsJ30nLCc+J107XG5cdFxuXHRpZiAoSW1iYS5FdmVudHMpIHtcblx0XHRJbWJhLkV2ZW50cy5yZWdpc3RlcihbJ2NvcHknLCdwYXN0ZScsJ2N1dCcsJ2JlZm9yZWN1dCcsJ2JlZm9yZXBhc3RlJywnYmVmb3JlY29weScsJ2tleXByZXNzJ10pO1xuXHR9O1xuXHRcblx0dmFyIExvZ2dlciA9IHJlcXVpcmUoJy4vY29yZS9sb2dnZXInKS5Mb2dnZXI7XG5cdHZhciBIaXN0b3J5ID0gcmVxdWlyZSgnLi9jb3JlL2hpc3RvcnknKS5IaXN0b3J5O1xuXHR2YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9jb3JlL2J1ZmZlcicpLkJ1ZmZlcjtcblx0dmFyIE9ic2VydmVyID0gcmVxdWlyZSgnLi9jb3JlL29ic2VydmVyJykuT2JzZXJ2ZXI7XG5cdFxuXHR2YXIgUmVnaW9uID0gcmVxdWlyZSgnLi9yZWdpb24nKS5SZWdpb247XG5cdHZhciBoaW50cyQgPSByZXF1aXJlKCcuL2NvcmUvaGludHMnKSwgSGludHMgPSBoaW50cyQuSGludHMsIEhpbnQgPSBoaW50cyQuSGludDtcblx0dmFyIEhpZ2hsaWdodGVyID0gcmVxdWlyZSgnLi9jb3JlL2hpZ2hsaWdodGVyJykuSGlnaGxpZ2h0ZXI7XG5cdFxuXHR2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG5cdFxuXHRyZXF1aXJlKCcuL2NvcmUvY2FyZXQnKTtcblx0XG5cdHJlcXVpcmUoJy4vdmlld3Mvb3ZlcmxheXMnKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWRpbXMnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2ggPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIHVuY2FjaGVcblx0XHRcdGlmICh0aGlzLl9vdyAhPSB0aGlzLmRvbSgpLm9mZnNldFdpZHRoKSB7XG5cdFx0XHRcdHRoaXMuX293ID0gdGhpcy5kb20oKS5vZmZzZXRXaWR0aDtcblx0XHRcdFx0dGhpcy5fY2ggPSBudWxsO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuX2NoIHx8ICh0aGlzLl9jaCA9IHRoaXMuZG9tKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltdmlld2JvZHknKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXZpZXcnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZmlsZW5hbWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRGaWxlbmFtZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9maWxlbmFtZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub2JzZXJ2ZXIgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX29ic2VydmVyOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRPYnNlcnZlciA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9vYnNlcnZlciA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaGlzdG9yeSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5faGlzdG9yeTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SGlzdG9yeSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9oaXN0b3J5ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5oaW50cyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5faGludHM7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEhpbnRzID0gZnVuY3Rpb24odil7IHRoaXMuX2hpbnRzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2dnZXIgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2xvZ2dlcjsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TG9nZ2VyID0gZnVuY3Rpb24odil7IHRoaXMuX2xvZ2dlciA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2hvcnRjdXRzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9zaG9ydGN1dHM7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFNob3J0Y3V0cyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9zaG9ydGN1dHMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLl9fZm9jdXNOb2RlID0ge3dhdGNoOiAnZm9jdXNOb2RlRGlkU2V0JyxuYW1lOiAnZm9jdXNOb2RlJ307XG5cdFx0dGFnLnByb3RvdHlwZS5mb2N1c05vZGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2ZvY3VzTm9kZTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Rm9jdXNOb2RlID0gZnVuY3Rpb24odil7XG5cdFx0XHR2YXIgYSA9IHRoaXMuZm9jdXNOb2RlKCk7XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5fZm9jdXNOb2RlID0gdjsgfVxuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuZm9jdXNOb2RlRGlkU2V0ICYmIHRoaXMuZm9jdXNOb2RlRGlkU2V0KHYsYSx0aGlzLl9fZm9jdXNOb2RlKSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2FyZXQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2NhcmV0OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDYXJldCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9jYXJldCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZnJhbWVzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9mcmFtZXM7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEZyYW1lcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9mcmFtZXMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlYWRvbmx5ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yZWFkb25seTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UmVhZG9ubHkgPSBmdW5jdGlvbih2KXsgdGhpcy5fcmVhZG9ubHkgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmhpZ2hsaWdodGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gSGlnaGxpZ2h0ZXI7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxpbmVIZWlnaHQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9kaW1zLmRvbSgpLm9mZnNldEhlaWdodDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2hhcldpZHRoID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZGltcy5jaCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc1JlYWRPbmx5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5oaXN0b3J5KCkubW9kZSgpID09ICdwbGF5Jztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudGFiU2l6ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIDQ7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnYnVpbGQgaW12aWV3J1xuXHRcdFx0VklFVyA9IHRoaXM7XG5cdFx0XHR0aGlzLnNldFRhYmluZGV4KDApO1xuXHRcdFx0XG5cdFx0XHR0aGlzLl9yZWFkb25seSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcih0aGlzKTtcblx0XHRcdHRoaXMuX2ZyYW1lcyA9IDA7XG5cdFx0XHR0aGlzLl9jaGFuZ2VzID0gMDtcblx0XHRcdFxuXHRcdFx0dGhpcy5faGludHMgPSBuZXcgSGludHModGhpcyk7XG5cdFx0XHR0aGlzLl9idWZmZXIgPSBuZXcgQnVmZmVyKHRoaXMpO1xuXHRcdFx0dGhpcy5faGlzdG9yeSA9IG5ldyBIaXN0b3J5KHRoaXMpO1xuXHRcdFx0dGhpcy5fc2hvcnRjdXRzID0gbmV3IFNob3J0Y3V0TWFuYWdlcih0aGlzKTtcblx0XHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0XHR0aGlzLl9vYnNlcnZlciA9IG5ldyBPYnNlcnZlcih0aGlzKTtcblx0XHRcdHRoaXMuY2FyZXQoKS5zZXRSZWdpb24obmV3IFJlZ2lvbigwLDAsdGhpcy5yb290KCksdGhpcykpO1xuXHRcdFx0XG5cdFx0XHQvLyBiaW5kIHRvIG1vdXNlbW92ZSBvZiBkb20/XG5cdFx0XHRcblx0XHRcdHRoaXMuZG9tKCkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJyxmdW5jdGlvbihlKSB7IHJldHVybiBJbWJhLkV2ZW50cy5kZWxlZ2F0ZShlKTsgfSk7XG5cdFx0XHR0aGlzLmRvbSgpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JyxmdW5jdGlvbihlKSB7IHJldHVybiBJbWJhLkV2ZW50cy5kZWxlZ2F0ZShlKTsgfSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25tb3VzZW92ZXIgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRyZXR1cm4gZS5oYWx0KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ubW91c2VvdXQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRyZXR1cm4gZS5oYWx0KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldElucHV0ID0gZnVuY3Rpb24gKGlucHV0KXtcblx0XHRcdFxuXHRcdFx0aWYgKGlucHV0ICE9IHRoaXMuX2lucHV0KSB7XG5cdFx0XHRcdHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nICdzZXQgaW5wdXQhISEnLEBpbnB1dFxuXHRcdFx0XHR0aGlzLl9pbnB1dC5kb20oKS5fcmVzcG9uZGVyID0gdGhpcy5kb20oKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5wdXQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9pbnB1dCB8fCB0aGlzLl9jYXJldC5pbnB1dCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gY2FsbGVkIGV2ZXJ5IGZyYW1lIC0gbG9va2luZyBmb3IgY2hhbmdlZCBub2RlcyB0byBkZWFsIHdpdGhcblx0XHQvLyB0byBkZWFsIHdpdGggbXV0YXRpb25zLlxuXHRcdHRhZy5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5fZnJhbWVzKys7XG5cdFx0XHR0aGlzLmhpc3RvcnkoKS50aWNrKCk7XG5cdFx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB0aGlzLnJlcGFpcigpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbW1pdCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMudGljaygpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBsb2dnZXJfO1xuXHRcdFx0KGxvZ2dlcl8gPSB0aGlzLmxvZ2dlcigpKS5sb2cuYXBwbHkobG9nZ2VyXyxhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmVkaXRlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0c2VsZi5fY2hhbmdlcysrO1xuXHRcdFx0c2VsZi5fZGlydHkgPSB0cnVlO1xuXHRcdFx0c2VsZi5fYnVmZmVyLnJlZnJlc2goKTtcblx0XHRcdFxuXHRcdFx0c2VsZi52aWV3KCkuaGludHMoKS5yZW0oZnVuY3Rpb24oaGludCkge1xuXHRcdFx0XHRyZXR1cm4gaGludC5ncm91cCgpID09ICdydW50aW1lJztcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRzZWxmLmhpbnRzKCkuY2xlYW51cCgpO1xuXHRcdFx0XG5cdFx0XHRzZWxmLmRlbGF5KCdkaWRjaGFuZ2UnLDUwLGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gSW1iYS5FdmVudHMudHJpZ2dlcignZWRpdGVkOmFzeW5jJyxzZWxmLHtkYXRhOiBzZWxmfSk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Ly8gd2UgY2FuIGltcHJvdmUgaG93L3doZW4gd2UgY2hvb3NlIHRvIGFubm90YXRlLlxuXHRcdFx0Ly8gY3VycmVudGx5IHdlIGRvIGl0IGFmdGVyIGV2ZXJ5IGVkaXQgLSBidXQgaXQgc2hvdWxkXG5cdFx0XHQvLyByZWFsbHkgb25seSBiZSBuZWVkZWQgd2hlbiB3ZSBoYXZlIGNoYW5nZWQgaWRlbnRpZmllcnMuXG5cdFx0XHQvLyBzaG91bGQgYWxzbyBvbmx5IHJlYW5ub3RhdGUgdGhlIGNsb3Nlc3Qga25vd24gc2NvcGUsXG5cdFx0XHQvLyBidXQgdGhpcyBjb21lcyBsYXRlciB3aXRoIHJlZmFjdG9yaW5nIGZyb20gd2hvbGUgZmlsZXNcblx0XHRcdC8vIHRvIHNjb3Blcy5cblx0XHRcdHNlbGYuZGVsYXkoJ2Fubm90YXRlJyw1MDAsZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLmFubm90YXRlKCk7IH0pO1xuXHRcdFx0c2VsZi5kZWxheSgncmVjb21waWxlJywtMSk7IC8vIGNhbmNlbCByZWNvbXBpbGF0aW9uXG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGlydHkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5mbGFnKCdhY3RpdmUnKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLnVuZmxhZygnYWN0aXZlJyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYm9keSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwO1xuXHRcdFx0cmV0dXJuICh0MCA9IHRoaXMuX2JvZHk9dGhpcy5fYm9keSB8fCB0YWckLiRpbXZpZXdib2R5KCkuc2V0UmVmKCdib2R5Jyx0aGlzKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdCh0aGlzLl9kaW1zID0gdGhpcy5fZGltcyB8fCB0YWckLiRpbWRpbXMoKS5zZXRSZWYoJ2RpbXMnLHRoaXMpKS5zZXRUZXh0KFwieFwiKS5lbmQoKSxcblx0XHRcdFx0KHRoaXMuX2NhcmV0ID0gdGhpcy5fY2FyZXQgfHwgdGFnJC4kaW1jYXJldCgpLnNldFJlZignY2FyZXQnLHRoaXMpKS5zZXRWaWV3KHRoaXMpLmVuZCgpLFxuXHRcdFx0XHQodGhpcy5fcm9vdCA9IHRoaXMuX3Jvb3QgfHwgdGFnJC4kaW1yb290KCkuc2V0UmVmKCdyb290Jyx0aGlzKS5mbGFnKCdpbWJhJykpLnNldFZpZXcodGhpcykuZW5kKClcblx0XHRcdF0sMikuZW5kKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmhlYWRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmZvb3RlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm92ZXJsYXlzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gKHRoaXMuX292ZXJsYXlzID0gdGhpcy5fb3ZlcmxheXMgfHwgdGFnJC4kc2NyaW1ibGFfb3ZlcmxheXMoKS5zZXRSZWYoJ292ZXJsYXlzJyx0aGlzKSkuc2V0Vmlldyh0aGlzKS5lbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGFnKCdyZWFkb25seScsdGhpcy5pc1JlYWRPbmx5KCkpLnNldENoaWxkcmVuKFtcblx0XHRcdFx0dGhpcy5oZWFkZXIoKSxcblx0XHRcdFx0dGhpcy5ib2R5KCksXG5cdFx0XHRcdHRoaXMuZm9vdGVyKClcblx0XHRcdF0sMSkuc3luY2VkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZWwgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmNhcmV0KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvb3QgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9yb290O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5idWZmZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9idWZmZXI7XG5cdFx0XHQvLyByb290LmNvZGVcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMucm9vdCgpLnNpemUoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb2RlLG8pe1xuXHRcdFx0dmFyIHBhcnNlZDtcblx0XHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdFx0dGhpcy5zZXRGaWxlbmFtZShvLmZpbGVuYW1lKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdsb2FkaW5nIGZpbGUgd2l0aCBmaWxlbmFtZScsbzpmaWxlbmFtZVxuXHRcdFx0Ly8gb2JzZXJ2ZXIucGF1c2UgZG9cblx0XHRcdGlmIChvLmh0bWwpIHtcblx0XHRcdFx0dGhpcy5yb290KCkuZG9tKCkuaW5uZXJIVE1MID0gby5odG1sO1xuXHRcdFx0XHR0aGlzLl9idWZmZXIucmVmcmVzaCgpO1xuXHRcdFx0XHR0aGlzLmhpc3RvcnkoKS5vbmxvYWQodGhpcy5jb2RlKCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gc2hvdWxkIHVzZSBvdXIgbmV3IHBhcnNlclxuXHRcdFx0XHRpZiAocGFyc2VkID0gdGhpcy5wYXJzZShjb2RlKSkge1xuXHRcdFx0XHRcdGlmIChwYXJzZWQuaGlnaGxpZ2h0ZWQpIHtcblx0XHRcdFx0XHRcdHRoaXMucm9vdCgpLmRvbSgpLmlubmVySFRNTCA9IHBhcnNlZC5oaWdobGlnaHRlZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5yb290KCkuZG9tKCkudGV4dENvbnRlbnQgPSBjb2RlO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRoaXMuX2J1ZmZlci5yZWZyZXNoKCk7XG5cdFx0XHRcdHRoaXMuaGlzdG9yeSgpLm9ubG9hZChjb2RlKTtcblx0XHRcdFx0dGhpcy5hbm5vdGF0ZSgpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChjb2RlKXtcblx0XHRcdC8vIGhlcmUgd2UgY2FuIHBhcnNlIHRoZSBmdWxsIGNvZGVcblx0XHRcdHJldHVybiB7aGlnaGxpZ2h0ZWQ6IElNLnBhcnNlKGNvZGUpfTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVmb2N1cyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0aWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT0gdGhpcy5pbnB1dCgpLmRvbSgpKSB7IHRoaXMuaW5wdXQoKS5mb2N1cygpIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25pbnB1dGZvY3VzID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0Y29uc29sZS5sb2coJ29uaW5wdXRmb2N1cyEhJyk7XG5cdFx0XHRWSUVXID0gdGhpczsgLy8gaGFja1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZygnZm9jdXMnKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25pbnB1dGJsdXIgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRyZXR1cm4gdGhpcy51bmZsYWcoJ2ZvY3VzJyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uZm9jdXNpbiA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdFZJRVcgPSB0aGlzOyAvLyBoYWNrXG5cdFx0XHR0aGlzLmZsYWcoJ2ZvY3VzJyk7XG5cdFx0XHRjb25zb2xlLmxvZygnZm9jdXMnLGUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uZm9jdXNvdXQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLnVuZmxhZygnZm9jdXMnKTtcblx0XHRcdGNvbnNvbGUubG9nKCd1bmZvY3VzJyxlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmlucHV0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9udGV4dGlucHV0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmV4ZWNBY3Rpb24gPSBmdW5jdGlvbiAoYWN0aW9uLGtleWRvd24pe1xuXHRcdFx0dmFyIGNvbW1hbmRfO1xuXHRcdFx0aWYgKGFjdGlvbi5jb21tYW5kIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdFx0cmV0dXJuIGFjdGlvbi5jb21tYW5kLmNhbGwodGhpcyx0aGlzLmNhcmV0KCksYWN0aW9uLmRhdGEgfHwge2V2ZW50OiBrZXlkb3dufSx0aGlzKTtcblx0XHRcdH0gZWxzZSBpZiAoKHR5cGVvZiAoY29tbWFuZF8gPSBhY3Rpb24uY29tbWFuZCk9PSdzdHJpbmcnfHxjb21tYW5kXyBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdFx0dGhpcy5sb2coJ2NvbW1hbmQgaXMgc3RyaW5nJyxhY3Rpb24uY29tbWFuZCk7XG5cdFx0XHRcdHZhciBldiA9IEltYmEuRXZlbnRzLnRyaWdnZXIoYWN0aW9uLmNvbW1hbmQsdGhpcyx7ZGF0YTogYWN0aW9ufSk7XG5cdFx0XHRcdHRoaXMubG9nKGV2KTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50cnlDb21tYW5kID0gZnVuY3Rpb24gKGNtZCx0YXJnZXQscGFyYW1zKXtcblx0XHRcdGlmKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSBwYXJhbXMgPSBbXTtcblx0XHRcdGlmIChjbWQuY29udGV4dCkge1xuXHRcdFx0XHR2YXIgZ3VhcmQgPSBjbWQuY29udGV4dC5hcHBseSh0YXJnZXQgfHwgdGhpcyxwYXJhbXMpO1xuXHRcdFx0XHRpZiAoIWd1YXJkKSB7IHJldHVybiBmYWxzZSB9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGNtZC5jb21tYW5kIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdFx0cmV0dXJuIGNtZC5jb21tYW5kLmFwcGx5KHRhcmdldCB8fCB0aGlzLHBhcmFtcyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmtleWRvd24gPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR2YXIgYXJyO1xuXHRcdFx0VklFVyA9IHRoaXM7IC8vIGhhY2tcblx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0Ly8gdmFyIGNvbWJvID0gZS5rZXljb21ib1xuXHRcdFx0dmFyIGNvbWJvID0gdGhpcy5zaG9ydGN1dHMoKS5rZXlzRm9yRXZlbnQoZS5ldmVudCgpKTtcblx0XHRcdHZhciBhY3Rpb24gPSB0aGlzLnNob3J0Y3V0cygpLmdldFNob3J0Y3V0KGUpO1xuXHRcdFx0dmFyIGlucyA9IG51bGw7XG5cdFx0XHRcblx0XHRcdHZhciBzaGlmdCA9ICgvXFxic2hpZnRcXGIvKS50ZXN0KGNvbWJvKTtcblx0XHRcdHZhciBhbHQgPSAoL1xcYmFsdFxcYi8pLnRlc3QoY29tYm8pO1xuXHRcdFx0dmFyIHN1cCA9ICgvXFxic3VwZXJcXGIvKS50ZXN0KGNvbWJvKTtcblx0XHRcdFxuXHRcdFx0Ly8gbG9nICdpbXZpZXcga2V5ZG93bicsY29tYm9cblx0XHRcdFxuXHRcdFx0aWYgKGFjdGlvbikge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnYWN0aW9uIGhlcmU/IScsYWN0aW9uXG5cdFx0XHRcdGlmICh0aGlzLmV4ZWNBY3Rpb24oYWN0aW9uLGUpKSB7IGUuY2FuY2VsKCkgfTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gbW92ZSB0aGVzZSBpbnRvIGNvbW1hbmRzIGFzIHdlbGxcblx0XHRcdC8vIHRoaXNzaG91bGQgbW92ZSB0aGlzIGludG8gY29tbWFuZHMgaW5zdGVhZFxuXHRcdFx0aWYgKGFyciA9IGNvbWJvLm1hdGNoKC9cXGIobGVmdHxyaWdodHx1cHxkb3duKS8pKSB7XG5cdFx0XHRcdHRoaXMuaGludHMoKS5hY3RpdmF0ZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGlzQ29sbGFwc2VkID0gdGhpcy5jYXJldCgpLmlzQ29sbGFwc2VkKCk7XG5cdFx0XHRcdHZhciBlbmRzID0gdGhpcy5jYXJldCgpLmVuZHMoKTtcblx0XHRcdFx0XG5cdFx0XHRcdHNoaWZ0ID8gKHRoaXMuY2FyZXQoKS5kZWNvbGxhcHNlKCkpIDogKHRoaXMuY2FyZXQoKS5jb2xsYXBzZSgpKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChhcnJbMF0gPT0gJ2Rvd24nKSB7XG5cdFx0XHRcdFx0dGhpcy5jYXJldCgpLm1vdmVEb3duKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGUuY2FuY2VsKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYXJyWzBdID09ICd1cCcpIHtcblx0XHRcdFx0XHR0aGlzLmNhcmV0KCkubW92ZVVwKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGUuY2FuY2VsKCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgbW9kZSA9IElNLkNIQVJBQ1RFUlM7XG5cdFx0XHRcdHZhciBkaXIgPSAwO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGFyclswXSA9PSAnbGVmdCcpIHtcblx0XHRcdFx0XHRkaXIgPSAtMTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChhcnJbMF0gPT0gJ3JpZ2h0Jykge1xuXHRcdFx0XHRcdGRpciA9IDE7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoYWx0KSB7XG5cdFx0XHRcdFx0bW9kZSA9IGRpciA+IDAgPyAoSU0uV09SRF9FTkQpIDogKElNLldPUkRfU1RBUlQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHN1cCkge1xuXHRcdFx0XHRcdG1vZGUgPSBkaXIgPiAwID8gKElNLkxJTkVfRU5EKSA6IChJTS5MSU5FX1NUQVJUKTtcblx0XHRcdFx0fSBlbHNlIGlmICghc2hpZnQgJiYgIWlzQ29sbGFwc2VkKSB7XG5cdFx0XHRcdFx0dGhpcy5jYXJldCgpLmhlYWQoKS5zZXQoZGlyID4gMCA/IChlbmRzWzFdKSA6IChlbmRzWzBdKSk7XG5cdFx0XHRcdFx0dGhpcy5jYXJldCgpLmRpcnR5KCk7IC8vIHNob3VsZCBub3QgbmVlZCB0byBjYWxsIHRoaXMgYWxsIHRoZSB0aW1lXG5cdFx0XHRcdFx0cmV0dXJuIGUuY2FuY2VsKCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLmNhcmV0KCkubW92ZShkaXIsbW9kZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gZS5jYW5jZWwoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChlLmV2ZW50KCkud2hpY2ggPT0gMjI5KSB7XG5cdFx0XHRcdHJldHVybiBlLmhhbHQoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChjb21iby5tYXRjaCgvXnN1cGVyXFwrKGN8dnx4KSQvKSkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnbWF0Y2hpbmcgY29tYm8gZm9yIGNvcHkgcGFzdGUnXG5cdFx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0XHR0aGlzLl9hd2FpdENvbWJvID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5yZWZvY3VzKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChpbnMgIT0gbnVsbCkge1xuXHRcdFx0XHRlLmhhbHQoKS5jYW5jZWwoKTtcblx0XHRcdFx0dGhpcy5jYXJldCgpLmluc2VydChpbnMpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmtleXByZXNzID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0aWYgKHRoaXMuX2F3YWl0Q29tYm8pIHtcblx0XHRcdFx0dGhpcy5fYXdhaXRDb21ibyA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gZS5oYWx0KCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRlLmhhbHQoKTtcblx0XHRcdHZhciB0ZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShlLmV2ZW50KCkuY2hhckNvZGUpO1xuXHRcdFx0ZS5fdGV4dCA9IHRleHQ7XG5cdFx0XHRlLmNhbmNlbCgpO1xuXHRcdFx0dGhpcy5vbnR5cGUoZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub250ZXh0aW5wdXQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRlLmhhbHQoKS5jYW5jZWwoKTtcblx0XHRcdGUuX3RleHQgPSBlLmV2ZW50KCkuZGF0YTtcblx0XHRcdHRoaXMub250eXBlKGUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ua2V5dXAgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRlLmhhbHQoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmlucHV0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0ZS5oYWx0KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub250eXBlID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIGlucyA9IGUuX3RleHQ7XG5cdFx0XHRcdC8vIGxvZyAnb250eXBlJyxlLGluc1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIHNwYW5zID0gdGhpcy52aWV3KCkubm9kZXNJblJlZ2lvbih0aGlzLmNhcmV0KCkucmVnaW9uKCksZmFsc2UsdHJ1ZSk7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBzcGFuc1swXTtcblx0XHRcdFx0dmFyIGNtZDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChzcGFucy5sZW5ndGggPT0gMSkge1xuXHRcdFx0XHRcdC8vIGxvZyAnc2luZ2xlIG5vZGUgZm9yIG5vZGVzSW5SZWdpb24nLHRhcmdldDpub2RlXG5cdFx0XHRcdFx0aWYgKGNtZCA9IHRhcmdldC5ub2RlWyhcInRyaWdnZXItXCIgKyBpbnMpXSkge1xuXHRcdFx0XHRcdFx0Ly8gbG9nIFwiZm91bmQgY29tYm8gZm9yIHRoaXMhPz8hXCIsY21kXG5cdFx0XHRcdFx0XHRpZiAodGhpcy50cnlDb21tYW5kKGNtZCx0aGlzLmNhcmV0KCksW3RhcmdldC5ub2RlLHRhcmdldF0pKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Y21kID0gdGhpcy5zaG9ydGN1dHMoKS5nZXRUcmlnZ2VyKHRoaXMsaW5zKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjbWQgJiYgKGNtZC5jb21tYW5kIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG5cdFx0XHRcdFx0Ly8gbG9nICdmb3VuZCBjb21tYW5kISEnLGNtZFxuXHRcdFx0XHRcdC8vIHNob3VsZCByYXRoZXIgcnVuIHRyeUNvbW1hbmQ/IT9cblx0XHRcdFx0XHRyZXR1cm4gY21kLmNvbW1hbmQodGhpcy5jYXJldCgpLHRoaXMsaW5zLGUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChpbnMpIHsgcmV0dXJuIHRoaXMuY2FyZXQoKS5pbnNlcnQoaW5zKSB9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5sb2coJ2Vycm9yIGZyb20gb250eXBlJyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmJhY2tzcGFjZSA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGUuY2FuY2VsKCkuaGFsdCgpO1xuXHRcdFx0dGhpcy5jYXJldCgpLmVyYXNlKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uYmVmb3JlY29weSA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGlmIChERUJVRykgeyBjb25zb2xlLmxvZygnb25iZWZvcmVjb3B5JyxlKSB9O1xuXHRcdFx0dGhpcy5pbnB1dCgpLnNlbGVjdCgpO1xuXHRcdFx0dmFyIGRhdGEgPSBlLmV2ZW50KCkuY2xpcGJvYXJkRGF0YTtcblx0XHRcdGRhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsdGhpcy5jYXJldCgpLnRleHQoKSk7XG5cdFx0XHRyZXR1cm4gZS5oYWx0KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uY29weSA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGlmIChERUJVRykgeyBjb25zb2xlLmxvZygnb25jb3B5JyxlLHRoaXMuY2FyZXQoKS50ZXh0KCkpIH07XG5cdFx0XHR2YXIgZGF0YSA9IGUuZXZlbnQoKS5jbGlwYm9hcmREYXRhO1xuXHRcdFx0ZGF0YS5zZXREYXRhKCd0ZXh0L3BsYWluJyx0aGlzLmNhcmV0KCkudGV4dCgpKTtcblx0XHRcdGUuaGFsdCgpLmNhbmNlbCgpO1xuXHRcdFx0dGhpcy5yZWZvY3VzKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uY3V0ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0aWYgKERFQlVHKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdvbmN1dCcsZSk7XG5cdFx0XHR9O1xuXHRcdFx0dmFyIGRhdGEgPSBlLmV2ZW50KCkuY2xpcGJvYXJkRGF0YTtcblx0XHRcdGRhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsdGhpcy5jYXJldCgpLnRleHQoKSk7XG5cdFx0XHRlLmhhbHQoKS5jYW5jZWwoKTtcblx0XHRcdHJldHVybiB0aGlzLmNhcmV0KCkuZXJhc2UoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25iZWZvcmVwYXN0ZSA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHJldHVybiBjb25zb2xlLmxvZygnb25iZWZvcmVwYXN0ZScsZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ucGFzdGUgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRjb25zb2xlLmxvZygnb25wYXN0ZScsZSk7XG5cdFx0XHR2YXIgZGF0YSA9IGUuZXZlbnQoKS5jbGlwYm9hcmREYXRhO1xuXHRcdFx0dmFyIHRleHQgPSBkYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcblx0XHRcdGUuaGFsdCgpLmNhbmNlbCgpO1xuXHRcdFx0dGhpcy5jYXJldCgpLmluc2VydCh0ZXh0KTtcblx0XHRcdHRoaXMucmVmb2N1cygpO1xuXHRcdFx0cmV0dXJuIHRoaXMucmVwYWlyKCk7XG5cdFx0XHQvLyBlZGl0IHRleHQ6IGRhdGFcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gZm9jdXNOb2RlID0gc2VsLm5vZGUgIyBvbmx5IGlmIGl0IGlzIGluc2lkZSB0aGUgc2NvcGU/XG5cdFx0XHQvLyBjYXJldC5yZWdpb24gPSBzZWwucmVnaW9uXG5cdFx0XHR0aGlzLmNhcmV0KCkucmVuZGVyKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uIChvKXtcblx0XHRcdHZhciBmbiA9IG8uY29tbWFuZDtcblx0XHRcdHZhciBhcmdzID0gby5hcmdzIHx8IFtdO1xuXHRcdFx0dmFyIGV2ID0gbmV3IEltYmEuRXZlbnQoe3R5cGU6ICdjb21tYW5kJyx0YXJnZXQ6IHRoaXMuZG9tKCksZGF0YTogb30pO1xuXHRcdFx0ZXYuc2V0RGF0YShvKTtcblx0XHRcdGV2LnByb2Nlc3MoKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAodG91Y2gpe1xuXHRcdFx0dmFyIGFyeTtcblx0XHRcdHRoaXMuX3JlY3QgPSB0aGlzLl9ib2R5LmRvbSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0XG5cdFx0XHRpZiAodG91Y2guYnV0dG9uKCkgIT0gMCkgeyByZXR1cm4gfTtcblx0XHRcdFxuXHRcdFx0aWYgKHRvdWNoLl90b3VjaCkge1xuXHRcdFx0XHQvLyBpcyBpdCBub3QgcmVkaXJlY3RlZD9cblx0XHRcdFx0cmV0dXJuIHRvdWNoLnJlZGlyZWN0KHt9KTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBlID0gdG91Y2guZXZlbnQoKTtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdC8vIHNlZSBpZiBzaGlmdCBpcyBkb3duPyBzaG91bGQgY2hhbmdlIGJlaGF2aW91clxuXHRcdFx0dmFyIHNoaWZ0ID0gZS5zaGlmdEtleTtcblx0XHRcdC8vIGxvZyAnb250b3VjaHN0YXJ0Jyx0b3VjaCx0b3VjaC54LHRvdWNoLnksZSx0b3VjaC5idXR0b25cblx0XHRcdHZhciBhcnkgPSBpdGVyJCh0aGlzLnJjRm9yVG91Y2godG91Y2gpKTt2YXIgciA9IGFyeVswXSxjID0gYXJ5WzFdO1xuXHRcdFx0XG5cdFx0XHRpZiAoc2hpZnQpIHtcblx0XHRcdFx0dGhpcy5jYXJldCgpLnNlbGVjdGFibGUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuY2FyZXQoKS5jb2xsYXBzZSgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGhpcy5jYXJldCgpLmhlYWQoKS5zZXQocixjKS5ub3JtYWxpemUoKTtcblx0XHRcdHRoaXMuY2FyZXQoKS5kaXJ0eSgpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ3RvdWNoIHN0YXJ0IHJlZm9jdXM/J1xuXHRcdFx0dGhpcy5yZWZvY3VzKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUueHlUb1Jvd0NvbCA9IGZ1bmN0aW9uICh4LHkpe1xuXHRcdFx0dmFyIGNvbCA9IE1hdGgubWF4KE1hdGgucm91bmQoeCAvIHRoaXMuY2hhcldpZHRoKCkpLDApO1xuXHRcdFx0dmFyIHJvdyA9IE1hdGgubWF4KE1hdGguY2VpbCh5IC8gdGhpcy5saW5lSGVpZ2h0KCkpLDEpO1xuXHRcdFx0cmV0dXJuIFtyb3cgLSAxLGNvbF07XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJjRm9yVG91Y2ggPSBmdW5jdGlvbiAodG91Y2gpe1xuXHRcdFx0dmFyIHggPSBNYXRoLm1heCh0b3VjaC54KCkgLSB0aGlzLl9yZWN0LmxlZnQsMCk7XG5cdFx0XHR2YXIgeSA9IE1hdGgubWF4KHRvdWNoLnkoKSAtIHRoaXMuX3JlY3QudG9wLDApO1xuXHRcdFx0cmV0dXJuIHRoaXMueHlUb1Jvd0NvbCh4LHkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnRvdWNodXBkYXRlID0gZnVuY3Rpb24gKHRvdWNoKXtcblx0XHRcdHZhciBhcnk7XG5cdFx0XHRpZiAodG91Y2guYnV0dG9uKCkgIT0gMCkgeyByZXR1cm4gfTtcblx0XHRcdHZhciBhcnkgPSBpdGVyJCh0aGlzLnJjRm9yVG91Y2godG91Y2gpKTt2YXIgciA9IGFyeVswXSxjID0gYXJ5WzFdO1xuXHRcdFx0dGhpcy5jYXJldCgpLnNlbGVjdGFibGUoKTtcblx0XHRcdHRoaXMuY2FyZXQoKS5oZWFkKCkuc2V0KHIsYykubm9ybWFsaXplKCk7XG5cdFx0XHR0aGlzLmNhcmV0KCkuZGlydHkoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnRvdWNoZW5kID0gZnVuY3Rpb24gKHRvdWNoKXtcblx0XHRcdHZhciBhcnk7XG5cdFx0XHRpZiAodG91Y2guYnV0dG9uKCkgIT0gMCkgeyByZXR1cm4gfTtcblx0XHRcdHZhciBhcnkgPSBpdGVyJCh0aGlzLnJjRm9yVG91Y2godG91Y2gpKTt2YXIgciA9IGFyeVswXSxjID0gYXJ5WzFdO1xuXHRcdFx0dGhpcy5jYXJldCgpLmhlYWQoKS5zZXQocixjKS5ub3JtYWxpemUoKTtcblx0XHRcdHRoaXMuY2FyZXQoKS5kaXJ0eSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmVyYXNlID0gZnVuY3Rpb24gKHJlZyxlZGl0KXtcblx0XHRcdHJlZyA9IFJlZ2lvbi5ub3JtYWxpemUocmVnLHRoaXMpO1xuXHRcdFx0XG5cdFx0XHR2YXIgdGV4dCA9IHJlZy50ZXh0KCk7XG5cdFx0XHR0aGlzLmhpc3RvcnkoKS5vbmVyYXNlKHJlZyx0ZXh0LGVkaXQpO1xuXHRcdFx0XG5cdFx0XHR2YXIgc3BhbnMgPSB0aGlzLm5vZGVzSW5SZWdpb24ocmVnLGZhbHNlLHRydWUpO1xuXHRcdFx0Ly8gZ3JvcHUgdGhlIG5vZGVzXG5cdFx0XHR0aGlzLm9ic2VydmVyKCkucGF1c2UoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChzcGFucy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0c3BhbnNbMV0ubm9kZS5zZXRQcmV2KHRhZyQuJGltaW5zZXJ0KCkuZmxhZygnZGlydHknKS5lbmQoKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc3BhbnNbMF0gJiYgc3BhbnNbMF0ubW9kZSA9PSAnYWxsJykge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdyZW1vdmluZyBzaW5nbGUgbm9kZT8hJyk7XG5cdFx0XHRcdFx0dmFyIGJlZm9yZSA9IHNwYW5zWzBdLm5vZGUucHJldigpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHNwYW5zWzBdLm5vZGUuc2V0UHJldih0YWckLiRpbWluc2VydCgpLmZsYWcoJ2RpcnR5JykuZW5kKCkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNwYW5zKSwgbGVuID0gYXJ5Lmxlbmd0aCwgc2VsLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0Ly8gYnVmZmVyIG5lZWQgdG8gdXBkYXRlZCBkdXJpbmcgdGhpcz9cblx0XHRcdFx0XHRzZWwgPSBhcnlbaV07XG5cdFx0XHRcdFx0cmVzLnB1c2goc2VsLm5vZGUuZXJhc2Uoc2VsLnJlZ2lvbixzZWwubW9kZSxlZGl0KSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Ly8gZGVsYXkoJ2Fubm90YXRlJyw1MDApIGRvIGFubm90YXRlXG5cdFx0XHRyZXR1cm4gdGhpcy5lcmFzZWQocmVnKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5zZXJ0ZWQgPSBmdW5jdGlvbiAobG9jLHN0cil7XG5cdFx0XHRjb25zb2xlLmxvZygnaW5zZXJ0ZWQnLGxvYyxzdHIpO1xuXHRcdFx0dmFyIHJlZyA9IG5ldyBSZWdpb24obG9jLGxvYyArIHN0ci5sZW5ndGgsbnVsbCx0aGlzKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLmhpbnRzKCkpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0YXJ5W2ldLmFkanVzdChyZWcsdHJ1ZSk7XG5cdFx0XHR9O1xuXHRcdFx0Ly8gaGludHMuY2xlYW51cFxuXHRcdFx0dGhpcy5lZGl0ZWQoKTtcblx0XHRcdGlmICh1dGlsLmlzV2hpdGVzcGFjZShzdHIpKSB0aGlzLnJlcGFpcigpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmVyYXNlZCA9IGZ1bmN0aW9uIChyZWcpe1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMuaGludHMoKSksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRhcnlbaV0uYWRqdXN0KHJlZyxmYWxzZSk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5lZGl0ZWQoKTtcblx0XHRcdHJldHVybiB0aGlzLnJlcGFpcigpOyAvLyByZXBhaXIgc3luY2hyb25vdXNseVxuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAocG9pbnQsc3RyLGVkaXQpe1xuXHRcdFx0aWYgKHBvaW50IGluc3RhbmNlb2YgUmVnaW9uKSB7XG5cdFx0XHRcdGlmIChwb2ludC5zaXplKCkgPiAwKSB7XG5cdFx0XHRcdFx0dGhpcy5sb2dnZXIoKS53YXJuKCd1bmNvbGxhcHNlZCByZWdpb24gaW4gaW5zZXJ0IGlzIG5vdCBhbGxvd2VkJyk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHBvaW50ID0gcG9pbnQuc3RhcnQoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRoaXMubG9nKCdpbnNlcnQnLHBvaW50LHN0cik7XG5cdFx0XHQvLyBzaG91bGQgbWF5YmUgY3JlYXRlIHRoaXMgYXMgYSBjb21tYW5kIC0gYW5kIHRoZW4gbWFrZSBpdCBoYXBwZW4/XG5cdFx0XHRcblx0XHRcdHRoaXMuaGlzdG9yeSgpLm9uaW5zZXJ0KHBvaW50LHN0cixlZGl0KTtcblx0XHRcdFxuXHRcdFx0Ly8gbG9nICdpbnNlcnQgaW4gdmlldydcblx0XHRcdHZhciBzcGFucyA9IHRoaXMubm9kZXNJblJlZ2lvbihSZWdpb24ubm9ybWFsaXplKHBvaW50LHRoaXMpLGZhbHNlKTtcblx0XHRcdHZhciBtaWQgPSBzcGFuc1swXTtcblx0XHRcdHZhciB0YXJnZXQgPSBtaWQgfHwgc3BhbnMucHJldiB8fCBzcGFucy5uZXh0O1xuXHRcdFx0dmFyIGxmdCA9IHNwYW5zLmxmdCxyZ3QgPSBzcGFucy5yZ3Q7XG5cdFx0XHR2YXIgbm9kZTtcblx0XHRcdHZhciByZWc7XG5cdFx0XHRcblx0XHRcdC8vIGxvZyBzcGFucyxtaWQsbGZ0LHJndFxuXHRcdFx0dGhpcy5sb2coJ2JlZm9yZSBhbmQgYWZ0ZXInLGxmdCxyZ3Qsc3RyKTtcblx0XHRcdFxuXHRcdFx0aWYgKG1pZCkge1xuXHRcdFx0XHR0aGlzLmxvZygnaW5zZXJ0IG1pZCcsbWlkLm5vZGUpO1xuXHRcdFx0XHRtaWQubm9kZS5pbnNlcnQobWlkLnJlZ2lvbixzdHIsZWRpdCxtaWQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XG5cdFx0XHRcdHdoaWxlIChyZ3Qpe1xuXHRcdFx0XHRcdGlmIChyZ3QuY2FuUHJlcGVuZChzdHIpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmxvZygncHJlcGVuZCcscmd0LHN0cik7XG5cdFx0XHRcdFx0XHRyZ3QuaW5zZXJ0KCdwcmVwZW5kJyxzdHIsZWRpdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5pbnNlcnRlZChwb2ludCxzdHIpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocmd0LmlzRmlyc3QoKSkge1xuXHRcdFx0XHRcdFx0cmd0ID0gcmd0LnBhcmVudCgpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGZpbmQgdGhlIGNsb3Nlc3QgcGFyZW50XG5cdFx0XHRcdHdoaWxlIChsZnQpe1xuXHRcdFx0XHRcdGlmIChsZnQuY2FuQXBwZW5kKHN0cikpIHtcblx0XHRcdFx0XHRcdHRoaXMubG9nKCdhcHBlbmQnLGxmdCxzdHIpO1xuXHRcdFx0XHRcdFx0bGZ0Lmluc2VydCgnYXBwZW5kJyxzdHIsZWRpdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5pbnNlcnRlZChwb2ludCxzdHIpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobGZ0LmlzTGFzdCgpKSB7XG5cdFx0XHRcdFx0XHRsZnQgPSBsZnQucGFyZW50KCk7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0bm9kZSA9IHRhZyQuJGltaW5zZXJ0KCkuZW5kKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobGZ0KSB7XG5cdFx0XHRcdFx0bGZ0LnNldE5leHQobm9kZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocmd0KSB7XG5cdFx0XHRcdFx0cmd0LnNldFByZXYobm9kZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gbXVzdCBiZSBlbXB0eVxuXHRcdFx0XHRcdHRoaXMucm9vdCgpLmRvbSgpLmFwcGVuZENoaWxkKG5vZGUuZG9tKCkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0bm9kZS5pbnNlcnQoJ2FwcGVuZCcsc3RyLGVkaXQpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuaW5zZXJ0ZWQocG9pbnQsc3RyKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25tdXRhdGlvbnMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhaXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHR2YXIgZWxzID0gdGhpcy5kb20oKS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdkaXJ0eScpO1xuXHRcdFx0XG5cdFx0XHRpZiAoZWxzLmxlbmd0aCkge1xuXHRcdFx0XHQvLyBsb2dnZXIubG9nIFwie2VsczpsZW5ndGh9IGRpcnR5IG5vZGVzIHRvIHJlcGFpclwiXG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKHZhciBtdXRzID0gW10sIGkgPSAwLCBhcnkgPSBpdGVyJChlbHMpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRtdXRzLnB1c2godGFnJHdyYXAoYXJ5W2ldKSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobXV0cyksIGxlbiA9IGFyeS5sZW5ndGgsIG11dDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0bXV0ID0gYXJ5W2ldO1xuXHRcdFx0XHRcdG11dC51bmZsYWcoJ2RpcnR5Jyk7XG5cdFx0XHRcdFx0bXV0Lm11dGF0ZWQobXV0cyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9yb290LmRvbSgpLnRleHRDb250ZW50O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5mb2N1c05vZGVEaWRTZXQgPSBmdW5jdGlvbiAobmV3JCxvbGQpe1xuXHRcdFx0aWYgKCF0aGlzLnJvb3QoKS5jb250YWlucyhuZXckKSkgeyByZXR1cm4gfTtcblx0XHRcdFxuXHRcdFx0dmFyIHBhdGggPSBbXTtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKG5ldyQgJiYgbmV3JCAhPSB0aGlzLnJvb3QoKSl7XG5cdFx0XHRcdHBhdGgucHVzaChuZXckKTtcblx0XHRcdFx0bmV3JCA9IG5ldyQucGFyZW50KCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRxJCgnLmZvY3VzXycsdGhpcykubWFwKGZ1bmN0aW9uKG4pIHtcblx0XHRcdFx0aWYgKHBhdGguaW5kZXhPZihuKSA8IDApIHsgcmV0dXJuIG4udW5mbGFnKCdmb2N1c18nKSB9O1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXRoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHBhdGhbaV0uZmxhZygnZm9jdXNfJyk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlY29tcGlsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gc2hvdWxkIGhhcHBlbiBpbiBhIHNlcGFyYXRlIHRocmVhZCAtIGFuZCBiZSBkZWxheWVkXG5cdFx0XHRjb25zb2xlLmxvZygncmVjb21waWxlJyk7XG5cdFx0XHR2YXIgcmVzO1xuXHRcdFx0XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXMgPSBJbWJhYy5jb21waWxlKHRoaXMuY29kZSgpLHtiYXJlOiB0cnVlfSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7IH07XG5cdFx0XHRcblx0XHRcdGlmIChyZXMpIHtcblx0XHRcdFx0dGhpcy5jb21waWxlZChyZXMpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXBhcnNlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmxvZygncmVwYXJzZScpO1xuXHRcdFx0dGhpcy5yb290KCkucmVoaWdobGlnaHQoe2lubmVyOiB0cnVlfSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29tcGlsZWQgPSBmdW5jdGlvbiAocmVzKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnJ1bmVycm9yID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0Y29uc29sZS5sb2coJ29ucnVuZXJyb3InLGUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmFkZEVycm9yID0gZnVuY3Rpb24gKG1zZyxsb2Mpe1xuXHRcdFx0dmFyIG5vZGU7XG5cdFx0XHR2YXIgcmVnID0gUmVnaW9uLm5vcm1hbGl6ZShsb2MsdGhpcyk7XG5cdFx0XHRjb25zb2xlLmxvZygnZm91bmQgd2FybmluZ3MnLHJlZyxtc2csbG9jKTtcblx0XHRcdGlmIChub2RlID0gdGhpcy5ub2RlQXRSZWdpb24ocmVnKSkge1xuXHRcdFx0XHR0aGlzLmxvZygnbm9kZSBhdCByZWdpb24gaXM/IScsbm9kZSk7XG5cdFx0XHRcdG1zZyA9IG1zZy5zcGxpdCgvZXJyb3IgYXQgKFxcW1tcXGRcXDpdKlxcXSlcXDpcXHMqLykucG9wKCk7XG5cdFx0XHRcdG5vZGUuZmxhZygnZXJyJyk7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCdlcnJvcicsbXNnKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLmRlbGF5KCdhbm5vdGF0ZScsLTEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmFubm90YXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnYW5ub3RhdGUnXG5cdFx0XHRcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciBzdGF0ZSA9IHNlbGYucm9vdCgpLmNvZGVTdGF0ZSgpO1xuXHRcdFx0dmFyIGNvZGUgPSBzdGF0ZS5jb2RlO1xuXHRcdFx0XG5cdFx0XHR2YXIgYXBwbHkgPSBmdW5jdGlvbihtZXRhKSB7XG5cdFx0XHRcdHZhciB2YXJzID0gW107XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChtZXRhLnNjb3BlcyksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdGZvciAodmFyIGogPSAwLCBpdGVtcyA9IGl0ZXIkKGFyeVtpXS52YXJzKSwgbGVuXyA9IGl0ZW1zLmxlbmd0aDsgaiA8IGxlbl87IGorKykge1xuXHRcdFx0XHRcdFx0dmFycy5wdXNoKGl0ZW1zW2pdKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIHdhcm5pbmdzID0gbWV0YS53YXJuaW5ncyB8fCBbXTtcblx0XHRcdFx0dmFyIG9sZFdhcm5pbmdzID0gc2VsZi5oaW50cygpLmZpbHRlcihmdW5jdGlvbihoaW50KSB7IHJldHVybiBoaW50Lmdyb3VwKCkgPT0gJ2FuYWx5c2lzJzsgfSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAob2xkV2FybmluZ3MpIHtcblx0XHRcdFx0XHQvLyBjb3VsZCBpbnRlbGxpZ2VudGx5IGtlZXAgdGhlbSBpbnN0ZWFkXG5cdFx0XHRcdFx0c2VsZi5oaW50cygpLnJlbShvbGRXYXJuaW5ncyk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQod2FybmluZ3MpLCBsZW4gPSBhcnkubGVuZ3RoLCB3YXJuOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHR3YXJuID0gYXJ5W2ldO1xuXHRcdFx0XHRcdHdhcm4udHlwZSB8fCAod2Fybi50eXBlID0gJ2Vycm9yJyk7XG5cdFx0XHRcdFx0d2Fybi5ncm91cCA9ICdhbmFseXNpcyc7XG5cdFx0XHRcdFx0c2VsZi5oaW50cygpLmFkZCh3YXJuKS5hY3RpdmF0ZSgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHdhcm5pbmdzLmxlbmd0aCkgeyByZXR1cm4gc2VsZiB9O1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIG5vZGVzID0gSU0udGV4dE5vZGVzKHNlbGYucm9vdCgpLmRvbSgpLHRydWUpO1xuXHRcdFx0XHQvLyB3aGF0IGFib3V0IHJlbW92aW5nIG9sZCB3YXJuaW5ncz9cblx0XHRcdFx0XG5cdFx0XHRcdHZhciBtYXAgPSB7fTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG5vZGVzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgbm9kZTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGFyeVtpXTtcblx0XHRcdFx0XHRtYXBbbm9kZS5fbG9jXSA9IG5vZGU7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBnZXQgdGV4dE5vZGVzIHdpdGggbWFwcGluZyghKVxuXHRcdFx0XHRmb3IgKHZhciBpMSA9IDAsIGxlbiA9IHZhcnMubGVuZ3RoOyBpMSA8IGxlbjsgaTErKykge1xuXHRcdFx0XHRcdGZvciAodmFyIGsgPSAwLCBhcnkgPSBpdGVyJCh2YXJzW2kxXS5yZWZzKSwgbGVuXyA9IGFyeS5sZW5ndGgsIHJlZjsgayA8IGxlbl87IGsrKykge1xuXHRcdFx0XHRcdFx0cmVmID0gYXJ5W2tdO1xuXHRcdFx0XHRcdFx0dmFyIGEgPSByZWYubG9jWzBdO1xuXHRcdFx0XHRcdFx0dmFyIGIgPSByZWYubG9jWzFdO1xuXHRcdFx0XHRcdFx0dmFyIGVyZWYgPSAoXCJ2XCIgKyBpMSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChtYXBbYV0pIHtcblx0XHRcdFx0XHRcdFx0dmFyIGRvbSA9IG1hcFthXS5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdFx0XHR2YXIgb2xkUmVmID0gZG9tLmdldEF0dHJpYnV0ZSgnZXJlZicpO1xuXHRcdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnc2V0dGluZyB0aGUgcmVmIGZvciBub2RlPycsZG9tLGRvbS5AdGFnXG5cdFx0XHRcdFx0XHRcdHRhZyR3cmFwKGRvbSkuc2V0RXJlZihlcmVmKTtcblx0XHRcdFx0XHRcdFx0Ly8gaWYgZG9tLkB0YWdcblx0XHRcdFx0XHRcdFx0Ly8gXHRkb20uQHRhZy5lcmVmID0gZXJlZlxuXHRcdFx0XHRcdFx0XHQvLyBlbHNlXG5cdFx0XHRcdFx0XHRcdC8vIFx0ZG9tLnNldEF0dHJpYnV0ZSgnZXJlZicsZXJlZikgdW5sZXNzIG9sZFJlZiA9PSBlcmVmXG5cdFx0XHRcdFx0XHRcdC8vIFx0ZG9tOmNsYXNzTGlzdC5hZGQoJ2x2YXInKVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnNvbGUudGltZSgnYW5hbHl6ZScpO1xuXHRcdFx0XHRJTS53b3JrZXIoKS5hbmFseXplKGNvZGUse2JhcmU6IHRydWV9LGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdyZXN1bHQgZnJvbSB3b3JrZXIgYW5hbHl6ZScpO1xuXHRcdFx0XHRcdGNvbnNvbGUudGltZUVuZCgnYW5hbHl6ZScpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChyZXMuZGF0YSkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS50aW1lKCdhbm5vdGF0ZScpO1xuXHRcdFx0XHRcdFx0YXBwbHkocmVzLmRhdGEpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNvbnNvbGUudGltZUVuZCgnYW5ub3RhdGUnKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0c2VsZi5sb2coJ2Vycm9yIGZyb20gYW5ub3RhdGUnLGUpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uY29tbWFuZCA9IGZ1bmN0aW9uIChlLGMpe1xuXHRcdFx0aWYgKHRoaXNbYy5jb21tYW5kXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRcdHRoaXNbYy5jb21tYW5kXS5jYWxsKHRoaXMsYy5hcmdzIHx8IFtdKTtcblx0XHRcdFx0ZS5oYWx0KCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmR1bXBTdGF0ZSA9IGZ1bmN0aW9uIChvKXtcblx0XHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aHRtbDogdGhpcy5yb290KCkuZG9tKCkuaW5uZXJIVE1MLFxuXHRcdFx0XHRjb2RlOiB0aGlzLnJvb3QoKS5jb2RlKCksXG5cdFx0XHRcdHNlbGVjdGlvbjogdGhpcy5jYXJldCgpLnJlZ2lvbigpLFxuXHRcdFx0XHR0aW1lc3RhbXA6IG5ldyBEYXRlKClcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxvYWRTdGF0ZSA9IGZ1bmN0aW9uIChvKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGlmKG8gPT09IHVuZGVmaW5lZCkgbyA9IHt9O1xuXHRcdFx0c2VsZi5vYnNlcnZlcigpLnBhdXNlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdl87XG5cdFx0XHRcdGlmIChvLmh0bWwpIHtcblx0XHRcdFx0XHRzZWxmLnJvb3QoKS5kb20oKS5pbm5lckhUTUwgPSBvLmh0bWw7XG5cdFx0XHRcdH0gZWxzZSBpZiAoby5jb2RlKSB7XG5cdFx0XHRcdFx0c2VsZi5sb2FkKG8uY29kZSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChvLnNlbGVjdGlvbikge1xuXHRcdFx0XHRcdHJldHVybiAoc2VsZi5jYXJldCgpLnNldFJlZ2lvbih2XyA9IG8uc2VsZWN0aW9uKSx2Xyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2FkU2Vzc2lvbiA9IGZ1bmN0aW9uIChzZXNzaW9uKXtcblx0XHRcdHRoaXMuaGlzdG9yeSgpLmxvYWQoc2Vzc2lvbik7XG5cdFx0XHR0aGlzLmhpc3RvcnkoKS5wbGF5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudGV4dE5vZGVzID0gZnVuY3Rpb24gKHJlbCl7XG5cdFx0XHRpZihyZWwgPT09IHVuZGVmaW5lZCkgcmVsID0gdGhpcy5yb290KCk7XG5cdFx0XHRyZXR1cm4gSU0udGV4dE5vZGVzKHJlbCk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBTaG91bGQgYmUgc2VwYXJhdGUgZnJvbSB0aGUgdmlld2NvZGU/XG5cdFx0dGFnLnByb3RvdHlwZS5yZWdpb25Gb3JOb2RlID0gZnVuY3Rpb24gKG5vZGUscmVsKXtcblx0XHRcdGlmKHJlbCA9PT0gdW5kZWZpbmVkKSByZWwgPSB0aGlzLnJvb3QoKTtcblx0XHRcdHZhciBlbCA9IG5vZGUuX2RvbSB8fCBub2RlO1xuXHRcdFx0dmFyIGxlbiA9IGVsLnRleHRDb250ZW50Lmxlbmd0aDtcblx0XHRcdHZhciBybmcgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuXHRcdFx0cm5nLnNldFN0YXJ0KHJlbC5fZG9tIHx8IHJlbCwwKTtcblx0XHRcdHJuZy5zZXRFbmQobm9kZS5fZG9tIHx8IG5vZGUsMCk7XG5cdFx0XHR2YXIgcHJlID0gcm5nLnRvU3RyaW5nKCk7XG5cdFx0XHRyZXR1cm4gbmV3IFJlZ2lvbihwcmUubGVuZ3RoLHByZS5sZW5ndGggKyBsZW4scmVsLHRoaXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gU2hvdWxkIG1lcmdlIHdpdGggbm9kZXNJblJlZ2lvblxuXHRcdHRhZy5wcm90b3R5cGUubm9kZUF0UmVnaW9uID0gZnVuY3Rpb24gKHJlZ2lvbixleGFjdCl7XG5cdFx0XHRpZihleGFjdCA9PT0gdW5kZWZpbmVkKSBleGFjdCA9IGZhbHNlO1xuXHRcdFx0Y29uc29sZS50aW1lKCdub2RlQXRSZWdpb24nKTtcblx0XHRcdHZhciByZWwgPSB0aGlzLnJvb3QoKTtcblx0XHRcdHZhciBhID0gcmVnaW9uLmEoKTtcblx0XHRcdHZhciBiID0gcmVnaW9uLmIoKTtcblx0XHRcdFxuXHRcdFx0dmFyIG5vZGVzID0gdGhpcy50ZXh0Tm9kZXMocmVsKTtcblx0XHRcdC8vIG1vdmUgaW50byByZWdpb24gaW5zdGVhZD9cblx0XHRcdHZhciBwb3MgPSAwO1xuXHRcdFx0dmFyIG1hdGNoID0gbnVsbDtcblx0XHRcdHZhciBhZGlzdCxiZGlzdCxzdHIsbGVuO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobm9kZXMpLCBsZW5fID0gYXJ5Lmxlbmd0aCwgbm9kZTsgaSA8IGxlbl87IGkrKykge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnbG9va2luZyB0aHJvdWdoIG5vZGVzJ1xuXHRcdFx0XHRub2RlID0gYXJ5W2ldO1xuXHRcdFx0XHRhZGlzdCA9IGEgLSBwb3M7XG5cdFx0XHRcdGJkaXN0ID0gYiAtIHBvcztcblx0XHRcdFx0c3RyID0gbm9kZS50ZXh0Q29udGVudDtcblx0XHRcdFx0bGVuID0gc3RyLmxlbmd0aDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChhZGlzdCA+PSAwICYmIGFkaXN0IDwgbGVuKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2ZvdW5kIHN0YXJ0aW5nIHBvaW50Pycsbm9kZSxzdHIsYWRpc3Rcblx0XHRcdFx0XHRtYXRjaCA9IG5vZGU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Ly8gcmV0dXJuIHRhZyhub2RlOnBhcmVudE5vZGUpXG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoYmRpc3QgPj0gMCAmJiBiZGlzdCA8IGxlbikge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nICdmb3VuZCBlbmRpbmcgcG9pbnQnLG5vZGUsc3RyLGJkaXN0XG5cdFx0XHRcdFx0Ly8gcmFuZ2Uuc2V0RW5kKG5vZGUsYmRpc3QpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0cG9zICs9IGxlbjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBlbCA9IHRhZyR3cmFwKG1hdGNoLnBhcmVudE5vZGUpO1xuXHRcdFx0Ly8gd2Ugd2FudCB0byBtYXRjaCB0aGUgb25lIHRoYXQgaXMgZnVsbCBsZW5ndGhcblx0XHRcdGlmIChleGFjdCAmJiBsZW4gPCByZWdpb24uc2l6ZSgpKSB7XG5cdFx0XHRcdHdoaWxlIChlbCl7XG5cdFx0XHRcdFx0Ly8gYmUgY2FyZWZ1bFxuXHRcdFx0XHRcdHZhciBlbHJlZyA9IGVsLnJlZ2lvbigpO1xuXHRcdFx0XHRcdGlmIChyZWdpb24uZXF1YWxzKGVscmVnKSkgeyByZXR1cm4gZWwgfTtcblx0XHRcdFx0XHRlbCA9IGVsLnBhcmVudCgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y29uc29sZS50aW1lRW5kKCdub2RlQXRSZWdpb24nKTtcblx0XHRcdHJldHVybiBtYXRjaCA/ICh0YWckd3JhcChtYXRjaC5wYXJlbnROb2RlKSkgOiAobnVsbCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5vZGVzRm9yRW50aXR5ID0gZnVuY3Rpb24gKHJlZil7XG5cdFx0XHRyZXR1cm4gcSQoJ1tlcmVmPVwiJysoXCJcIiArIHJlZikrJ1wiXScsdGhpcyk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBkb2VzIG5vdCBuZWVkIHRvIGJlbG9uZyB0byB2aWV3IGRpcmVjdGx5XG5cdFx0dGFnLnByb3RvdHlwZS5ub2Rlc0luUmVnaW9uID0gZnVuY3Rpb24gKHJlZ2lvbixpbmNsdWRlRW5kcyxnZW5lcmFsaXplKXtcblx0XHRcdGlmKGluY2x1ZGVFbmRzID09PSB1bmRlZmluZWQpIGluY2x1ZGVFbmRzID0gdHJ1ZTtcblx0XHRcdGlmKGdlbmVyYWxpemUgPT09IHVuZGVmaW5lZCkgZ2VuZXJhbGl6ZSA9IGZhbHNlO1xuXHRcdFx0Y29uc29sZS50aW1lKCdub2Rlc0luUmVnaW9uJyk7XG5cdFx0XHRyZWdpb24gPSBSZWdpb24ubm9ybWFsaXplKHJlZ2lvbix0aGlzKS5ub3JtYWxpemUoKTtcblx0XHRcdHZhciBhID0gcmVnaW9uLnN0YXJ0KCk7XG5cdFx0XHR2YXIgYiA9IHJlZ2lvbi5lbmQoKTtcblx0XHRcdFxuXHRcdFx0Ly8gY2FuIGJlIG9wdGltaXplZCBieSBzdXBwbHlpbmcgdGhlIHJlZ2lvbnNcblx0XHRcdHZhciBub2RlcyA9IElNLnRleHROb2RlcyhyZWdpb24ucm9vdCgpIHx8IHRoaXMucm9vdCgpKTtcblx0XHRcdHZhciBtYXRjaGVzID0gW107XG5cdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHR2YXIgZWw7XG5cdFx0XHQvLyBtb3ZlIGludG8gcmVnaW9uIGluc3RlYWQ/XG5cdFx0XHRtYXRjaGVzLmluY2x1ZGVFbmRzID0gaW5jbHVkZUVuZHM7XG5cdFx0XHRtYXRjaGVzLnJlZ2lvbiA9IHJlZ2lvbjtcblx0XHRcdFxuXHRcdFx0dmFyIHBvcyA9IDA7XG5cdFx0XHR2YXIgZW5kcyA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBpMSA9IDAsIGFyeSA9IGl0ZXIkKG5vZGVzKSwgbGVuXyA9IGFyeS5sZW5ndGgsIG5vZGU7IGkxIDwgbGVuXzsgaTErKykge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnbG9va2luZyB0aHJvdWdoIG5vZGVzJ1xuXHRcdFx0XHRub2RlID0gYXJ5W2kxXTtcblx0XHRcdFx0dmFyIGFkaXN0ID0gYSAtIHBvcztcblx0XHRcdFx0dmFyIGJkaXN0ID0gYiAtIHBvcztcblx0XHRcdFx0dmFyIHN0ciA9IG5vZGUudGV4dENvbnRlbnQ7XG5cdFx0XHRcdHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKChwb3MgKyBsZW4pID49IGEgJiYgcG9zIDw9IGIpIHtcblx0XHRcdFx0XHRlbCA9IHRhZyR3cmFwKG5vZGUucGFyZW50Tm9kZSk7XG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gTWF0aC5tYXgoMCxhIC0gcG9zKTtcblx0XHRcdFx0XHR2YXIgZW5kID0gTWF0aC5taW4obGVuLE1hdGgubWF4KGIgLSBwb3MsMCkpO1xuXHRcdFx0XHRcdHZhciBwYXI7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0bWF0Y2ggPSB7XG5cdFx0XHRcdFx0XHRub2RlOiBlbCxcblx0XHRcdFx0XHRcdHN0YXJ0T2Zmc2V0OiBzdGFydCxcblx0XHRcdFx0XHRcdGVuZE9mZnNldDogZW5kLFxuXHRcdFx0XHRcdFx0cmVnaW9uOiBuZXcgUmVnaW9uKHN0YXJ0LGVuZCxlbCx0aGlzKSxcblx0XHRcdFx0XHRcdHNpemU6IGxlblxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Ly8gbG9nIFwibm9kZSBhdCB7cG9zfSArIHtsZW59IC0gbG9va2luZyBpbiByYW5nZSB7YX0gLSB7Yn1cIlxuXHRcdFx0XHRcdHZhciBtb2RlID0gJ2FsbCc7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHN0YXJ0ID09IGxlbikge1xuXHRcdFx0XHRcdFx0bW9kZSA9ICdlbmQnO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZW5kID09IDApIHtcblx0XHRcdFx0XHRcdG1vZGUgPSAnc3RhcnQnO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoc3RhcnQgPT0gMCAmJiBlbmQgPT0gbGVuKSB7XG5cdFx0XHRcdFx0XHRwYXIgPSBlbC5kb20oKS5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdFx0dmFyIGlzT3BlbmVyID0gcGFyICE9IHRoaXMuX3Jvb3QuZG9tKCkgJiYgZWwuZG9tKCkgPT0gcGFyLmZpcnN0Q2hpbGQ7XG5cdFx0XHRcdFx0XHR2YXIgaXNDbG9zZXIgPSBwYXIgIT0gdGhpcy5fcm9vdC5kb20oKSAmJiBlbC5kb20oKSA9PSBwYXIubGFzdENoaWxkO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoaXNPcGVuZXIpIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2gub3BlbnMgPSBlbC5wYXJlbnQoKTtcblx0XHRcdFx0XHRcdFx0ZW5kcy5wdXNoKG1hdGNoKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChpc0Nsb3Nlcikge1xuXHRcdFx0XHRcdFx0XHRlbmQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0XHRcdGlmIChlbmQgJiYgZW5kLm9wZW5zID09IGVsLnBhcmVudCgpKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZW5kLmNsb3NlciA9IG1hdGNoO1xuXHRcdFx0XHRcdFx0XHRcdG1hdGNoLm9wZW5lciA9IGVuZDtcblx0XHRcdFx0XHRcdFx0XHRlbmRzLnBvcCgpO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0bWF0Y2guY2xvc2VzID0gZWwucGFyZW50KCk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRtb2RlID0gJ2FsbCc7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG1vZGUgPSAncGFydGlhbCc7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRtYXRjaC5tb2RlID0gbW9kZTtcblx0XHRcdFx0XHRtYXRjaGVzLnB1c2gobWF0Y2gpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0cG9zICs9IGxlbjtcblx0XHRcdFx0aWYgKHBvcyA+IGIpIHsgYnJlYWs7IH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgZmlyc3QgPSBtYXRjaGVzWzBdO1xuXHRcdFx0dmFyIGxhc3QgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG5cdFx0XHRcblx0XHRcdGlmIChmaXJzdCAmJiBmaXJzdC5tb2RlID09ICdlbmQnKSB7XG5cdFx0XHRcdG1hdGNoZXMucHJldiA9IGZpcnN0O1xuXHRcdFx0XHRtYXRjaGVzLmxmdCA9IGZpcnN0Lm5vZGU7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBpZiBmaXJzdDpub2RlIGlzYSBJTS5UeXBlczpjbG9zZVxuXHRcdFx0XHQvLyBcdG1hdGNoZXM6bGZ0ID0gZmlyc3Q6bm9kZS5wYXJlbnRcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghaW5jbHVkZUVuZHMpIHsgbWF0Y2hlcy5zaGlmdCgpIH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAobGFzdCAmJiBsYXN0Lm1vZGUgPT0gJ3N0YXJ0Jykge1xuXHRcdFx0XHRtYXRjaGVzLm5leHQgPSBsYXN0O1xuXHRcdFx0XHRtYXRjaGVzLnJndCA9IGxhc3Qubm9kZTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGlmIGxhc3Q6bm9kZSBpc2EgSU0uVHlwZXM6b3BlblxuXHRcdFx0XHQvLyBcdG1hdGNoZXM6cmd0ID0gbGFzdDpub2RlLnBhcmVudFxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCFpbmNsdWRlRW5kcykgeyBtYXRjaGVzLnBvcCgpIH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdC8vIG5vcm1hbGl6ZSB0aGUgbm9kZXMgaW4gZ3JvdXBzXG5cdFx0XHRpZiAoZ2VuZXJhbGl6ZSkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnZ2VuZXJhbGl6ZSEnLG1hdGNoZXNcblx0XHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0XHR2YXIgbTtcblx0XHRcdFx0d2hpbGUgKG0gPSBtYXRjaGVzW2ldKXtcblx0XHRcdFx0XHRpZiAobS5jbG9zZXIpIHtcblx0XHRcdFx0XHRcdHZhciBpZHggPSBtYXRjaGVzLmluZGV4T2YobS5jbG9zZXIpO1xuXHRcdFx0XHRcdFx0bGVuID0gbS5vcGVucy5zaXplKCk7XG5cdFx0XHRcdFx0XHR2YXIgbmV3JCA9IHtcblx0XHRcdFx0XHRcdFx0bW9kZTogJ2FsbCcsXG5cdFx0XHRcdFx0XHRcdHJlZ2lvbjogbmV3IFJlZ2lvbigwLGxlbixtLm9wZW5zLHRoaXMpLFxuXHRcdFx0XHRcdFx0XHRzdGFydE9mZnNldDogMCxcblx0XHRcdFx0XHRcdFx0ZW5kT2Zmc2V0OiBsZW4sXG5cdFx0XHRcdFx0XHRcdG5vZGU6IG0ub3BlbnNcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR2YXIgcmVtID0gbWF0Y2hlcy5zcGxpY2UoaSxpZHggLSBpICsgMSxuZXckKTtcblx0XHRcdFx0XHRcdG5ldyQuY2hpbGRyZW4gPSByZW07XG5cdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnc2xpY2UgYXdheSB0aGUgaXRlbXMnXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRjb25zb2xlLnRpbWVFbmQoJ25vZGVzSW5SZWdpb24nKTtcblx0XHRcdHJldHVybiBtYXRjaGVzO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIG1vdmUgdG8gQnVmZmVyIGNsYXNzXG5cdFx0dGFnLnByb3RvdHlwZS5saW5lY291bnQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmJ1ZmZlcigpLmxpbmVjb3VudCgpO1xuXHRcdFx0Ly8gYnVmZmVyLnNwbGl0KCdcXG4nKVs6bGVuZ3RoXVxuXHRcdH07XG5cdFx0XG5cdFx0Ly8gUmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhlIHJlZ2lvbiBhcyBhIHN0cmluZy5cblx0XHQvLyBSZXR1cm5zIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0IG9mIHRoZSBwb2ludC5cblx0XHR0YWcucHJvdG90eXBlLnN1YnN0ciA9IGZ1bmN0aW9uIChyZWdpb24sbGVuKXtcblx0XHRcdHJldHVybiB0aGlzLmJ1ZmZlcigpLnN1YnN0cihyZWdpb24sbGVuKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIG1vdmUgaW50byBCdWZmZXJcblx0XHR0YWcucHJvdG90eXBlLmxpbmVzdHIgPSBmdW5jdGlvbiAobnIpe1xuXHRcdFx0cmV0dXJuIHRoaXMuYnVmZmVyKCkubGluZShucik7XG5cdFx0XHQvLyBpZiBuciBpc2EgTnVtYmVyXG5cdFx0XHQvLyBcdGJ1ZmZlci5zcGxpdCgnXFxuJylbbnJdIG9yICcnXG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmV4cGFuZFJlZ2lvblRvID0gZnVuY3Rpb24gKHJlZ2lvbixtYXRjaCxmb3J3YXJkKXtcblx0XHRcdGlmKGZvcndhcmQgPT09IHVuZGVmaW5lZCkgZm9yd2FyZCA9IHRydWU7XG5cdFx0XHR2YXIgYnVmID0gdGhpcy5idWZmZXIoKS50b1N0cmluZygpO1xuXHRcdFx0dmFyIHBvcyA9IHJlZ2lvbi5zdGFydCgpO1xuXHRcdFx0dmFyIGVuZCA9IHJlZ2lvbi5lbmQoKTtcblx0XHRcdFxuXHRcdFx0aWYgKGZvcndhcmQpIHtcblx0XHRcdFx0d2hpbGUgKGJ1ZltlbmQgKyAxXSAhPSBtYXRjaCl7XG5cdFx0XHRcdFx0ZW5kKys7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoYnVmW3BvcyAtIDFdICE9IG1hdGNoKXtcblx0XHRcdFx0XHRwb3MtLTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBuZXcgUmVnaW9uKHBvcyxlbmQsdGhpcyk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0cmV0dXJuIFZJRVcgPSBudWxsO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvdmlldy5pbWJhXG4gKiogbW9kdWxlIGlkID0gMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRmdW5jdGlvbiBpdGVyJChhKXsgcmV0dXJuIGEgPyAoYS50b0FycmF5ID8gYS50b0FycmF5KCkgOiBhKSA6IFtdOyB9O1xuXHRcblx0dmFyIFJlZ2lvbiA9IHJlcXVpcmUoJy4uL3JlZ2lvbicpLlJlZ2lvbjtcblx0XG5cdGZ1bmN0aW9uIEJ1ZmZlcih2aWV3KXtcblx0XHR0aGlzLl92aWV3ID0gdmlldztcblx0XHR0aGlzLl9idWZmZXIgPSAnJztcblx0XHR0aGlzLl9jYWNoZSA9IHt9O1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlcjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRcblx0XG5cdEJ1ZmZlci5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmlldzsgfVxuXHRCdWZmZXIucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0QnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoYnVmZmVyKXtcblx0XHRpZiAoYnVmZmVyID09IHRoaXMuX2J1ZmZlcikge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLl9idWZmZXIgPSBidWZmZXI7XG5cdFx0dGhpcy5fY2FjaGUgPSB7fTtcblx0XHR0aGlzLl9saW5lcyA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5zZXQodGhpcy52aWV3KCkucm9vdCgpLmNvZGUoKSk7XG5cdH07XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLmxpbmVzID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2xpbmVzIHx8ICh0aGlzLl9saW5lcyA9ICh0cnVlKSAmJiAoXG5cdFx0XHR0aGlzLl9idWZmZXIuc3BsaXQoJ1xcbicpXG5cdFx0KSk7XG5cdH07XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2J1ZmZlci5zcGxpdC5hcHBseSh0aGlzLl9idWZmZXIsYXJndW1lbnRzKTtcblx0fTtcblx0XG5cdEJ1ZmZlci5wcm90b3R5cGUubGluZWNvdW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMubGluZXMoKS5sZW5ndGg7XG5cdH07XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLmxpbmUgPSBmdW5jdGlvbiAobnIpe1xuXHRcdGlmICgodHlwZW9mIG5yPT0nbnVtYmVyJ3x8bnIgaW5zdGFuY2VvZiBOdW1iZXIpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5saW5lcygpW25yXSB8fCAnJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH07XG5cdH07XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLmxlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9idWZmZXIubGVuZ3RoO1xuXHR9O1xuXHRcblx0Ly8gbG9jYXRpb24gdG8gXG5cdEJ1ZmZlci5wcm90b3R5cGUubG9jVG9SYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0QnVmZmVyLnByb3RvdHlwZS5sb2NhdGlvbiA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0QnVmZmVyLnByb3RvdHlwZS5sb2NUb1JvdyA9IGZ1bmN0aW9uIChsb2Mpe1xuXHRcdHZhciBsbiA9IDA7XG5cdFx0dmFyIGxlbiA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMubGluZXMoKSksIGxlbl8gPSBhcnkubGVuZ3RoOyBpIDwgbGVuXzsgaSsrKSB7XG5cdFx0XHRsZW4gKz0gYXJ5W2ldLmxlbmd0aCArIDE7XG5cdFx0XHRpZiAobG9jIDwgbGVuKSB7IHJldHVybiBpIH07XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcy5saW5lcygpLmxlbmd0aDtcblx0fTtcblx0XG5cdEJ1ZmZlci5wcm90b3R5cGUubG9jVG9DZWxsID0gZnVuY3Rpb24gKGxvYyl7XG5cdFx0aWYgKHRoaXMuX2NhY2hlW2xvY10pIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYWNoZVtsb2NdO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIHBvcyA9IGxvYztcblx0XHR2YXIgY29sID0gMDtcblx0XHR2YXIgcm93ID0gMDtcblx0XHR2YXIgY2hhciQ7XG5cdFx0XG5cdFx0dmFyIGJ1ZiA9IHRoaXMuX2J1ZmZlcjtcblx0XHR2YXIgdGFic2l6ZSA9IHRoaXMuX3ZpZXcudGFiU2l6ZSgpO1xuXHRcdFxuXHRcdC8vIGdvIGJhY2sgdG8gc3RhcnQgb2YgbGluZVxuXHRcdC8vIGdvZXMgdGhyb3VnaCB0aGUgd2hvbGVcblx0XHR3aGlsZSAoY2hhciQgPSBidWZbcG9zIC0gMV0pe1xuXHRcdFx0aWYgKGNoYXIkID09ICdcXG4nKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fTtcblx0XHRcdHBvcy0tO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gZ2V0IGNvbHVtbiBmb3Igc2xpY2Vcblx0XHR3aGlsZSAoKHBvcyA8IGxvYykgJiYgKGNoYXIkID0gYnVmW3Bvc10pKXtcblx0XHRcdGlmIChjaGFyJCA9PSAnXFx0Jykge1xuXHRcdFx0XHR2YXIgcmVzdCA9IHRhYnNpemUgLSAoY29sICUgdGFic2l6ZSk7XG5cdFx0XHRcdGNvbCArPSByZXN0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29sICs9IDE7XG5cdFx0XHR9O1xuXHRcdFx0cG9zKys7XG5cdFx0fTtcblx0XHRcblx0XHR3aGlsZSAoY2hhciQgPSBidWZbcG9zIC0gMV0pe1xuXHRcdFx0aWYgKGNoYXIkID09ICdcXG4nKSB7XG5cdFx0XHRcdHJvdysrO1xuXHRcdFx0fTtcblx0XHRcdHBvcy0tO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXMuX2NhY2hlW2xvY10gPSBbcm93LGNvbF07XG5cdH07XG5cdFxuXHRCdWZmZXIucHJvdG90eXBlLnN1YnN0ciA9IGZ1bmN0aW9uIChyZWdpb24sbGVuKXtcblx0XHRpZiAocmVnaW9uIGluc3RhbmNlb2YgUmVnaW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYnVmZmVyLnN1YnN0cihyZWdpb24uc3RhcnQoKSxyZWdpb24uc2l6ZSgpKTtcblx0XHR9IGVsc2UgaWYgKCh0eXBlb2YgcmVnaW9uPT0nbnVtYmVyJ3x8cmVnaW9uIGluc3RhbmNlb2YgTnVtYmVyKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2J1ZmZlci5zdWJzdHIocmVnaW9uLGxlbiB8fCAxKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgJ211c3QgYmUgcmVnaW9uIG9yIG51bWJlcic7XG5cdFx0fTtcblx0fTtcblx0XG5cdEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fYnVmZmVyIHx8ICcnO1xuXHR9O1xuXHRyZXR1cm4gQnVmZmVyO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvY29yZS9idWZmZXIuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0dmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblx0XG5cdGZ1bmN0aW9uIE9ic2VydmVyKHZpZXcsY2ZnKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0c2VsZi5fYWN0aXZlID0gZmFsc2U7XG5cdFx0c2VsZi5fdmlldyA9IHZpZXc7XG5cdFx0c2VsZi5fY29uZmlnID0gY2ZnIHx8IHthdHRyaWJ1dGVzOiBmYWxzZSxjaGlsZExpc3Q6IHRydWUsY2hhcmFjdGVyRGF0YTogdHJ1ZSxzdWJ0cmVlOiB0cnVlfTtcblx0XHRzZWxmLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKG11dHMpIHsgcmV0dXJuIHNlbGYub25tdXRhdGlvbnMobXV0cyk7IH0pO1xuXHRcdHNlbGY7XG5cdH07XG5cdFxuXHRleHBvcnRzLk9ic2VydmVyID0gT2JzZXJ2ZXI7IC8vIGV4cG9ydCBjbGFzcyBcblx0XG5cdFxuXHRPYnNlcnZlci5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmlldzsgfVxuXHRPYnNlcnZlci5wcm90b3R5cGUuc2V0VmlldyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92aWV3ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0T2JzZXJ2ZXIucHJvdG90eXBlLmNvbmZpZyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fY29uZmlnOyB9XG5cdE9ic2VydmVyLnByb3RvdHlwZS5zZXRDb25maWcgPSBmdW5jdGlvbih2KXsgdGhpcy5fY29uZmlnID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0T2JzZXJ2ZXIucHJvdG90eXBlLmFjdGl2ZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fYWN0aXZlOyB9XG5cdE9ic2VydmVyLnByb3RvdHlwZS5zZXRBY3RpdmUgPSBmdW5jdGlvbih2KXsgdGhpcy5fYWN0aXZlID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRPYnNlcnZlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKCF0aGlzLl9hY3RpdmUpIHtcblx0XHRcdHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy52aWV3KCkucm9vdCgpLmRvbSgpLHRoaXMuY29uZmlnKCkpO1xuXHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0T2JzZXJ2ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKGJsayl7XG5cdFx0dmFyIHdhc0FjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcblx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRpZiAod2FzQWN0aXZlKSB7IHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKSB9O1xuXHRcdFxuXHRcdGlmIChibGsgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0YmxrKCk7XG5cdFx0XHRpZiAod2FzQWN0aXZlKSB0aGlzLnJlc3VtZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRPYnNlcnZlci5wcm90b3R5cGUucGF1c2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuICF0aGlzLl9hY3RpdmU7XG5cdH07XG5cdFxuXHRPYnNlcnZlci5wcm90b3R5cGUub25tdXRhdGlvbnMgPSBmdW5jdGlvbiAobXV0YXRpb25zKXtcblx0XHR2YXIgZWw7XG5cdFx0dGhpcy52aWV3KCkubG9nZ2VyKCkuZ3JvdXAoJ211dGF0aW9ucycpO1xuXHRcdFxuXHRcdHZhciBkZWVwID0gZmFsc2U7XG5cdFx0dmFyIG5vZGVzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG11dGF0aW9ucyksIGxlbiA9IGFyeS5sZW5ndGgsIG11dDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRtdXQgPSBhcnlbaV07XG5cdFx0XHR0aGlzLnZpZXcoKS5sb2coJ211dGF0aW9uJyxtdXQpO1xuXHRcdFx0dmFyIHR5cGUgPSBtdXQudHlwZTtcblx0XHRcdHZhciB0YXJnZXQgPSBtdXQucHJldmlvdXNTaWJsaW5nIHx8IG11dC50YXJnZXQ7XG5cdFx0XHRcblx0XHRcdGlmICh0eXBlID09ICdjaGFyYWN0ZXJEYXRhJykge1xuXHRcdFx0XHR0aGlzLnZpZXcoKS5sb2coKFwidXBkYXRlZCBjb2RlIHRvIFwiICsgKHRhcmdldC50ZXh0Q29udGVudCkpKTtcblx0XHRcdFx0dGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gJ2NoaWxkTGlzdCcpIHtcblx0XHRcdFx0ZGVlcCA9IHRydWU7XG5cdFx0XHRcdHZhciBhZGQgPSBtdXQuYWRkZWROb2Rlcztcblx0XHRcdFx0aWYgKGFkZC5sZW5ndGggPT0gMSAmJiAoYWRkWzBdIGluc3RhbmNlb2YgRWxlbWVudCkpIHtcblx0XHRcdFx0XHR0YXJnZXQgPSBhZGRbMF07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0aGlzLnZpZXcoKS5sb2codGFyZ2V0LHRhZyR3cmFwKHRhcmdldCkpO1xuXHRcdFx0Ly8gdmFyIGFkZGVkID0gbXV0OmFkZGVkTm9kZXNcblx0XHRcdC8vIGZvciBub2RlIGluIG11dDphZGRlZE5vZGVzXG5cdFx0XHQvLyBpZiB0YXJnZXQgYW5kIHRhcmdldDpwYXJlbnROb2RlICMgYW5kIHRhcmdldC5AdGFnXG5cdFx0XHRpZiAoZWwgPSB0YWckd3JhcCh0YXJnZXQpKSB7XG5cdFx0XHRcdHRoaXMudmlldygpLmxvZygnYWRkIHRhcmdldD8hJyk7XG5cdFx0XHRcdGlmIChub2Rlcy5pbmRleE9mKGVsKSA8IDApIHsgbm9kZXMucHVzaChlbCkgfTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8vIGlmIHdlIGhhdmUgYWRkZWQgYSBub2RlIGluc3RlYWRcblx0XHR9O1xuXHRcdFxuXHRcdC8vIG11dGF0aW9ucyBhcmUgbm90IHJlZ2lzdGVyZWQgb24gbm9kZS1sZXZlbCBidXQgb24gZXh0ZW50XG5cdFx0Ly8gbm90IHJlYWxseSBob3cgdGhpcyBzaG91bGQgaGFwcGVuXG5cdFx0XG5cdFx0dmFyIGNvbW1vbiA9IHV0aWwuY29tbW9uQW5jZXN0b3Iobm9kZXMpO1xuXHRcdFxuXHRcdHRoaXMudmlldygpLmxvZygnY29tbW9uIGNvbnRhaW5lciBmb3IgbXV0YXRpb25zIGlzJyxjb21tb24sbm9kZXMpO1xuXHRcdFxuXHRcdHZhciBleHRlbnQ7XG5cdFx0XG5cdFx0aWYgKG5vZGVzLmxlbmd0aCA9PSAxKSB7XG5cdFx0XHR0aGlzLnZpZXcoKS5sb2coJ2Egc2luZ2xlIG5vZGUgd2FzIG11dGF0ZWQnLG5vZGVzWzBdKTtcblx0XHRcdG5vZGVzWzBdLm11dGF0ZWQoe2RlZXA6IGRlZXAsbXV0YXRpb25zOiBtdXRhdGlvbnN9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gY29sbGVjdCBleHRlbnRzIGZvciBhbGwgbm9kZXM/XG5cdFx0XHQvLyByYXRoZXIgbWFrZSBhIHJlZ2lvbiBleHBhbmQgXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbm9kZXMubGVuZ3RoLCBub2RlOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0bm9kZSA9IG5vZGVzW2ldO1xuXHRcdFx0XHRpZiAoZXh0ZW50ICYmIGV4dGVudC5jb250YWlucyhub2RlLmRvbSgpKSkgeyAvLyA6bm9kZXMuaW5kZXhPZihub2RlLmRvbSkgPj0gMFxuXHRcdFx0XHRcdHRoaXMudmlldygpLmxvZygndGhpcyBub2RlIGlzIGFscmVhZHkgcGFydCBvZiB0aGUgZXh0ZW50Jyxub2RlLmRvbSgpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRleHRlbnQgPSBub2RlLmRpcnR5RXh0ZW50KCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdC8vIG5vZGU/Lm11dGF0ZWRcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChleHRlbnQpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2ZvdW5kIGV4dGVudCghKScsZXh0ZW50XG5cdFx0XHRcdHRoaXMucGF1c2UoZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9KTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLnZpZXcoKS5sb2dnZXIoKS5ncm91cEVuZCgpO1xuXHRcdHRoaXMudmlldygpLm9ubXV0YXRpb25zKHtub2Rlczogbm9kZXMsbXV0YXRpb25zOiBtdXRhdGlvbnMsZXh0ZW50OiBleHRlbnR9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0cmV0dXJuIE9ic2VydmVyO1xuXHRcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvb2JzZXJ2ZXIuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0dmFyIFJlZ2lvbiA9IHJlcXVpcmUoJy4uL3JlZ2lvbicpLlJlZ2lvbjtcblx0XG5cdHZhciBsYWJlbHMgPSB7XG5cdFx0XCJVbmV4cGVjdGVkICdUQUdfRU5EJ1wiOiAnVGFnIGNsb3NlZCB1bmV4cGVjdGVkbHknLFxuXHRcdFwiVW5leHBlY3RlZCAnVEVSTUlOQVRPUidcIjogJ1VuZXhwZWN0ZWQg4o+OJyxcblx0XHRcIlVuZXhwZWN0ZWQgJ1BPU1RfSUYnXCI6ICdNaXNzaW5nIGJvZHkgaW4gPGI+SUY8L2I+J1xuXHR9O1xuXHRcblx0dmFyIHJ1bGVzID0gW1xuXHRcdFsvVW5jYXVnaHQgRXJyb3I6IHRhZyAoXFx3KykgaXMgbm90IGRlZmluZWQvLFwidGFnIDxiPiQxPC9iPiBkb2VzIG5vdCBleGlzdFwiXVxuXHRdO1xuXHRcblx0ZnVuY3Rpb24gSGludChvcHRzLHZpZXcpe1xuXHRcdHRoaXMuX3ZpZXcgPSB2aWV3O1xuXHRcdHRoaXMuX2RhdGEgPSBvcHRzO1xuXHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdHRoaXMuX3JlZ2lvbiA9IG9wdHMubG9jID8gKFJlZ2lvbi5ub3JtYWxpemUob3B0cy5sb2MsdmlldykpIDogKG51bGwpO1xuXHRcdC8vIHRyeSB0byBmaW5kIHRoZSBub2RlIGltbWVkaWF0ZWx5XG5cdFx0dGhpcy5fbm9kZSA9IG9wdHMubm9kZSB8fCB0aGlzLm5vZGUoKTtcblx0XHR0aGlzO1xuXHR9O1xuXHRcblx0ZXhwb3J0cy5IaW50ID0gSGludDsgLy8gZXhwb3J0IGNsYXNzIFxuXHRIaW50LmJ1aWxkID0gZnVuY3Rpb24gKG8sdmlldyl7XG5cdFx0cmV0dXJuIG5ldyB0aGlzKG8sdmlldyk7XG5cdH07XG5cdFxuXHRcblx0XG5cdEhpbnQucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZpZXc7IH1cblx0SGludC5wcm90b3R5cGUuc2V0VmlldyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92aWV3ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0SGludC5wcm90b3R5cGUucmVnaW9uID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yZWdpb247IH1cblx0SGludC5wcm90b3R5cGUuc2V0UmVnaW9uID0gZnVuY3Rpb24odil7IHRoaXMuX3JlZ2lvbiA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEhpbnQucHJvdG90eXBlLmFjdGl2ZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fYWN0aXZlOyB9XG5cdEhpbnQucHJvdG90eXBlLnNldEFjdGl2ZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9hY3RpdmUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEhpbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChrZXkpe1xuXHRcdHJldHVybiB0aGlzLl9kYXRhW2tleV07XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoa2V5LHZhbCl7XG5cdFx0dGhpcy5fZGF0YVtrZXldID0gdmFsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGludC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9kYXRhLnR5cGUgfHwgJ2Vycm9yJztcblx0fTtcblx0XG5cdEhpbnQucHJvdG90eXBlLmdyb3VwID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGEuZ3JvdXA7XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fZGF0YS5yZWY7XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX25vZGUgfHwgKHRoaXMuX25vZGUgPSB0aGlzLl9yZWdpb24gJiYgdGhpcy52aWV3KCkubm9kZUF0UmVnaW9uKHRoaXMuX3JlZ2lvbikpO1xuXHR9O1xuXHRcblx0SGludC5wcm90b3R5cGUucm93ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMucmVnaW9uKCkucm93KCk7XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5jb2wgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5yZWdpb24oKS5jb2woKTtcblx0fTtcblx0XG5cdEhpbnQucHJvdG90eXBlLmxhYmVsID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGxibDtcblx0XHRyZXR1cm4gdGhpcy5fbGFiZWwgfHwgKHRoaXMuX2xhYmVsID0gKHRydWUpICYmIChcblx0XHRcdGxibCA9IHRoaXMuX2RhdGEubGFiZWwgfHwgdGhpcy5fZGF0YS5tZXNzYWdlIHx8ICdIaW50Jyxcblx0XHRcdGxibCA9IGxibC5zcGxpdCgvZXJyb3IgYXQgKFxcW1tcXGRcXDpdKlxcXSlcXDpcXHMqLykucG9wKCksXG5cdFx0XHRsYmwgPSBsYWJlbHNbbGJsXSB8fCBsYmxcblx0XHQpKTtcblx0fTtcblx0XG5cdFxuXHRIaW50LnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBub2RlXztcblx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkge1xuXHRcdFx0Ly8gbm9kZT8uc2V0QXR0cmlidXRlKCdoaW50JyxyZWYpXG5cdFx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlO1xuXHRcdFx0KG5vZGVfID0gdGhpcy5ub2RlKCkpICYmIG5vZGVfLnNldEhpbnQgICYmICBub2RlXy5zZXRIaW50KHRoaXMpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0Y29uc29sZS5sb2coJ2RlYWN0aXZhdGUgaGludCEhJyk7XG5cdFx0dGhpcy5zZXRBY3RpdmUoZmFsc2UpO1xuXHRcdHJldHVybiB0aGlzO1xuXHRcdC8vIGNsZWFudXBcblx0XHQvLyByZW1vdmVcblx0fTtcblx0XG5cdEhpbnQucHJvdG90eXBlLnBydW5lID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMudmlldygpLmhpbnRzKCkucHJ1bmUodGhpcyk7XG5cdH07XG5cdFxuXHQvLyBzaG91bGQgbWFrZSB0aGlzIGhpbnQgcmVhZHkgdG8gYmUgcmVtb3ZlZFxuXHRIaW50LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKHRoaXMuX25vZGUpIHtcblx0XHRcdGlmICh0aGlzLl9ub2RlLmhpbnQoKSA9PSB0aGlzKSB7IHRoaXMuX25vZGUuc2V0SGludChudWxsKSB9O1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRIaW50LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLnZpZXcoKS5oaW50cygpLnJlbSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEhpbnQucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbiAoKXtcblx0XHQvLyBjb25zb2xlLmxvZyAnZGVhY3RpdmF0ZSBvbiBjaGFuZ2VkISdcblx0XHQvLyBAZGVhY3RpdmF0ZSA9IHllc1xuXHRcdHRoaXMucHJ1bmUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEhpbnQucHJvdG90eXBlLmFkanVzdCA9IGZ1bmN0aW9uIChyZWcsaW5zKXtcblx0XHRpZihpbnMgPT09IHVuZGVmaW5lZCkgaW5zID0gdHJ1ZTtcblx0XHRpZiAodGhpcy5yZWdpb24oKS5pbnRlcnNlY3RzKHJlZykpIHtcblx0XHRcdC8vIGRlYWN0aXZhdGVcblx0XHRcdHRoaXMucHJ1bmUoKTtcblx0XHRcdC8vIEBkZWFjdGl2YXRlID0geWVzXG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLnJlZ2lvbigpLmFkanVzdChyZWcsaW5zKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdGZ1bmN0aW9uIEhpbnRzKHZpZXcpe1xuXHRcdHRoaXMuX3BydW5lID0gW107XG5cdFx0dGhpcy5fYXJyYXkgPSBbXTtcblx0XHR0aGlzLl9tYXAgPSB7fTtcblx0XHR0aGlzLl92aWV3ID0gdmlldztcblx0fTtcblx0XG5cdGV4cG9ydHMuSGludHMgPSBIaW50czsgLy8gZXhwb3J0IGNsYXNzIFxuXHR2YXIgbnIgPSAwO1xuXHRcblx0SGludHMucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fYXJyYXk7XG5cdH07XG5cdFxuXHRIaW50cy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHJlZil7XG5cdFx0cmV0dXJuIHRoaXMuX21hcFtyZWZdO1xuXHR9O1xuXHRcblx0SGludHMucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHRoaXMuX2FycmF5KSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRhcnlbaV0uYWN0aXZhdGUoKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Ly8gdGhpcyBzaG91bGQgdGFrZSBjYXJlIG9mIGRlYWxsb2NhdGluZyB0aGUgaGludCBubz9cblx0SGludHMucHJvdG90eXBlLnJlbSA9IGZ1bmN0aW9uIChoaW50KXtcblx0XHRpZiAoaGludCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRoaW50ID0gdGhpcy5fYXJyYXkuZmlsdGVyKGhpbnQpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKGhpbnQgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGhpbnQpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dGhpcy5yZW0oYXJ5W2ldKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gaGludDtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICgodHlwZW9mIGhpbnQ9PSdzdHJpbmcnfHxoaW50IGluc3RhbmNlb2YgU3RyaW5nKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVtKHRoaXMuZ2V0KGhpbnQpKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICh0aGlzLl9hcnJheS5pbmRleE9mKGhpbnQpID49IDApIHtcblx0XHRcdGhpbnQuY2xlYW51cCgpO1xuXHRcdFx0dGhpcy5fYXJyYXkuc3BsaWNlKHRoaXMuX2FycmF5LmluZGV4T2YoaGludCksMSk7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gaGludDtcblx0fTtcblx0XG5cdEhpbnRzLnByb3RvdHlwZS5wcnVuZSA9IGZ1bmN0aW9uIChoaW50KXtcblx0XHRpZiAodGhpcy5fcHJ1bmUuaW5kZXhPZihoaW50KSA8IDApIHsgdGhpcy5fcHJ1bmUucHVzaChoaW50KSB9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGludHMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIGFyciA9IHRoaXMuX2FycmF5O1xuXHRcdHRoaXMuX2FycmF5ID0gW107XG5cdFx0XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKGFyciksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0YXJ5W2ldLmRlYWN0aXZhdGUoKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0SGludHMucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKXtcblx0XHRcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0c2VsZi5fYXJyYXkubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdGlmIChzZWxmLl9wcnVuZS5pbmRleE9mKGl0ZW0pID49IDApIHtcblx0XHRcdFx0aXRlbS5kZWFjdGl2YXRlKCk7XG5cdFx0XHRcdHJldHVybiBzZWxmLnJlbShpdGVtKTtcblx0XHRcdH07XG5cdFx0fSk7XG5cdFx0c2VsZi5fcHJ1bmUgPSBbXTtcblx0XHRyZXR1cm4gc2VsZjtcblx0fTtcblx0XG5cdFxuXHRIaW50cy5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGNiKXtcblx0XHRyZXR1cm4gdGhpcy5fYXJyYXkuZmlsdGVyKGNiKTtcblx0fTtcblx0XG5cdEhpbnRzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobyl7XG5cdFx0dmFyIHJlZiA9IG8ucmVmID0gKFwiaGludFwiICsgKG5yKyspKTtcblx0XHRpZiAoISgobyBpbnN0YW5jZW9mIEhpbnQpKSkgeyBvID0gSGludC5idWlsZChvLHRoaXMuX3ZpZXcpIH07XG5cdFx0dGhpcy5fbWFwW3JlZl0gPSBvO1xuXHRcdHRoaXMuX2FycmF5LnB1c2gobyk7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cdHJldHVybiBIaW50cztcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvaGludHMuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0dmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblx0dmFyIFJlZ2lvbiA9IHJlcXVpcmUoJy4uL3JlZ2lvbicpLlJlZ2lvbjtcblx0XG5cdGZ1bmN0aW9uIFJvd0NvbChyb3csY29sLGNhcmV0KXtcblx0XHRpZihyb3cgPT09IHVuZGVmaW5lZCkgcm93ID0gMDtcblx0XHRpZihjb2wgPT09IHVuZGVmaW5lZCkgY29sID0gMDtcblx0XHRpZihjYXJldCA9PT0gdW5kZWZpbmVkKSBjYXJldCA9IG51bGw7XG5cdFx0dGhpcy5fcm93ID0gcm93O1xuXHRcdHRoaXMuX2NvbCA9IGNvbDtcblx0XHR0aGlzLl9jYXJldCA9IGNhcmV0O1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUucm93ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yb3c7IH1cblx0Um93Q29sLnByb3RvdHlwZS5zZXRSb3cgPSBmdW5jdGlvbih2KXsgdGhpcy5fcm93ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRcblx0Um93Q29sLnByb3RvdHlwZS5jb2wgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2NvbDsgfVxuXHRSb3dDb2wucHJvdG90eXBlLnNldENvbCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9jb2wgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLmNhcmV0ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9jYXJldDsgfVxuXHRSb3dDb2wucHJvdG90eXBlLnNldENhcmV0ID0gZnVuY3Rpb24odil7IHRoaXMuX2NhcmV0ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5jYXJldCgpLnZpZXcoKTtcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKCl7XG5cdFx0dGhpcy5fY29sID0gdGhpcy5yZWFsQ29sKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChyb3csY29sKXtcblx0XHR2YXIgYXJ5O1xuXHRcdGlmIChyb3cgaW5zdGFuY2VvZiBSb3dDb2wpIHtcblx0XHRcdGNvbCA9IHJvdy5jb2woKTtcblx0XHRcdHJvdyA9IHJvdy5yb3coKTtcblx0XHRcdFxuXHRcdFx0Ly8gcmV0dXJuIHNldChyb3cucm93LHJvdy5jb2wpXG5cdFx0fTtcblx0XHRcblx0XHRpZiAocm93IGluc3RhbmNlb2YgUmVnaW9uKSB7XG5cdFx0XHR2YXIgYXJ5ID0gaXRlciQodXRpbC5yb3djb2wodGhpcy52aWV3KCkuX2J1ZmZlcixyb3cuc3RhcnQoKSkpO3JvdyA9IGFyeVswXTtjb2wgPSBhcnlbMV07XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgbGMgPSB0aGlzLnZpZXcoKS5fYnVmZmVyLmxpbmVjb3VudCgpO1xuXHRcdFxuXHRcdGlmIChyb3cgPj0gbGMpIHtcblx0XHRcdHJvdyA9IGxjIC0gMTtcblx0XHRcdGNvbCA9IDEwMDA7XG5cdFx0fTtcblx0XHRcblx0XHR0aGlzLl9yb3cgPSByb3c7XG5cdFx0dGhpcy5fY29sID0gY29sO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uIChvZmZzZXQpe1xuXHRcdHRoaXMubm9ybWFsaXplKCk7XG5cdFx0XG5cdFx0dmFyIGNvbCA9IHRoaXMucmVhbENvbCgpICsgb2Zmc2V0O1xuXHRcdHZhciBsbGVuID0gdGhpcy5saW5lbGVuKCk7XG5cdFx0XG5cdFx0dmFyIGxsb2MgPSB0aGlzLmxpbmVsb2MoKTtcblx0XHQvLyBmaW5kIHRoZSByZWFsIG9mZnNldCBpbiBjaGFyYWN0ZXJzIChub3QgY29sdW1ucylcblx0XHRcblx0XHRcblx0XHQvLyBpZiBvZmZzZXQgPCAwXG5cdFx0Ly8gXHQjIG5vcm1hbGl6ZT9cblx0XHQvLyBcdEBjb2wgPSBNYXRoLm1pbihAY29sLGxsZW4pXG5cdFx0XG5cdFx0aWYgKGNvbCA8IDApIHtcblx0XHRcdGlmICh0aGlzLl9yb3cgPiAwKSB7XG5cdFx0XHRcdHRoaXMubW92ZVVwKCk7XG5cdFx0XHRcdHRoaXMuX2NvbCA9IHRoaXMubGluZWxlbigpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fcm93ID0gMDtcblx0XHRcdFx0dGhpcy5fY29sID0gMDtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9IGVsc2UgaWYgKGNvbCA+IGxsZW4pIHtcblx0XHRcdGlmICh0aGlzLl9yb3cgPj0gKHRoaXMudmlldygpLl9idWZmZXIubGluZWNvdW50KCkgLSAxKSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRoaXMubW92ZURvd24oKTtcblx0XHRcdHZhciByZXN0ID0gTWF0aC5tYXgoMCxjb2wgLSBsbGVuIC0gMSk7XG5cdFx0XHR2YXIgbW92ZXMgPSB1dGlsLmNvbHNGb3JMaW5lKHRoaXMubGluZXN0cigpLnN1YnN0cigwLHJlc3QpKTtcblx0XHRcdHRoaXMuX2NvbCA9IG1vdmVzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHQvLyB0aGlzIHNob3VsZCB3b3JrXG5cdFx0dGhpcy5fY29sID0gdXRpbC5jb2xzRm9yTGluZSh0aGlzLmxpbmVzdHIoKS5zdWJzdHIoMCxsbG9jICsgb2Zmc2V0KSk7XG5cdFx0Ly8gQGNvbCArPSBvZmZzZXRcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUubW92ZVVwID0gZnVuY3Rpb24gKGxlbil7XG5cdFx0dGhpcy5fcm93ID0gTWF0aC5tYXgoMCx0aGlzLl9yb3cgLSAxKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUubW92ZURvd24gPSBmdW5jdGlvbiAobGVuKXtcblx0XHRjb25zb2xlLmxvZygnbW92ZURvd24nKTtcblx0XHR2YXIgbGMgPSB0aGlzLnZpZXcoKS5fYnVmZmVyLmxpbmVjb3VudCgpOyAvLyBzcGxpdCgnXFxuJylbOmxlbmd0aF1cblx0XHR0aGlzLl9yb3cgPSB0aGlzLl9yb3cgKyAxO1xuXHRcdGlmICh0aGlzLl9yb3cgPj0gbGMpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdvdXQgb2YgYm91bmRzJyk7XG5cdFx0XHR0aGlzLnNldExvYyh0aGlzLnZpZXcoKS5fYnVmZmVyLmxlbigpKTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBuZXcgUm93Q29sKHRoaXMucm93KCksdGhpcy5jb2woKSx0aGlzLmNhcmV0KCkpO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS5saW5lbGVuID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHV0aWwuY29sc0ZvckxpbmUodGhpcy5saW5lc3RyKCkpO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS5saW5lbG9jID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHV0aWwuY29sVG9Mb2ModGhpcy5saW5lc3RyKCksdGhpcy5yZWFsQ29sKCkpO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS5yZWFsQ29sID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHJjID0gdXRpbC5jb2xUb1ZpZXdDb2wodGhpcy5saW5lc3RyKCksdGhpcy5fY29sKTtcblx0XHRyZXR1cm4gcmM7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLmxpbmVzdHIgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy52aWV3KCkubGluZXN0cih0aGlzLnJvdygpKTtcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUucGVla2JlaGluZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzdHIgPSB0aGlzLmxpbmVzdHIoKTtcblx0XHRyZXR1cm4gc3RyLnN1YnN0cigwLHV0aWwuY29sVG9Mb2Moc3RyLHRoaXMucmVhbENvbCgpKSk7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLnBlZWthaGVhZCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzdHIgPSB0aGlzLmxpbmVzdHIoKTtcblx0XHRyZXR1cm4gc3RyLnNsaWNlKHV0aWwuY29sVG9Mb2Moc3RyLHRoaXMucmVhbENvbCgpKSk7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLnNldExvYyA9IGZ1bmN0aW9uIChsb2Mpe1xuXHRcdHZhciBhcnk7XG5cdFx0dmFyIGFyeSA9IGl0ZXIkKHV0aWwucm93Y29sKHRoaXMudmlldygpLl9idWZmZXIsbG9jKSk7dmFyIHJvdyA9IGFyeVswXSxjb2wgPSBhcnlbMV07XG5cdFx0dGhpcy5zZXQocm93LGNvbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSb3dDb2wucHJvdG90eXBlLmxvYyA9IGZ1bmN0aW9uICgpe1xuXHRcdC8vIHNob3VsZCBjYWNoZSghKVxuXHRcdHZhciBsaW5lcyA9IHRoaXMudmlldygpLl9idWZmZXIubGluZXMoKTtcblx0XHQvLyB2YXIgbGluZXMgPSB2aWV3LmJ1ZmZlci5zcGxpdCgnXFxuJylcblx0XHR2YXIgbG9jID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQobGluZXMpLCBsZW4gPSBhcnkubGVuZ3RoLCBsaW5lOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGxpbmUgPSBhcnlbaV07XG5cdFx0XHR2YXIgbG4gPSBsaW5lLmxlbmd0aDtcblx0XHRcdGlmIChpIDwgdGhpcy5fcm93KSB7XG5cdFx0XHRcdGxvYyArPSBsbiArIDE7IC8vIGluY2x1ZGUgbmV3bGluZVxuXHRcdFx0fSBlbHNlIGlmIChpID09IHRoaXMuX3Jvdykge1xuXHRcdFx0XHR2YXIgdmlld2NvbCA9IHV0aWwuY29sVG9WaWV3Q29sKGxpbmUsdGhpcy5fY29sKTtcblx0XHRcdFx0dmFyIG9mZnNldCA9IHV0aWwuY29sVG9Mb2MobGluZSx2aWV3Y29sKTtcblx0XHRcdFx0bG9jICs9IE1hdGgubWluKGxuLG9mZnNldCk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0cmV0dXJuIGxvYztcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUudGFiID0gZnVuY3Rpb24gKCl7XG5cdFx0Ly8gd3JvbmcgLSBuZWVkIHRvIHJvdW5kIGluc3RlYWQ/XG5cdFx0XG5cdFx0dmFyIGxmdCA9IHRoaXMuY29sKCkgJSA0O1xuXHRcdHRoaXMuc2V0Q29sKHRoaXMuY29sKCkgKyAoNCAtIGxmdCkpOyAvLyBNYXRoLmZsb29yKGNvbCAvIDQpICogNCArIDRcblx0XHRjb25zb2xlLmxvZygnbWFya2VyIHRhYicsbGZ0LHRoaXMuY29sKCksdGhpcy5yZWFsQ29sKCkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Um93Q29sLnByb3RvdHlwZS51bnRhYiA9IGZ1bmN0aW9uICgpe1xuXHRcdGNvbnNvbGUubG9nKCd1bnRhYicsdGhpcy5jb2woKSk7XG5cdFx0dmFyIHJlc3QgPSA0IC0gdGhpcy5jb2woKSAlIDQ7XG5cdFx0dGhpcy5zZXRDb2woTWF0aC5jZWlsKHRoaXMuY29sKCkgLyA0KSAqIDQgLSA0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdFJvd0NvbC5wcm90b3R5cGUuYWx0ZXIgPSBmdW5jdGlvbiAobW9kZSxkaXIpe1xuXHRcdHZhciAkMSwgJDIsICQzLCAkNCwgJDUsICQ2O1xuXHRcdHZhciBub2RlcyA9IHRoaXMuY2FyZXQoKS52aWV3KCkubm9kZXNJblJlZ2lvbih0aGlzLmxvYygpLGZhbHNlKTtcblx0XHR2YXIgbm9kZSA9IG5vZGVzWzBdO1xuXHRcdHZhciBtaWQgPSBub2RlICYmIG5vZGUubm9kZTtcblx0XHR2YXIgbGZ0ID0gbm9kZXMucHJldiAmJiBub2Rlcy5wcmV2Lm5vZGU7XG5cdFx0dmFyIHJndCA9IG5vZGVzLm5leHQgJiYgbm9kZXMubmV4dC5ub2RlO1xuXHRcdHZhciBwYXJ0O1xuXHRcdFxuXHRcdC8vIGxvZyAnbW92ZScsb2Zmc2V0LG1vZGUsbm9kZXNcblx0XHRpZiAobW9kZSA9PSBJTS5XT1JEX1NUQVJUKSB7XG5cdFx0XHR2YXIgZWwgPSBtaWQgfHwgbGZ0O1xuXHRcdFx0aWYgKCgkMSA9IGxmdCkgJiYgJDEubWF0Y2hlcyAgJiYgICQxLm1hdGNoZXMocSQoJy5faW1jbG9zZScsdGhpcykpKSB7XG5cdFx0XHRcdHRoaXMuc2V0TG9jKGxmdC5wYXJlbnQoKS5yZWdpb24oKS5zdGFydCgpKTtcblx0XHRcdH0gZWxzZSBpZiAoKCQyID0gbGZ0KSAmJiAkMi5tYXRjaGVzICAmJiAgJDIubWF0Y2hlcyhxJCgnLl9pbXN0cicsdGhpcykpKSB7XG5cdFx0XHRcdHRoaXMuc2V0TG9jKGxmdC5yZWdpb24oKS5zdGFydCgpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBsb2MgPSB0aGlzLmxvYygpO1xuXHRcdFx0XHQvLyBsZXQgYnVmID0gdmlldy5idWZmZXJcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ3BlZWtiZWhpbmQnLHBlZWtiZWhpbmQsbG9jLHN0clxuXHRcdFx0XHR2YXIgc3RyID0gdGhpcy5wZWVrYmVoaW5kKCkuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcblx0XHRcdFx0bG9jIC09IHN0ci5tYXRjaCgvXihbXFxzXFx0XFwuXSouKz98KShcXGJ8JCkvKVsxXS5sZW5ndGg7XG5cdFx0XHRcdHRoaXMuc2V0TG9jKGxvYyk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAobW9kZSA9PSBJTS5XT1JEX0VORCkge1xuXHRcdFx0ZWwgPSBtaWQgfHwgcmd0O1xuXHRcdFx0aWYgKCgkMyA9IHJndCkgJiYgJDMubWF0Y2hlcyAgJiYgICQzLm1hdGNoZXMocSQoJy5faW1vcGVuJyx0aGlzKSkpIHtcblx0XHRcdFx0dGhpcy5zZXRMb2Mocmd0LnBhcmVudCgpLnJlZ2lvbigpLmVuZCgpKTtcblx0XHRcdH0gZWxzZSBpZiAoKCQ0ID0gcmd0KSAmJiAkNC5tYXRjaGVzICAmJiAgJDQubWF0Y2hlcyhxJCgnLl9pbXN0cicsdGhpcykpKSB7XG5cdFx0XHRcdHRoaXMuc2V0TG9jKHJndC5yZWdpb24oKS5lbmQoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgbG9jMSA9IHRoaXMubG9jKCk7XG5cdFx0XHRcdC8vIGxldCBidWYgPSB2aWV3LmJ1ZmZlclxuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nICdwZWVrYWhlYWQnLHBlZWthaGVhZCxsb2Ncblx0XHRcdFx0bG9jMSArPSB0aGlzLnBlZWthaGVhZCgpLm1hdGNoKC9eKFtcXHNcXC5dKi4rP3wpKFxcYnwkKS8pWzFdLmxlbmd0aDtcblx0XHRcdFx0Ly8gbG9jKysgdW50aWwgYnVmW2xvY10ubWF0Y2goL1tcXG5cXF0vKVxuXHRcdFx0XHR0aGlzLnNldExvYyhsb2MxKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmIChtb2RlID09IElNLkxJTkVfRU5EKSB7XG5cdFx0XHR0aGlzLnNldCh0aGlzLnJvdygpLDEwMDApO1xuXHRcdH0gZWxzZSBpZiAobW9kZSA9PSBJTS5MSU5FX1NUQVJUKSB7XG5cdFx0XHQvLyBGSVhNRSB0YWJzLWZvci1zcGFjZXNcblx0XHRcdHZhciB0YWJzID0gdGhpcy5saW5lc3RyKCkubWF0Y2goL15cXHQqLylbMF0ubGVuZ3RoO1xuXHRcdFx0dmFyIG5ld2NvbCA9IHRhYnMgKiB0aGlzLnZpZXcoKS50YWJTaXplKCk7XG5cdFx0XHR0aGlzLnNldENvbCh0aGlzLmNvbCgpID4gbmV3Y29sID8gKG5ld2NvbCkgOiAoMCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoZGlyIDwgMCAmJiAoJDUgPSBsZnQpICYmICQ1Lm1hdGNoZXMgICYmICAkNS5tYXRjaGVzKCcuX2ltdGFiJykpIHtcblx0XHRcdFx0Ly8gaGVhZC5jb2wgPSBoZWFkLmNvbCAtIDRcblx0XHRcdFx0Ly8gY2FyZXQudmlldy5sb2cgJ3JpZ2h0IGlzIHRhYicsbGZ0LnJlZ2lvblxuXHRcdFx0XHR0aGlzLnNldExvYyhsZnQucmVnaW9uKCkuc3RhcnQoKSk7XG5cdFx0XHRcdC8vIGhlYWQudW50YWJcblx0XHRcdH0gZWxzZSBpZiAoZGlyID4gMCAmJiAoJDYgPSByZ3QpICYmICQ2Lm1hdGNoZXMgICYmICAkNi5tYXRjaGVzKCcuX2ltdGFiJykpIHtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIHVzZSB0YWIgaW5zdGVhZFxuXHRcdFx0XHR0aGlzLnRhYigpO1xuXHRcdFx0XHQvLyBoZWFkLmNvbCA9IGhlYWQuY29sICsgNFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gLi4uXG5cdFx0XHRcdHRoaXMubW92ZShkaXIpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltY2FyZXRoZWFkJyk7XG5cdFxuXHQvLyBzaG91bGQgbW92ZSBpbnRvIE1hcmtlciAobGlrZSBBdG9tKVxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2ltY2FyZXQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVnaW9uID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yZWdpb247IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJlZ2lvbiA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9yZWdpb24gPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZpZXc7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubGluZXMgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2xpbmVzOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRMaW5lcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9saW5lcyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmFuZ2VzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yYW5nZXM7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJhbmdlcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9yYW5nZXMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLl9fbW9kZSA9IHt3YXRjaDogJ21vZGVEaWRTZXQnLG5hbWU6ICdtb2RlJ307XG5cdFx0dGFnLnByb3RvdHlwZS5tb2RlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9tb2RlOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRNb2RlID0gZnVuY3Rpb24odil7XG5cdFx0XHR2YXIgYSA9IHRoaXMubW9kZSgpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuX21vZGUgPSB2OyB9XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5tb2RlRGlkU2V0ICYmIHRoaXMubW9kZURpZFNldCh2LGEsdGhpcy5fX21vZGUpIH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX2NvbCA9IHsnZGVmYXVsdCc6IDAsd2F0Y2g6ICdkaXJ0eScsbmFtZTogJ2NvbCd9O1xuXHRcdHRhZy5wcm90b3R5cGUuY29sID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9jb2w7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldENvbCA9IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGEgPSB0aGlzLmNvbCgpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuX2NvbCA9IHY7IH1cblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLmRpcnR5ICYmIHRoaXMuZGlydHkodixhLHRoaXMuX19jb2wpIH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHR0YWcucHJvdG90eXBlLl9jb2wgPSAwOyAvLyB0aGUgcmVhbCBjb2x1bW4gb2YgdGhlIGNhcmV0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX3JvdyA9IHsnZGVmYXVsdCc6IDAsd2F0Y2g6ICdkaXJ0eScsbmFtZTogJ3Jvdyd9O1xuXHRcdHRhZy5wcm90b3R5cGUucm93ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yb3c7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFJvdyA9IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGEgPSB0aGlzLnJvdygpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuX3JvdyA9IHY7IH1cblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLmRpcnR5ICYmIHRoaXMuZGlydHkodixhLHRoaXMuX19yb3cpIH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHR0YWcucHJvdG90eXBlLl9yb3cgPSAwO1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5wdXQgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2lucHV0OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRJbnB1dCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9pbnB1dCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudGFpbCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdGFpbDsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VGFpbCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl90YWlsID0gdjsgcmV0dXJuIHRoaXM7IH07IC8vIHJvd2NvbFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaGVhZCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5faGVhZDsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SGVhZCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9oZWFkID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9oYXNoOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIYXNoID0gZnVuY3Rpb24odil7IHRoaXMuX2hhc2ggPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uIChsZnQscmd0KXtcblx0XHRcdHZhciBhcnk7XG5cdFx0XHRpZihsZnQgPT09IHVuZGVmaW5lZCkgbGZ0ID0gMDtcblx0XHRcdGlmKHJndCA9PT0gdW5kZWZpbmVkKSByZ3QgPSAwO1xuXHRcdFx0dGhpcy5sb2coJ2ltY2FyZXQgZXhwYW5kJyxsZnQscmd0KTtcblx0XHRcdHRoaXMuZGVjb2xsYXBzZSgpO1xuXHRcdFx0dmFyIGFyeSA9IGl0ZXIkKHRoaXMuZW5kcygpKTt2YXIgYSA9IGFyeVswXSxiID0gYXJ5WzFdO1xuXHRcdFx0YS5tb3ZlKGxmdCk7XG5cdFx0XHRiLm1vdmUocmd0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRpZiAodGhpcy5pc0NvbGxhcHNlZCgpKSB7XG5cdFx0XHRcdHJldHVybiBbdGhpcy5oZWFkKCkucm93KCksdGhpcy5oZWFkKCkuY29sKCldO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIFt0aGlzLmhlYWQoKS5yb3coKSx0aGlzLmhlYWQoKS5jb2woKSx0aGlzLnRhaWwoKS5yb3coKSx0aGlzLnRhaWwoKS5jb2woKV07XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50b0hhc2ggPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiAnWycgKyB0aGlzLnRvQXJyYXkoKS5qb2luKCcsJykgKyAnXSc7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0aWYgKHZhbCBpbnN0YW5jZW9mIElNLlR5cGVzLlRvaykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXQodmFsLnJlZ2lvbigpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmICh2YWwgaW5zdGFuY2VvZiBSZWdpb24pIHtcblx0XHRcdFx0cmV0dXJuICh0aGlzLnNldFJlZ2lvbih2YWwpLHZhbCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0dGhpcy5oZWFkKCkuc2V0Um93KHZhbFswXSk7XG5cdFx0XHRcdHRoaXMuaGVhZCgpLnNldENvbCh2YWxbMV0pO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHZhbC5sZW5ndGggPT0gNCkge1xuXHRcdFx0XHRcdHRoaXMuZGVjb2xsYXBzZSgpO1xuXHRcdFx0XHRcdHRoaXMudGFpbCgpLnNldFJvdyh2YWxbMl0pO1xuXHRcdFx0XHRcdHRoaXMudGFpbCgpLnNldENvbCh2YWxbM10pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuc2V0VGFpbCh0aGlzLmhlYWQoKSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5kaXJ0eSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmV4cGFuZFRvTGluZXMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBhcnk7XG5cdFx0XHR0aGlzLnNlbGVjdGFibGUoKTtcblx0XHRcdHZhciBhcnkgPSBpdGVyJCh0aGlzLmVuZHMoKSk7dmFyIGEgPSBhcnlbMF0sYiA9IGFyeVsxXTtcblx0XHRcdGEuc2V0Q29sKDApO1xuXHRcdFx0Yi5zZXRDb2woMTAwMCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXJ0eSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZWxlY3RBbGwgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuZGVjb2xsYXBzZSgpO1xuXHRcdFx0dGhpcy50YWlsKCkuc2V0TG9jKDApO1xuXHRcdFx0dGhpcy5oZWFkKCkuc2V0TG9jKHRoaXMudmlldygpLl9idWZmZXIubGVuKCkpOyAvLyA6bGVuZ3RoXG5cdFx0XHR0aGlzLmRpcnR5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2VsZWN0YWJsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5kZWNvbGxhcHNlKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGVjb2xsYXBzZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHZfO1xuXHRcdFx0aWYgKHRoaXMudGFpbCgpID09IHRoaXMuaGVhZCgpKSB7ICh0aGlzLnNldFRhaWwodl8gPSB0aGlzLmhlYWQoKS5jbG9uZSgpKSx2XykgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb2xsYXBzZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5zZXRUYWlsKHRoaXMuaGVhZCgpKTtcblx0XHRcdHRoaXMuZGlydHkoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb2xsYXBzZVRvU3RhcnQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGlmICh0aGlzLmlzUmV2ZXJzZWQoKSkge1xuXHRcdFx0XHR0aGlzLnNldFRhaWwodGhpcy5oZWFkKCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZXRIZWFkKHRoaXMudGFpbCgpKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLmRpcnR5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub3JpZW50YXRpb24gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmlzUmV2ZXJzZWQoKSA/ICgncmV2ZXJzZWQnKSA6ICgnbm9ybWFsJyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlzQ29sbGFwc2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy50YWlsKCkgPT0gdGhpcy5oZWFkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlzUmV2ZXJzZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmhlYWQoKS5yb3coKSA8IHRoaXMudGFpbCgpLnJvdygpIHx8ICh0aGlzLnRhaWwoKS5yb3coKSA9PSB0aGlzLmhlYWQoKS5yb3coKSAmJiB0aGlzLmhlYWQoKS5jb2woKSA8IHRoaXMudGFpbCgpLmNvbCgpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5kZW50ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc3RyID0gdGhpcy5oZWFkKCkubGluZXN0cigpO1xuXHRcdFx0dmFyIGluZCA9IHN0ci5tYXRjaCgvXihcXHQqKS8pWzBdO1xuXHRcdFx0cmV0dXJuIGluZDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGVla2JlaGluZCA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0dmFyIHN0ciA9IHRoaXMuZW5kcygpWzBdLnBlZWtiZWhpbmQoKTtcblx0XHRcdGlmICh2YWwgaW5zdGFuY2VvZiBSZWdFeHApIHsgcmV0dXJuIHN0ci5tYXRjaCh2YWwpIH07XG5cdFx0XHRyZXR1cm4gc3RyO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKG9mZnNldCxtb2RlKXtcblx0XHRcdGlmKG9mZnNldCA9PT0gdW5kZWZpbmVkKSBvZmZzZXQgPSAxO1xuXHRcdFx0aWYobW9kZSA9PT0gdW5kZWZpbmVkKSBtb2RlID0gMDtcblx0XHRcdHRoaXMuaGVhZCgpLmFsdGVyKG1vZGUsb2Zmc2V0KTtcblx0XHRcdHJldHVybiB0aGlzLmRpcnR5KCk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyB3aGF0IGlmIHdlIFxuXHRcdHRhZy5wcm90b3R5cGUubW92ZURvd24gPSBmdW5jdGlvbiAobGVuKXtcblx0XHRcdGlmKGxlbiA9PT0gdW5kZWZpbmVkKSBsZW4gPSAxO1xuXHRcdFx0dGhpcy5oZWFkKCkubW92ZURvd24oKTtcblx0XHRcdHJldHVybiB0aGlzLmRpcnR5KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm1vdmVVcCA9IGZ1bmN0aW9uIChsZW4pe1xuXHRcdFx0aWYobGVuID09PSB1bmRlZmluZWQpIGxlbiA9IDE7XG5cdFx0XHR0aGlzLmhlYWQoKS5tb3ZlVXAoKTtcblx0XHRcdHJldHVybiB0aGlzLmRpcnR5KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmVuZHMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmlzUmV2ZXJzZWQoKSA/IChbdGhpcy5oZWFkKCksdGhpcy50YWlsKCldKSA6IChbdGhpcy50YWlsKCksdGhpcy5oZWFkKCldKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMucmVnaW9uKCkudGV4dCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZWdpb24gPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIGdldCB0aGUgYWN0dWFsIHJlZ2lvbiBiYXNlZCBvbiBoZWFkIGFuZCB0YWlsXG5cdFx0XHQvLyBnZXR0aW5nIHRoZSBjb2RlIG1pZ2h0IGJlIGV4cGVuc2l2ZSBpZiBkb25lXG5cdFx0XHQvLyB0b28gbWFueSB0aW1lcyAtLSBidXQgZWFzeSB0byBjYWNoZVxuXHRcdFx0Ly8gc2VuZCB0aGlzIHRvIHV0aWwgaW5zdGVhZFxuXHRcdFx0dmFyIGFyeTtcblx0XHRcdHZhciBjb2RlID0gdGhpcy52aWV3KCkuY29kZSgpO1xuXHRcdFx0dmFyIGxpbmVzID0gY29kZS5zcGxpdCgnXFxuJyk7XG5cdFx0XHR2YXIgYXJ5ID0gaXRlciQodGhpcy5lbmRzKCkpO3ZhciBhID0gYXJ5WzBdLGIgPSBhcnlbMV07XG5cdFx0XHRcblx0XHRcdHZhciBzdGFydCA9IDA7XG5cdFx0XHR2YXIgZW5kID0gMDtcblx0XHRcdHZhciBsbiA9IDA7XG5cdFx0XHRcblx0XHRcdHZhciBhciA9IGEucm93KCksYWMgPSBhLmNvbCgpLGJyID0gYi5yb3coKSxiYyA9IGIuY29sKCk7XG5cdFx0XHR2YXIgY2hhciQ7XG5cdFx0XHRcblx0XHRcdGZvciAodmFyIGkgPSAwLCBpdGVtcyA9IGl0ZXIkKGxpbmVzKSwgbGVuID0gaXRlbXMubGVuZ3RoLCBsaW5lOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0bGluZSA9IGl0ZW1zW2ldO1xuXHRcdFx0XHRsbiA9IGxpbmUubGVuZ3RoO1xuXHRcdFx0XHRpZiAoaSA8IGFyKSB7XG5cdFx0XHRcdFx0c3RhcnQgKz0gbG4gKyAxOyAvLyBpbmNsdWRlIG5ld2xpbmVcblx0XHRcdFx0fSBlbHNlIGlmIChpID09IGFyKSB7XG5cdFx0XHRcdFx0dmFyIG9mZnNldCA9IHV0aWwuY29sVG9Mb2MobGluZSxhYyk7XG5cdFx0XHRcdFx0c3RhcnQgKz0gTWF0aC5taW4obG4sb2Zmc2V0KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChpIDwgYnIpIHtcblx0XHRcdFx0XHRlbmQgKz0gbG4gKyAxOyAvLyBpbmNsdWRlIG5ld2xpbmVcblx0XHRcdFx0fSBlbHNlIGlmIChpID09IGJyKSB7XG5cdFx0XHRcdFx0b2Zmc2V0ID0gdXRpbC5jb2xUb0xvYyhsaW5lLGJjKTtcblx0XHRcdFx0XHRlbmQgKz0gTWF0aC5taW4obG4sb2Zmc2V0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBuZXcgUmVnaW9uKHN0YXJ0LGVuZCx0aGlzLnZpZXcoKS5yb290KCksdGhpcy52aWV3KCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSZWdpb24gPSBmdW5jdGlvbiAocmVnKXtcblx0XHRcdHZhciBidWYgPSB0aGlzLnZpZXcoKS5jb2RlKCk7XG5cdFx0XHR2YXIgYSA9IHV0aWwucm93Y29sKGJ1ZixyZWcuYSgpKTtcblx0XHRcdHZhciBiID0gdXRpbC5yb3djb2woYnVmLHJlZy5iKCkpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnNldEhlYWQobmV3IFJvd0NvbChiWzBdLGJbMV0sdGhpcykpO1xuXHRcdFx0XG5cdFx0XHRpZiAocmVnLnNpemUoKSA9PSAwKSB7XG5cdFx0XHRcdHRoaXMuc2V0VGFpbCh0aGlzLmhlYWQoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNldFRhaWwobmV3IFJvd0NvbChhWzBdLGFbMV0sdGhpcykpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzLmRpcnR5KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5vZGVzID0gZnVuY3Rpb24gKHJlZyl7XG5cdFx0XHRpZihyZWcgPT09IHVuZGVmaW5lZCkgcmVnID0gdGhpcy5yZWdpb24oKTtcblx0XHRcdHJldHVybiB0aGlzLnZpZXcoKS5ub2Rlc0luUmVnaW9uKHJlZyx0aGlzLmlzQ29sbGFwc2VkKCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gc2hvdWxkIHJhdGhlciBtb3ZlIHRoaXMgdG8gcmVnaW9uIGl0c2VsZlxuXHRcdHRhZy5wcm90b3R5cGUudGFyZ2V0ID0gZnVuY3Rpb24gKHJlZyl7XG5cdFx0XHRpZihyZWcgPT09IHVuZGVmaW5lZCkgcmVnID0gdGhpcy5yZWdpb24oKTtcblx0XHRcdHZhciBub2RlcyA9IHRoaXMubm9kZXMocmVnKTtcblx0XHRcdGlmIChub2Rlcy5sZW5ndGggPiAyKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsLmNvbW1vbkFuY2VzdG9yKG5vZGVzLm1hcChmdW5jdGlvbihuKSB7IHJldHVybiBuLm5vZGU7IH0pKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gbm9kZXNbMF0ubm9kZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHRleHQsZWRpdCl7XG5cdFx0XHRcblx0XHRcdHZhciBzdWIgPSAnJztcblx0XHRcdHRoaXMudmlldygpLmhpc3RvcnkoKS5tYXJrKCdhY3Rpb24nKTtcblx0XHRcdFxuXHRcdFx0aWYgKCEodGhpcy5pc0NvbGxhcHNlZCgpKSkge1xuXHRcdFx0XHR2YXIgcmVnID0gdGhpcy5yZWdpb24oKTtcblx0XHRcdFx0c3ViID0gcmVnLnRleHQoKTtcblx0XHRcdFx0dGhpcy52aWV3KCkuZXJhc2UocmVnKTtcblx0XHRcdFx0dGhpcy5jb2xsYXBzZVRvU3RhcnQoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciBtb3ZlID0gMDtcblx0XHRcdHZhciBzZWw7XG5cdFx0XHRcblx0XHRcdC8vIG5lZWQgYSBkaWZmZXJlbnQgc3ludGF4IGZvciAkMCAtLSBjYW4gYmUgaW4gcmVndWxhciBwYXN0ZWQgY29kZVxuXHRcdFx0Ly8gc2hvdWxkIGhhdmUgYSBzZXBhcmF0ZSBjb21tYW5kIGZvciBpbnNlcnRTbmlwcGV0IHByb2JhYmx5LlxuXHRcdFx0aWYgKHRleHQuaW5kZXhPZignJDAnKSA+PSAwKSB7XG5cdFx0XHRcdHNlbCA9IHRoaXMucmVnaW9uKCkuY2xvbmUoMCxzdWIubGVuZ3RoKS5tb3ZlKHRleHQuaW5kZXhPZignJDAnKSk7XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoJyQwJyxzdWIpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0ZWRpdCB8fCAoZWRpdCA9IHtzaXplOiB0ZXh0Lmxlbmd0aH0pO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmhlYWQoKS5ub3JtYWxpemUoKTtcblx0XHRcdHZhciByZXMgPSB0aGlzLnZpZXcoKS5pbnNlcnQodGhpcy5yZWdpb24oKS5zdGFydCgpLHRleHQsZWRpdCk7XG5cdFx0XHR0aGlzLnZpZXcoKS5sb2coJ2luc2VydGVkIC0tIG5vdyBtb3ZlJyxlZGl0LnNpemUpO1xuXHRcdFx0XG5cdFx0XHRpZiAoc2VsKSB7XG5cdFx0XHRcdHRoaXMuc2V0UmVnaW9uKHNlbCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBtb3ZlIGxvY2F0aW9uc1xuXHRcdFx0XHR0aGlzLmhlYWQoKS5zZXRMb2ModGhpcy5oZWFkKCkubG9jKCkgKyBlZGl0LnNpemUpO1xuXHRcdFx0XHQvLyBoZWFkLm1vdmUoZWRpdDpzaXplKVxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dGhpcy5kaXJ0eSgpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZXJhc2UgPSBmdW5jdGlvbiAobW9kZSl7XG5cdFx0XHR0aGlzLnZpZXcoKS5oaXN0b3J5KCkubWFyaygnYWN0aW9uJyk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmlzQ29sbGFwc2VkKCkpIHtcblx0XHRcdFx0dGhpcy5sb2coJ2lzQ29sbGFwc2VkJyxtb2RlKTtcblx0XHRcdFx0dGhpcy5kZWNvbGxhcHNlKCk7XG5cdFx0XHRcdHRoaXMuaGVhZCgpLmFsdGVyKG1vZGUsLTEpOyAvLyBcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGRpcnR5XG5cdFx0XHRcdC8vIHJldHVybiBlcmFzZSAjIGNhbGwgYWdhaW4gbm93XG5cdFx0XHR9O1xuXHRcdFx0Y29uc29sZS5sb2coJ2VyYXNpbmcgcmVnaW9uJyx0aGlzLnJlZ2lvbigpKTtcblx0XHRcdHRoaXMudmlldygpLmVyYXNlKHRoaXMucmVnaW9uKCkpO1xuXHRcdFx0Ly8gbG9nICdub3cgY29sbGFwc2UgcmVnaW9uIHRvIHN0YXJ0JyxyZWdpb25cblx0XHRcdHRoaXMuY29sbGFwc2VUb1N0YXJ0KCk7XG5cdFx0XHQvLyBsb2cgcmVnaW9uXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFxuXHRcdFx0dmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0KHRoaXMucmVnKCkpO1xuXHRcdFx0dGhpcy5zZXRSZWdpb24odGhpcy5yZWcoKSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnZpZXcoKS5lZGl0KFxuXHRcdFx0XHR7dGV4dDogJycsXG5cdFx0XHRcdHRhcmdldDogdGFyZ2V0LFxuXHRcdFx0XHRyZWdpb246IHRoaXMucmVnKCksXG5cdFx0XHRcdGNhcmV0OiB0aGlzLnJlZygpLmNsb25lKCkuY29sbGFwc2UoZmFsc2UpfVxuXHRcdFx0KTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGlydHkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciAkMSwgJDI7XG5cdFx0XHR0aGlzLl90aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0Ly8gdmFyIGhhc2ggPSB0b0FycmF5LmpvaW4oXCJcIilcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuX2hhc2ggIT0gdGhpcy50b0hhc2goKSkge1xuXHRcdFx0XHQvLyB0aGUgcmVhbENvbCB2YWx1ZXMgY291bGQgaGF2ZSBjaGFuZ2VkIHRob3VnaD9cblx0XHRcdFx0dGhpcy52aWV3KCkuaGlzdG9yeSgpLm9uY2FyZXQodGhpcy5faGFzaCx0aGlzLnRvSGFzaCgpLHRoaXMpO1xuXHRcdFx0XHR0aGlzLl9oYXNoID0gdGhpcy50b0hhc2goKTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2NhcmV0IGhhcyBhY3R1YWxseSBjaGFuZ2VkJyxAaGFzaFxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIHJldiA9IHRoaXMuaXNSZXZlcnNlZCgpO1xuXHRcdFx0dmFyIGEgPSB0aGlzLnRhaWwoKTtcblx0XHRcdHZhciBiID0gdGhpcy5oZWFkKCk7XG5cdFx0XHRcblx0XHRcdGlmIChyZXYpIHsgJDEgPSBiLCQyID0gYSxhID0gJDEsYiA9ICQyIH07XG5cdFx0XHRcblx0XHRcdHZhciBsYyA9IGIucm93KCkgLSBhLnJvdygpO1xuXHRcdFx0dmFyIHJvdyA9IGEucm93KCk7XG5cdFx0XHRcblx0XHRcdHZhciBhYyA9IGEucmVhbENvbCgpOyAvLyBNYXRoLm1pbiggYS5jb2wsIHV0aWwuY29sc0ZvckxpbmUodmlldy5saW5lc3RyKGEucm93KSApIClcblx0XHRcdHZhciBiYyA9IGIucmVhbENvbCgpOyAvLyBNYXRoLm1pbiggYi5jb2wsIHV0aWwuY29sc0ZvckxpbmUodmlldy5saW5lc3RyKGIucm93KSApIClcblx0XHRcdHZhciBoYyx0Yztcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaXNSZXZlcnNlZCgpKSB7XG5cdFx0XHRcdGhjID0gYWM7XG5cdFx0XHRcdHRjID0gYmM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYyA9IGJjO1xuXHRcdFx0XHR0YyA9IGFjO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gbG9nICdkaXJ0eScscmVnaW9uLGEucm93LGEuY29sLGIucm93LGIuY29sLGhjLHRjLGhlYWQsdGFpbCxyZXZcblx0XHRcdFxuXHRcdFx0dGhpcy5jc3Moe3RyYW5zZm9ybTogKFwidHJhbnNsYXRlKDBweCxcIiArIChhLnJvdygpICogMTAwKSArIFwiJSlcIil9KTtcblx0XHRcdC8vIGNvbnZlcnQgdGhlIHJvdyBhbmQgY29sdW1uIHRvIGEgcmVnaW9uIChzaG91bGQgZ28gYm90aCB3YXlzKVxuXHRcdFx0dGhpcy5fY2FyZXQuY3NzKHt0cmFuc2Zvcm06IChcInRyYW5zbGF0ZShcIiArIGhjICsgXCJjaCxcIiArICgodGhpcy5oZWFkKCkucm93KCkgLSByb3cpICogMTAwKSArIFwiJSlcIil9KTtcblx0XHRcdHRoaXMuX3N0YXJ0LmNzcyh7bWFyZ2luTGVmdDogKFwiXCIgKyBhYyArIFwiY2hcIiksd2lkdGg6IFwiYXV0b1wifSk7XG5cdFx0XHR0aGlzLl9lbmQuY3NzKHt3aWR0aDogKFwiXCIgKyBiYyArIFwiY2hcIil9KTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaXNDb2xsYXBzZWQoKSkge1xuXHRcdFx0XHR0aGlzLnNldE1vZGUoJ2NvbGxhcHNlZCcpO1xuXHRcdFx0fSBlbHNlIGlmIChsYyA9PSAwKSB7XG5cdFx0XHRcdHRoaXMuc2V0TW9kZSgnc2luZ2xlJyk7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0LmNzcyh7d2lkdGg6IChiYyAtIGFjKSArIFwiY2hcIn0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fbWlkLnNldFRleHQobGMgPiAxID8gKCgnXFxuJykucmVwZWF0KGxjIC0gMSkpIDogKCcnKSk7XG5cdFx0XHRcdHRoaXMuc2V0TW9kZSgnbXVsdGknKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgZWxhcHNlZCA9IChuZXcgRGF0ZSgpIC0gdGhpcy5fdGltZXN0YW1wKTtcblx0XHRcdHZhciBmbGlwID0gTWF0aC5yb3VuZChlbGFwc2VkIC8gNTAwKSAlIDI7XG5cdFx0XHRcblx0XHRcdGlmIChmbGlwICE9IHRoaXMuX2ZsaXApIHtcblx0XHRcdFx0dGhpcy5fY2FyZXQuZmxhZygnYmxpbmsnLGZsaXApO1xuXHRcdFx0XHR0aGlzLl9mbGlwID0gZmxpcDtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHZfLCB0MDtcblx0XHRcdHRoaXMuc2V0VGFpbCgodGhpcy5zZXRIZWFkKHZfID0gbmV3IFJvd0NvbCgwLDAsdGhpcykpLHZfKSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnNldENoaWxkcmVuKFtcblx0XHRcdFx0Ly8gPGltY2FwdG9yQGlucHV0IHZhbHVlPSd4Jz5cblx0XHRcdFx0KHRoaXMuJGEgPSB0aGlzLiRhIHx8IHRhZyQuJHNwYW4oKS5mbGFnKCdkaW0nKSkuc2V0VGV4dCgneCcpLmVuZCgpLFxuXHRcdFx0XHQodGhpcy5fY2FyZXQgPSB0aGlzLl9jYXJldCB8fCB0YWckLiRpbWNhcmV0aGVhZCgpLnNldFJlZignY2FyZXQnLHRoaXMpKS5lbmQoKSxcblx0XHRcdFx0KHQwID0gdGhpcy5fbGluZXM9dGhpcy5fbGluZXMgfHwgdGFnJC4kZGl2KCkuc2V0UmVmKCdsaW5lcycsdGhpcykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdCh0aGlzLl9zdGFydCA9IHRoaXMuX3N0YXJ0IHx8IHRhZyQuJGRpdigpLnNldFJlZignc3RhcnQnLHRoaXMpKS5zZXRUZXh0KFwiIFwiKS5lbmQoKSxcblx0XHRcdFx0XHQodGhpcy5fbWlkID0gdGhpcy5fbWlkIHx8IHRhZyQuJGRpdigpLnNldFJlZignbWlkJyx0aGlzKSkuZW5kKCksXG5cdFx0XHRcdFx0KHRoaXMuX2VuZCA9IHRoaXMuX2VuZCB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ2VuZCcsdGhpcykpLnNldFRleHQoXCIgXCIpLmVuZCgpXG5cdFx0XHRcdF0sMikuZW5kKClcblx0XHRcdF0sMikuc3luY2VkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5oZWFkKCkubm9ybWFsaXplKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubW9kZURpZFNldCA9IGZ1bmN0aW9uIChuZXckLG9sZCl7XG5cdFx0XHR0aGlzLnVuZmxhZyhvbGQpO1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZyhuZXckKTtcblx0XHR9O1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL2NvcmUvY2FyZXQuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdzY3JpbWJsYS1vdmVybGF5JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZpZXc7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDaGlsZHJlbihKU09OLnN0cmluZ2lmeSh0aGlzLm9iamVjdCgpKSwzKS5zeW5jZWQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnc2NyaW1ibGEtb3ZlcmxheXMnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmlldzsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VmlldyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92aWV3ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodHlwZSxkYXRhKXtcblx0XHRcdGlmKGRhdGEgPT09IHVuZGVmaW5lZCkgZGF0YSA9IHt9O1xuXHRcdFx0Y29uc29sZS5sb2coJ2FkZCBvdmVybGF5IScpO1xuXHRcdFx0dGhpcy5hcHBlbmQodGFnJC4kc2NyaW1ibGFfb3ZlcmxheSgpLnNldFZpZXcodGhpcy52aWV3KCkpLnNldE9iamVjdChkYXRhKS5lbmQoKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVwb3NpdGlvbiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy92aWV3cy9vdmVybGF5cy5pbWJhXG4gKiogbW9kdWxlIGlkID0gNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpe1xuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdpbWVkaXRvcicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5yZW5kZXIoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnNldENoaWxkcmVuKFxuXHRcdFx0XHQodGhpcy5fdmlldyA9IHRoaXMuX3ZpZXcgfHwgdGFnJC4kaW12aWV3KCkuc2V0UmVmKCd2aWV3Jyx0aGlzKSkuZW5kKClcblx0XHRcdCwyKS5zeW5jZWQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX3ZpZXc7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLnZpZXcoKS5hY3RpdmF0ZSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMudmlldygpLmRlYWN0aXZhdGUoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvZGUsb3B0cyl7XG5cdFx0XHR0aGlzLnZpZXcoKS5sb2FkKGNvZGUsb3B0cyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZnMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBJTS5GUztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25jb21tYW5kID0gZnVuY3Rpb24gKGUsYyl7XG5cdFx0XHRpZiAodGhpc1tjLmNvbW1hbmRdIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdFx0dGhpc1tjLmNvbW1hbmRdLmNhbGwodGhpcyxjLmFyZ3MgfHwgW10pO1xuXHRcdFx0XHRlLmhhbHQoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25zYXZlc2Vzc2lvbiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Y29uc29sZS5sb2coXCJpbWVkaXRvci5zYXZlU2Vzc2lvblwiLHRoaXMpO1xuXHRcdFx0dmFyIHBhdGggPSB0aGlzLnZpZXcoKS5maWxlbmFtZSgpLnJlcGxhY2UoL1xcLmltYmEkLywnLmltYmFzZXNzaW9uJyk7XG5cdFx0XHR2YXIgYm9keSA9IEpTT04uc3RyaW5naWZ5KHRoaXMudmlldygpLmhpc3RvcnkoKSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBJTS5GUy5zYXZlKHBhdGgsYm9keSxmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGNvbnNvbGUubG9nKCdyZXR1cm5lZCBmcm9tIHNhdmluZyEnLHBhdGgpO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9lZGl0b3IuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0XG5cdC8qXG5cdEJyaWRnZSBmb3IgY29tbXVuaWNhdGluZyB3aXRoIHRoZSBJbWJhIGNvbXBpbGVyIGluIGEgd29ya2VyXG5cdCovXG5cdFxuXHRmdW5jdGlvbiBJbWJhY1dvcmtlcihwYXRoKXtcblx0XHRpZihwYXRoID09PSB1bmRlZmluZWQpIHBhdGggPSBcIi92ZW5kb3IvaW1iYS9pbWJhYy53b3JrZXIubWluLmpzXCI7XG5cdFx0dGhpcy5fcGF0aCA9IHBhdGg7XG5cdFx0dGhpcy5fY2FsbGJhY2tzID0gW107XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdGV4cG9ydHMuSW1iYWNXb3JrZXIgPSBJbWJhY1dvcmtlcjsgLy8gZXhwb3J0IGNsYXNzIFxuXHRJbWJhY1dvcmtlci5wcm90b3R5cGUud29ya2VyID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBwcm9jZXNzMTtcblx0XHRyZXR1cm4gc2VsZi5fd29ya2VyIHx8IChzZWxmLl93b3JrZXIgPSAodHJ1ZSkgJiYgKFxuXHRcdFx0cHJvY2VzczEgPSBuZXcgV29ya2VyKHNlbGYuX3BhdGgpLFxuXHRcdFx0cHJvY2VzczEub25tZXNzYWdlID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gc2VsZi5vbm1lc3NhZ2UoZSk7IH0sXG5cdFx0XHRwcm9jZXNzMVxuXHRcdCkpO1xuXHR9O1xuXHRcblx0SW1iYWNXb3JrZXIucHJvdG90eXBlLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKXtcblx0XHR2YXIgZm47XG5cdFx0aWYgKGZuID0gdGhpcy5fY2FsbGJhY2tzLnNoaWZ0KCkpIHtcblx0XHRcdHJldHVybiBmbihlLmRhdGEsZSk7XG5cdFx0fTtcblx0fTtcblx0XG5cdEltYmFjV29ya2VyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKGNvZGUsbyxjYil7XG5cdFx0dGhpcy5fY2FsbGJhY2tzLnB1c2goY2IpO1xuXHRcdHRoaXMud29ya2VyKCkucG9zdE1lc3NhZ2UoWydjb21waWxlJyxjb2RlLG9dKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEltYmFjV29ya2VyLnByb3RvdHlwZS5hbmFseXplID0gZnVuY3Rpb24gKGNvZGUsbyxjYil7XG5cdFx0dGhpcy5fY2FsbGJhY2tzLnB1c2goY2IpO1xuXHRcdHRoaXMud29ya2VyKCkucG9zdE1lc3NhZ2UoWydhbmFseXplJyxjb2RlLG9dKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0cmV0dXJuIEltYmFjV29ya2VyO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvY29yZS93b3JrZXIuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0cmVxdWlyZShcIi4vYmFzZVwiKTtcblx0cmVxdWlyZShcIi4vdG9rZW5cIik7XG5cdHJlcXVpcmUoXCIuL2Jsb2NrXCIpO1xuXHRyZXF1aXJlKFwiLi9yb290XCIpO1xuXHRyZXF1aXJlKFwiLi9saXRlcmFsc1wiKTtcblx0cmVxdWlyZShcIi4vb3BlcmF0b3JzXCIpO1xuXHRyZXF1aXJlKFwiLi9zZWxlY3RvclwiKTtcblx0cmVxdWlyZShcIi4vd2hpdGVzcGFjZVwiKTtcblx0cmV0dXJuIHJlcXVpcmUoXCIuL2Fubm90YXRpb25zXCIpO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvbm9kZXMvaW5kZXguaW1iYVxuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0dmFyIEhpZ2hsaWdodGVyID0gcmVxdWlyZSgnLi4vY29yZS9oaWdobGlnaHRlcicpLkhpZ2hsaWdodGVyO1xuXHR2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXHRcblx0Ly8gZGFuZ2Vyb3VzIHRvIGV4dGVuZCBhbGwgaHRtbGVsZW1lbnQgdGFncyBnbG9iYWxseVxuXHR0YWckLmV4dGVuZFRhZygnaHRtbGVsZW1lbnQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnViYmxlID0gZnVuY3Rpb24gKG5hbWUsZGF0YSl7XG5cdFx0XHQvLyBsb2cgXCJidWJibGUgZXZlbnRcIixuYW1lLGRhdGFcblx0XHRcdHZhciBldiA9IEltYmEuRXZlbnRzLnRyaWdnZXIobmFtZSx0aGlzLHtkYXRhOiBkYXRhLGJ1YmJsZTogdHJ1ZX0pO1xuXHRcdFx0cmV0dXJuIGV2O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uIChuYW1lLHRpbWUsYmxrKXtcblx0XHRcdHRoaXMuX3RpbWVvdXRzIHx8ICh0aGlzLl90aW1lb3V0cyA9IHt9KTtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0c1tuYW1lXSk7XG5cdFx0XHRpZiAodGltZSAhPSAtMSkgeyB0aGlzLl90aW1lb3V0c1tuYW1lXSA9IHNldFRpbWVvdXQoYmxrLHRpbWUpIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TmV4dCA9IGZ1bmN0aW9uIChlbCl7XG5cdFx0XHRpZiAoZWwgaW5zdGFuY2VvZiBJTUZyYWdtZW50KSB7XG5cdFx0XHRcdGVsID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWwuZG9tKCkuY2hpbGROb2Rlcyk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoZWwgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoZWwucmV2ZXJzZSgpKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXROZXh0KGFyeVtpXSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIGN1cnIgPSB0aGlzLmRvbSgpLm5leHRTaWJsaW5nO1xuXHRcdFx0aWYgKCh0eXBlb2YgZWw9PSdzdHJpbmcnfHxlbCBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdFx0ZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShlbCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoY3Vycikge1xuXHRcdFx0XHR0aGlzLnBhcmVudCgpLmluc2VydEJlZm9yZShlbCxjdXJyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucGFyZW50KCkuYXBwZW5kQ2hpbGQoZWwpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGVsO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRQcmV2ID0gZnVuY3Rpb24gKGVsKXtcblx0XHRcdGlmIChlbCBpbnN0YW5jZW9mIElNRnJhZ21lbnQpIHtcblx0XHRcdFx0ZWwgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlbC5kb20oKS5jaGlsZE5vZGVzKTtcblx0XHRcdFx0Ly8gZWwgPSBbXS5jb25jYXQoZWwuZG9tOmNoaWxkTm9kZXMpXG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAoZWwgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoZWwpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHR0aGlzLnNldFByZXYoYXJ5W2ldKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgY3VyciA9IHRoaXMuZG9tKCkucHJldlNpYmxpbmc7XG5cdFx0XHRpZiAoKHR5cGVvZiBlbD09J3N0cmluZyd8fGVsIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuXHRcdFx0XHRlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGVsKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLnBhcmVudCgpLmluc2VydEJlZm9yZShlbCx0aGlzKTtcblx0XHRcdC8vIHBhcmVudC5pbnNlcnQoZWwsIGJlZm9yZTogc2VsZilcblx0XHRcdHJldHVybiBlbDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmV4dE5vZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLm5leHRTaWJsaW5nO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wcmV2Tm9kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkucHJldlNpYmxpbmc7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRJTS5UeXBlcyA9IHt9O1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltJywgJ2InLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5rZXkgPSBmdW5jdGlvbiAoa2V5LGhhbmRsZXIpe1xuXHRcdFx0dGhpcy5wcm90b3R5cGVbKFwiaGFuZGxlXCIgKyBrZXkpXSA9IGhhbmRsZXI7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5uYXRpdmUgPSBmdW5jdGlvbiAodHlwKXtcblx0XHRcdHRoaXMuX25hdGl2ZVR5cGUgPSB0eXA7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy50eXBlID0gZnVuY3Rpb24gKHR5cCl7XG5cdFx0XHRJTS5UeXBlc1t0eXBdID0gdGhpcztcblx0XHRcdHRoaXMuX3R5cGUgPSB0eXA7XG5cdFx0XHR0aGlzLnByb3RvdHlwZS5fdHlwZSA9IHR5cDtcblx0XHRcdC8vIEBkb21GbGFncy5wdXNoKHR5cCkgaWYgQGRvbUZsYWdzXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy50eXBlKCdUb2snKTtcblx0XHRcblx0XHR0YWcuYWxpYXMgPSBmdW5jdGlvbiAodHlwKXtcblx0XHRcdElNLlR5cGVzW3R5cF0gPSB0aGlzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcudHJpZ2dlciA9IGZ1bmN0aW9uIChtYXRjaCxjbWQpe1xuXHRcdFx0aWYgKGNtZCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRcdGNtZCA9IHtjb21tYW5kOiBjbWR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y21kLnRyaWdnZXIgPSBtYXRjaDtcblx0XHRcdHJldHVybiB0aGlzLnByb3RvdHlwZVsoXCJ0cmlnZ2VyLVwiICsgbWF0Y2gpXSA9IGNtZDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SGludCA9IGZ1bmN0aW9uIChoaW50KXtcblx0XHRcdGlmIChoaW50ICYmIGhpbnQgIT0gdGhpcy5faGludCkge1xuXHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnaGludCcsaGludC5yZWYoKSk7XG5cdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKFwiaGludC10eXBlXCIsaGludC50eXBlKCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2hpbnQnKTtcblx0XHRcdFx0dGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2hpbnQtdHlwZScpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzLl9oaW50ID0gaGludDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaGludCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gc3RyYW5nZSBubz9cdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5faGludCB8fCB0aGlzLnZpZXcoKS5oaW50cygpLmdldCh0aGlzLmdldEF0dHJpYnV0ZSgnaGludCcpKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGdvIG92ZXIgdG8gdXNpbmcgdGhpcyBcblx0XHR0YWcucHJvdG90eXBlLndhbGtUZXh0Tm9kZXMgPSBmdW5jdGlvbiAobWFyayl7XG5cdFx0XHRpZihtYXJrID09PSB1bmRlZmluZWQpIG1hcmsgPSBmYWxzZTtcblx0XHRcdHRoaXMuc2V0Um9vdCh0aGlzLmRvbSgpKTtcblx0XHRcdHZhciBlbDtcblx0XHRcdHZhciBub2RlcyA9IFtdO1xuXHRcdFx0dmFyIHBvcyA9IDA7XG5cdFx0XHR2YXIgd2FsayA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIodGhpcy5yb290KCksTm9kZUZpbHRlci5TSE9XX1RFWFQsbnVsbCxmYWxzZSk7XG5cdFx0XHRcblx0XHRcdHdoaWxlIChlbCA9IHdhbGsubmV4dE5vZGUoKSl7XG5cdFx0XHRcdGlmIChtYXJrKSB7XG5cdFx0XHRcdFx0dmFyIGxlbiA9IGVsLmxlbmd0aDtcblx0XHRcdFx0XHRlbC5fbG9jID0gcG9zO1xuXHRcdFx0XHRcdHBvcyArPSBsZW47XG5cdFx0XHRcdH07XG5cdFx0XHRcdG5vZGVzLnB1c2goZWwpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG5vZGVzO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS51dGlsID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdXRpbDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkuY2FyZXQoKS5zZXQodGhpcy5yZWdpb24oKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNhblByZXBlbmQgPSBmdW5jdGlvbiAodGV4dCl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNhbkFwcGVuZCA9IGZ1bmN0aW9uICh0ZXh0KXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgbG9nZ2VyXztcblx0XHRcdChsb2dnZXJfID0gdGhpcy52aWV3KCkubG9nZ2VyKCkpLmxvZy5hcHBseShsb2dnZXJfLGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLm91dGVySFRNTDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc3BhY2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRpZiAodGhpcy5kb20oKS5uZXh0U2libGluZyBpbnN0YW5jZW9mIFRleHQpIHtcblx0XHRcdFx0cmV0dXJuICgvW1xcdCBdLykudGVzdCh0aGlzLmRvbSgpLm5leHRTaWJsaW5nLnRleHRDb250ZW50WzBdKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnVuc3BhY2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gISh0aGlzLnNwYWNlZCgpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmV4dEltbWVkaWF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gY291bGQgYmUgdGV4dCBhcyB3ZWxsP1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkubmV4dFNpYmxpbmcgaW5zdGFuY2VvZiBUZXh0ID8gKG51bGwpIDogKHRoaXMubmV4dCgpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucHJldkltbWVkaWF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gY291bGQgYmUgdGV4dCBhcyB3ZWxsP1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkucHJldmlvdXNTaWJsaW5nIGluc3RhbmNlb2YgVGV4dCA/IChudWxsKSA6ICh0aGlzLnByZXYoKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcGFpciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmRvbSgpLnRleHRDb250ZW50O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpe1xuXHRcdFx0dGhpcy5kb20oKS50ZXh0Q29udGVudCA9IHRleHQ7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY29kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tKCkudGV4dENvbnRlbnQ7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldENvZGUgPSBmdW5jdGlvbiAoY29kZSxzaWxlbnQpe1xuXHRcdFx0dmFyIGhpbnRfO1xuXHRcdFx0aWYoc2lsZW50ID09PSB1bmRlZmluZWQpIHNpbGVudCA9IGZhbHNlO1xuXHRcdFx0dmFyIHByZXYgPSB0aGlzLmNvZGUoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuX2RvbS5maXJzdENoaWxkID09IHRoaXMuX2RvbS5sYXN0Q2hpbGQgJiYgKHRoaXMuX2RvbS5maXJzdENoaWxkIGluc3RhbmNlb2YgVGV4dCkpIHtcblx0XHRcdFx0Ly8gc3RpbGwgc2V0IGlmIGl0IGhhcyBub3QgY2hhbmdlZD9cblx0XHRcdFx0dGhpcy5fZG9tLmZpcnN0Q2hpbGQudGV4dENvbnRlbnQgPSBjb2RlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fZG9tLnRleHRDb250ZW50ID0gY29kZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChjb2RlICE9IHByZXYpIHtcblx0XHRcdFx0KGhpbnRfID0gdGhpcy5oaW50KCkpICYmIGhpbnRfLmNoYW5nZWQgICYmICBoaW50Xy5jaGFuZ2VkKCk7XG5cdFx0XHRcdGlmICghc2lsZW50KSB7IHRoaXMub25jaGFuZ2VkKGNvZGUscHJldikgfTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25jaGFuZ2VkID0gZnVuY3Rpb24gKGNvZGUscHJldil7XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGFnKCdkaXJ0eScpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb2RlKCkubGVuZ3RoO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgcGFyZW50Xztcblx0XHRcdHJldHVybiB0aGlzLl92aWV3IHx8ICgocGFyZW50XyA9IHRoaXMucGFyZW50KCkpICYmIHBhcmVudF8udmlldyAgJiYgIHBhcmVudF8udmlldygpKSB8fCBWSUVXO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZWwgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnZpZXcoKS5jYXJldCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZWdpb24gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnZpZXcoKS5yZWdpb25Gb3JOb2RlKHRoaXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2MgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnJlZ2lvbigpLmxvYygpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGVjcmVhc2VJbmRlbnQgPSBmdW5jdGlvbiAocHJlLHN0YXRlKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5jcmVhc2VJbmRlbnQgPSBmdW5jdGlvbiAocHJlLHN0YXRlKXtcblx0XHRcdHZhciByZWcgPSAvXihcXHMqKC4qXFw9XFxzKik/KGNsYXNzfGRlZnx0YWd8dW5sZXNzfGlmfGVsc2V8ZWxpZnxzd2l0Y2h8dHJ5fGNhdGNofGZpbmFsbHl8Zm9yfHdoaWxlfHVudGlsfGRvKSkvO1xuXHRcdFx0cmV0dXJuIHJlZy50ZXN0KHByZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmVyYXNlID0gZnVuY3Rpb24gKHJlZ2lvbixtb2RlKXtcblx0XHRcdGlmIChtb2RlID09ICdhbGwnKSB7XG5cdFx0XHRcdHRoaXMub3JwaGFuaXplKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNldENvZGUodXRpbC5wYXRjaFN0cmluZyh0aGlzLmNvZGUoKSwnJyxyZWdpb24pKTsgLy8gY29kZS5pbnMoJycscmVnaW9uKVxuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAocmVnaW9uLHN0cixlZGl0LHBhcnMpe1xuXHRcdFx0aWYoIXBhcnN8fHBhcnMuY29uc3RydWN0b3IgIT09IE9iamVjdCkgcGFycyA9IHt9O1xuXHRcdFx0dmFyIG1vZGUgPSBwYXJzLm1vZGUgIT09IHVuZGVmaW5lZCA/IHBhcnMubW9kZSA6IG51bGw7XG5cdFx0XHR0aGlzLnNldENvZGUodXRpbC5wYXRjaFN0cmluZyh0aGlzLmNvZGUoKSxzdHIscmVnaW9uKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25pbnNlcnRlZCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmNvbW1hbmQgPSBmdW5jdGlvbiAoZSxjbWQpe1xuXHRcdFx0dmFyIG5hbWUgPSBjbWQuY29tbWFuZDtcblx0XHRcdHZhciBmbiA9IHRoaXNbbmFtZV07XG5cdFx0XHR0aGlzLmxvZygncnVuIG9uY29tbWFuZCcsbmFtZSxjbWQpO1xuXHRcdFx0XG5cdFx0XHRpZiAoZm4gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0XHRmbi5jYWxsKHRoaXMsZSxjbWQpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pbmRlbnRCbG9jayA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHRoaXMubG9nKCdpbS5pbmRlbnRCbG9jaycsYXJndW1lbnRzLHRoaXMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0XHRyZXR1cm4gSU0udG9rKHZhbCkuY2xhc3NpZnkoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlzRmlyc3QgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBwYXIgPSB0aGlzLnBhcmVudCgpO1xuXHRcdFx0cmV0dXJuIChwYXIgaW5zdGFuY2VvZiBJTS5UeXBlcy5Ub2spICYmIHBhci5kb20oKS5maXJzdENoaWxkID09IHRoaXMuZG9tKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlzTGFzdCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHBhciA9IHRoaXMucGFyZW50KCk7XG5cdFx0XHRyZXR1cm4gKHBhciBpbnN0YW5jZW9mIElNLlR5cGVzLlRvaykgJiYgcGFyLmRvbSgpLmxhc3RDaGlsZCA9PSB0aGlzLmRvbSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdFx0aWYoY29kZSA9PT0gdW5kZWZpbmVkKSBjb2RlID0gdGhpcy50ZXh0KCk7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWxpZGF0ZShjb2RlKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubWFya0ludmFsaWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuZmxhZygnaW52YWxpZCcpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm1hcmtWYWxpZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy51bmZsYWcoJ2ludmFsaWQnKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0ludmFsaWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmhhc0ZsYWcoJ2ludmFsaWQnKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2xhc3NpZnkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gdW53cmFwIC8gcmVtb3ZlIHRoaXMgbm9kZSBmcm9tIHBhcmVudFxuXHRcdHRhZy5wcm90b3R5cGUudW53cmFwID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgZWwgPSB0aGlzLmRvbSgpO1xuXHRcdFx0dmFyIHBhciA9IGVsLnBhcmVudE5vZGU7XG5cdFx0XHRcblx0XHRcdHdoaWxlIChlbC5maXJzdENoaWxkKXtcblx0XHRcdFx0cGFyLmluc2VydEJlZm9yZShlbC5maXJzdENoaWxkLGVsKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVwbGFjZVdpdGggPSBmdW5jdGlvbiAob3RoZXIpe1xuXHRcdFx0dGhpcy5zZXRQcmV2KG90aGVyKTtcblx0XHRcdHJldHVybiB0aGlzLm9ycGhhbml6ZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zY29wZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuY2xvc2VzdChxJCgnLl9pbmRlbnQnLHRoaXMpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubXV0YXRlZCA9IGZ1bmN0aW9uIChtdXRzKXtcblx0XHRcdC8vIHJlbW92ZSBub2RlIGlmIGl0IGlzIG9ycGhhbml6ZWRcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGlmIChzZWxmLmNvZGUoKSA9PSAnJykge1xuXHRcdFx0XHRzZWxmLmxvZygncmVtb3ZlIHdob2xlIG5vZGUnKTtcblx0XHRcdFx0Ly8gc2hvdWxkIHBvc3NpYmx5XG5cdFx0XHRcdHJldHVybiBzZWxmLm9ycGhhbml6ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5sb2coJ211dGF0ZWQgLS0gcmVwYXJzZScpO1xuXHRcdFx0XHRyZXR1cm4gc2VsZi52aWV3KCkub2JzZXJ2ZXIoKS5wYXVzZShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi52aWV3KCkuaGlnaGxpZ2h0ZXIoKS5yZXBhcnNlKHNlbGYuZGlydHlFeHRlbnQoKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVjbGFzc2lmeSA9IGZ1bmN0aW9uICh0eXBlKXtcblx0XHRcdC8vIHJlY2xhc3NpZnkgc2hvdWxkIGhhcHBlbiB0aHJvdWdoIHRoZSBoaWdobGlnaHRlclxuXHRcdFx0Ly8gbG9nICdyZWNsYXNzaWZ5IG5vZGUgYXMgdHlwZScsdHlwZVxuXHRcdFx0dmFyIGNscyA9IElNLlR5cGVzW3R5cGVdIHx8IEltYmEuVEFHU1soXCJpbVwiICsgdHlwZSldO1xuXHRcdFx0XG5cdFx0XHRpZiAoY2xzKSB7XG5cdFx0XHRcdC8vIGxvZyAnZm91bmQgY2xhc3MgdG8gcmVjbGFzc2lmeSBhcycsY2xzLHNlbGY6Y29uc3RydWN0b3Jcblx0XHRcdFx0aWYgKGNscyA9PSB0aGlzLmNvbnN0cnVjdG9yKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBsb2cgJ2ZvdW5kIGNsYXNzIHRvIHJlY2xhc3NpZnkgYXMnLGNsc1xuXHRcdFx0XHR2YXIgbm9kZSA9IG5ldyBjbHModGhpcy5kb20oKSkuc2V0dXAoKTtcblx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcGFyc2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYmFzZUNsYXNzZXMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBjbHMgPSB0aGlzLmNvbnN0cnVjdG9yLmRvbSgpLmNsYXNzTmFtZTtcblx0XHRcdGlmICh0aGlzLl90eXBlKSB7IGNscyArPSAnICcgKyB0aGlzLl90eXBlIH07XG5cdFx0XHRyZXR1cm4gY2xzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5fZG9tLmNsYXNzTmFtZSA9IHRoaXMuYmFzZUNsYXNzZXMoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXVzZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0dXAuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc0F0b21pYyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gZmluZCB0aGUgbm9kZXMgLyByZWdpb24gdGhhdCBzaG91bGQgYmUgcmVwYXJzZWQgaWYgdGhpcyBlbGVtZW50IGhhcyBjaGFuZ2VkXG5cdFx0Ly8gdGhpcyBpcyBjdXJyZW50bHkgcXVvdGUgXG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5kaXJ0eUV4dGVudCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gM2xvZyBcImdldCBkaXJ0eSBleHRlbnQgZm9yXCIsZG9tXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIHNlbCwgc2VsMSwgc2VsMiwgJDE7XG5cdFx0XHRpZiAoc2VsID0gc2VsZi51cChxJCgnLnNlbGVjdG9yJyxzZWxmKSkpIHtcblx0XHRcdFx0cmV0dXJuIHNlbC5kaXJ0eUV4dGVudCgpO1xuXHRcdFx0fSBlbHNlIGlmIChzZWwxID0gc2VsZi51cChxJCgnLl9pbXRhZ25vZGUnLHNlbGYpKSkge1xuXHRcdFx0XHRyZXR1cm4gc2VsMS5kaXJ0eUV4dGVudCgpO1xuXHRcdFx0fSBlbHNlIGlmIChzZWwyID0gc2VsZi51cChxJCgnLl9pbWlzdHJpbmcnLHNlbGYpKSkge1xuXHRcdFx0XHRyZXR1cm4gc2VsMi5kaXJ0eUV4dGVudCgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKHNlbGYuaXNBdG9taWMoKSkgeyAvLyBobW1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRub2RlczogW3NlbGYuZG9tKCldLFxuXHRcdFx0XHRcdGNvZGU6IHNlbGYuY29kZSgpLFxuXHRcdFx0XHRcdGNvbnRhaW5zOiBmdW5jdGlvbihlbCkgeyByZXR1cm4gc2VsZi5kb20oKS5jb250YWlucyhlbC5fZG9tIHx8IGVsKTsgfVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0dmFyIHN0YXJ0ID0gc2VsZi5kb20oKTtcblx0XHRcdHZhciBlbmQgPSBzZWxmLmRvbSgpO1xuXHRcdFx0XG5cdFx0XHR2YXIgcHJldixuZXh0O1xuXHRcdFx0dmFyIG5vZGVzID0gW3NlbGYuZG9tKCldO1xuXHRcdFx0dmFyIG9wZW5lcixjbG9zZXI7XG5cdFx0XHRcblx0XHRcdHdoaWxlIChwcmV2ID0gc3RhcnQucHJldmlvdXNTaWJsaW5nKXtcblx0XHRcdFx0aWYgKHByZXYgaW5zdGFuY2VvZiBUZXh0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gZWxzZSBpZiAocHJldi5tYXRjaGVzKCcuX2ltbmV3bGluZSwuX2ltdGFiJykpIHsgLy8gLC5faW1vcGVuLC5faW1jbG9zZVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHByZXYubWF0Y2hlcygnLl9pbW9wZW4nKSkge1xuXHRcdFx0XHRcdG9wZW5lciA9IHByZXY7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRzdGFydCA9IHByZXY7XG5cdFx0XHRcdG5vZGVzLnVuc2hpZnQoc3RhcnQpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKG5leHQgPSBlbmQubmV4dFNpYmxpbmcpe1xuXHRcdFx0XHRpZiAobmV4dCBpbnN0YW5jZW9mIFRleHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fSBlbHNlIGlmIChuZXh0Lm1hdGNoZXMoJy5faW1uZXdsaW5lJykpIHsgLy8gLl9pbW9wZW4sLl9pbWNsb3NlXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobmV4dC5tYXRjaGVzKCcuX2ltY2xvc2UnKSkge1xuXHRcdFx0XHRcdGNsb3NlciA9IG5leHQ7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRlbmQgPSBuZXh0O1xuXHRcdFx0XHRub2Rlcy5wdXNoKGVuZCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBzZWUgaWYgd2UgaW5jbHVkZSBhbiBvcGVuIG9yIGNsb3NlLXRhZ1xuXHRcdFx0XG5cdFx0XHR2YXIgcmVzdWx0ID0ge1xuXHRcdFx0XHRub2Rlczogbm9kZXMsXG5cdFx0XHRcdGNvZGU6IFwiXCIsXG5cdFx0XHRcdHRhcmdldDogc2VsZi5kb20oKSxcblx0XHRcdFx0bmVzdGVkOiBbXSxcblx0XHRcdFx0Y29udGFpbnM6IGZ1bmN0aW9uKG5vZGUpIHsgcmV0dXJuIHRoaXMubm9kZXMuaW5kZXhPZihub2RlKSA+PSAwOyB9XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAob3BlbmVyIHx8IGNsb3Nlcikge1xuXHRcdFx0XHQvLyBsb2cgXCJpbmNsdWRlcyBvcGVuZXIgYW5kIC8gb3IgY2xvc2VyXCIsb3BlbmVyLGNsb3NlclxuXHRcdFx0XHR2YXIgcGFyID0gdGFnJHdyYXAoKG9wZW5lciB8fCBjbG9zZXIpLnBhcmVudE5vZGUpO1xuXHRcdFx0XHRpZiAoKCQxID0gcGFyKSAmJiAkMS5pc0F0b21pYyAgJiYgICQxLmlzQXRvbWljKCkpIHtcblx0XHRcdFx0XHQvLyBsb2cgJ3JldHVybiB0aGUgcGFyZW50IGRpcnR5IGV4dGVudCcscGFyXG5cdFx0XHRcdFx0cmV0dXJuIHBhci5kaXJ0eUV4dGVudCgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgbm9kZXMgPSBbXSwgaSA9IDAsIGFyeSA9IGl0ZXIkKChvcGVuZXIgfHwgY2xvc2VyKS5wYXJlbnROb2RlLmNoaWxkcmVuKSwgbGVuXyA9IGFyeS5sZW5ndGg7IGkgPCBsZW5fOyBpKyspIHtcblx0XHRcdFx0XHRub2Rlcy5wdXNoKGFyeVtpXSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgbG9jID0gMDtcblx0XHRcdFxuXHRcdFx0Ly8gc2hvdWxkIHVzZSB0aGUgdGFncyBkaXJlY3RseVxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKG5vZGVzKSwgbGVuXyA9IGFyeS5sZW5ndGgsIG5vZGU7IGkgPCBsZW5fOyBpKyspIHtcblx0XHRcdFx0bm9kZSA9IGFyeVtpXTtcblx0XHRcdFx0dmFyIHJpY2ggPSB0YWckd3JhcChub2RlKTtcblx0XHRcdFx0dmFyIHRleHQgPSBub2RlLnRleHRDb250ZW50O1xuXHRcdFx0XHR2YXIgbGVuID0gdGV4dC5sZW5ndGg7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoZmFsc2UgJiYgcmljaCAmJiAoKHJpY2ggaW5zdGFuY2VvZiBJTS5UeXBlcy5wYWlyKSB8fCByaWNoLmlzSW52YWxpZCgpKSkge1xuXHRcdFx0XHRcdHRleHQgPSBcIifCp8KnwqcnXCI7XG5cdFx0XHRcdFx0bGVuID0gNTtcblx0XHRcdFx0XHRzZWxmLmxvZyhcImFkZGVkIG5vZGUgYXMgbmVzdGVkIHJlZmVyZW5jZVwiLHJpY2guZG9tKCkpO1xuXHRcdFx0XHRcdC8vIHRoaXMgaXMgZnVja2VkIHVwXG5cdFx0XHRcdFx0Ly8gdGhpcyByZWFsbHkgZG9lcyBtZXNzIHVwIHRoZSByaWNoIG5vZGVzIGhlcmUoPyEpXG5cdFx0XHRcdFx0cmVzdWx0Lm5lc3RlZC5wdXNoKHJpY2gpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0cmVzdWx0LmNvZGUgKz0gdGV4dDtcblx0XHRcdFx0bG9jICs9IGxlbjtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJlc3VsdC5ub2RlcyA9IG5vZGVzO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVwYXJzZUV4dGVudCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHJldHVybiBzZWxmLnZpZXcoKS5vYnNlcnZlcigpLnBhdXNlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZGlydHkgPSBzZWxmLmRpcnR5RXh0ZW50KCk7XG5cdFx0XHRcdGlmIChlKSB7IGUuaGFuZGxlZCgpIH07XG5cdFx0XHRcdHJldHVybiBIaWdobGlnaHRlci5yZXBhcnNlKGRpcnR5KTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdC8vIHBpZWNlIG9mIHVucGFyc2VkIGNvZGVcblx0dGFnJC5kZWZpbmVUYWcoJ2ltcmF3JywgJ2ltJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgncmF3Jyk7XG5cdFx0dGFnLmFsaWFzKCdAJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRSYXcgPSBmdW5jdGlvbiAocmF3KXtcblx0XHRcdHRoaXMuX3JhdyA9IHJhdztcblx0XHRcdHRoaXMuX2RvbS50ZXh0Q29udGVudCA9IHJhdztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmVkaXQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLnNldENvZGUoZS5wYXRjaCh0aGlzKSk7XG5cdFx0XHRyZXR1cm4gZS5oYW5kbGVkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1mcmFnbWVudCcsICdpbXJhdycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2ZyYWdtZW50Jyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQpe1xuXHRcdFx0aWYgKHR5cGVvZiBjb250ZW50ID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRoaXMuZG9tKCkuaW5uZXJIVE1MID0gY29udGVudDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhZy5fX3N1cGVyX18uc2V0Q29udGVudC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcGFpciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy51bndyYXAoKTtcblx0XHRcdHRoaXMub3JwaGFuaXplKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdElNRnJhZ21lbnQgPSBJbWJhLlRBR1MuaW1mcmFnbWVudDtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbW9wZW4nLCAnaW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdC8vIEBub2RlVHlwZSA9ICdzJ1xuXHRcdHRhZy50eXBlKCdvcGVuJyk7XG5cdFx0XG5cdFx0dGFnLmFsaWFzKCdbJyk7XG5cdFx0dGFnLmFsaWFzKCcoJyk7XG5cdFx0dGFnLmFsaWFzKCd7Jyk7XG5cdFx0dGFnLmFsaWFzKCd7eycpO1xuXHRcdHRhZy5hbGlhcygnaW5kZXhfc3RhcnQnKTtcblx0XHR0YWcuYWxpYXMoJ2Jsb2NrX3BhcmFtX3N0YXJ0Jyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltY2xvc2UnLCAnaW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy50eXBlKCdjbG9zZScpO1xuXHRcdC8vIEBub2RlVHlwZSA9ICdzJ1xuXHRcdFxuXHRcdHRhZy5hbGlhcygnXScpO1xuXHRcdHRhZy5hbGlhcygnKScpO1xuXHRcdHRhZy5hbGlhcygnfScpO1xuXHRcdHRhZy5hbGlhcygnfX0nKTtcblx0XHR0YWcuYWxpYXMoJ2luZGV4X2VuZCcpO1xuXHRcdHRhZy5hbGlhcygnYmxvY2tfcGFyYW1fZW5kJyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltcnBhcmVuJywgJ2ltY2xvc2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdycGFyZW4nKTtcblx0XHR0YWcuYWxpYXMoJyknKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW10YWdvcGVuJywgJ2ltb3BlbicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3RhZ19zdGFydCcpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXRhZ2Nsb3NlJywgJ2ltY2xvc2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCd0YWdfZW5kJyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltc2Vsb3BlbicsICdpbW9wZW4nLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdzZWxlY3Rvcl9zdGFydCcpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNlbGNsb3NlJywgJ2ltY2xvc2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdzZWxlY3Rvcl9lbmQnKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1xdW90ZScsICdpbScpO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltc2luZ2xlcXVvdGUnLCAnaW1xdW90ZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoXCInXCIpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWRvdWJsZXF1b3RlJywgJ2ltcXVvdGUnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdcIicpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXN0cnN0YXJ0JywgJ2ltb3BlbicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3N0cmluZ19zdGFydCcpO1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnaW1zdHJlbmQnLCAnaW1jbG9zZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3N0cmluZ19lbmQnKTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9ub2Rlcy9iYXNlLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHR2YXIgUmVnaW9uID0gcmVxdWlyZSgnLi4vcmVnaW9uJykuUmVnaW9uO1xuXHR2YXIgSGlnaGxpZ2h0ZXIgPSByZXF1aXJlKCcuLi9jb3JlL2hpZ2hsaWdodGVyJykuSGlnaGxpZ2h0ZXI7XG5cdFxuXHRcblx0dmFyIGtleXdvcmRzID0gW1xuXHRcdCd0cnVlJywnZmFsc2UnLCdudWxsJywndGhpcycsXG5cdFx0J2RlbGV0ZScsJ3R5cGVvZicsJ2luJywnaW5zdGFuY2VvZicsXG5cdFx0J3Rocm93JywnYnJlYWsnLCdjb250aW51ZScsJ2RlYnVnZ2VyJyxcblx0XHQnaWYnLCdlbHNlJywnc3dpdGNoJywnZm9yJywnd2hpbGUnLCdkbycsJ3RyeScsJ2NhdGNoJywnZmluYWxseScsXG5cdFx0J2NsYXNzJywnZXh0ZW5kcycsJ3N1cGVyJywncmV0dXJuJyxcblx0XHQndW5kZWZpbmVkJywndGhlbicsJ3VubGVzcycsJ3VudGlsJywnbG9vcCcsJ29mJywnYnknLFxuXHRcdCd3aGVuJywnZGVmJywndGFnJywnZG8nLCdlbGlmJywnYmVnaW4nLCd2YXInLCdsZXQnLCdzZWxmJywnYXdhaXQnLCdpbXBvcnQnLFxuXHRcdCdhbmQnLCdvcicsJ2lzJywnaXNudCcsJ25vdCcsJ3llcycsJ25vJywnaXNhJywnY2FzZScsJ25pbCcsJ2V4dGVuZCcsJ2V4cG9ydCcsJ293bidcblx0XTtcblx0XG5cdC8vIHRoaXMgaXMgcmVhbGx5IHRoZSBnZW5lcmFsIHRva2VuXG5cdHRhZyQuZGVmaW5lVGFnKCdpbXRvaycsICdpbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLmFsaWFzKCd0b2tlbicpO1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX19lcmVmID0ge3dhdGNoOiAnZXJlZkRpZFNldCcsbmFtZTogJ2VyZWYnfTtcblx0XHR0YWcucHJvdG90eXBlLmVyZWYgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdlcmVmJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEVyZWYgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5lcmVmKCk7XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2VyZWYnLHYpOyB9XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5lcmVmRGlkU2V0ICYmIHRoaXMuZXJlZkRpZFNldCh2LGEsdGhpcy5fX2VyZWYpIH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5lcmVmRGlkU2V0ID0gZnVuY3Rpb24gKG5ldyQsb2xkKXtcblx0XHRcdC8vIGV4cGVyaW1lbnRhbFxuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2VyZWZEaWRTZXQnLG5ldyxvbGRcblx0XHRcdGlmICghKG5ldyQgJiYgb2xkKSkgeyB0aGlzLmZsYWcoJ2x2YXInLCEoIShuZXckKSkpIH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaXNWYXJSZWYgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmhhc0ZsYWcoJ2x2YXInKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuY2xlYXJWYXJSZWYgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuc2V0RXJlZihudWxsKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0cmV0dXJuIElNLnRvayh2YWwpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpe1xuXHRcdFx0dGFnLl9fc3VwZXJfXy5zZXRUZXh0LmNhbGwodGhpcyx0ZXh0KTtcblx0XHRcdHRoaXMuY2xhc3NpZnkoKTtcblx0XHRcdFxuXHRcdFx0dmFyIHR5cCA9IElNLmlkZW50aWZ5KHRleHQpO1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwKSB7XG5cdFx0XHRcdHRoaXMubG9nKCdyZWNsYXNzaWZ5aW5nIGltdG9rIGltbWVkaWF0ZWx5Jyk7XG5cdFx0XHRcdHRoaXMuc2V0Q29kZSh0ZXh0KTtcblx0XHRcdFx0cmV0dXJuIHRoaXMucmVjbGFzc2lmeSh0eXApO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gcmV0dXJuIHJhdyB0b2tlbiBpZiBub3QgY2xhc3NpZmllZD9cblx0XHRcdHJldHVybiB0aGlzLl90eXAgPyAodGhpcykgOiAodGFnJC4kaW1yYXcoKS5zZXRSYXcodGV4dCkuZW5kKCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5QcmVwZW5kID0gZnVuY3Rpb24gKHRleHQpe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNhbkFwcGVuZCA9IGZ1bmN0aW9uICh0ZXh0KXtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jbGFzc2lmeSA9IGZ1bmN0aW9uIChtYXApe1xuXHRcdFx0bWFwIHx8IChtYXAgPSBJTS5pZGVudGlmeSh0aGlzLmNvZGUoKSkpO1xuXHRcdFx0aWYgKG1hcCkge1xuXHRcdFx0XHRpZiAoIW1hcC5tYXRjaCgvXFxiX1tcXHddLykpIHsgbWFwID0gJ19pbXRvayAnICsgbWFwIH07XG5cdFx0XHRcdHRoaXMuZG9tKCkuY2xhc3NOYW1lID0gbWFwO1xuXHRcdFx0XHR0aGlzLl90eXAgPSBtYXA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl90eXAgPSBudWxsO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjb2RlKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVwYWlyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmxvZygncmVwYWlyJyk7XG5cdFx0XHR0aGlzLmNsYXNzaWZ5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAocmVnaW9uKXtcblx0XHRcdHJlZ2lvbiA9IFJlZ2lvbi5ub3JtYWxpemUocmVnaW9uKTtcblx0XHRcdHZhciBsZnQgPSB0aGlzLmNvZGUoKS5zdWJzdHJpbmcoMCxyZWdpb24uc3RhcnQoKSk7XG5cdFx0XHR2YXIgcmd0ID0gdGhpcy5jb2RlKCkuc2xpY2UocmVnaW9uLmVuZCgpKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5zZXRDb2RlKGxmdCk7XG5cdFx0XHR0aGlzLnNldE5leHQoSU0udG9rKHJndCkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAobyl7XG5cdFx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRcdHZhciBkaXJ0eSA9IHRoaXMuZGlydHlFeHRlbnQoKTtcblx0XHRcdHRoaXMudmlldygpLm9ic2VydmVyKCkucGF1c2UoZnVuY3Rpb24oKSB7IHJldHVybiBIaWdobGlnaHRlci5yZXBhcnNlKGRpcnR5KTsgfSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmV1c2UgPSBmdW5jdGlvbiAodG9rLG5ldyQsb2xkKXtcblx0XHRcdGlmIChuZXckID09IG9sZCkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0cmV0dXJuIHRhZy5fX3N1cGVyX18ucmV1c2UuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKG8pe1xuXHRcdFx0aWYobyA9PT0gdW5kZWZpbmVkKSBvID0ge307XG5cdFx0XHRpZiAoIW8uZGVlcCAmJiB0aGlzLnZhbGlkYXRlKHRoaXMuY29kZSgpKSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0cmV0dXJuIHRhZy5fX3N1cGVyX18ubXV0YXRlZC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uZGJsY2xpY2sgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRlLmhhbHQoKTtcblx0XHRcdHJldHVybiB0aGlzLnNlbGVjdCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbm1vdXNlb3ZlciA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5lcmVmKCkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMudmlldygpLm5vZGVzRm9yRW50aXR5KHRoaXMuZXJlZigpKS5tYXAoZnVuY3Rpb24oZWwpIHsgcmV0dXJuIGVsLmZsYWcoJ2hsJyk7IH0pO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25tb3VzZW91dCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0aWYgKHRoaXMuZXJlZigpKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnZpZXcoKS5ub2Rlc0ZvckVudGl0eSh0aGlzLmVyZWYoKSkubWFwKGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbC51bmZsYWcoJ2hsJyk7IH0pO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1pZGVudGlmaWVyJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnaWRlbnRpZmllcicpO1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0TmFtZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnbmFtZScsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0XHQvLyByZWdleCBmb3IgaWRlbnRpZmllclxuXHRcdFx0cmV0dXJuICgvXlthLXpdKC0/W1xcd0EtWmEtel9cXC1cXHg3Zi1cXHVmZmZmXFwkXSspKiQvKS50ZXN0KGNvZGUpICYmIGtleXdvcmRzLmluZGV4T2YoY29kZSkgPT0gLTE7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKHRvayxuZXckLG9sZCl7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnaWRlbnRpZmllciBzZXR1cCcsYmFzZUNsYXNzZXNcblx0XHRcdHZhciB2Xztcblx0XHRcdGlmICh0b2sgJiYgdG9rLl92YWx1ZSkgeyAodGhpcy5zZXROYW1lKHZfID0gdG9rLl92YWx1ZSksdl8pIH07XG5cdFx0XHR0aGlzLl9kb20uY2xhc3NOYW1lID0gdGhpcy5iYXNlQ2xhc3NlcygpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdpbWlkZW50aWZpZXIgbXV0YXRlZCdcblx0XHRcdHRoaXMuc2V0TmFtZSh0aGlzLmNvZGUoKSk7XG5cdFx0XHRpZiAodGhpcy5pc1ZhclJlZigpKSB7XG5cdFx0XHRcdHRoaXMuY2xlYXJWYXJSZWYoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGFnLl9fc3VwZXJfXy5tdXRhdGVkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXRhZ3R5cGUnLCAnaW10b2snLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCd0YWdfdHlwZScpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXRhZ2lkJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgndGFnX2lkJyk7XG5cdFx0dGFnLmFsaWFzKCdpZHJlZicpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWNvbnN0JywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnY29uc3QnKTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdFx0cmV0dXJuICgvXltBLVpdKC0/W1xcd0EtWmEtel9cXC1cXHg3Zi1cXHVmZmZmXFwkXSspKiQvKS50ZXN0KGNvZGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gZGVmIG9uY2hhbmdlZCBjb2RlLCBwcmV2XG5cdFx0Ly8gXHQjIGNvbnNvbGUubG9nICdpbWNvbnN0IG9uY2hhbmdlZCcsY29kZSxwcmV2XG5cdFx0Ly8gXHRmbGFnKCdkaXJ0eScpIHVubGVzcyB2YWxpZGF0ZShjb2RlKVxuXHR9KTtcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1pdmFyJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnaXZhcicpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWN2YXInLCAnaW10b2snLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdjdmFyJyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2lta2V5d29yZCcsICdpbXRvaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2tleXdvcmQnKTtcblx0XHR0YWcuYWxpYXMoJ25ldycpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAodG9rLG5ldyQsb2xkKXtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdzZXR1cCBpbWtleXdvcmQnLHRvaywgbmV3LCBvbGRcblx0XHRcdHZhciBjbHMgPSB0aGlzLmJhc2VDbGFzc2VzKCk7XG5cdFx0XHRpZiAodG9rICYmIHRvay5fdmFsdWUpIHsgY2xzICs9ICcgJyArIHRvay5fdmFsdWUgfTtcblx0XHRcdHRoaXMuX2RvbS5jbGFzc05hbWUgPSBjbHM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdGtleXdvcmRzLm1hcChmdW5jdGlvbihrZXl3b3JkKSB7IHJldHVybiBJTS5UeXBlc1trZXl3b3JkXSA9IElNLlR5cGVzLmtleXdvcmQ7IH0pO1xuXHRcblx0SU0uVHlwZXMuZm9yaW4gPSBJTS5UeXBlcy5rZXl3b3JkO1xuXHRJTS5UeXBlcy5mb3JvZiA9IElNLlR5cGVzLmtleXdvcmQ7XG5cdElNLlR5cGVzLnBvc3RfaWYgPSBJTS5UeXBlcy5rZXl3b3JkO1xuXHRJTS5UeXBlcy5wb3N0X3VubGVzcyA9IElNLlR5cGVzLmtleXdvcmQ7XG5cdElNLlR5cGVzLnBvc3RfZm9yID0gSU0uVHlwZXMua2V5d29yZDtcblx0SU0uVHlwZXMucG9zdF93aGlsZSA9IElNLlR5cGVzLmtleXdvcmQ7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1udW0nLCAnaW10b2snLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdudW1iZXInKTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNvZGUpe1xuXHRcdFx0cmV0dXJuICgvXlxcZCsoXFwuXFxkKyk/JC8pLnRlc3QoY29kZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJldXNlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWludCcsICdpbW51bScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2ludCcpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWZsb2F0JywgJ2ltbnVtJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnZmxvYXQnKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1ib29sJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnYm9vbCcpO1xuXHRcdHRhZy5hbGlhcygndHJ1ZScpO1xuXHRcdHRhZy5hbGlhcygnZmFsc2UnKTtcblx0fSk7XG5cdFxuXHQvLyB0aGlzIHNob3VsZCBiZSBtb3JlIGFkdmFuY2VkIC0gbm9cblx0dGFnJC5kZWZpbmVUYWcoJ2ltc3RyJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc3RyaW5nJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5xdW90ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuY29kZSgpWzBdO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRRdW90ZSA9IGZ1bmN0aW9uIChxdW90ZSl7XG5cdFx0XHR0aGlzLnNldENvZGUocXVvdGUgKyB0aGlzLmNvZGUoKS5zbGljZSgxLC0xKSArIHF1b3RlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uICh0b2ssbmV3JCxvbGQpe1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ3NldHVwIHN0cmluZycsdG9rLCBuZXcsIG9sZFxuXHRcdFx0dGhpcy5fZG9tLmNsYXNzTmFtZSA9IHRoaXMuYmFzZUNsYXNzZXMoKTtcblx0XHRcdHRoaXMuc2V0Q29kZShuZXckKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnVud3JhcCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHZhciB2Xztcblx0XHRcdHRoaXMubG9nKCdpbXN0cmluZyBvbnVud3JhcCEhIScsZSk7XG5cdFx0XHRlLmhhbHQoKTtcblx0XHRcdC8vIGxvb2sgYXQgcHJldiBhbmQgbmV4dCBhcyB3ZWxsP1xuXHRcdFx0Ly8gc2hvdWxkIGRvIHRoaXMgdGhyb3VnaCB0aGUgdmlld1xuXHRcdFx0cmV0dXJuICh0aGlzLnNldENvZGUodl8gPSB0aGlzLmNvZGUoKS5zbGljZSgxLC0xKSksdl8pO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmRibGNsaWNrID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0ZS5oYWx0KCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZWxlY3QoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0XHRpZiAoY29kZVswXSA9PSAnXCInKSB7XG5cdFx0XHRcdHJldHVybiAoL15cXFwiKFteXCJcXHtdKilcXFwiJC8pLnRlc3QoY29kZSk7XG5cdFx0XHR9IGVsc2UgaWYgKGNvZGVbMF0gPT0gXCInXCIpIHtcblx0XHRcdFx0cmV0dXJuICgvXlxcJyhbXidcXHtdKilcXCckLykudGVzdChjb2RlKTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRcblx0XHR0YWcudHJpZ2dlcignXCInLGZ1bmN0aW9uKHRva2VuLG8pIHtcblx0XHRcdGlmICh0b2tlbi5xdW90ZSgpID09ICdcIicpIHtcblx0XHRcdFx0dGhpcy5pbnNlcnQoJ1xcXFxcIicpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAodG9rZW4ucXVvdGUoKSA9PSBcIidcIiAmJiBvLm1vZGUgPT0gJ2FsbCcpIHtcblx0XHRcdFx0dG9rZW4uc2V0UXVvdGUoJ1wiJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHR9KTtcblx0XHRcblx0XHR0YWcudHJpZ2dlcihcIidcIixmdW5jdGlvbih0b2tlbixvKSB7XG5cdFx0XHR2YXIgdl87XG5cdFx0XHRpZiAodG9rZW4ucXVvdGUoKSA9PSAnXCInKSB7XG5cdFx0XHRcdHJldHVybiAodG9rZW4uc2V0UXVvdGUodl8gPSBcIidcIiksdl8pO1xuXHRcdFx0fSBlbHNlIGlmICh0b2tlbi5xdW90ZSgpID09IFwiJ1wiICYmIG8ubW9kZSA9PSAnYWxsJykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5pbnNlcnQoXCJcXFxcJ1wiKTtcblx0XHRcdH07XG5cdFx0fSk7XG5cdH0pO1xuXHRcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1uZW9zdHJpbmcnLCAnaW10b2snLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCduZW9zdHJpbmcnKTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAobyl7XG5cdFx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRcdGlmICghby5kZWVwICYmICF0aGlzLmNvZGUoKS5tYXRjaCgvW1xce1xcXCJcXCddLykpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcdHJldHVybiB0YWcuX19zdXBlcl9fLm11dGF0ZWQuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltc3ltJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc3ltYm9sJyk7XG5cdH0pO1xuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdpbXRhZ2F0dHInLCAnaW10b2snLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCd0YWdfYXR0cicpO1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL25vZGVzL3Rva2VuLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGlkeCQoYSxiKXtcblx0XHRyZXR1cm4gKGIgJiYgYi5pbmRleE9mKSA/IGIuaW5kZXhPZihhKSA6IFtdLmluZGV4T2YuY2FsbChhLGIpO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0XG5cdHZhciBIaWdobGlnaHRlciA9IHJlcXVpcmUoJy4uL2NvcmUvaGlnaGxpZ2h0ZXInKS5IaWdobGlnaHRlcjtcblx0dmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWJsb2NrJywgJ2ltJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRlbGV0ZUxlZnRSaWdodCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHRoaXMubG9nKCdpbWJsb2NrIGRlbGV0ZUxlZnRSaWdodCcsZS5yZWdpb24oKS5wZWVrKC0xLDEpKTtcblx0XHRcdFxuXHRcdFx0aWYgKGUucmVnaW9uKCkucGVlaygtMSwxKSA9PSB0aGlzLmNvZGUoKSkge1xuXHRcdFx0XHR0aGlzLm9ycGhhbml6ZSgpO1xuXHRcdFx0XHRyZXR1cm4gZS5oYW5kbGVkKCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5kZW50QmxvY2sgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRlLmhhbmRsZWQoKTtcblx0XHRcdFxuXHRcdFx0c2VsZi52aWV3KCkuY2FyZXQoKS5leHBhbmRUb0xpbmVzKCk7XG5cdFx0XHR2YXIgcmVnaW9uID0gc2VsZi52aWV3KCkuY2FyZXQoKS5yZWdpb24oKTtcblx0XHRcdHZhciBub2RlcyA9IHNlbGYudmlldygpLm5vZGVzSW5SZWdpb24ocmVnaW9uKTtcblx0XHRcdFxuXHRcdFx0bm9kZXMubWFwKGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHRcdGlmIChtYXRjaC5ub2RlLm1hdGNoZXMoJy5faW1uZXdsaW5lJykpIHtcblx0XHRcdFx0XHRzZWxmLmxvZygnZm91bmQgdGFiIGluIHNlbGVjdGlvbicsbWF0Y2gpO1xuXHRcdFx0XHRcdGlmIChtYXRjaC5tb2RlICE9ICdzdGFydCcpIHtcblx0XHRcdFx0XHRcdHJldHVybiBtYXRjaC5ub2RlLmluZGVudCgpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0c2VsZi52aWV3KCkuY2FyZXQoKS5kaXJ0eSgpO1xuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnVuZGVudCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHRoaXMubG9nKCdpbWJsb2NrLnVuZGVudCcsYXJndW1lbnRzKTtcblx0XHRcdHZhciBub2RlcyA9IGUudmlldygpLm5vZGVzSW5SZWdpb24oZS5yZWdpb24oKS5jbG9uZSgpLnN0YXJ0QXRMaW5lKCkpO1xuXHRcdFx0bm9kZXMubWFwKGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHRcdGlmIChtYXRjaC5ub2RlLm1hdGNoZXMoJy5faW1uZXdsaW5lJykgJiYgbWF0Y2gubW9kZSAhPSAnc3RhcnQnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoLm5vZGUudW5kZW50KCk7XG5cdFx0XHRcdFx0Ly8gZS5jYXJldC5leHBhbmQoMCwtMSlcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy52aWV3KCkuY2FyZXQoKS5leHBhbmRUb0xpbmVzKCk7XG5cdFx0XHRyZXR1cm4gZS5oYW5kbGVkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnBhaXJhYmxlID0gZnVuY3Rpb24gKHN0cixlKXtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKG5vZGUpe1xuXHRcdFx0dGhpcy5zZXRDaGlsZHJlbihbbm9kZV0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcGFpciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gbG9nIFwicmVwYWlyIGJsb2NrXCJcblx0XHRcdHEkKCcuX2ltcmF3Jyx0aGlzKS5tYXAoZnVuY3Rpb24ocmF3KSB7IHJldHVybiByYXcucmVwYWlyKCk7IH0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyB2YXIgcmVnID0gdmlldy5zZWwucmVnaW9uXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR2YXIgc3RhdGUgPSBzZWxmLmNvZGVTdGF0ZSgpO1xuXHRcdFx0dmFyIGhsID0gSU0ucGFyc2Uoc3RhdGUuY29kZSk7XG5cdFx0XHQvLyBjb3VsZCBzZW5kIHRoaXMgdGhyb3VnaCBsb2FkIGluc3RlYWRcblx0XHRcdC8vIHdoYXQgYWJvdXQgYW5ub3RhdGlvbnMgaGVyZT9cblx0XHRcdHRocm93ICdkb250IHJlaGlnaGxpZ2h0Jztcblx0XHRcdFxuXHRcdFx0aWYgKGhsKSB7XG5cdFx0XHRcdHNlbGYudmlldygpLm9ic2VydmVyKCkucGF1c2UoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c2VsZi5kb20oKS5pbm5lckhUTUwgPSBobCArICdcXG4nO1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZS5pbnZhbGlkcy5tYXAoZnVuY3Rpb24oaW52KSB7XG5cdFx0XHRcdFx0XHQvLyB3ZSBjb3VsZCBnbyBsb2NhbCBpbnN0ZWFkXG5cdFx0XHRcdFx0XHR2YXIgbm9kZTtcblx0XHRcdFx0XHRcdGlmIChub2RlID0gc2VsZi52aWV3KCkubm9kZUF0UmVnaW9uKGludi5yZWdpb24sdHJ1ZSkpIHtcblx0XHRcdFx0XHRcdFx0c2VsZi5sb2coJ2ZvdW5kIG5vZGUgYXQgaW52YWxpZCBwb3NpdGlvbicsbm9kZSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBub2RlLnJlcGxhY2VXaXRoKGludi5ub2RlKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gYmFkIG5hbWluZ1xuXHRcdHRhZy5wcm90b3R5cGUuY29kZVN0YXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR2YXIgcmVhbCA9IHNlbGYuY29kZSgpO1xuXHRcdFx0dmFyIHZhbGlkID0gcmVhbDtcblx0XHRcdHZhciBpbnZhbGlkcyA9IHEkKCcuaW52YWxpZCcsc2VsZik7XG5cdFx0XHR2YXIgb3ducmVnID0gc2VsZi5yZWdpb24oKTtcblx0XHRcdHZhciBzZWxyZWcgPSBzZWxmLnZpZXcoKS5zZWwoKS5yZWdpb24oKTtcblx0XHRcdFxuXHRcdFx0dmFyIHJlbWVtYmVyID0gaW52YWxpZHMubWFwKGZ1bmN0aW9uKGludikge1xuXHRcdFx0XHQvLyBtdWx0aWxldmVsIG5lc3Rpbmc/XG5cdFx0XHRcdHZhciByZWdpb24gPSBpbnYucmVnaW9uKCk7XG5cdFx0XHRcdHZhciByZWxyZWcgPSByZWdpb24ucmVsYXRpdmVUbyhvd25yZWcpO1xuXHRcdFx0XHRzZWxmLmxvZygnaW52YWxpZCByZWdpb24nLG93bnJlZywnc2VsZicscmVnaW9uLHJlbHJlZyk7XG5cdFx0XHRcdHZhbGlkID0gdmFsaWQuaW5zKGludi5wbGFjZWhvbGRlcigpLHJlbHJlZyk7XG5cdFx0XHRcdHJldHVybiB7cmVnaW9uOiByZWdpb24scGxhY2Vob2xkZXI6IGludi5wbGFjZWhvbGRlcigpLHJhdzogaW52LmNvZGUoKSxub2RlOiBpbnYscm9vdDogc2VsZixyZWxSZWdpb246IHJlbHJlZ307XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cmVnaW9uOiBvd25yZWcsXG5cdFx0XHRcdG1hcmtlcjogKHNlbHJlZy5pbnRlcnNlY3RzKG93bnJlZykgPyAoc2VscmVnKSA6IChudWxsKSksXG5cdFx0XHRcdHJhdzogcmVhbCxcblx0XHRcdFx0Y29kZTogdmFsaWQsXG5cdFx0XHRcdGludmFsaWRzOiByZW1lbWJlclxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1pbnRlcnBvbGF0ZWQnLCAnaW1ibG9jaycpO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2luZGVudCcsICdpbWJsb2NrJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIG1hcCA9IHt9O1xuXHRcdFx0dmFyIHZhcnMgPSBbXTtcblx0XHRcdHEkKCcuX2x2YXInLHRoaXMpLm1hcChmdW5jdGlvbihsdmFyKSB7XG5cdFx0XHRcdHZhciBuYW1lID0gbHZhci50ZXh0KCk7XG5cdFx0XHRcdGlmICghbWFwW25hbWVdKSB7XG5cdFx0XHRcdFx0bWFwW25hbWVdID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm4gdmFycy5wdXNoKG5hbWUpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gdmFycztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXBhaXInLCAnaW1ibG9jaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ3BhaXInKTtcblx0XHRcblx0XHR0YWcucGFpciA9IGZ1bmN0aW9uIChvcGVuLGNsb3NlKXtcblx0XHRcdHRoaXMucHJvdG90eXBlLl9vcGVuID0gb3Blbjtcblx0XHRcdHRoaXMucHJvdG90eXBlLl9jbG9zZSA9IGNsb3NlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9vcGVuIHx8ICcnO1xuXHRcdH07XG5cdFx0dGFnLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX2Nsb3NlIHx8ICcnO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5nZW4oKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQpe1xuXHRcdFx0dGhyb3cgJ3Nob3VsZCBub3QgZ2V0IGhlcmUnO1xuXHRcdFx0dGhpcy5kb20oKS5pbm5lckhUTUwgPSB0aGlzLm9wZW4oKSArIElNLnBhcnNlKGNvbnRlbnQpICsgdGhpcy5jbG9zZSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmNvZGUoKS5yZXBsYWNlKC9bXFxzXFx0IFxcbl0vLCcnKSA9PSAodGhpcy5vcGVuKCkgKyB0aGlzLmNsb3NlKCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc1BhaXJlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIGNvZGUgPSB0aGlzLmNvZGUoKTtcblx0XHRcdHJldHVybiBjb2RlWzBdID09IHRoaXMub3BlbigpICYmIGNvZGVbY29kZS5sZW5ndGggLSAxXSA9PSB0aGlzLmNsb3NlKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlzT3BlbmVkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb2RlKClbMF0gPT0gdGhpcy5vcGVuKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlzQ2xvc2VkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb2RlKClbdGhpcy5jb2RlKCkubGVuZ3RoIC0gMV0gPT0gdGhpcy5jbG9zZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS51bndyYXAgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGlmICh0aGlzLmlzRW1wdHkoKSkge1xuXHRcdFx0XHR0aGlzLmxvZygncmVtb3ZlIHRoZSB3aG9sZSB0aGluZycpO1xuXHRcdFx0XHR0aGlzLm9ycGhhbml6ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGVsO1xuXHRcdFx0XHR2YXIgcGFyID0gdGhpcy5wYXJlbnQoKTtcblx0XHRcdFx0d2hpbGUgKGVsID0gdGhpcy5fZG9tLmZpcnN0Q2hpbGQpe1xuXHRcdFx0XHRcdHBhci5kb20oKS5pbnNlcnRCZWZvcmUoZWwsdGhpcy5fZG9tKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0Ly8gcmVtb3ZlIHNlbGYgYXMgd2VsbFxuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnVud3JhcCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHRoaXMubG9nKCdpbXBhaXIgb251bndyYXAhISEnLGUpO1xuXHRcdFx0cmV0dXJuIGUuaGFsdCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5nZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuc2V0Q2hpbGRyZW4oW1xuXHRcdFx0XHR0YWckLiRpbW9wZW4oKS5zZXRDb250ZW50KHRoaXMub3BlbigpLDApLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRpbWNsb3NlKCkuc2V0Q29udGVudCh0aGlzLmNsb3NlKCksMCkuZW5kKClcblx0XHRcdF0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uaW5zZXJ0ZWQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRlLnNldENhcmV0KHRoaXMucmVnaW9uKCkuY29sbGFwc2UoZmFsc2UpLm1vdmUoMSkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ubGluZWJyZWFrID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dmFyIHByZSA9IGUubGluZXN0cigncHJlJyk7XG5cdFx0XHR2YXIgaW5kZW50ID0gZS5pbmRlbnQoKTtcblx0XHRcdHZhciBuZXckID0gdGhpcy50ZXh0KCkuaW5zKCcnLGUucmVsUmVnaW9uKCkpO1xuXHRcdFx0XG5cdFx0XHQvLyB0aGlzIGlzIGEgc3BlY2lhbCBjYXNlIC0gbm8/XG5cdFx0XHRpZiAobmV3JCA9PSAodGhpcy5vcGVuKCkgKyB0aGlzLmNsb3NlKCkpKSB7XG5cdFx0XHRcdHZhciBwcmVmaXggPSAnXFxuJyArIGluZGVudCArICdcXHQnO1xuXHRcdFx0XHR2YXIgcG9zdCA9ICdcXG4nICsgaW5kZW50O1xuXHRcdFx0XHR0aGlzLm9ud2hpdGVzcGFjZShlLHByZWZpeCArIHBvc3QpO1xuXHRcdFx0XHRlLmNhcmV0KCkuY29sbGFwc2UoZmFsc2UpLm1vdmUoLXBvc3QubGVuZ3RoKTtcblx0XHRcdFx0cmV0dXJuIGUuaGFuZGxlZCgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gbmVlZCB0byBmaXJzdCBjb25zaWRlciB0aGUgc3BsaXR0aW5nLCBubz9cblx0XHRcdGlmICh0aGlzLmluY3JlYXNlSW5kZW50KHByZSkpIHsgaW5kZW50ICs9ICdcXHQnIH07XG5cdFx0XHRpZiAodGhpcy5kZWNyZWFzZUluZGVudChwcmUpKSB7IGluZGVudCA9IGluZGVudC5zbGljZSgxKSB9O1xuXHRcdFx0dGhpcy5vbndoaXRlc3BhY2UoZSwnXFxuJyArIGluZGVudCk7XG5cdFx0XHRyZXR1cm4gZS5oYW5kbGVkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcGFpciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5sb2coJ3JlcGFpciBpbXRhZycpO1xuXHRcdFx0aWYgKCEodGhpcy5pc1BhaXJlZCgpKSkgeyB0aGlzLnJldmFsaWRhdGUodHJ1ZSkgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmxvZygnaW1wYWlyIG11dGF0ZWQnKTtcblx0XHRcdHJldHVybiB0aGlzLnJldmFsaWRhdGUoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGVmYXVsdFZhbGlkYXRpb25Nb2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gJ3Rva2VuaXplJztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVoaWdobGlnaHQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZXZhbGlkYXRlID0gZnVuY3Rpb24gKG1vZGUsd3JpdGUpe1xuXHRcdFx0Ly8gdHJpY2t5IG1vdGhlcmZ1Y2tlciAtLSBtb3N0bHkgdXNlZnVsIGZvciB2YWxpZGF0aW9uc1xuXHRcdFx0Ly8gSSBzdXBwb3NlIHdlIGNhbiBkbyB0aGlzIGEgc2ltcGxlciB3YXkgLS0gYnkgdHVybmluZ1xuXHRcdFx0Ly8gb2ZmIG9ic2VydmVycyAtLSB0ZW1wb3JhcmlseSByZXBsYWNpbmcgaW5uZXIgY29kZSBldGNcblx0XHRcdFxuXHRcdFx0Ly8gd2hlbiBhIGJsb2NrIGNoZWNrcyB2YWxpZGl0eSBpdCBzaG91bGQgcHJvYmFibHlcblx0XHRcdC8vIHN1YnN0aXR1dGUgaW5uZXIgaW52YWxpZCBwYXJ0cyAtIHNvIHRoYXQgdGhlIGJsb2NrXG5cdFx0XHQvLyB0aGluZyBpcyBzdGlsbCB2YWxpZFxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCBobDtcblx0XHRcdGlmKG1vZGUgPT09IHVuZGVmaW5lZCkgbW9kZSA9IHNlbGYuZGVmYXVsdFZhbGlkYXRpb25Nb2RlKCk7XG5cdFx0XHRpZih3cml0ZSA9PT0gdW5kZWZpbmVkKSB3cml0ZSA9IGZhbHNlO1xuXHRcdFx0dmFyIHdhc0ludmFsaWQgPSBzZWxmLmhhc0ZsYWcoJ2ludmFsaWQnKTtcblx0XHRcdHZhciBvbGRTdGF0ZSA9IHNlbGYuaGFzRmxhZygnaW52YWxpZCcpO1xuXHRcdFx0dmFyIHN0YXRlID0gc2VsZi5jb2RlU3RhdGUoKTtcblx0XHRcdHZhciBjb2RlID0gc3RhdGUuY29kZTtcblx0XHRcdFxuXHRcdFx0aWYgKCEoc2VsZi5pc1BhaXJlZCgpKSkge1xuXHRcdFx0XHRyZXR1cm4gc2VsZi5tYXJrSW52YWxpZCgpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y29uc29sZS5sb2coJ3dpbGwgcmV2YWxpZGF0ZSB3aXRoIGNvZGUnLGNvZGUpO1xuXHRcdFx0Y29uc29sZS50aW1lKCdyZXZhbGlkYXRlJyk7XG5cdFx0XHRcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmIChtb2RlID09ICdjb21waWxlJykge1xuXHRcdFx0XHRcdHNlbGYuX291dHB1dCA9IEltYmFjLmNvbXBpbGUoY29kZSx7YmFyZTogdHJ1ZX0pO1xuXHRcdFx0XHRcdHNlbGYuX3Rva2VucyA9IHNlbGYuX291dHB1dC5vcHRpb25zLl90b2tlbnM7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZi5fdG9rZW5zID0gSW1iYWMudG9rZW5pemUoY29kZSx7YmFyZTogdHJ1ZX0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRzZWxmLm1hcmtWYWxpZCgpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRzZWxmLl90b2tlbnMgPSBudWxsO1xuXHRcdFx0XHRzZWxmLm1hcmtJbnZhbGlkKCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRjb25zb2xlLnRpbWVFbmQoJ3JldmFsaWRhdGUnKTtcblx0XHRcdFxuXHRcdFx0aWYgKHdhc0ludmFsaWQgJiYgc2VsZi5fdG9rZW5zKSB7XG5cdFx0XHRcdC8vIG5lZWQgdG8gZml4IGlubmVyIGZvciByb290XG5cdFx0XHRcdGlmIChobCA9IEhpZ2hsaWdodGVyLmhpZ2hsaWdodChjb2RlLHt0b2tlbnM6IHNlbGYuX3Rva2Vucyxpbm5lcjogdHJ1ZX0pKSB7XG5cdFx0XHRcdFx0Ly8gdGhpcyBzaG91bGQgYmUgcmVmYWN0b3JlZCBvdXQgaW50byBhIHNlcGFyYXRlIG1ldGhvZFxuXHRcdFx0XHRcdC8vIHBvc3NpYmx5IGRvIGxvYWRTdGF0ZSAvIGR1bXBTdGF0ZVxuXHRcdFx0XHRcdHNlbGYudmlldygpLm9ic2VydmVyKCkucGF1c2UoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzZWxmLmRvbSgpLmlubmVySFRNTCA9IGhsO1xuXHRcdFx0XHRcdFx0c3RhdGUuaW52YWxpZHMubWFwKGZ1bmN0aW9uKGludikge1xuXHRcdFx0XHRcdFx0XHR2YXIgbm9kZTtcblx0XHRcdFx0XHRcdFx0aWYgKG5vZGUgPSBzZWxmLnZpZXcoKS5ub2RlQXRSZWdpb24oaW52LnJlZ2lvbix0cnVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBub2RlLnJlcGxhY2VXaXRoKGludi5ub2RlKTtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0aWYgKHN0YXRlLm1hcmtlcikgeyByZXR1cm4gc2VsZi52aWV3KCkuc2VsKCkuc2V0KHN0YXRlLm1hcmtlcikgfTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wbGFjZWhvbGRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMub3BlbigpICsgKCcgJykucmVwZWF0KHRoaXMuc2l6ZSgpIC0gMikgKyB0aGlzLmNsb3NlKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlzQXRvbWljID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubXV0YXRlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5sb2coJ211YXRlZCBpbWN1cmx5Jyk7XG5cdFx0XHR0aGlzLnZpZXcoKS5oaWdobGlnaHRlcigpLnJlcGFyc2UodGhpcy5kaXJ0eUV4dGVudCgpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltY3VybHknLCAnaW1wYWlyJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnY3VybHknKTtcblx0XHR0YWcucGFpcigneycsJ30nKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1zcXVhcmUnLCAnaW1wYWlyJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc3F1YXJlJyk7XG5cdFx0dGFnLnBhaXIoJ1snLCddJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wcmV0dGlmeSA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHNlbGYubG9nKCdwcmV0dGlmeSEnKTtcblx0XHRcdGUuaGFuZGxlZCgpO1xuXHRcdFx0dmFyIGluZCA9IGUucmVnaW9uKCkuaW5kZW50KCk7XG5cdFx0XHRzZWxmLmxvZygnd2l0aCBpbmRlbnRhdGlvbicsaW5kLGluZC5sZW5ndGgpO1xuXHRcdFx0XG5cdFx0XHRzZWxmLnZpZXcoKS5vYnNlcnZlcigpLnBhdXNlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoc2VsZi5jaGlsZHJlbigpKSwgbGVuID0gYXJ5Lmxlbmd0aCwgY2hpbGQsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRjaGlsZCA9IGFyeVtpXTtcblx0XHRcdFx0XHRyZXMucHVzaChjaGlsZC5tYXRjaGVzKCcuY29tbWEsLl9pbW9wZW4nKSA/IChcblx0XHRcdFx0XHRcdGNoaWxkLnNldE5leHQoJ1xcbicgKyBpbmQgKyAnXFx0Jylcblx0XHRcdFx0XHQpIDogKChjaGlsZC5tYXRjaGVzKCcuX2ltY2xvc2UnKSkgJiYgKFxuXHRcdFx0XHRcdFx0Y2hpbGQuc2V0UHJldignXFxuJyArIGluZClcblx0XHRcdFx0XHQpKSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1wYXJlbnMnLCAnaW1wYWlyJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgncGFyZW5zJyk7XG5cdFx0dGFnLnBhaXIoJygnLCcpJyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnVud3JhcCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHRoaXMubG9nKCdpbXBhaXIgb251bndyYXAhISEnLGUpO1xuXHRcdFx0ZS5oYWx0KCk7XG5cdFx0XHQvLyBsb29rIGF0IHByZXYgYW5kIG5leHQgYXMgd2VsbD9cblx0XHRcdC8vIHNob3VsZCBkbyB0aGlzIHRocm91Z2ggdGhlIHZpZXdcblx0XHRcdHRoaXMuc2V0Q29kZSgnICcgKyB0aGlzLmNvZGUoKS5zbGljZSgxLC0xKSk7XG5cdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkucmVwYWlyKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW1pc3RyaW5nJywgJ2ltcGFpcicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2lzdHJpbmcnKTtcblx0XHR0YWcucGFpcignXCInLCdcIicpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWlleHByJywgJ2ltcGFpcicsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0dGFnLnR5cGUoJ2lleHByJyk7XG5cdFx0dGFnLnBhaXIoJ3snLCd9Jyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltYmxvY2twYXJhbXMnLCAnaW1wYWlyJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnYmxvY2twYXJhbXMnKTtcblx0XHR0YWcucGFpcignfCcsJ3wnKTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2ltdGFnbm9kZScsICdpbXBhaXInLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCd0YWdub2RlJyk7XG5cdFx0dGFnLnBhaXIoJzwnLCc+Jyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wYWlyYWJsZSA9IGZ1bmN0aW9uIChzdHIsZSl7XG5cdFx0XHRyZXR1cm4gaWR4JChzdHIsWyd7JywnWycsJygnLCdcIicsXCInXCJdKSA+PSAwO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wbGFjZWhvbGRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMub3BlbigpICsgKCd4JykucmVwZWF0KHRoaXMuc2l6ZSgpIC0gMikgKyB0aGlzLmNsb3NlKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRlZmF1bHRWYWxpZGF0aW9uTW9kZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuICdjb21waWxlJztcblx0XHR9O1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL25vZGVzL2Jsb2NrLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2ltcm9vdCcsICdpbWJsb2NrJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3ZpZXc7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbih2KXsgdGhpcy5fdmlldyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdHRhZy5fbm9kZVR5cGUgPSAnY29kZSc7XG5cdFx0Ly8gZGVmIHNlbGYuZG9tXG5cdFx0Ly9cdEBkb20gfHw9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvZGUnKVxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudHJ5VW5kZW50ID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0c2VsZi5sb2coJ3RyeVVuZGVudCcpO1xuXHRcdFx0dmFyIG5vZGVzID0gZS52aWV3KCkubm9kZXNJblJlZ2lvbihlLnJlZ2lvbigpLmNsb25lKCkuc3RhcnRBdExpbmUoKSk7XG5cdFx0XHRub2Rlcy5tYXAoZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0aWYgKG1hdGNoLm5vZGUubWF0Y2hlcygnLl9pbW5ld2xpbmUnKSAmJiBtYXRjaC5tb2RlICE9ICdzdGFydCcpIHtcblx0XHRcdFx0XHRtYXRjaC5ub2RlLnVuZGVudCgpO1xuXHRcdFx0XHRcdHJldHVybiBzZWxmLnZpZXcoKS5jYXJldCgpLm1vdmUoLTEpO1xuXHRcdFx0XHRcdC8vIGUuY2FyZXQubW92ZSgtMSlcblx0XHRcdFx0XHQvLyBlLmNhcmV0LmV4cGFuZCgwLC0xKVxuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdC8vIGUubW92ZUNhcmV0ID0gMFxuXHRcdFx0ZS5oYW5kbGVkKCk7XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRhZy5fX3N1cGVyX18uYnVpbGQuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmRvbSgpLmFkZEV2ZW50TGlzdGVuZXIoJycpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbW1pdCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldE5leHQgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0XHR0aGlzLmFwcGVuZENoaWxkKG5vZGUpO1xuXHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldFByZXYgPSBmdW5jdGlvbiAobm9kZSl7XG5cdFx0XHR2YXIgZmlyc3QgPSB0aGlzLmRvbSgpLmZpcnN0Q2hpbGQ7XG5cdFx0XHRmaXJzdCA/ICh0aGlzLmluc2VydEJlZm9yZShub2RlLGZpcnN0KSkgOiAodGhpcy5hcHBlbmRDaGlsZChub2RlKSk7XG5cdFx0XHRyZXR1cm4gbm9kZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25saW5lYnJlYWsgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR2YXIgcHJlID0gZS5saW5lc3RyKCdwcmUnKTtcblx0XHRcdHZhciBpbmRlbnQgPSBlLmluZGVudCgpO1xuXHRcdFx0dmFyIG5ldyQgPSB0aGlzLnRleHQoKS5pbnMoJycsZS5yZWxSZWdpb24oKSk7XG5cdFx0XHQvLyBuZWVkIHRvIGZpcnN0IGNvbnNpZGVyIHRoZSBzcGxpdHRpbmcsIG5vP1xuXHRcdFx0aWYgKHRoaXMuaW5jcmVhc2VJbmRlbnQocHJlKSkgeyBpbmRlbnQgKz0gJ1xcdCcgfTtcblx0XHRcdGlmICh0aGlzLmRlY3JlYXNlSW5kZW50KHByZSkpIHsgaW5kZW50ID0gaW5kZW50LnNsaWNlKDEpIH07XG5cdFx0XHR0aGlzLm9ud2hpdGVzcGFjZShlLCdcXG4nICsgaW5kZW50KTtcblx0XHRcdHJldHVybiBlLmhhbmRsZWQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubXV0YXRlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5sb2coJ2ltcm9vdCBtdXRhdGVkJyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGlydHlFeHRlbnQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHNlbGYubG9nKCdpbXJvb3QgZGlydHlFeHRlbnQnKTtcblx0XHRcdC8vIHN1cGVyXG5cdFx0XHR2YXIgbm9kZXMgPSBzZWxmLmNoaWxkcmVuKCkubWFwKGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uZG9tKCk7IH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRjb2RlOiBzZWxmLmNvZGUoKSxcblx0XHRcdFx0bm9kZXM6IG5vZGVzLFxuXHRcdFx0XHRwYXJlbnQ6IHNlbGYuZG9tKCksXG5cdFx0XHRcdGNvbnRhaW5zOiBmdW5jdGlvbihlbCkgeyByZXR1cm4gc2VsZi5kb20oKS5jb250YWlucyhlbC5fZG9tIHx8IGVsKTsgfVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL25vZGVzL3Jvb3QuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0Ly8gZXh0ZXJucztcblx0XG5cdHZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG5cdFxuXHR2YXIgU0lOR0xFX1NUUiA9IC9eJ1teJ10qJyQvO1xuXHR2YXIgRE9VQkxFX1NUUiA9IC9eXCJbXlwiXFx7XSpcIiQvO1xuXHR2YXIgQ09NTUVOVCA9IC9eXFwjWyBcXHRdW15cXG5dKiQvO1xuXHRcblx0RE9VQkxFX1NUUiA9IC9eXCIoW15cXFxcXCJcXHtdfFxcXFxcXFxcfFxcXFxcIikqXCIkLztcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWxpdCcsICdpbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjb2RlKXtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnaW1yZWdleCcsICdpbWxpdCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnR5cGUoJ3JlZ2V4Jyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGFpcmluZyA9IGZ1bmN0aW9uIChjaHIpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJldmFsaWRhdGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciByZWcgPSB0aGlzLmNvZGUoKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBvYmogPSBldmFsKHJlZyk7XG5cdFx0XHR9IGNhdGNoIChlKSB7IH07XG5cdFx0XHR0aGlzLmxvZygncmVnZXggaXMnLHJlZyxvYmopO1xuXHRcdFx0dGhpcy5mbGFnKCdpbnZhbGlkJywhb2JqKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tdXRhdGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmxvZygncmVnZXggbXV0YXRlZCcpO1xuXHRcdFx0cmV0dXJuIHRoaXMucmV2YWxpZGF0ZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5wbGFjZWhvbGRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuICcvJyArICdSJy5yZXBlYXQodGhpcy5zaXplKCkgLSAyKSArICcvJztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaXNBdG9taWMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdH0pO1xuXHRcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vc2NyaW1ibGEvc3JjL25vZGVzL2xpdGVyYWxzLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHQvLyBzaG91bGQgcmF0aGVyIHJlY29uY2lsZSBpbnRvIHRva2VuIC0gb3Igc29tZXRoaW5nIGxpa2UgaXRcblx0dmFyIG5hbWVzID0ge1xuXHRcdCcuJzogJ2RvdCcsXG5cdFx0Jz0nOiAnZXEnLFxuXHRcdCc/JzogJ3EnLFxuXHRcdCchJzogJ3VuYXJ5Jyxcblx0XHQnOic6ICdjb2xvbicsXG5cdFx0JywnOiAnY29tbWEnLFxuXHRcdCcjJzogJ2hhc2gnLFxuXHRcdCcqJzogJ211bHQnLFxuXHRcdCc+Pic6ICdiaXRzaGlmdCdcblx0fTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbW9wJywgJ2ltJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcudHlwZSgnb3AnKTtcblx0XHR0YWcuYWxpYXMoJ3JlbGF0aW9uJyk7XG5cdFx0dGFnLmFsaWFzKCdjb21wYXJlJyk7XG5cdFx0dGFnLmFsaWFzKCdjb21wb3VuZF9hc3NpZ24nKTtcblx0XHR0YWcuYWxpYXMoJ2Fzc2lnbicpO1xuXHRcdHRhZy5hbGlhcygnYmxvY2tfYXJnJyk7XG5cdFx0dGFnLmFsaWFzKCdzcGxhdCcpO1xuXHRcdHRhZy5hbGlhcygnbG9naWMnKTtcblx0XHR0YWcuYWxpYXMoJ21hdGgnKTtcblx0XHR0YWcuYWxpYXMoJ3NoaWZ0Jyk7XG5cdFx0dGFnLmFsaWFzKCd1bmFyeScpO1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoY29kZSl7XG5cdFx0XHRyZXR1cm4gSU0uaXNPcChjb2RlKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYmFzZUNsYXNzZXMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0YWcuX19zdXBlcl9fLmJhc2VDbGFzc2VzLmFwcGx5KHRoaXMsYXJndW1lbnRzKSArICcgJyArIChuYW1lc1t0aGlzLmNvZGUoKV0gfHwgJycpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uICh0b2tlbil7XG5cdFx0XHR2YXIgdmFsID0gdG9rZW4gJiYgdG9rZW4uX3ZhbHVlIHx8IHRoaXMuY29kZSgpO1xuXHRcdFx0dGhpcy5kb20oKS5jbGFzc05hbWUgPSAoXCJfaW0gX2ltb3Agb3AgXCIgKyAobmFtZXNbdmFsXSB8fCAnJykpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBzaG91bGQgbWVyZ2Ugd2l0aCBhIG1vcmUgZ2VuZXJpYyB2ZXJzaW9uIGZvciB0b2tlbiBpbiBnZW5lcmFsXG5cdFx0Ly8gc2FtZSBnb2VzIGZvciB0ZXh0IGV0Y1xuXHRcdHRhZy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0YWcuX19zdXBlcl9fLmluc2VydC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmNvZGUoKSA9PSAnLy8nKSB7XG5cdFx0XHRcdHRoaXMubG9nKCdpcyBhIHJlZ2V4ISEnKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMucmVjbGFzc2lmeSgncmVnZXgnKTtcblx0XHRcdH07XG5cdFx0fTtcblx0fSk7XG5cdFxuXHQvLyBsaW5rIHJlZ3VsYXIgb3BzIHRvIG9wLW5vZGVcblx0cmV0dXJuICcrIC0gKiAvID0gKysgLS0gPT0gPT09ICE9ICE9PSA+IDwgPj0gPD0gJiAmJiB8IHx8IG9yIC4gOiA/ICY9IHx8PSAmJj0gPy4gPzogLCAhIC4uIC4uLiAuOiA+PiA8PCAjJy5zcGxpdCgnICcpLm1hcChmdW5jdGlvbihvcCkge1xuXHRcdHJldHVybiBJTS5UeXBlc1tvcF0gPSBJTS5UeXBlcy5vcDtcblx0fSk7XG5cdFxuXHRcblx0Ly8gSU0uVHlwZXM6bG9naWMgPSBJTS5UeXBlczpvcFxuXHQvLyBJTS5UeXBlczpjb21wYXJlID0gSU0uVHlwZXM6b3Bcblx0Ly8gSU0uVHlwZXM6bWF0aCA9IElNLlR5cGVzOm9wXG5cdC8vIElNLlR5cGVzOnNoaWZ0ID0gSU0uVHlwZXM6b3Bcblx0XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9ub2Rlcy9vcGVyYXRvcnMuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0XG5cdC8vIHRoaXMgc2hvdWxkIGJlIG1vcmUgYWR2YW5jZWQgdGhhbiB0aGlzLCBubz9cblx0dGFnJC5kZWZpbmVUYWcoJ2ltc2VsJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VsZWN0b3InKTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlzQXRvbWljID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVwYXJzZWQgPSBmdW5jdGlvbiAoY29kZSxvbGQpe1xuXHRcdFx0dGhpcy5sb2coXCJpbXNlbCByZXBhcnNlZFwiLGNvZGUsb2xkKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltc2VsdGFnJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VsZWN0b3JfdGFnJyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltc2VsY2xhc3MnLCAnaW10b2snLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdzZWxlY3Rvcl9jbGFzcycpO1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNlbGNvbWInLCAnaW10b2snLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdzZWxlY3Rvcl9jb21iaW5hdG9yJyk7XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltc2VsYXR0cm9wJywgJ2ltdG9rJywgZnVuY3Rpb24odGFnKXtcblx0XHR0YWcudHlwZSgnc2VsZWN0b3JfYXR0cl9vcCcpO1xuXHR9KTtcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnaW1zZWxhdHRyb3AnLCAnaW10b2snLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdzZWxlY3Rvcl9hdHRyX29wJyk7XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvbm9kZXMvc2VsZWN0b3IuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0dGFnJC5kZWZpbmVUYWcoJ2ltaW5zZXJ0JywgJ2ltJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNhbkFwcGVuZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNhblByZXBlbmQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAocmVnLGlucyl7XG5cdFx0XHRjb25zb2xlLmxvZygnaW5zZXJ0IGNvZGUgaW50byBpbWluc2VydCEhJyxpbnMscmVnKTtcblx0XHRcdFxuXHRcdFx0aWYgKGlucyBpbnN0YW5jZW9mIElNLlR5cGVzLmZyYWdtZW50KSB7XG5cdFx0XHRcdGlucyA9IGlucy5jb2RlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGlucyBpbnN0YW5jZW9mIElNLlR5cGVzLnJhdykge1xuXHRcdFx0XHRpbnMgPSBpbnMuX3Jhdztcblx0XHRcdH0gZWxzZSBpZiAoKHR5cGVvZiBpbnM9PSdzdHJpbmcnfHxpbnMgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG5cdFx0XHRcdGlucyA9ICh0aGlzLmNvZGUoKSB8fCBcIlwiKS5pbnMoaW5zLHJlZyk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0aGlzLnNldENvZGUoaW5zKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pc1doaXRlc3BhY2UgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmNvZGUoKS5tYXRjaCgvXltcXG5cXHRcXCBdKyQvKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubXV0YXRlZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5sb2coJ2ltaW5zZXJ0IG11dGF0ZWQnKTtcblx0XHRcdFxuXHRcdFx0dmFyIGRpcnR5ID0gdGhpcy5kaXJ0eUV4dGVudCgpO1xuXHRcdFx0dGhpcy52aWV3KCkuaGlnaGxpZ2h0ZXIoKS5yZXBhcnNlKGRpcnR5KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltd2hpdGVzcGFjZScsICdpbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jYW5QcmVwZW5kID0gZnVuY3Rpb24gKHN0cil7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWxpZGF0ZShzdHIgKyB0aGlzLmNvZGUoKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNhbkFwcGVuZCA9IGZ1bmN0aW9uIChzdHIpe1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsaWRhdGUodGhpcy5jb2RlKCkgKyBzdHIpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltbmV3bGluZScsICdpbXdoaXRlc3BhY2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy50eXBlKCduZXdsaW5lJyk7XG5cdFx0dGFnLmFsaWFzKCdcXG4nKTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNhblByZXBlbmQgPSBmdW5jdGlvbiAoc3RyKXtcblx0XHRcdGlmIChzdHIubWF0Y2goL15bXFxuXFx0XFwgXSskLykpIHtcblx0XHRcdFx0Ly8gc2hvdWxkIG5vdCByZWFsbHkgYmUgYWJsZSB0byBwcmVwZW5kIGhlcmVcblx0XHRcdFx0Ly8gaXQgc2hvbGQgcmF0aGVyIGluc2VydCBhIG5ldyBuZXdsaW5lIGluXG5cdFx0XHRcdC8vIGFuIGltaW5zZXJ0LCBhbmQgdGhhdCBzaG91bGQgYmUgYWJsZSB0b1xuXHRcdFx0XHQvLyBkZWNpZGUgdGhhdCBubyByZXBhcnNlIGlzIG5lZWRlZFxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0XHRpZih2YWwgPT09IHVuZGVmaW5lZCkgdmFsID0gdGhpcy5jb2RlKCk7XG5cdFx0XHRyZXR1cm4gdmFsID09ICdcXG4nO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pbmRlbnQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMudmlldygpLmluc2VydCh0aGlzLnJlZ2lvbigpLmVuZCgpLCdcXHQnKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS51bmRlbnQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCd1bmRlbnQgbmV3bGluZScpO1xuXHRcdFx0dmFyIHJlZyA9IHRoaXMucmVnaW9uKCkuY2xvbmUoKS5jb2xsYXBzZSh0cnVlKS5jbG9uZSgwLDEpO1xuXHRcdFx0aWYgKHJlZy50ZXh0KCkgPT0gJ1xcdCcpIHtcblx0XHRcdFx0dGhpcy5sb2coJ2NhbiB1bmRlbnQhIScpO1xuXHRcdFx0XHR0aGlzLnZpZXcoKS5lcmFzZShyZWcpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gdmlldy5vYnNlcnZlci5wYXVzZSBkb1xuXHRcdFx0Ly9cdG5leHQub3JwaGFuaXplIGlmIG5leHQ/Lm1hdGNoZXMoJy5faW10YWInKVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIGxvZyAnaW1uZXdsaW5lIG11dGF0ZWQhISdcblx0XHRcdC8vIHJlbW92ZSBub2RlIGlmIGl0IGlzIG9ycGhhbml6ZWRcblx0XHRcdGlmICh0aGlzLmNvZGUoKSA9PSAnJykge1xuXHRcdFx0XHR0aGlzLmxvZygncmVtb3ZlIHdob2xlIG5vZGUnKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMub3JwaGFuaXplKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmxvZygncmVwYXJzZSBuZXdsaW5lJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnZpZXcoKS5oaWdobGlnaHRlcigpLnJlcGFyc2Uoe25vZGVzOiBbdGhpcy5kb20oKV0sY29kZTogdGhpcy5jb2RlKCl9KTtcblx0XHRcdH07XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNwYWNlJywgJ2ltd2hpdGVzcGFjZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnR5cGUoJ3doaXRlc3BhY2UnKTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0XHRpZih2YWwgPT09IHVuZGVmaW5lZCkgdmFsID0gdGhpcy5jb2RlKCk7XG5cdFx0XHRyZXR1cm4gKC9eWyBdKyQvKS50ZXN0KHZhbCk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyB0aGlzIHNob3VsZCBiZSB0aGUgZGVmYXVsdCBmb3IgYWxsIG5vZGVzLCBubz9cblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAobyl7XG5cdFx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRcdGlmICghby5kZWVwICYmIHRoaXMudmFsaWRhdGUodGhpcy5jb2RlKCkpKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XHRyZXR1cm4gdGFnLl9fc3VwZXJfXy5tdXRhdGVkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbXNlbWljb2xvbicsICdpbXdoaXRlc3BhY2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy50eXBlKCdzZW1pY29sb24nKTtcblx0XHR0YWcuYWxpYXMoJzsnKTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaW10YWInLCAnaW13aGl0ZXNwYWNlJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcudHlwZSgndGFiJyk7XG5cdFx0dGFnLmFsaWFzKCdcXHQnKTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uZWRpdCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdGlmIChlLmlzU3Vycm91bmRlZCgpKSB7XG5cdFx0XHRcdHRoaXMubG9nKCdkZWxldGUgdGFiPyE/Jyk7XG5cdFx0XHRcdGlmIChlLnRleHQoKSkgeyAvLyBvdGhlcndpc2Ugd2UgcmVhbGx5IGFyZSBkb25lXG5cdFx0XHRcdFx0ZS5yZWRpcmVjdCh0aGlzLnByZXYoKSB8fCB0aGlzLm5leHQoKSB8fCB0aGlzLnBhcmVudCgpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlLmhhbmRsZWQoKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGUucmVnaW9uKCkuY29sbGFwc2UoZmFsc2UpO1xuXHRcdFx0XHR0aGlzLm9ycGhhbml6ZSgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0aWYodmFsID09PSB1bmRlZmluZWQpIHZhbCA9IHRoaXMuY29kZSgpO1xuXHRcdFx0cmV0dXJuIHZhbCA9PSAnXFx0Jztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdpbWNvbW1lbnQnLCAnaW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy50eXBlKCdjb21tZW50Jyk7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjb2RlKXtcblx0XHRcdHJldHVybiBDT01NRU5ULnRlc3QoY29kZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm11dGF0ZWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9nKCdpbWNvbW1lbnQgbXV0YXRlZCcpO1xuXHRcdFx0cmV0dXJuIHRhZy5fX3N1cGVyX18ubXV0YXRlZC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlcGFpciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcztcblx0XHRcdHRoaXMubG9nKCdyZXBhaXIgY29tbWVudCcpO1xuXHRcdFx0dmFyIHJlZ2lvbiA9IHRoaXMucmVnaW9uKCkuZW5kQXRMaW5lKCk7XG5cdFx0XHR2YXIgZnVsbCA9IHJlZ2lvbi50ZXh0KCk7IC8vIHNob3VsZCBub3QgaW5jbHVkZSB0aGUgbGFzdCBsaW5lP1xuXHRcdFx0dmFyIG5vZGVzID0gcmVnaW9uLm5vZGVzKGZhbHNlKTtcblx0XHRcdHRoaXMubG9nKCd3aG9sZSByZWdpb24gc2hvdWxkIGJlJyxyZWdpb24sZnVsbCxub2Rlcyk7XG5cdFx0XHR0aGlzLmxvZygnYWxsIG5vZGVzJyxub2Rlcyk7XG5cdFx0XHRcblx0XHRcdC8vIFZFUlkgdGVtcG9yYXJ5XG5cdFx0XHRpZiAobm9kZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHR0aGlzLnNldENvZGUoZnVsbCk7XG5cdFx0XHRcdHdoaWxlIChub2Rlcy5sZW5ndGggPiAxKXtcblx0XHRcdFx0XHR2YXIgZWwgPSBub2Rlcy5wb3AoKTtcblx0XHRcdFx0XHRlbC5ub2RlLm9ycGhhbml6ZSgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmluc2VydGVkID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0cmV0dXJuIHRoaXMucmVwYWlyKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNhblByZXBlbmQgPSBmdW5jdGlvbiAodGV4dCl7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNhbkFwcGVuZCA9IGZ1bmN0aW9uICh0ZXh0KXtcblx0XHRcdGlmICghdGV4dC5tYXRjaCgvW1xcbl0vKSkgeyByZXR1cm4gdHJ1ZSB9O1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdC8vIGFsbG93IGluc2VydGluZyBhZGRpdGlvbmFsIHRhYnMgZGlyZWN0bHkgaGVyZT9cblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnZW9mJyk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NjcmltYmxhL3NyYy9ub2Rlcy93aGl0ZXNwYWNlLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2ltd2FybicsICdpbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5tZXNzYWdlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbWVzc2FnZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRNZXNzYWdlID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCdtZXNzYWdlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5sb2coJ2J1aWx0IGVycm9yIHdpdGggZXJyb3InLHRoaXMub2JqZWN0KCkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2ltZXJyJywgJ2ltd2FybicpO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zY3JpbWJsYS9zcmMvbm9kZXMvYW5ub3RhdGlvbnMuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0dmFyIFJvdXRlciA9IHJlcXVpcmUoJy4vcm91dGVyJykuUm91dGVyO1xuXHRcblx0ZnVuY3Rpb24gQXBwKCl7XG5cdFx0dGhpcy5zZXRDYWNoZSh7fSk7XG5cdFx0dGhpcy5zZXREZXBzKHt9KTtcblx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0dGhpcy50aWNrKCk7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdGV4cG9ydHMuQXBwID0gQXBwOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0QXBwLnByb3RvdHlwZS5yZXEgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3JlcTsgfVxuXHRBcHAucHJvdG90eXBlLnNldFJlcSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9yZXEgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdFxuXHRBcHAucHJvdG90eXBlLnJlcyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcmVzOyB9XG5cdEFwcC5wcm90b3R5cGUuc2V0UmVzID0gZnVuY3Rpb24odil7IHRoaXMuX3JlcyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEFwcC5wcm90b3R5cGUuZGVwcyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZGVwczsgfVxuXHRBcHAucHJvdG90eXBlLnNldERlcHMgPSBmdW5jdGlvbih2KXsgdGhpcy5fZGVwcyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEFwcC5wcm90b3R5cGUuc2l0ZSA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fc2l0ZTsgfVxuXHRBcHAucHJvdG90eXBlLnNldFNpdGUgPSBmdW5jdGlvbih2KXsgdGhpcy5fc2l0ZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0XG5cdEFwcC5wcm90b3R5cGUuY2FjaGUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2NhY2hlOyB9XG5cdEFwcC5wcm90b3R5cGUuc2V0Q2FjaGUgPSBmdW5jdGlvbih2KXsgdGhpcy5fY2FjaGUgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XG5cdEFwcC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKXtcblx0XHR0aGlzLnNldENhY2hlKHt9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEFwcC5wcm90b3R5cGUucm91dGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3JvdXRlciB8fCAodGhpcy5fcm91dGVyID0gbmV3IFJvdXRlcih0aGlzKSk7XG5cdH07XG5cdFxuXHRBcHAucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gSW1iYS5TRVJWRVIgPyAodGhpcy5yZXEoKS5wYXRoKSA6ICh0aGlzLl9wYXRoKTtcblx0fTtcblx0XG5cdEFwcC5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiAnJztcblx0fTtcblx0XG5cdEFwcC5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiBJbWJhLlNFUlZFUiA/ICgnJykgOiAoZG9jdW1lbnQubG9jYXRpb24uaGFzaC5zdWJzdHIoMSkpO1xuXHR9O1xuXHRcblx0QXBwLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCl7XG5cdFx0aWYgKCFJbWJhLlNFUlZFUikge1xuXHRcdFx0dGhpcy5fcGF0aCA9IGRvY3VtZW50LmxvY2F0aW9uLnBhdGhuYW1lO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRBcHAucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKCl7XG5cdFx0SW1iYS5zY2hlZHVsZSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEFwcC5wcm90b3R5cGUudW5zY2hlZHVsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdEltYmEudW5zY2hlZHVsZSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEFwcC5wcm90b3R5cGUuZmV0Y2hEb2N1bWVudCA9IGZ1bmN0aW9uIChzcmMsY2Ipe1xuXHRcdFxuXHRcdHZhciBkZXBzXywgJDEsICQzLCAkMjtcblx0XHRpZiAoSW1iYS5TRVJWRVIpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdmZXRjaCBkb2N1bWVudCcsc3JjKTtcblx0XHRcdFxuXHRcdFx0dmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcblx0XHRcdHZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXHRcdFx0XG5cdFx0XHR2YXIgZmlsZXBhdGggPSAoXCJcIiArIF9fZGlybmFtZSArIFwiLy4uL2RvY3MvXCIgKyBzcmMpLnJlcGxhY2UoL1xcL1xcLy9nLCcvJyk7XG5cdFx0XHRcblx0XHRcdHZhciByZXMgPSB0aGlzLmRlcHMoKVtzcmNdO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXJlcykge1xuXHRcdFx0XHR2YXIgYm9keSA9IGZzLnJlYWRGaWxlU3luYyhmaWxlcGF0aCwndXRmLTgnKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChzcmMubWF0Y2goL1xcLm1kJC8pKSB7XG5cdFx0XHRcdFx0cmVzID0gdGhpcy5NYXJrZG93bi5yZW5kZXIoYm9keSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc3JjLm1hdGNoKC9cXC5qc29uJC8pKSB7XG5cdFx0XHRcdFx0cmVzID0gSlNPTi5wYXJzZShib2R5KTtcblx0XHRcdFx0fSBlbHNlIGlmIChzcmMubWF0Y2goL1xcLmltYmEkLykpIHtcblx0XHRcdFx0XHR2YXIgaHRtbCA9IHRoaXMuSGlnaGxpZ2h0ZXIuaGlnaGxpZ2h0KGJvZHkse21vZGU6ICdmdWxsJ30pO1xuXHRcdFx0XHRcdHJlcyA9IHtib2R5OiBib2R5LGh0bWw6IGh0bWx9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0KGRlcHNfID0gdGhpcy5kZXBzKCkpWygkMSA9IHNyYyldIHx8IChkZXBzX1skMV0gPSByZXMpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5zaXRlKCkpIHtcblx0XHRcdFx0KCQzID0gdGhpcy5zaXRlKCkuZGVwcygpKVsoJDIgPSBzcmMpXSB8fCAoJDNbJDJdID0gcmVzKTtcblx0XHRcdH07XG5cdFx0XHRjYiAmJiBjYihyZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoREVQU1tzcmNdKSB7XG5cdFx0XHRcdGNiICYmIGNiKERFUFNbc3JjXSk7XG5cdFx0XHRcdHJldHVybiB7dGhlbjogZnVuY3Rpb24odikgeyByZXR1cm4gdihyZXMpOyB9fTsgLy8gZmFrZSBwcm9taXNlIGhhY2tcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHRcdHhoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJyxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0REVQU1tzcmNdID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcblx0XHRcdFx0cmV0dXJuIGNiICYmIGNiKERFUFNbc3JjXSk7XG5cdFx0XHRcdC8vIFhIUiA9IHhoclxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAncmVzcG9uc2UgaGVyZScseGhyOnJlc3BvbnNlVGV4dFxuXHRcdFx0fSk7XG5cdFx0XHR4aHIub3BlbihcIkdFVFwiLHNyYyk7XG5cdFx0XHR4aHIuc2VuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRcblx0ZnVuY3Rpb24gRG9jKHBhdGgpe1xuXHRcdHRoaXMuX3BhdGggPSBwYXRoO1xuXHRcdHRoaXMuX3JlYWR5ID0gZmFsc2U7XG5cdFx0dGhpcy5mZXRjaCgpO1xuXHRcdHRoaXM7XG5cdH07XG5cdFxuXHRleHBvcnRzLkRvYyA9IERvYzsgLy8gZXhwb3J0IGNsYXNzIFxuXHR2YXIgY2FjaGUgPSB7fTtcblx0XG5cdERvYy5nZXQgPSBmdW5jdGlvbiAocGF0aCl7XG5cdFx0dmFyICQxO1xuXHRcdHZhciBjYWNoZSA9IEFQUC5jYWNoZSgpO1xuXHRcdHJldHVybiBjYWNoZVsoJDEgPSAnZG9jLScgKyBwYXRoKV0gfHwgKGNhY2hlWyQxXSA9IG5ldyB0aGlzKHBhdGgpKTtcblx0fTtcblx0XG5cdFxuXHRcblx0RG9jLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9wYXRoOyB9XG5cdERvYy5wcm90b3R5cGUuc2V0UGF0aCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9wYXRoID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHREb2MucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3JlYWR5O1xuXHR9O1xuXHRcblx0RG9jLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uICgpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRpZiAoSW1iYS5TRVJWRVIpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdmZXRjaCBHdWlkZSBvbiBzZXJ2ZXInLHBhdGhcblx0XHRcdHJldHVybiBBUFAuZmV0Y2hEb2N1bWVudChzZWxmLl9wYXRoICsgJy5tZCcsZnVuY3Rpb24ocmVzKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nICdmZXRjaCBHdWlkZSBvbiBzZXJ2ZXIgZG9uZScscGF0aFxuXHRcdFx0XHRyZXR1cm4gc2VsZi5sb2FkKHJlcyk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBzZWxmLl9wcm9taXNlIHx8IChzZWxmLl9wcm9taXNlID0gQVBQLmZldGNoRG9jdW1lbnQoc2VsZi5fcGF0aCArICcubWQnLGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0cmV0dXJuIHNlbGYubG9hZChyZXMpO1xuXHRcdH0pKTtcblx0fTtcblx0XG5cdERvYy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChkb2Mpe1xuXHRcdHRoaXMuX29iamVjdCA9IGRvYztcblx0XHR0aGlzLl9tZXRhID0gZG9jLm1ldGEgfHwge307XG5cdFx0dGhpcy5fcmVhZHkgPSB0cnVlO1xuXHRcdEltYmEuZW1pdCh0aGlzLCdyZWFkeScpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0RG9jLnByb3RvdHlwZS50aXRsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9vYmplY3QudGl0bGUgfHwgJ3BhdGgnO1xuXHR9O1xuXHRcblx0RG9jLnByb3RvdHlwZS50b2MgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fb2JqZWN0ICYmIHRoaXMuX29iamVjdC50b2NbMF07XG5cdH07XG5cdFxuXHREb2MucHJvdG90eXBlLmJvZHkgPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fb2JqZWN0ICYmIHRoaXMuX29iamVjdC5ib2R5O1xuXHR9O1xuXHRyZXR1cm4gRG9jO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hcHAuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0Ly8gZXh0ZXJucztcblx0XG5cdGZ1bmN0aW9uIFJvdXRlcihhcHApe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzZWxmLl9hcHAgPSBhcHA7XG5cdFx0XG5cdFx0aWYgKEltYmEuaXNDbGllbnQoKSkge1xuXHRcdFx0d2luZG93Lm9ucG9wc3RhdGUgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHNlbGYucmVmcmVzaCgpO1xuXHRcdFx0XHRjb25zb2xlLmxvZygncG9wc3RhdGUnKTtcblx0XHRcdFx0cmV0dXJuIEltYmEuc2V0VGltZW91dCgwLGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0c2VsZjtcblx0fTtcblx0XG5cdGV4cG9ydHMuUm91dGVyID0gUm91dGVyOyAvLyBleHBvcnQgY2xhc3MgXG5cdFxuXHRcblx0Um91dGVyLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9wYXRoOyB9XG5cdFJvdXRlci5wcm90b3R5cGUuc2V0UGF0aCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9wYXRoID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFxuXHRSb3V0ZXIuc2x1ZyA9IGZ1bmN0aW9uIChzdHIpe1xuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCcnKS50b0xvd2VyQ2FzZSgpOyAvLyB0cmltXG5cdFx0Ly8gcmVtb3ZlIGFjY2VudHMsIHN3YXAgw7EgZm9yIG4sIGV0Y1xuXHRcdHZhciBmcm9tID0gXCLDoMOhw6TDosOlw6jDqcOrw6rDrMOtw6/DrsOyw7PDtsO0w7nDusO8w7vDscOnwrcvXyw6O1wiO1xuXHRcdHZhciB0byA9IFwiYWFhYWFlZWVlaWlpaW9vb291dXV1bmMtLS0tLS1cIjtcblx0XHRcblx0XHQvLyBmb3IgKHZhciBpPTAsIGw9ZnJvbS5sZW5ndGggOyBpPGwgOyBpKyspXG5cdFx0Ly8gXHRzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKGZyb20uY2hhckF0KGkpLCAnZycpLCB0by5jaGFyQXQoaSkpXG5cdFx0XG5cdFx0c3RyID0gc3RyLnJlcGxhY2UoL1teYS16MC05IC1dL2csJycpOyAvLyByZW1vdmUgaW52YWxpZCBjaGFyc1xuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKC9cXHMrL2csJy0nKTsgLy8gY29sbGFwc2Ugd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBieSAtXG5cdFx0c3RyID0gc3RyLnJlcGxhY2UoLy0rL2csJy0nKTsgLy8gY29sbGFwc2UgZGFzaGVzXG5cdFx0XG5cdFx0cmV0dXJuIHN0cjtcblx0fTtcblx0XG5cdFJvdXRlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Um91dGVyLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX2FwcC5wYXRoKCk7XG5cdH07XG5cdFxuXHRSb3V0ZXIucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKXtcblx0XHRyZXR1cm4gdGhpcy5fYXBwLmhhc2goKTtcblx0fTtcblx0XG5cdFJvdXRlci5wcm90b3R5cGUuZXh0ID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHBhdGggPSB0aGlzLnBhdGgoKTtcblx0XHR2YXIgbSA9IHBhdGgubWF0Y2goL1xcLihbXlxcL10rKSQvKTtcblx0XHRyZXR1cm4gbSAmJiBtWzFdIHx8ICcnO1xuXHR9O1xuXHRcblx0Um91dGVyLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIChocmVmLHN0YXRlLHJlcGxhY2Upe1xuXHRcdGlmKHN0YXRlID09PSB1bmRlZmluZWQpIHN0YXRlID0ge307XG5cdFx0aWYocmVwbGFjZSA9PT0gdW5kZWZpbmVkKSByZXBsYWNlID0gZmFsc2U7XG5cdFx0aWYgKGhyZWYgPT0gJy9pbnN0YWxsJykge1xuXHRcdFx0Ly8gcmVkaXJlY3RzIGhlcmVcblx0XHRcdGhyZWYgPSAnL2d1aWRlcyN0b2MtZ2V0dGluZy1zdGFydGVkLWluc3RhbGxhdGlvbic7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAocmVwbGFjZSkge1xuXHRcdFx0aGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsbnVsbCxocmVmKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsbnVsbCxocmVmKTtcblx0XHR9O1xuXHRcdFxuXHRcdGlmICghaHJlZi5tYXRjaCgvXFwjLykpIHtcblx0XHRcdHdpbmRvdy5zY3JvbGxUbygwLDApO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHRSb3V0ZXIucHJvdG90eXBlLnNjb3BlZCA9IGZ1bmN0aW9uIChyZWcscGFydCl7XG5cdFx0dmFyIHBhdGggPSB0aGlzLnBhdGgoKSArICcjJyArIHRoaXMuaGFzaCgpO1xuXHRcdGlmICgodHlwZW9mIHJlZz09J3N0cmluZyd8fHJlZyBpbnN0YW5jZW9mIFN0cmluZykpIHtcblx0XHRcdHZhciBueHQgPSBwYXRoW3JlZy5sZW5ndGhdO1xuXHRcdFx0cmV0dXJuIHBhdGguc3Vic3RyKDAscmVnLmxlbmd0aCkgPT0gcmVnICYmICghbnh0IHx8IG54dCA9PSAnLScgfHwgbnh0ID09ICcvJyB8fCBueHQgPT0gJyMnIHx8IG54dCA9PSAnPycgfHwgbnh0ID09ICdfJyk7XG5cdFx0fSBlbHNlIGlmIChyZWcgaW5zdGFuY2VvZiBSZWdFeHApIHtcblx0XHRcdHZhciBtID0gcGF0aC5tYXRjaChyZWcpO1xuXHRcdFx0cmV0dXJuIHBhcnQgJiYgbSA/IChtW3BhcnRdKSA6IChtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdH07XG5cdFxuXHRSb3V0ZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHJlZyxwYXJ0KXtcblx0XHR2YXIgcGF0aCA9IHRoaXMucGF0aCgpICsgJyMnICsgdGhpcy5oYXNoKCk7XG5cdFx0XG5cdFx0aWYgKCh0eXBlb2YgcmVnPT0nc3RyaW5nJ3x8cmVnIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuXHRcdFx0cmV0dXJuIHBhdGggPT0gcmVnO1xuXHRcdH0gZWxzZSBpZiAocmVnIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdFx0XHR2YXIgbSA9IHBhdGgubWF0Y2gocmVnKTtcblx0XHRcdHJldHVybiBwYXJ0ICYmIG0gPyAobVtwYXJ0XSkgOiAobSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHR9O1xuXHRyZXR1cm4gUm91dGVyO1xuXHRcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvcm91dGVyLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHRyZXF1aXJlKCcuL2Jhc2UnKTtcblx0cmVxdWlyZSgnLi9tYXJrZG93bicpO1xuXHRcblx0cmVxdWlyZSgnLi9zaXRlJyk7XG5cdHJlcXVpcmUoJy4vbmF2Jyk7XG5cdHJlcXVpcmUoJy4vcGFnZScpO1xuXHRyZXF1aXJlKCcuL2hvbWUnKTtcblx0cmVxdWlyZSgnLi9ibG9nJyk7XG5cdHJlcXVpcmUoJy4vZ3VpZGVzJyk7XG5cdHJlcXVpcmUoJy4vZG9jcycpO1xuXHRyZXR1cm4gcmVxdWlyZSgnLi9zbmlwcGV0Jyk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL2luZGV4LmltYmFcbiAqKiBtb2R1bGUgaWQgPSA1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHRhZyQuZXh0ZW5kVGFnKCdlbGVtZW50JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvdXRlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgncm91dGUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Um91dGUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvdXRlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRIdG1sID0gZnVuY3Rpb24gKGh0bWwpe1xuXHRcdFx0dGhpcy5fZG9tLmlubmVySFRNTCA9IGh0bWw7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiAocm91dGUpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvdXRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIEFQUC5yb3V0ZXIoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVyb3V0ZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5mbGFnKCdzY29wZWQnLHRoaXMucm91dGVyKCkuc2NvcGVkKHRoaXMucm91dGUoKSx0aGlzKSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGFnKCdzZWxlY3RlZCcsdGhpcy5yb3V0ZXIoKS5tYXRjaCh0aGlzLnJvdXRlKCksdGhpcykpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUpe1xuXHRcdFx0dGhpcy5jc3MoJ3RyYW5zZm9ybScsdmFsdWUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuY3NzKCd0cmFuc2Zvcm0nKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZXh0ZW5kVGFnKCdzY3JpcHQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAodmFsdWUpe1xuXHRcdFx0dGhpcy5fY2hpbGRyZW4gPSB2YWx1ZTtcblx0XHRcdHRoaXMuZG9tKCkuaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZXh0ZW5kVGFnKCdjYW52YXMnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZHByID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZHByIHx8ICh0aGlzLl9kcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0V2lkdGggPSBmdW5jdGlvbiAod2lkdGgpe1xuXHRcdFx0aWYgKHdpZHRoICE9IHRoaXMuX3dpZHRoKSB7XG5cdFx0XHRcdHRoaXMuZG9tKCkud2lkdGggPSB3aWR0aCAqIHRoaXMuZHByKCk7XG5cdFx0XHRcdHRoaXMuY3NzKHt3aWR0aDogd2lkdGh9KTtcblx0XHRcdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCl7XG5cdFx0XHRpZiAoaGVpZ2h0ICE9IHRoaXMuX2hlaWdodCkge1xuXHRcdFx0XHR0aGlzLmRvbSgpLmhlaWdodCA9IGhlaWdodCAqIHRoaXMuZHByKCk7XG5cdFx0XHRcdHRoaXMuY3NzKHtoZWlnaHQ6IGhlaWdodH0pO1xuXHRcdFx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5leHRlbmRUYWcoJ2EnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucm91dGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9yb3V0ZSB8fCB0aGlzLmhyZWYoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub250YXAgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHRpZiAoZS5ldmVudCgpLm1ldGFLZXkgfHwgZS5ldmVudCgpLmFsdEtleSkge1xuXHRcdFx0XHRlLl9yZXNwb25kZXIgPSBudWxsO1xuXHRcdFx0XHRyZXR1cm4gZS5oYWx0KCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5ocmVmKClbMF0gPT0gJyMnIHx8IHRoaXMuaHJlZigpWzBdID09ICcvJykge1xuXHRcdFx0XHRlLmNhbmNlbCgpLmhhbHQoKTtcblx0XHRcdFx0dGhpcy5yb3V0ZXIoKS5nbyh0aGlzLmhyZWYoKSx7fSk7XG5cdFx0XHRcdEltYmEuRXZlbnRzLnRyaWdnZXIoJ3JvdXRlJyx0aGlzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGUuX3Jlc3BvbmRlciA9IG51bGw7XG5cdFx0XHRcdHJldHVybiBlLmhhbHQoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXJvdXRlKCk7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL2Jhc2UuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0Ly8gZm9yIG1hcmtkb3duIHJlbmRlcmluZ1xuXHR0YWckLmRlZmluZVRhZygnbWQnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX19zcmMgPSB7d2F0Y2g6ICdyZWxvYWQnLG5hbWU6ICdzcmMnfTtcblx0XHR0YWcucHJvdG90eXBlLnNyYyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NyYycpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRTcmMgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5zcmMoKTtcblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLnNldEF0dHJpYnV0ZSgnc3JjJyx2KTsgfVxuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMucmVsb2FkICYmIHRoaXMucmVsb2FkKHYsYSx0aGlzLl9fc3JjKSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX19odG1sID0ge3dhdGNoOiAnaHRtbERpZFNldCcsbmFtZTogJ2h0bWwnfTtcblx0XHR0YWcucHJvdG90eXBlLmh0bWwgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2h0bWw7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEh0bWwgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5odG1sKCk7XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5faHRtbCA9IHY7IH1cblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLmh0bWxEaWRTZXQgJiYgdGhpcy5odG1sRGlkU2V0KHYsYSx0aGlzLl9faHRtbCkgfVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRvYyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZG9jOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXREb2MgPSBmdW5jdGlvbih2KXsgdGhpcy5fZG9jID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5naHNyYyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIChcImh0dHBzOi8vZ2l0aHViLmNvbS9zb21lYmVlL2ltYmEuaW8vYmxvYi9tYXN0ZXIvZG9jc1wiICsgdGhpcy5zcmMoKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmh0bWxEaWRTZXQgPSBmdW5jdGlvbiAoaHRtbCl7XG5cdFx0XHR0aGlzLmJvZHkoKS5kb20oKS5pbm5lckhUTUwgPSBodG1sO1xuXHRcdFx0dGhpcy5zZXR1cCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0aWYgKEltYmEuU0VSVkVSKSB7XG5cdFx0XHRcdEFQUC5mZXRjaERvY3VtZW50KHNlbGYuc3JjKCkgKyAnLm1kJyxmdW5jdGlvbihkb2MpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi5hc3NlbWJsZShkb2MpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSBpZiAoc2VsZi5fc25pcHBldHMpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYuX3NuaXBwZXRzKSwgbGVuID0gYXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0YXJ5W2ldLmVuZCgpOyAvLyBzaW11bGF0ZSByZWFsIHJlbmRlcmluZyBoZXJlP1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gbm90IG9uIGZyb250cGFnZT8hXG5cdFx0dGFnLnByb3RvdHlwZS5hc3NlbWJsZSA9IGZ1bmN0aW9uIChkb2Mpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZygnbWQnKS5zZXRIdG1sKGRvYy5ib2R5KS5zeW5jZWQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRhZy5fX3N1cGVyX18uYnVpbGQuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdFx0aWYgKEltYmEuaXNDbGllbnQoKSAmJiB0aGlzLnNyYygpKSB7IHJldHVybiB0aGlzLnJlbG9hZCgpIH07XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmF3YWtlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0Ly8gbG9nIFwiYXdha2VuZWQgbWQgZnJvbSBjbGllbnQoISlcIlxuXHRcdFx0dGhpcy5fc25pcHBldHMgPSBxJCgnLl9zbmlwcGV0Jyx0aGlzKS50b0FycmF5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucHJlbG9hZCA9IGZ1bmN0aW9uIChodG1sKXtcblx0XHRcdHRoaXMuX2RvbS5pbm5lckhUTUwgPSBodG1sO1xuXHRcdFx0dGhpcy5fc25pcHBldHMgPSBxJCgnLl9zbmlwcGV0Jyx0aGlzKS50b0FycmF5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVsb2FkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRpZiAoSW1iYS5pc0NsaWVudCgpKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nICdyZWxvYWRpbmcgbWFya2Rvd24nXG5cdFx0XHRcdHNlbGYuX3NuaXBwZXRzID0gW107XG5cdFx0XHRcdEFQUC5mZXRjaERvY3VtZW50KHNlbGYuc3JjKCkgKyAnLm1kJyxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyAncmV0dXJuZWQgZnJvbSBtYXJrZG93biBoZXJlPyEnLHJlc1xuXHRcdFx0XHRcdHNlbGYuYXNzZW1ibGUoKHNlbGYuc2V0RG9jKHJlcykscmVzKSk7XG5cdFx0XHRcdFx0c2VsZi5fc25pcHBldHMgPSBxJCgnLl9zbmlwcGV0JyxzZWxmKS50b0FycmF5KCk7XG5cdFx0XHRcdFx0c2VsZi5wYXJlbnQoKS5kb20oKS5zY3JvbGxUb3AgPSAwO1xuXHRcdFx0XHRcdHJldHVybiBzZWxmO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHR9KTtcblx0XG5cdC8vIGRlZmluZSByZW5kZXJlclxuXHR2YXIgbWFya2VkID0gcmVxdWlyZSgnbWFya2VkJyk7XG5cdHZhciBtZHIgPSBuZXcgKG1hcmtlZC5SZW5kZXJlcikoKTtcblx0XG5cdG1kci5oZWFkaW5nID0gZnVuY3Rpb24gKHRleHQsbHZsKXtcblx0XHRyZXR1cm4gKFwiPGhcIiArIGx2bCArIFwiPlwiICsgdGV4dCArIFwiPC9oXCIgKyBsdmwgKyBcIj5cIik7XG5cdH07XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ21hcmtlZCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXJlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAodGV4dCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDb250ZW50KHRleHQsMCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiAodmFsLHR5cCl7XG5cdFx0XHRpZiAodmFsICE9IHRoaXMuX2NvbnRlbnQpIHtcblx0XHRcdFx0dGhpcy5fY29udGVudCA9IHZhbDtcblx0XHRcdFx0dGhpcy5kb20oKS5pbm5lckhUTUwgPSBtYXJrZWQodmFsLHtyZW5kZXJlcjogbWRyfSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL21hcmtkb3duLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBtYXJrZWQgLSBhIG1hcmtkb3duIHBhcnNlclxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTQsIENocmlzdG9waGVyIEplZmZyZXkuIChNSVQgTGljZW5zZWQpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2hqai9tYXJrZWRcbiAqL1xuXG47KGZ1bmN0aW9uKCkge1xuXG4vKipcbiAqIEJsb2NrLUxldmVsIEdyYW1tYXJcbiAqL1xuXG52YXIgYmxvY2sgPSB7XG4gIG5ld2xpbmU6IC9eXFxuKy8sXG4gIGNvZGU6IC9eKCB7NH1bXlxcbl0rXFxuKikrLyxcbiAgZmVuY2VzOiBub29wLFxuICBocjogL14oICpbLSpfXSl7Myx9ICooPzpcXG4rfCQpLyxcbiAgaGVhZGluZzogL14gKigjezEsNn0pICooW15cXG5dKz8pICojKiAqKD86XFxuK3wkKS8sXG4gIG5wdGFibGU6IG5vb3AsXG4gIGxoZWFkaW5nOiAvXihbXlxcbl0rKVxcbiAqKD18LSl7Mix9ICooPzpcXG4rfCQpLyxcbiAgYmxvY2txdW90ZTogL14oICo+W15cXG5dKyhcXG4oPyFkZWYpW15cXG5dKykqXFxuKikrLyxcbiAgbGlzdDogL14oICopKGJ1bGwpIFtcXHNcXFNdKz8oPzpocnxkZWZ8XFxuezIsfSg/ISApKD8hXFwxYnVsbCApXFxuKnxcXHMqJCkvLFxuICBodG1sOiAvXiAqKD86Y29tbWVudCAqKD86XFxufFxccyokKXxjbG9zZWQgKig/OlxcbnsyLH18XFxzKiQpfGNsb3NpbmcgKig/OlxcbnsyLH18XFxzKiQpKS8sXG4gIGRlZjogL14gKlxcWyhbXlxcXV0rKVxcXTogKjw/KFteXFxzPl0rKT4/KD86ICtbXCIoXShbXlxcbl0rKVtcIildKT8gKig/Olxcbit8JCkvLFxuICB0YWJsZTogbm9vcCxcbiAgcGFyYWdyYXBoOiAvXigoPzpbXlxcbl0rXFxuPyg/IWhyfGhlYWRpbmd8bGhlYWRpbmd8YmxvY2txdW90ZXx0YWd8ZGVmKSkrKVxcbiovLFxuICB0ZXh0OiAvXlteXFxuXSsvXG59O1xuXG5ibG9jay5idWxsZXQgPSAvKD86WyorLV18XFxkK1xcLikvO1xuYmxvY2suaXRlbSA9IC9eKCAqKShidWxsKSBbXlxcbl0qKD86XFxuKD8hXFwxYnVsbCApW15cXG5dKikqLztcbmJsb2NrLml0ZW0gPSByZXBsYWNlKGJsb2NrLml0ZW0sICdnbScpXG4gICgvYnVsbC9nLCBibG9jay5idWxsZXQpXG4gICgpO1xuXG5ibG9jay5saXN0ID0gcmVwbGFjZShibG9jay5saXN0KVxuICAoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAoJ2hyJywgJ1xcXFxuKyg/PVxcXFwxPyg/OlstKl9dICopezMsfSg/OlxcXFxuK3wkKSknKVxuICAoJ2RlZicsICdcXFxcbisoPz0nICsgYmxvY2suZGVmLnNvdXJjZSArICcpJylcbiAgKCk7XG5cbmJsb2NrLmJsb2NrcXVvdGUgPSByZXBsYWNlKGJsb2NrLmJsb2NrcXVvdGUpXG4gICgnZGVmJywgYmxvY2suZGVmKVxuICAoKTtcblxuYmxvY2suX3RhZyA9ICcoPyEoPzonXG4gICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlJ1xuICArICd8dmFyfHNhbXB8a2JkfHN1YnxzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG8nXG4gICsgJ3xzcGFufGJyfHdicnxpbnN8ZGVsfGltZylcXFxcYilcXFxcdysoPyE6L3xbXlxcXFx3XFxcXHNAXSpAKVxcXFxiJztcblxuYmxvY2suaHRtbCA9IHJlcGxhY2UoYmxvY2suaHRtbClcbiAgKCdjb21tZW50JywgLzwhLS1bXFxzXFxTXSo/LS0+LylcbiAgKCdjbG9zZWQnLCAvPCh0YWcpW1xcc1xcU10rPzxcXC9cXDE+LylcbiAgKCdjbG9zaW5nJywgLzx0YWcoPzpcIlteXCJdKlwifCdbXiddKid8W14nXCI+XSkqPz4vKVxuICAoL3RhZy9nLCBibG9jay5fdGFnKVxuICAoKTtcblxuYmxvY2sucGFyYWdyYXBoID0gcmVwbGFjZShibG9jay5wYXJhZ3JhcGgpXG4gICgnaHInLCBibG9jay5ocilcbiAgKCdoZWFkaW5nJywgYmxvY2suaGVhZGluZylcbiAgKCdsaGVhZGluZycsIGJsb2NrLmxoZWFkaW5nKVxuICAoJ2Jsb2NrcXVvdGUnLCBibG9jay5ibG9ja3F1b3RlKVxuICAoJ3RhZycsICc8JyArIGJsb2NrLl90YWcpXG4gICgnZGVmJywgYmxvY2suZGVmKVxuICAoKTtcblxuLyoqXG4gKiBOb3JtYWwgQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLm5vcm1hbCA9IG1lcmdlKHt9LCBibG9jayk7XG5cbi8qKlxuICogR0ZNIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay5nZm0gPSBtZXJnZSh7fSwgYmxvY2subm9ybWFsLCB7XG4gIGZlbmNlczogL14gKihgezMsfXx+ezMsfSlbIFxcLl0qKFxcUyspPyAqXFxuKFtcXHNcXFNdKj8pXFxzKlxcMSAqKD86XFxuK3wkKS8sXG4gIHBhcmFncmFwaDogL14vLFxuICBoZWFkaW5nOiAvXiAqKCN7MSw2fSkgKyhbXlxcbl0rPykgKiMqICooPzpcXG4rfCQpL1xufSk7XG5cbmJsb2NrLmdmbS5wYXJhZ3JhcGggPSByZXBsYWNlKGJsb2NrLnBhcmFncmFwaClcbiAgKCcoPyEnLCAnKD8hJ1xuICAgICsgYmxvY2suZ2ZtLmZlbmNlcy5zb3VyY2UucmVwbGFjZSgnXFxcXDEnLCAnXFxcXDInKSArICd8J1xuICAgICsgYmxvY2subGlzdC5zb3VyY2UucmVwbGFjZSgnXFxcXDEnLCAnXFxcXDMnKSArICd8JylcbiAgKCk7XG5cbi8qKlxuICogR0ZNICsgVGFibGVzIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay50YWJsZXMgPSBtZXJnZSh7fSwgYmxvY2suZ2ZtLCB7XG4gIG5wdGFibGU6IC9eICooXFxTLipcXHwuKilcXG4gKihbLTpdKyAqXFx8Wy18IDpdKilcXG4oKD86LipcXHwuKig/OlxcbnwkKSkqKVxcbiovLFxuICB0YWJsZTogL14gKlxcfCguKylcXG4gKlxcfCggKlstOl0rWy18IDpdKilcXG4oKD86ICpcXHwuKig/OlxcbnwkKSkqKVxcbiovXG59KTtcblxuLyoqXG4gKiBCbG9jayBMZXhlclxuICovXG5cbmZ1bmN0aW9uIExleGVyKG9wdGlvbnMpIHtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy50b2tlbnMubGlua3MgPSB7fTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gIHRoaXMucnVsZXMgPSBibG9jay5ub3JtYWw7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRhYmxlcykge1xuICAgICAgdGhpcy5ydWxlcyA9IGJsb2NrLnRhYmxlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydWxlcyA9IGJsb2NrLmdmbTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2UgQmxvY2sgUnVsZXNcbiAqL1xuXG5MZXhlci5ydWxlcyA9IGJsb2NrO1xuXG4vKipcbiAqIFN0YXRpYyBMZXggTWV0aG9kXG4gKi9cblxuTGV4ZXIubGV4ID0gZnVuY3Rpb24oc3JjLCBvcHRpb25zKSB7XG4gIHZhciBsZXhlciA9IG5ldyBMZXhlcihvcHRpb25zKTtcbiAgcmV0dXJuIGxleGVyLmxleChzcmMpO1xufTtcblxuLyoqXG4gKiBQcmVwcm9jZXNzaW5nXG4gKi9cblxuTGV4ZXIucHJvdG90eXBlLmxleCA9IGZ1bmN0aW9uKHNyYykge1xuICBzcmMgPSBzcmNcbiAgICAucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJylcbiAgICAucmVwbGFjZSgvXFx0L2csICcgICAgJylcbiAgICAucmVwbGFjZSgvXFx1MDBhMC9nLCAnICcpXG4gICAgLnJlcGxhY2UoL1xcdTI0MjQvZywgJ1xcbicpO1xuXG4gIHJldHVybiB0aGlzLnRva2VuKHNyYywgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIExleGluZ1xuICovXG5cbkxleGVyLnByb3RvdHlwZS50b2tlbiA9IGZ1bmN0aW9uKHNyYywgdG9wLCBicSkge1xuICB2YXIgc3JjID0gc3JjLnJlcGxhY2UoL14gKyQvZ20sICcnKVxuICAgICwgbmV4dFxuICAgICwgbG9vc2VcbiAgICAsIGNhcFxuICAgICwgYnVsbFxuICAgICwgYlxuICAgICwgaXRlbVxuICAgICwgc3BhY2VcbiAgICAsIGlcbiAgICAsIGw7XG5cbiAgd2hpbGUgKHNyYykge1xuICAgIC8vIG5ld2xpbmVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5uZXdsaW5lLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChjYXBbMF0ubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnc3BhY2UnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvZGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5jb2RlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGNhcCA9IGNhcFswXS5yZXBsYWNlKC9eIHs0fS9nbSwgJycpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgdGV4dDogIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgID8gY2FwLnJlcGxhY2UoL1xcbiskLywgJycpXG4gICAgICAgICAgOiBjYXBcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZmVuY2VzIChnZm0pXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZmVuY2VzLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgIGxhbmc6IGNhcFsyXSxcbiAgICAgICAgdGV4dDogY2FwWzNdIHx8ICcnXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGhlYWRpbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5oZWFkaW5nLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgIGRlcHRoOiBjYXBbMV0ubGVuZ3RoLFxuICAgICAgICB0ZXh0OiBjYXBbMl1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFibGUgbm8gbGVhZGluZyBwaXBlIChnZm0pXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy5ucHRhYmxlLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgIGl0ZW0gPSB7XG4gICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgIGhlYWRlcjogY2FwWzFdLnJlcGxhY2UoL14gKnwgKlxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBjZWxsczogY2FwWzNdLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5hbGlnbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSsgKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0uY2VsbHNbaV0gPSBpdGVtLmNlbGxzW2ldLnNwbGl0KC8gKlxcfCAqLyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goaXRlbSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxoZWFkaW5nXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubGhlYWRpbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgZGVwdGg6IGNhcFsyXSA9PT0gJz0nID8gMSA6IDIsXG4gICAgICAgIHRleHQ6IGNhcFsxXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBoclxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmhyLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaHInXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGJsb2NrcXVvdGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5ibG9ja3F1b3RlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdibG9ja3F1b3RlX3N0YXJ0J1xuICAgICAgfSk7XG5cbiAgICAgIGNhcCA9IGNhcFswXS5yZXBsYWNlKC9eICo+ID8vZ20sICcnKTtcblxuICAgICAgLy8gUGFzcyBgdG9wYCB0byBrZWVwIHRoZSBjdXJyZW50XG4gICAgICAvLyBcInRvcGxldmVsXCIgc3RhdGUuIFRoaXMgaXMgZXhhY3RseVxuICAgICAgLy8gaG93IG1hcmtkb3duLnBsIHdvcmtzLlxuICAgICAgdGhpcy50b2tlbihjYXAsIHRvcCwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnYmxvY2txdW90ZV9lbmQnXG4gICAgICB9KTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGlzdFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmxpc3QuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgYnVsbCA9IGNhcFsyXTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdsaXN0X3N0YXJ0JyxcbiAgICAgICAgb3JkZXJlZDogYnVsbC5sZW5ndGggPiAxXG4gICAgICB9KTtcblxuICAgICAgLy8gR2V0IGVhY2ggdG9wLWxldmVsIGl0ZW0uXG4gICAgICBjYXAgPSBjYXBbMF0ubWF0Y2godGhpcy5ydWxlcy5pdGVtKTtcblxuICAgICAgbmV4dCA9IGZhbHNlO1xuICAgICAgbCA9IGNhcC5sZW5ndGg7XG4gICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGNhcFtpXTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxpc3QgaXRlbSdzIGJ1bGxldFxuICAgICAgICAvLyBzbyBpdCBpcyBzZWVuIGFzIHRoZSBuZXh0IHRva2VuLlxuICAgICAgICBzcGFjZSA9IGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpdGVtID0gaXRlbS5yZXBsYWNlKC9eICooWyorLV18XFxkK1xcLikgKy8sICcnKTtcblxuICAgICAgICAvLyBPdXRkZW50IHdoYXRldmVyIHRoZVxuICAgICAgICAvLyBsaXN0IGl0ZW0gY29udGFpbnMuIEhhY2t5LlxuICAgICAgICBpZiAofml0ZW0uaW5kZXhPZignXFxuICcpKSB7XG4gICAgICAgICAgc3BhY2UgLT0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgaXRlbSA9ICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICAgID8gaXRlbS5yZXBsYWNlKG5ldyBSZWdFeHAoJ14gezEsJyArIHNwYWNlICsgJ30nLCAnZ20nKSwgJycpXG4gICAgICAgICAgICA6IGl0ZW0ucmVwbGFjZSgvXiB7MSw0fS9nbSwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIG5leHQgbGlzdCBpdGVtIGJlbG9uZ3MgaGVyZS5cbiAgICAgICAgLy8gQmFja3BlZGFsIGlmIGl0IGRvZXMgbm90IGJlbG9uZyBpbiB0aGlzIGxpc3QuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21hcnRMaXN0cyAmJiBpICE9PSBsIC0gMSkge1xuICAgICAgICAgIGIgPSBibG9jay5idWxsZXQuZXhlYyhjYXBbaSArIDFdKVswXTtcbiAgICAgICAgICBpZiAoYnVsbCAhPT0gYiAmJiAhKGJ1bGwubGVuZ3RoID4gMSAmJiBiLmxlbmd0aCA+IDEpKSB7XG4gICAgICAgICAgICBzcmMgPSBjYXAuc2xpY2UoaSArIDEpLmpvaW4oJ1xcbicpICsgc3JjO1xuICAgICAgICAgICAgaSA9IGwgLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIGl0ZW0gaXMgbG9vc2Ugb3Igbm90LlxuICAgICAgICAvLyBVc2U6IC8oXnxcXG4pKD8hIClbXlxcbl0rXFxuXFxuKD8hXFxzKiQpL1xuICAgICAgICAvLyBmb3IgZGlzY291bnQgYmVoYXZpb3IuXG4gICAgICAgIGxvb3NlID0gbmV4dCB8fCAvXFxuXFxuKD8hXFxzKiQpLy50ZXN0KGl0ZW0pO1xuICAgICAgICBpZiAoaSAhPT0gbCAtIDEpIHtcbiAgICAgICAgICBuZXh0ID0gaXRlbS5jaGFyQXQoaXRlbS5sZW5ndGggLSAxKSA9PT0gJ1xcbic7XG4gICAgICAgICAgaWYgKCFsb29zZSkgbG9vc2UgPSBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogbG9vc2VcbiAgICAgICAgICAgID8gJ2xvb3NlX2l0ZW1fc3RhcnQnXG4gICAgICAgICAgICA6ICdsaXN0X2l0ZW1fc3RhcnQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlY3Vyc2UuXG4gICAgICAgIHRoaXMudG9rZW4oaXRlbSwgZmFsc2UsIGJxKTtcblxuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtX2VuZCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnbGlzdF9lbmQnXG4gICAgICB9KTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaHRtbFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmh0bWwuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICAgID8gJ3BhcmFncmFwaCdcbiAgICAgICAgICA6ICdodG1sJyxcbiAgICAgICAgcHJlOiAhdGhpcy5vcHRpb25zLnNhbml0aXplclxuICAgICAgICAgICYmIChjYXBbMV0gPT09ICdwcmUnIHx8IGNhcFsxXSA9PT0gJ3NjcmlwdCcgfHwgY2FwWzFdID09PSAnc3R5bGUnKSxcbiAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGRlZlxuICAgIGlmICgoIWJxICYmIHRvcCkgJiYgKGNhcCA9IHRoaXMucnVsZXMuZGVmLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5saW5rc1tjYXBbMV0udG9Mb3dlckNhc2UoKV0gPSB7XG4gICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgdGl0bGU6IGNhcFszXVxuICAgICAgfTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRhYmxlIChnZm0pXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy50YWJsZS5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICBpdGVtID0ge1xuICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICBoZWFkZXI6IGNhcFsxXS5yZXBsYWNlKC9eICp8ICpcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgY2VsbHM6IGNhcFszXS5yZXBsYWNlKC8oPzogKlxcfCAqKT9cXG4kLywgJycpLnNwbGl0KCdcXG4nKVxuICAgICAgfTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uYWxpZ24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtLmNlbGxzW2ldID0gaXRlbS5jZWxsc1tpXVxuICAgICAgICAgIC5yZXBsYWNlKC9eICpcXHwgKnwgKlxcfCAqJC9nLCAnJylcbiAgICAgICAgICAuc3BsaXQoLyAqXFx8ICovKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbnMucHVzaChpdGVtKTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdG9wLWxldmVsIHBhcmFncmFwaFxuICAgIGlmICh0b3AgJiYgKGNhcCA9IHRoaXMucnVsZXMucGFyYWdyYXBoLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgIHRleHQ6IGNhcFsxXS5jaGFyQXQoY2FwWzFdLmxlbmd0aCAtIDEpID09PSAnXFxuJ1xuICAgICAgICAgID8gY2FwWzFdLnNsaWNlKDAsIC0xKVxuICAgICAgICAgIDogY2FwWzFdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRleHRcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50ZXh0LmV4ZWMoc3JjKSkge1xuICAgICAgLy8gVG9wLWxldmVsIHNob3VsZCBuZXZlciByZWFjaCBoZXJlLlxuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3JjKSB7XG4gICAgICB0aHJvdyBuZXdcbiAgICAgICAgRXJyb3IoJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy50b2tlbnM7XG59O1xuXG4vKipcbiAqIElubGluZS1MZXZlbCBHcmFtbWFyXG4gKi9cblxudmFyIGlubGluZSA9IHtcbiAgZXNjYXBlOiAvXlxcXFwoW1xcXFxgKnt9XFxbXFxdKCkjK1xcLS4hXz5dKS8sXG4gIGF1dG9saW5rOiAvXjwoW14gPl0rKEB8OlxcLylbXiA+XSspPi8sXG4gIHVybDogbm9vcCxcbiAgdGFnOiAvXjwhLS1bXFxzXFxTXSo/LS0+fF48XFwvP1xcdysoPzpcIlteXCJdKlwifCdbXiddKid8W14nXCI+XSkqPz4vLFxuICBsaW5rOiAvXiE/XFxbKGluc2lkZSlcXF1cXChocmVmXFwpLyxcbiAgcmVmbGluazogL14hP1xcWyhpbnNpZGUpXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8sXG4gIG5vbGluazogL14hP1xcWygoPzpcXFtbXlxcXV0qXFxdfFteXFxbXFxdXSkqKVxcXS8sXG4gIHN0cm9uZzogL15fXyhbXFxzXFxTXSs/KV9fKD8hXyl8XlxcKlxcKihbXFxzXFxTXSs/KVxcKlxcKig/IVxcKikvLFxuICBlbTogL15cXGJfKCg/OlteX118X18pKz8pX1xcYnxeXFwqKCg/OlxcKlxcKnxbXFxzXFxTXSkrPylcXCooPyFcXCopLyxcbiAgY29kZTogL14oYCspXFxzKihbXFxzXFxTXSo/W15gXSlcXHMqXFwxKD8hYCkvLFxuICBicjogL14gezIsfVxcbig/IVxccyokKS8sXG4gIGRlbDogbm9vcCxcbiAgdGV4dDogL15bXFxzXFxTXSs/KD89W1xcXFw8IVxcW18qYF18IHsyLH1cXG58JCkvXG59O1xuXG5pbmxpbmUuX2luc2lkZSA9IC8oPzpcXFtbXlxcXV0qXFxdfFteXFxbXFxdXXxcXF0oPz1bXlxcW10qXFxdKSkqLztcbmlubGluZS5faHJlZiA9IC9cXHMqPD8oW1xcc1xcU10qPyk+Pyg/OlxccytbJ1wiXShbXFxzXFxTXSo/KVsnXCJdKT9cXHMqLztcblxuaW5saW5lLmxpbmsgPSByZXBsYWNlKGlubGluZS5saW5rKVxuICAoJ2luc2lkZScsIGlubGluZS5faW5zaWRlKVxuICAoJ2hyZWYnLCBpbmxpbmUuX2hyZWYpXG4gICgpO1xuXG5pbmxpbmUucmVmbGluayA9IHJlcGxhY2UoaW5saW5lLnJlZmxpbmspXG4gICgnaW5zaWRlJywgaW5saW5lLl9pbnNpZGUpXG4gICgpO1xuXG4vKipcbiAqIE5vcm1hbCBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5ub3JtYWwgPSBtZXJnZSh7fSwgaW5saW5lKTtcblxuLyoqXG4gKiBQZWRhbnRpYyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5wZWRhbnRpYyA9IG1lcmdlKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gIHN0cm9uZzogL15fXyg/PVxcUykoW1xcc1xcU10qP1xcUylfXyg/IV8pfF5cXCpcXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqXFwqKD8hXFwqKS8sXG4gIGVtOiAvXl8oPz1cXFMpKFtcXHNcXFNdKj9cXFMpXyg/IV8pfF5cXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqKD8hXFwqKS9cbn0pO1xuXG4vKipcbiAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5nZm0gPSBtZXJnZSh7fSwgaW5saW5lLm5vcm1hbCwge1xuICBlc2NhcGU6IHJlcGxhY2UoaW5saW5lLmVzY2FwZSkoJ10pJywgJ358XSknKSgpLFxuICB1cmw6IC9eKGh0dHBzPzpcXC9cXC9bXlxcczxdK1tePC4sOjtcIicpXFxdXFxzXSkvLFxuICBkZWw6IC9efn4oPz1cXFMpKFtcXHNcXFNdKj9cXFMpfn4vLFxuICB0ZXh0OiByZXBsYWNlKGlubGluZS50ZXh0KVxuICAgICgnXXwnLCAnfl18JylcbiAgICAoJ3wnLCAnfGh0dHBzPzovL3wnKVxuICAgICgpXG59KTtcblxuLyoqXG4gKiBHRk0gKyBMaW5lIEJyZWFrcyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5icmVha3MgPSBtZXJnZSh7fSwgaW5saW5lLmdmbSwge1xuICBicjogcmVwbGFjZShpbmxpbmUuYnIpKCd7Mix9JywgJyonKSgpLFxuICB0ZXh0OiByZXBsYWNlKGlubGluZS5nZm0udGV4dCkoJ3syLH0nLCAnKicpKClcbn0pO1xuXG4vKipcbiAqIElubGluZSBMZXhlciAmIENvbXBpbGVyXG4gKi9cblxuZnVuY3Rpb24gSW5saW5lTGV4ZXIobGlua3MsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gIHRoaXMubGlua3MgPSBsaW5rcztcbiAgdGhpcy5ydWxlcyA9IGlubGluZS5ub3JtYWw7XG4gIHRoaXMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyO1xuICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKCF0aGlzLmxpbmtzKSB7XG4gICAgdGhyb3cgbmV3XG4gICAgICBFcnJvcignVG9rZW5zIGFycmF5IHJlcXVpcmVzIGEgYGxpbmtzYCBwcm9wZXJ0eS4nKTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5icmVha3MpIHtcbiAgICAgIHRoaXMucnVsZXMgPSBpbmxpbmUuYnJlYWtzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJ1bGVzID0gaW5saW5lLmdmbTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgdGhpcy5ydWxlcyA9IGlubGluZS5wZWRhbnRpYztcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBJbmxpbmUgUnVsZXNcbiAqL1xuXG5JbmxpbmVMZXhlci5ydWxlcyA9IGlubGluZTtcblxuLyoqXG4gKiBTdGF0aWMgTGV4aW5nL0NvbXBpbGluZyBNZXRob2RcbiAqL1xuXG5JbmxpbmVMZXhlci5vdXRwdXQgPSBmdW5jdGlvbihzcmMsIGxpbmtzLCBvcHRpb25zKSB7XG4gIHZhciBpbmxpbmUgPSBuZXcgSW5saW5lTGV4ZXIobGlua3MsIG9wdGlvbnMpO1xuICByZXR1cm4gaW5saW5lLm91dHB1dChzcmMpO1xufTtcblxuLyoqXG4gKiBMZXhpbmcvQ29tcGlsaW5nXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uKHNyYykge1xuICB2YXIgb3V0ID0gJydcbiAgICAsIGxpbmtcbiAgICAsIHRleHRcbiAgICAsIGhyZWZcbiAgICAsIGNhcDtcblxuICB3aGlsZSAoc3JjKSB7XG4gICAgLy8gZXNjYXBlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZXNjYXBlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSBjYXBbMV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBhdXRvbGlua1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmF1dG9saW5rLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICB0ZXh0ID0gY2FwWzFdLmNoYXJBdCg2KSA9PT0gJzonXG4gICAgICAgICAgPyB0aGlzLm1hbmdsZShjYXBbMV0uc3Vic3RyaW5nKDcpKVxuICAgICAgICAgIDogdGhpcy5tYW5nbGUoY2FwWzFdKTtcbiAgICAgICAgaHJlZiA9IHRoaXMubWFuZ2xlKCdtYWlsdG86JykgKyB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgICBocmVmID0gdGV4dDtcbiAgICAgIH1cbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgbnVsbCwgdGV4dCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB1cmwgKGdmbSlcbiAgICBpZiAoIXRoaXMuaW5MaW5rICYmIChjYXAgPSB0aGlzLnJ1bGVzLnVybC5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saW5rKGhyZWYsIG51bGwsIHRleHQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFnXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMudGFnLmV4ZWMoc3JjKSkge1xuICAgICAgaWYgKCF0aGlzLmluTGluayAmJiAvXjxhIC9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICB0aGlzLmluTGluayA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaW5MaW5rICYmIC9ePFxcL2E+L2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXJcbiAgICAgICAgICA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKVxuICAgICAgICAgIDogZXNjYXBlKGNhcFswXSlcbiAgICAgICAgOiBjYXBbMF1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxpbmtcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saW5rLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIG91dCArPSB0aGlzLm91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgdGl0bGU6IGNhcFszXVxuICAgICAgfSk7XG4gICAgICB0aGlzLmluTGluayA9IGZhbHNlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcmVmbGluaywgbm9saW5rXG4gICAgaWYgKChjYXAgPSB0aGlzLnJ1bGVzLnJlZmxpbmsuZXhlYyhzcmMpKVxuICAgICAgICB8fCAoY2FwID0gdGhpcy5ydWxlcy5ub2xpbmsuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGxpbmsgPSAoY2FwWzJdIHx8IGNhcFsxXSkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgbGluayA9IHRoaXMubGlua3NbbGluay50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIGlmICghbGluayB8fCAhbGluay5ocmVmKSB7XG4gICAgICAgIG91dCArPSBjYXBbMF0uY2hhckF0KDApO1xuICAgICAgICBzcmMgPSBjYXBbMF0uc3Vic3RyaW5nKDEpICsgc3JjO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIG91dCArPSB0aGlzLm91dHB1dExpbmsoY2FwLCBsaW5rKTtcbiAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBzdHJvbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5zdHJvbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuc3Ryb25nKHRoaXMub3V0cHV0KGNhcFsyXSB8fCBjYXBbMV0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGVtXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZW0uZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuZW0odGhpcy5vdXRwdXQoY2FwWzJdIHx8IGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gY29kZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmNvZGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuY29kZXNwYW4oZXNjYXBlKGNhcFsyXSwgdHJ1ZSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYnJcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5ici5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5icigpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZGVsIChnZm0pXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZGVsLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmRlbCh0aGlzLm91dHB1dChjYXBbMV0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRleHRcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50ZXh0LmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnRleHQoZXNjYXBlKHRoaXMuc21hcnR5cGFudHMoY2FwWzBdKSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNyYykge1xuICAgICAgdGhyb3cgbmV3XG4gICAgICAgIEVycm9yKCdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29tcGlsZSBMaW5rXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm91dHB1dExpbmsgPSBmdW5jdGlvbihjYXAsIGxpbmspIHtcbiAgdmFyIGhyZWYgPSBlc2NhcGUobGluay5ocmVmKVxuICAgICwgdGl0bGUgPSBsaW5rLnRpdGxlID8gZXNjYXBlKGxpbmsudGl0bGUpIDogbnVsbDtcblxuICByZXR1cm4gY2FwWzBdLmNoYXJBdCgwKSAhPT0gJyEnXG4gICAgPyB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgdGl0bGUsIHRoaXMub3V0cHV0KGNhcFsxXSkpXG4gICAgOiB0aGlzLnJlbmRlcmVyLmltYWdlKGhyZWYsIHRpdGxlLCBlc2NhcGUoY2FwWzFdKSk7XG59O1xuXG4vKipcbiAqIFNtYXJ0eXBhbnRzIFRyYW5zZm9ybWF0aW9uc1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5zbWFydHlwYW50cyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgaWYgKCF0aGlzLm9wdGlvbnMuc21hcnR5cGFudHMpIHJldHVybiB0ZXh0O1xuICByZXR1cm4gdGV4dFxuICAgIC8vIGVtLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS0vZywgJ1xcdTIwMTQnKVxuICAgIC8vIGVuLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS9nLCAnXFx1MjAxMycpXG4gICAgLy8gb3BlbmluZyBzaW5nbGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1wiXFxzXSknL2csICckMVxcdTIwMTgnKVxuICAgIC8vIGNsb3Npbmcgc2luZ2xlcyAmIGFwb3N0cm9waGVzXG4gICAgLnJlcGxhY2UoLycvZywgJ1xcdTIwMTknKVxuICAgIC8vIG9wZW5pbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcXHUyMDE4XFxzXSlcIi9nLCAnJDFcXHUyMDFjJylcbiAgICAvLyBjbG9zaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvXCIvZywgJ1xcdTIwMWQnKVxuICAgIC8vIGVsbGlwc2VzXG4gICAgLnJlcGxhY2UoL1xcLnszfS9nLCAnXFx1MjAyNicpO1xufTtcblxuLyoqXG4gKiBNYW5nbGUgTGlua3NcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUubWFuZ2xlID0gZnVuY3Rpb24odGV4dCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5tYW5nbGUpIHJldHVybiB0ZXh0O1xuICB2YXIgb3V0ID0gJydcbiAgICAsIGwgPSB0ZXh0Lmxlbmd0aFxuICAgICwgaSA9IDBcbiAgICAsIGNoO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2ggPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgIGNoID0gJ3gnICsgY2gudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICBvdXQgKz0gJyYjJyArIGNoICsgJzsnO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmVuZGVyZXJcbiAqL1xuXG5mdW5jdGlvbiBSZW5kZXJlcihvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG59XG5cblJlbmRlcmVyLnByb3RvdHlwZS5jb2RlID0gZnVuY3Rpb24oY29kZSwgbGFuZywgZXNjYXBlZCkge1xuICBpZiAodGhpcy5vcHRpb25zLmhpZ2hsaWdodCkge1xuICAgIHZhciBvdXQgPSB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KGNvZGUsIGxhbmcpO1xuICAgIGlmIChvdXQgIT0gbnVsbCAmJiBvdXQgIT09IGNvZGUpIHtcbiAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgY29kZSA9IG91dDtcbiAgICB9XG4gIH1cblxuICBpZiAoIWxhbmcpIHtcbiAgICByZXR1cm4gJzxwcmU+PGNvZGU+J1xuICAgICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUoY29kZSwgdHJ1ZSkpXG4gICAgICArICdcXG48L2NvZGU+PC9wcmU+JztcbiAgfVxuXG4gIHJldHVybiAnPHByZT48Y29kZSBjbGFzcz1cIidcbiAgICArIHRoaXMub3B0aW9ucy5sYW5nUHJlZml4XG4gICAgKyBlc2NhcGUobGFuZywgdHJ1ZSlcbiAgICArICdcIj4nXG4gICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUoY29kZSwgdHJ1ZSkpXG4gICAgKyAnXFxuPC9jb2RlPjwvcHJlPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuYmxvY2txdW90ZSA9IGZ1bmN0aW9uKHF1b3RlKSB7XG4gIHJldHVybiAnPGJsb2NrcXVvdGU+XFxuJyArIHF1b3RlICsgJzwvYmxvY2txdW90ZT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmh0bWwgPSBmdW5jdGlvbihodG1sKSB7XG4gIHJldHVybiBodG1sO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmhlYWRpbmcgPSBmdW5jdGlvbih0ZXh0LCBsZXZlbCwgcmF3KSB7XG4gIHJldHVybiAnPGgnXG4gICAgKyBsZXZlbFxuICAgICsgJyBpZD1cIidcbiAgICArIHRoaXMub3B0aW9ucy5oZWFkZXJQcmVmaXhcbiAgICArIHJhdy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teXFx3XSsvZywgJy0nKVxuICAgICsgJ1wiPidcbiAgICArIHRleHRcbiAgICArICc8L2gnXG4gICAgKyBsZXZlbFxuICAgICsgJz5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmhyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGhyLz5cXG4nIDogJzxocj5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbihib2R5LCBvcmRlcmVkKSB7XG4gIHZhciB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnO1xuICByZXR1cm4gJzwnICsgdHlwZSArICc+XFxuJyArIGJvZHkgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5saXN0aXRlbSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8bGk+JyArIHRleHQgKyAnPC9saT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnBhcmFncmFwaCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8cD4nICsgdGV4dCArICc8L3A+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50YWJsZSA9IGZ1bmN0aW9uKGhlYWRlciwgYm9keSkge1xuICByZXR1cm4gJzx0YWJsZT5cXG4nXG4gICAgKyAnPHRoZWFkPlxcbidcbiAgICArIGhlYWRlclxuICAgICsgJzwvdGhlYWQ+XFxuJ1xuICAgICsgJzx0Ym9keT5cXG4nXG4gICAgKyBib2R5XG4gICAgKyAnPC90Ym9keT5cXG4nXG4gICAgKyAnPC90YWJsZT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRhYmxlcm93ID0gZnVuY3Rpb24oY29udGVudCkge1xuICByZXR1cm4gJzx0cj5cXG4nICsgY29udGVudCArICc8L3RyPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGFibGVjZWxsID0gZnVuY3Rpb24oY29udGVudCwgZmxhZ3MpIHtcbiAgdmFyIHR5cGUgPSBmbGFncy5oZWFkZXIgPyAndGgnIDogJ3RkJztcbiAgdmFyIHRhZyA9IGZsYWdzLmFsaWduXG4gICAgPyAnPCcgKyB0eXBlICsgJyBzdHlsZT1cInRleHQtYWxpZ246JyArIGZsYWdzLmFsaWduICsgJ1wiPidcbiAgICA6ICc8JyArIHR5cGUgKyAnPic7XG4gIHJldHVybiB0YWcgKyBjb250ZW50ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG59O1xuXG4vLyBzcGFuIGxldmVsIHJlbmRlcmVyXG5SZW5kZXJlci5wcm90b3R5cGUuc3Ryb25nID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxzdHJvbmc+JyArIHRleHQgKyAnPC9zdHJvbmc+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5lbSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8ZW0+JyArIHRleHQgKyAnPC9lbT4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmNvZGVzcGFuID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxjb2RlPicgKyB0ZXh0ICsgJzwvY29kZT4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmJyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGJyLz4nIDogJzxicj4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8ZGVsPicgKyB0ZXh0ICsgJzwvZGVsPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGluayA9IGZ1bmN0aW9uKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuc2FuaXRpemUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHByb3QgPSBkZWNvZGVVUklDb21wb25lbnQodW5lc2NhcGUoaHJlZikpXG4gICAgICAgIC5yZXBsYWNlKC9bXlxcdzpdL2csICcnKVxuICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmIChwcm90LmluZGV4T2YoJ2phdmFzY3JpcHQ6JykgPT09IDAgfHwgcHJvdC5pbmRleE9mKCd2YnNjcmlwdDonKSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuICB2YXIgb3V0ID0gJzxhIGhyZWY9XCInICsgaHJlZiArICdcIic7XG4gIGlmICh0aXRsZSkge1xuICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgfVxuICBvdXQgKz0gJz4nICsgdGV4dCArICc8L2E+JztcbiAgcmV0dXJuIG91dDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5pbWFnZSA9IGZ1bmN0aW9uKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gIHZhciBvdXQgPSAnPGltZyBzcmM9XCInICsgaHJlZiArICdcIiBhbHQ9XCInICsgdGV4dCArICdcIic7XG4gIGlmICh0aXRsZSkge1xuICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgfVxuICBvdXQgKz0gdGhpcy5vcHRpb25zLnhodG1sID8gJy8+JyA6ICc+JztcbiAgcmV0dXJuIG91dDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gdGV4dDtcbn07XG5cbi8qKlxuICogUGFyc2luZyAmIENvbXBpbGluZ1xuICovXG5cbmZ1bmN0aW9uIFBhcnNlcihvcHRpb25zKSB7XG4gIHRoaXMudG9rZW5zID0gW107XG4gIHRoaXMudG9rZW4gPSBudWxsO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5vcHRpb25zLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlcjtcbiAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlcjtcbiAgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xufVxuXG4vKipcbiAqIFN0YXRpYyBQYXJzZSBNZXRob2RcbiAqL1xuXG5QYXJzZXIucGFyc2UgPSBmdW5jdGlvbihzcmMsIG9wdGlvbnMsIHJlbmRlcmVyKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMsIHJlbmRlcmVyKTtcbiAgcmV0dXJuIHBhcnNlci5wYXJzZShzcmMpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBMb29wXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHNyYykge1xuICB0aGlzLmlubGluZSA9IG5ldyBJbmxpbmVMZXhlcihzcmMubGlua3MsIHRoaXMub3B0aW9ucywgdGhpcy5yZW5kZXJlcik7XG4gIHRoaXMudG9rZW5zID0gc3JjLnJldmVyc2UoKTtcblxuICB2YXIgb3V0ID0gJyc7XG4gIHdoaWxlICh0aGlzLm5leHQoKSkge1xuICAgIG91dCArPSB0aGlzLnRvaygpO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTmV4dCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b2tlbiA9IHRoaXMudG9rZW5zLnBvcCgpO1xufTtcblxuLyoqXG4gKiBQcmV2aWV3IE5leHQgVG9rZW5cbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdIHx8IDA7XG59O1xuXG4vKipcbiAqIFBhcnNlIFRleHQgVG9rZW5zXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRleHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJvZHkgPSB0aGlzLnRva2VuLnRleHQ7XG5cbiAgd2hpbGUgKHRoaXMucGVlaygpLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIGJvZHkgKz0gJ1xcbicgKyB0aGlzLm5leHQoKS50ZXh0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuaW5saW5lLm91dHB1dChib2R5KTtcbn07XG5cbi8qKlxuICogUGFyc2UgQ3VycmVudCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUudG9rID0gZnVuY3Rpb24oKSB7XG4gIHN3aXRjaCAodGhpcy50b2tlbi50eXBlKSB7XG4gICAgY2FzZSAnc3BhY2UnOiB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNhc2UgJ2hyJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaHIoKTtcbiAgICB9XG4gICAgY2FzZSAnaGVhZGluZyc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmhlYWRpbmcoXG4gICAgICAgIHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLnRleHQpLFxuICAgICAgICB0aGlzLnRva2VuLmRlcHRoLFxuICAgICAgICB0aGlzLnRva2VuLnRleHQpO1xuICAgIH1cbiAgICBjYXNlICdjb2RlJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuY29kZSh0aGlzLnRva2VuLnRleHQsXG4gICAgICAgIHRoaXMudG9rZW4ubGFuZyxcbiAgICAgICAgdGhpcy50b2tlbi5lc2NhcGVkKTtcbiAgICB9XG4gICAgY2FzZSAndGFibGUnOiB7XG4gICAgICB2YXIgaGVhZGVyID0gJydcbiAgICAgICAgLCBib2R5ID0gJydcbiAgICAgICAgLCBpXG4gICAgICAgICwgcm93XG4gICAgICAgICwgY2VsbFxuICAgICAgICAsIGZsYWdzXG4gICAgICAgICwgajtcblxuICAgICAgLy8gaGVhZGVyXG4gICAgICBjZWxsID0gJyc7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50b2tlbi5oZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZmxhZ3MgPSB7IGhlYWRlcjogdHJ1ZSwgYWxpZ246IHRoaXMudG9rZW4uYWxpZ25baV0gfTtcbiAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbChcbiAgICAgICAgICB0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi5oZWFkZXJbaV0pLFxuICAgICAgICAgIHsgaGVhZGVyOiB0cnVlLCBhbGlnbjogdGhpcy50b2tlbi5hbGlnbltpXSB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBoZWFkZXIgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMudG9rZW4uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcm93ID0gdGhpcy50b2tlbi5jZWxsc1tpXTtcblxuICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCByb3cubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKFxuICAgICAgICAgICAgdGhpcy5pbmxpbmUub3V0cHV0KHJvd1tqXSksXG4gICAgICAgICAgICB7IGhlYWRlcjogZmFsc2UsIGFsaWduOiB0aGlzLnRva2VuLmFsaWduW2pdIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYm9keSArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIudGFibGUoaGVhZGVyLCBib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnYmxvY2txdW90ZV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnYmxvY2txdW90ZV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuYmxvY2txdW90ZShib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnbGlzdF9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJydcbiAgICAgICAgLCBvcmRlcmVkID0gdGhpcy50b2tlbi5vcmRlcmVkO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2xpc3RfZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmxpc3QoYm9keSwgb3JkZXJlZCk7XG4gICAgfVxuICAgIGNhc2UgJ2xpc3RfaXRlbV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9pdGVtX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRva2VuLnR5cGUgPT09ICd0ZXh0J1xuICAgICAgICAgID8gdGhpcy5wYXJzZVRleHQoKVxuICAgICAgICAgIDogdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdGl0ZW0oYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2xvb3NlX2l0ZW1fc3RhcnQnOiB7XG4gICAgICB2YXIgYm9keSA9ICcnO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2xpc3RfaXRlbV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdGl0ZW0oYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2h0bWwnOiB7XG4gICAgICB2YXIgaHRtbCA9ICF0aGlzLnRva2VuLnByZSAmJiAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgID8gdGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dClcbiAgICAgICAgOiB0aGlzLnRva2VuLnRleHQ7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5odG1sKGh0bWwpO1xuICAgIH1cbiAgICBjYXNlICdwYXJhZ3JhcGgnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMucGFyc2VUZXh0KCkpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIZWxwZXJzXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGh0bWwsIGVuY29kZSkge1xuICByZXR1cm4gaHRtbFxuICAgIC5yZXBsYWNlKCFlbmNvZGUgPyAvJig/ISM/XFx3KzspL2cgOiAvJi9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgIC5yZXBsYWNlKC8nL2csICcmIzM5OycpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZShodG1sKSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoLyYoWyNcXHddKyk7L2csIGZ1bmN0aW9uKF8sIG4pIHtcbiAgICBuID0gbi50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChuID09PSAnY29sb24nKSByZXR1cm4gJzonO1xuICAgIGlmIChuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICByZXR1cm4gbi5jaGFyQXQoMSkgPT09ICd4J1xuICAgICAgICA/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobi5zdWJzdHJpbmcoMiksIDE2KSlcbiAgICAgICAgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKCtuLnN1YnN0cmluZygxKSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2UocmVnZXgsIG9wdCkge1xuICByZWdleCA9IHJlZ2V4LnNvdXJjZTtcbiAgb3B0ID0gb3B0IHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb24gc2VsZihuYW1lLCB2YWwpIHtcbiAgICBpZiAoIW5hbWUpIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4LCBvcHQpO1xuICAgIHZhbCA9IHZhbC5zb3VyY2UgfHwgdmFsO1xuICAgIHZhbCA9IHZhbC5yZXBsYWNlKC8oXnxbXlxcW10pXFxeL2csICckMScpO1xuICAgIHJlZ2V4ID0gcmVnZXgucmVwbGFjZShuYW1lLCB2YWwpO1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cbm5vb3AuZXhlYyA9IG5vb3A7XG5cbmZ1bmN0aW9uIG1lcmdlKG9iaikge1xuICB2YXIgaSA9IDFcbiAgICAsIHRhcmdldFxuICAgICwga2V5O1xuXG4gIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0ID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAoa2V5IGluIHRhcmdldCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSB0YXJnZXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5cbi8qKlxuICogTWFya2VkXG4gKi9cblxuZnVuY3Rpb24gbWFya2VkKHNyYywgb3B0LCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgfHwgdHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0O1xuICAgICAgb3B0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBvcHQgPSBtZXJnZSh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQgfHwge30pO1xuXG4gICAgdmFyIGhpZ2hsaWdodCA9IG9wdC5oaWdobGlnaHRcbiAgICAgICwgdG9rZW5zXG4gICAgICAsIHBlbmRpbmdcbiAgICAgICwgaSA9IDA7XG5cbiAgICB0cnkge1xuICAgICAgdG9rZW5zID0gTGV4ZXIubGV4KHNyYywgb3B0KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICB9XG5cbiAgICBwZW5kaW5nID0gdG9rZW5zLmxlbmd0aDtcblxuICAgIHZhciBkb25lID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBvdXQgPSBQYXJzZXIucGFyc2UodG9rZW5zLCBvcHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnIgPSBlO1xuICAgICAgfVxuXG4gICAgICBvcHQuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuXG4gICAgICByZXR1cm4gZXJyXG4gICAgICAgID8gY2FsbGJhY2soZXJyKVxuICAgICAgICA6IGNhbGxiYWNrKG51bGwsIG91dCk7XG4gICAgfTtcblxuICAgIGlmICghaGlnaGxpZ2h0IHx8IGhpZ2hsaWdodC5sZW5ndGggPCAzKSB7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBvcHQuaGlnaGxpZ2h0O1xuXG4gICAgaWYgKCFwZW5kaW5nKSByZXR1cm4gZG9uZSgpO1xuXG4gICAgZm9yICg7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIChmdW5jdGlvbih0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gJ2NvZGUnKSB7XG4gICAgICAgICAgcmV0dXJuIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZ2hsaWdodCh0b2tlbi50ZXh0LCB0b2tlbi5sYW5nLCBmdW5jdGlvbihlcnIsIGNvZGUpIHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgIGlmIChjb2RlID09IG51bGwgfHwgY29kZSA9PT0gdG9rZW4udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRva2VuLnRleHQgPSBjb2RlO1xuICAgICAgICAgIHRva2VuLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSkodG9rZW5zW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAob3B0KSBvcHQgPSBtZXJnZSh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICAgIHJldHVybiBQYXJzZXIucGFyc2UoTGV4ZXIubGV4KHNyYywgb3B0KSwgb3B0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGUubWVzc2FnZSArPSAnXFxuUGxlYXNlIHJlcG9ydCB0aGlzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGpqL21hcmtlZC4nO1xuICAgIGlmICgob3B0IHx8IG1hcmtlZC5kZWZhdWx0cykuc2lsZW50KSB7XG4gICAgICByZXR1cm4gJzxwPkFuIGVycm9yIG9jY3VyZWQ6PC9wPjxwcmU+J1xuICAgICAgICArIGVzY2FwZShlLm1lc3NhZ2UgKyAnJywgdHJ1ZSlcbiAgICAgICAgKyAnPC9wcmU+JztcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnNcbiAqL1xuXG5tYXJrZWQub3B0aW9ucyA9XG5tYXJrZWQuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdCkge1xuICBtZXJnZShtYXJrZWQuZGVmYXVsdHMsIG9wdCk7XG4gIHJldHVybiBtYXJrZWQ7XG59O1xuXG5tYXJrZWQuZGVmYXVsdHMgPSB7XG4gIGdmbTogdHJ1ZSxcbiAgdGFibGVzOiB0cnVlLFxuICBicmVha3M6IGZhbHNlLFxuICBwZWRhbnRpYzogZmFsc2UsXG4gIHNhbml0aXplOiBmYWxzZSxcbiAgc2FuaXRpemVyOiBudWxsLFxuICBtYW5nbGU6IHRydWUsXG4gIHNtYXJ0TGlzdHM6IGZhbHNlLFxuICBzaWxlbnQ6IGZhbHNlLFxuICBoaWdobGlnaHQ6IG51bGwsXG4gIGxhbmdQcmVmaXg6ICdsYW5nLScsXG4gIHNtYXJ0eXBhbnRzOiBmYWxzZSxcbiAgaGVhZGVyUHJlZml4OiAnJyxcbiAgcmVuZGVyZXI6IG5ldyBSZW5kZXJlcixcbiAgeGh0bWw6IGZhbHNlXG59O1xuXG4vKipcbiAqIEV4cG9zZVxuICovXG5cbm1hcmtlZC5QYXJzZXIgPSBQYXJzZXI7XG5tYXJrZWQucGFyc2VyID0gUGFyc2VyLnBhcnNlO1xuXG5tYXJrZWQuUmVuZGVyZXIgPSBSZW5kZXJlcjtcblxubWFya2VkLkxleGVyID0gTGV4ZXI7XG5tYXJrZWQubGV4ZXIgPSBMZXhlci5sZXg7XG5cbm1hcmtlZC5JbmxpbmVMZXhlciA9IElubGluZUxleGVyO1xubWFya2VkLmlubGluZUxleGVyID0gSW5saW5lTGV4ZXIub3V0cHV0O1xuXG5tYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBtYXJrZWQ7XG59IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBtYXJrZWQ7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy5tYXJrZWQgPSBtYXJrZWQ7XG59XG5cbn0pLmNhbGwoZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzIHx8ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCk7XG59KCkpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbWFya2VkL2xpYi9tYXJrZWQuanNcbiAqKiBtb2R1bGUgaWQgPSA2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdHRhZyQuZGVmaW5lVGFnKCdzaXRlJywgJ2h0bWwnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZGVwcyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fZGVwczsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0RGVwcyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9kZXBzID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5oZWFkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGFnJC4kaGVhZCgpLnNldENvbnRlbnQoW1xuXHRcdFx0XHR0YWckLiR0aXRsZSgpLnNldFRleHQoXCJpbWJhXCIpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRtZXRhKCkuc2V0Q2hhcnNldChcInV0Zi04XCIpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRtZXRhKCkuc2V0TmFtZShcInZpZXdwb3J0XCIpLnNldENvbnRlbnQoXCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MSwgbWF4aW11bS1zY2FsZT0xLG1pbmltdW0tc2NhbGU9MVwiKS5lbmQoKSxcblx0XHRcdFx0dGFnJC4kbWV0YSgpLnNldE5hbWUoXCJEZXNjcmlwdGlvblwiKS5zZXRDb250ZW50KFwiSW1iYSBpcyBhIHJpY2ggcHJvZ3JhbW1pbmcgbGFuZ3VhZ2UgZm9yIHRoZSB3ZWIuXCIpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRtZXRhKCkuc2V0TmFtZShcImtleXdvcmRzXCIpLnNldENvbnRlbnQoXCJpbWJhIGphdmFzY3JpcHQgbGFuZ3VhZ2UganNcIikuZW5kKCksXG5cdFx0XHRcdHRhZyQuJGxpbmsoKS5zZXRIcmVmKCdodHRwOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1Tb3VyY2UrQ29kZStQcm86NDAwLDUwMCw2MDAnKS5zZXRSZWwoJ3N0eWxlc2hlZXQnKS5zZXRUeXBlKCd0ZXh0L2NzcycpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRsaW5rKCkuc2V0UmVsKFwic3R5bGVzaGVldFwiKS5zZXRIcmVmKFwiL2Nzcy9zaXRlLmNzc1wiKS5zZXRNZWRpYShcInNjcmVlblwiKS5lbmQoKSxcblx0XHRcdFx0dGFnJC4kc2NyaXB0KCkuc2V0VGV4dCgnREVQUyA9IHt9OycpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRzY3JpcHQoKS5zZXRTcmMoXCIvdmVuZG9yL2dhLmpzXCIpLmVuZCgpXG5cdFx0XHRdLDIpLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGFnJC4kYm9keSgpLnNldElkKCdzaXRlJykuc2V0Q29udGVudChbXG5cdFx0XHRcdHRhZyQuJHNpdGVfbmF2KCkuc2V0SWQoJ2hlYWRlcicpLmZsYWcoJ2F3YWtlbicpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRob21lKCkuc2V0Um91dGUoJy9ob21lJykuZW5kKCksXG5cdFx0XHRcdHRhZyQuJGd1aWRlcygpLnNldFJvdXRlKCcvZ3VpZGVzJykuZW5kKCksXG5cdFx0XHRcdHRhZyQuJGRvY3MoKS5zZXRSb3V0ZSgnL2RvY3MnKS5lbmQoKSxcblx0XHRcdFx0dGFnJC4kYmxvZygpLnNldFJvdXRlKCcvYmxvZycpLmVuZCgpXG5cdFx0XHRdLDIpLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zY3JpcHRzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIHQwO1xuXHRcdFx0cmV0dXJuIHRhZyQuJGRpdigpLmZsYWcoJ3NjcmlwdHMnKS5zZXRDb250ZW50KFtcblx0XHRcdFx0KGZ1bmN0aW9uKHQwKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgbyA9IHNlbGYuZGVwcygpLCBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKG8pLCBsID0ga2V5cy5sZW5ndGgsIHJlcyA9IFtdOyBpIDwgbDsgaSsrKXtcblx0XHRcdFx0XHRcdHJlcy5wdXNoKHRhZyQuJHNjcmlwdCgpLnNldFR5cGUoXCJ0ZXh0L2phdmFzY3JpcHRcIikuc2V0U3JjKChrZXlzW2ldICsgJy5kZXAnKSkuZW5kKCkpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0fSkodDApLFxuXHRcdFx0XHR0YWckLiRzY3JpcHQoKS5zZXRTcmMoXCIvdmVuZG9yL2hsLmpzXCIpLmVuZCgpLFxuXHRcdFx0XHR0YWckLiRzY3JpcHQoKS5zZXRTcmMoXCIvY2xpZW50LmpzXCIpLmVuZCgpXG5cdFx0XHRdLDApLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdC8vIGRpcnR5IHdvcmthcm91bmRzXG5cdFx0XHRBUFAuc2V0U2l0ZSh0aGlzKTtcblx0XHRcdHRoaXMuc2V0RGVwcyh7fSk7XG5cdFx0XHRBUFAuZmV0Y2hEb2N1bWVudCgnL2d1aWRlcy5tZCcpO1xuXHRcdFx0dmFyIGJvZHkgPSB0aGlzLmJvZHkoKTtcblx0XHRcdGJvZHkuYXBwZW5kKHRoaXMuc2NyaXB0cygpKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5mbGFnKCdsaWdodCcpLnNldENoaWxkcmVuKFtcblx0XHRcdFx0dGhpcy5oZWFkKCksXG5cdFx0XHRcdGJvZHlcblx0XHRcdF0sMSkuc3luY2VkKCk7XG5cdFx0XHRBUFAuc2V0U2l0ZShudWxsKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnc2l0ZS1uYXYnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudG9nZ2xlTWVudSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHEkJCgnYm9keScpLnRvZ2dsZUZsYWcoJ21lbnUnKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDAsIHQxLCB0MiwgdDMsIHQ0LCB0NSwgdDYsIHQ3O1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Q2hpbGRyZW4oXG5cdFx0XHRcdCh0MCA9IHRoaXMuJGE9dGhpcy4kYSB8fCB0YWckLiRuYXYoKS5mbGFnKCdjb250ZW50JykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdCh0MSA9IHQwLiQkYT10MC4kJGEgfHwgdGFnJC4kYSgpLmZsYWcoJ21lbnUnKS5zZXRIYW5kbGVyKCd0YXAnLCd0b2dnbGVNZW51Jyx0aGlzKSkuc2V0Q29udGVudCgodDEuJCRhID0gdDEuJCRhIHx8IHRhZyQuJGIoKSkuZW5kKCksMikuZW5kKCksXG5cdFx0XHRcdFx0KHQyID0gdDAuJCRiPXQwLiQkYiB8fCB0YWckLiRhKCkuZmxhZygndGFiJykuZmxhZygnbG9nbycpLnNldEhyZWYoJy9ob21lJykpLnNldENvbnRlbnQoKHQyLiQkYSA9IHQyLiQkYSB8fCB0YWckLiRpKCkpLnNldFRleHQoJ2ltYmEnKS5lbmQoKSwyKS5lbmQoKSxcblx0XHRcdFx0XHQodDAuJCRjID0gdDAuJCRjIHx8IHRhZyQuJHNwYW4oKS5mbGFnKCdncmVlZHknKSkuZW5kKCksXG5cdFx0XHRcdFx0KHQzID0gdDAuJCRkPXQwLiQkZCB8fCB0YWckLiRhKCkuZmxhZygndGFiJykuZmxhZygnaG9tZScpLnNldEhyZWYoJy9ob21lJykpLnNldENvbnRlbnQoKHQzLiQkYSA9IHQzLiQkYSB8fCB0YWckLiRpKCkpLnNldFRleHQoJ2hvbWUnKS5lbmQoKSwyKS5lbmQoKSxcblx0XHRcdFx0XHQodDQgPSB0MC4kJGU9dDAuJCRlIHx8IHRhZyQuJGEoKS5mbGFnKCd0YWInKS5mbGFnKCdndWlkZXMnKS5zZXRIcmVmKCcvZ3VpZGVzJykpLnNldENvbnRlbnQoKHQ0LiQkYSA9IHQ0LiQkYSB8fCB0YWckLiRpKCkpLnNldFRleHQoJ2d1aWRlcycpLmVuZCgpLDIpLmVuZCgpLFxuXHRcdFx0XHRcdCh0NSA9IHQwLiQkZj10MC4kJGYgfHwgdGFnJC4kYSgpLmZsYWcoJ3RhYicpLmZsYWcoJ2RvY3MnKS5zZXRIcmVmKCcvZG9jcycpKS5zZXRDb250ZW50KCh0NS4kJGEgPSB0NS4kJGEgfHwgdGFnJC4kaSgpKS5zZXRUZXh0KCdkb2NzJykuZW5kKCksMikuZW5kKCksXG5cdFx0XHRcdFx0KHQ2ID0gdDAuJCRnPXQwLiQkZyB8fCB0YWckLiRhKCkuZmxhZygndGFiJykuZmxhZygnYmxvZycpLnNldEhyZWYoJy9ibG9nJykpLnNldENvbnRlbnQoKHQ2LiQkYSA9IHQ2LiQkYSB8fCB0YWckLiRpKCkpLnNldFRleHQoJ2Jsb2cnKS5lbmQoKSwyKS5lbmQoKSxcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQodDcgPSB0MC4kJGg9dDAuJCRoIHx8IHRhZyQuJGEoKS5mbGFnKCdnaXRodWInKS5zZXRIcmVmKCdodHRwczovL2dpdGh1Yi5jb20vc29tZWJlZS9pbWJhJykpLnNldENvbnRlbnQoKHQ3LiQkYSA9IHQ3LiQkYSB8fCB0YWckLiRpKCkpLnNldFRleHQoJ2dpdGh1YicpLmVuZCgpLDIpLmVuZCgpXG5cdFx0XHRcdF0sMikuZW5kKClcblx0XHRcdCwyKS5zeW5jZWQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXdha2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5zY2hlZHVsZSh7ZnBzOiAwfSk7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL3NpdGUuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnbmF2bWVudScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnJvdXRlID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdtZW51Jyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCduYXYtbGlzdCcpO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ25hdi1saW5rJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmhyZWYgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdocmVmJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEhyZWYgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2hyZWYnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Q2hpbGRyZW4oKHQwID0gdGhpcy4kYT10aGlzLiRhIHx8IHRhZyQuJGEoKSkuc2V0SHJlZih0aGlzLmhyZWYoKSkuc2V0Q29udGVudCh0aGlzLl9jb250ZW50LDMpLmVuZCgpLDIpLnN5bmNlZCgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCd0b2MnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy50b2dnbGVGbGFnKCdjb2xsYXBzZWQnKTtcblx0XHR9O1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvdmlld3MvbmF2LmltYmFcbiAqKiBtb2R1bGUgaWQgPSA2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ3BhZ2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdHRhZy5wcm90b3R5cGUuYm9keSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuICh0aGlzLl9ib2R5ID0gdGhpcy5fYm9keSB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ2JvZHknLHRoaXMpKS5zZXRUZXh0KFwiQ29udGVudCBoZXJlXCIpLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5uYXYgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiAodGhpcy5fbmF2ID0gdGhpcy5fbmF2IHx8IHRhZyQuJGRpdigpLnNldFJlZignbmF2Jyx0aGlzKSkuc2V0VGV4dChcIk5hdmlnYXRpb24gaGVyZVwiKS5lbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXNzZW1ibGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnNldENoaWxkcmVuKFtcblx0XHRcdFx0dGhpcy5uYXYoKSxcblx0XHRcdFx0dGhpcy5ib2R5KClcblx0XHRcdF0sMSkuc3luY2VkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyBsb2cgJ3JlbmRlciBwYWdlJyxyb3V0ZVxuXHRcdFx0dmFyIHNjb3BlZCA9IHRoaXMucm91dGVyKCkuc2NvcGVkKHRoaXMucm91dGUoKSx0aGlzKTtcblx0XHRcdHRoaXMuZmxhZygnc2NvcGVkJyxzY29wZWQpO1xuXHRcdFx0dGhpcy5mbGFnKCdzZWxlY3RlZCcsdGhpcy5yb3V0ZXIoKS5tYXRjaCh0aGlzLnJvdXRlKCksdGhpcykpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIShzY29wZWQgJiYgdGhpcy5yZWFkeSgpKSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0cmV0dXJuIHRoaXMuYXNzZW1ibGUoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXdha2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5zY2hlZHVsZSh7ZnBzOiAxfSk7XG5cdFx0fTtcblx0fSk7XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL3BhZ2UuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0ZnVuY3Rpb24gc2h1ZmZsZShhcnJheSl7XG5cdFx0dmFyIGNvdW50ZXIgPSBhcnJheS5sZW5ndGgsdGVtcCxpbmRleDtcblx0XHRcblx0XHQvLyBXaGlsZSB0aGVyZSBhcmUgZWxlbWVudHMgaW4gdGhlIGFycmF5XG5cdFx0d2hpbGUgKGNvdW50ZXIgPiAwKXtcblx0XHRcdC8vIFBpY2sgYSByYW5kb20gaW5kZXhcblx0XHRcdGluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY291bnRlcik7XG5cdFx0XHRjb3VudGVyLS07IC8vIERlY3JlYXNlIGNvdW50ZXIgYnkgMVxuXHRcdFx0XG5cdFx0XHQvLyBBbmQgc3dhcCB0aGUgbGFzdCBlbGVtZW50IHdpdGggaXRcblx0XHRcdHRlbXAgPSBhcnJheVtjb3VudGVyXTtcblx0XHRcdGFycmF5W2NvdW50ZXJdID0gYXJyYXlbaW5kZXhdO1xuXHRcdFx0YXJyYXlbaW5kZXhdID0gdGVtcDtcblx0XHR9O1xuXHRcdFxuXHRcdHJldHVybiBhcnJheTtcblx0fTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdwYXR0ZXJuJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRpZiAoSW1iYS5TRVJWRVIpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcdFxuXHRcdFx0dmFyIHBhcnRzID0ge3RhZ3M6IFtdLGtleXdvcmRzOiBbXSxtZXRob2RzOiBbXX07XG5cdFx0XHR2YXIgaXRlbXMgPSBbXTtcblx0XHRcdHZhciBsaW5lcyA9IFtdO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBvID0gSW1iYS5UYWcucHJvdG90eXBlLCBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKG8pLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspe1xuXHRcdFx0XHRrID0ga2V5c1tpXTtpdGVtcy5wdXNoKChcIjxlbT5cIiArIGsgKyBcIjwvZW0+XCIpKTtcblx0XHRcdFx0cGFydHMubWV0aG9kcy5wdXNoKChcIjxlbT5cIiArIGsgKyBcIjwvZW0+XCIpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChIVE1MX1RBR1MpLCBsZW5fID0gYXJ5Lmxlbmd0aCwgazE7IGkgPCBsZW5fOyBpKyspIHtcblx0XHRcdFx0Ly8gZm9yIG93biBrLHYgb2YgSW1iYS5UQUdTXG5cdFx0XHRcdC8vIGlmIHYgYW5kIHY6cHJvdG90eXBlIGlzYSBJbWJhLlRhZ1xuXHRcdFx0XHRrMSA9IGFyeVtpXTtcblx0XHRcdFx0aXRlbXMucHVzaCgoXCI8dT4mbHQ7XCIgKyBrMSArIFwiJmd0OzwvdT5cIikpO1xuXHRcdFx0XHRwYXJ0cy50YWdzLnB1c2goKFwiPHU+Jmx0O1wiICsgazEgKyBcIiZndDs8L3U+XCIpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHZhciB3b3JkcyA9IFwiZGVmIGlmIGVsc2UgZWxpZiB3aGlsZSB1bnRpbCBmb3IgaW4gb2YgdmFyIGxldCBjbGFzcyBleHRlbmQgZXhwb3J0IGltcG9ydCB0YWcgZ2xvYmFsXCI7XG5cdFx0XHRcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh3b3Jkcy5zcGxpdChcIiBcIikpLCBsZW5fID0gYXJ5Lmxlbmd0aCwgazI7IGkgPCBsZW5fOyBpKyspIHtcblx0XHRcdFx0azIgPSBhcnlbaV07XG5cdFx0XHRcdGl0ZW1zLnB1c2goKFwiPGk+XCIgKyBrMiArIFwiPC9pPlwiKSk7XG5cdFx0XHRcdHBhcnRzLmtleXdvcmRzLnB1c2goKFwiPGk+XCIgKyBrMiArIFwiPC9pPlwiKSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgc2h1ZmZsZWQgPSBzaHVmZmxlKGl0ZW1zKTtcblx0XHRcdHZhciBhbGwgPSBbXS5jb25jYXQoc2h1ZmZsZWQpO1xuXHRcdFx0dmFyIGNvdW50ID0gaXRlbXMubGVuZ3RoIC0gMTtcblx0XHRcdFxuXHRcdFx0Zm9yICh2YXIgbGVuID0gMTIsIGxuID0gMDsgbG4gPD0gbGVuOyBsbisrKSB7XG5cdFx0XHRcdHZhciBjaGFycyA9IDA7XG5cdFx0XHRcdGxpbmVzW2xuXSA9IFtdO1xuXHRcdFx0XHR3aGlsZSAoY2hhcnMgPCAzMDApe1xuXHRcdFx0XHRcdHZhciBpdGVtID0gKHNodWZmbGVkLnBvcCgpIHx8IGFsbFtNYXRoLmZsb29yKGNvdW50ICogTWF0aC5yYW5kb20oKSldKTtcblx0XHRcdFx0XHRpZiAoaXRlbSkge1xuXHRcdFx0XHRcdFx0Y2hhcnMgKz0gaXRlbS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRsaW5lc1tsbl0ucHVzaChpdGVtKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2hhcnMgPSA0MDA7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHRoaXMuZG9tKCkuaW5uZXJIVE1MID0gJzxkaXY+JyArIGxpbmVzLm1hcChmdW5jdGlvbihsbikge1xuXHRcdFx0XHRyZXR1cm4gJzxkaXYgY2xhc3M9XCJsaW5lXCI+JyArIGxuLmpvaW4oXCIgXCIpICsgJzwvZGl2Pic7XG5cdFx0XHR9KS5qb2luKCcnKSArICc8L2Rpdj4nO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmF3YWtlbiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5sb2coJ2F3YWtlbmluZyBwYXR0ZXJuISEnKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQocSQoJy5saW5lJyx0aGlzKSksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHR2YXIgeiA9IDIwICsgaSAqIDEwO1xuXHRcdFx0XHQvLyB6ID0gcGFyc2VJbnQoLXogKyBNYXRoLnJhbmRvbSAqIHogKiAyKVxuXHRcdFx0XHRhcnlbaV0uY3NzKCd0cmFuc2Zvcm0nLChcInRyYW5zbGF0ZVooXCIgKyB6ICsgXCJweClcIikpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdob21lJywgJ3BhZ2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHZhciB0b2RvcyA9IHtkZW1vOiB0cnVlLGF1dG9ydW46IHRydWV9O1xuXHRcdHZhciBjbG9jayA9IHtkZW1vOiB0cnVlLGF1dG9ydW46IHRydWV9O1xuXHRcdHZhciByZW1pbmRlcnMgPSB7ZGVtbzogdHJ1ZSxhdXRvcnVuOiB0cnVlfTtcblx0XHR2YXIgaGVybyA9IHthdXRvcnVuOiB0cnVlfTtcblx0XHR2YXIgY2FudmFzID0ge2RlbW86IHRydWUsYXV0b3J1bjogdHJ1ZX07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hd2FrZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzbmlwcGV0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2NvZGVbZGF0YS1zcmNdJyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoc25pcHBldHMpLCBsZW4gPSBhcnkubGVuZ3RoLCBzbmlwcGV0OyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0c25pcHBldCA9IGFyeVtpXTtcblx0XHRcdFx0dmFyIHNyYyA9IHNuaXBwZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXNyYycpO1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyAnZmV0Y2hpbmcgc25pcHBldCBmb3IgJyxzcmNcblx0XHRcdFx0REVQU1tzcmNdID0ge2h0bWw6IHNuaXBwZXQuaW5uZXJIVE1MfTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0YWcuX19zdXBlcl9fLmF3YWtlbi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm5hdiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJvZHkgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MCwgdDEsIHQyLCB0MywgdDQ7XG5cdFx0XHRyZXR1cm4gKHQwID0gdGhpcy5fYm9keT10aGlzLl9ib2R5IHx8IHRhZyQuJGRpdigpLnNldFJlZignYm9keScsdGhpcykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHQodDEgPSB0MC4kJGE9dDAuJCRhIHx8IHRhZyQuJGRpdigpLnNldElkKCdoZXJvJykuZmxhZygnZGFyaycpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHQodGhpcy5fcGF0dGVybiA9IHRoaXMuX3BhdHRlcm4gfHwgdGFnJC4kcGF0dGVybigpLnNldFJlZigncGF0dGVybicsdGhpcykuZmxhZygnYXdha2VuJykpLmVuZCgpLFxuXHRcdFx0XHRcdCh0MS4kJGIgPSB0MS4kJGIgfHwgdGFnJC4kZXhhbXBsZSgpLmZsYWcoJ2hlcm8nKS5mbGFnKCdkYXJrJykuc2V0U3JjKCcvaG9tZS9leGFtcGxlcy9oZXJvLmltYmEnKSkuZW5kKClcblx0XHRcdFx0XSwyKS5lbmQoKSxcblx0XHRcdFx0XG5cdFx0XHRcdCh0MiA9IHRoaXMuX2NvbnRlbnQ9dGhpcy5fY29udGVudCB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ2NvbnRlbnQnLHRoaXMpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHQodDIuJCRhID0gdDIuJCRhIHx8IHRhZyQuJG1hcmtlZCgpLmZsYWcoJ3NlY3Rpb24nKS5mbGFnKCdtZCcpLmZsYWcoJ3dlbGNvbWUnKS5mbGFnKCdodWdlJykuZmxhZygnbGlnaHQnKSkuc2V0VGV4dChcIiMgUnVieSwgUHl0aG9uIGFuZCBSZWFjdCBnb3QgdG9nZXRoZXIuIE5pbmUgbW9udGhzIGxhdGVyLCBJbWJhIHdhcyBib3JuLlxcblxcbkltYmEgaXMgYSBuZXcgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2UgZm9yIHRoZSB3ZWIgdGhhdCBjb21waWxlcyB0byBoaWdobHkgXFxucGVyZm9ybWFudCBhbmQgcmVhZGFibGUgSmF2YVNjcmlwdC4gSXQgaGFzIGxhbmd1YWdlIGxldmVsIHN1cHBvcnQgZm9yIGRlZmluaW5nLCBcXG5leHRlbmRpbmcsIHN1YmNsYXNzaW5nLCBpbnN0YW50aWF0aW5nIGFuZCByZW5kZXJpbmcgZG9tIG5vZGVzLiBGb3IgYSBzZW1pLWNvbXBsZXggXFxuYXBwbGljYXRpb24gbGlrZSBUb2RvTVZDLCBpdCBpcyBtb3JlIHRoYW4gXFxuWzEwIHRpbWVzIGZhc3RlciB0aGFuIFJlYWN0XShodHRwOi8vc29tZWJlZS5naXRodWIuaW8vdG9kb212Yy1yZW5kZXItYmVuY2htYXJrL2luZGV4Lmh0bWwpIFxcbndpdGggbGVzcyBjb2RlLCBhbmQgYSBtdWNoIHNtYWxsZXIgbGlicmFyeS5cXG5cXG4tLS1cXG5cXG4tICMjIEltYmEuaW5zcGlyYXRpb25cXG4gIEltYmEgYnJpbmdzIHRoZSBiZXN0IGZyb20gUnVieSwgUHl0aG9uLCBhbmQgUmVhY3QgKCsgSlNYKSB0b2dldGhlciBpbiBhIGNsZWFuIGxhbmd1YWdlIGFuZCBydW50aW1lLlxcblxcbi0gIyMgSW1iYS5pbnRlcm9wZXJhYmlsaXR5XFxuICBJbWJhIGNvbXBpbGVzIGRvd24gdG8gY2xlYW4gYW5kIHJlYWRhYmxlIEphdmFTY3JpcHQuIFVzZSBhbnkgSlMgbGlicmFyeSBpbiBJbWJhIGFuZCB2aWNhLXZlcnNhLlxcblxcbi0gIyMgSW1iYS5wZXJmb3JtYW5jZVxcbiAgQnVpbGQgeW91ciBhcHBsaWNhdGlvbiB2aWV3cyB1c2luZyBJbWJhJ3MgbmF0aXZlIHRhZ3MgZm9yIHVucHJlY2VkZW50ZWQgcGVyZm9ybWFuY2UuXFxuXCIpLmVuZCgpLFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdCh0Mi4kJGIgPSB0Mi4kJGIgfHwgdGFnJC4kZXhhbXBsZSgpLmZsYWcoJ2RhcmsnKS5zZXRIZWFkaW5nKFwiU2ltcGxlIHJlbWluZGVyc1wiKS5zZXRTcmMoJy9ob21lL2V4YW1wbGVzL3JlbWluZGVycy5pbWJhJykpLmVuZCgpLFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdCh0Mi4kJGMgPSB0Mi4kJGMgfHwgdGFnJC4kbWFya2VkKCkuZmxhZygnc2VjdGlvbicpLmZsYWcoJ21kJykpLnNldFRleHQoXCIjIyBSZXVzYWJsZSBjb21wb25lbnRzXFxuXFxuQSBjdXN0b20gdGFnIC8gY29tcG9uZW50IGNhbiBtYWludGFpbiBpbnRlcm5hbCBzdGF0ZSBhbmQgY29udHJvbCBob3cgdG8gcmVuZGVyIGl0c2VsZi5cXG5XaXRoIHRoZSBwZXJmb3JtYW5jZSBvZiBET00gcmVjb25jaWxpYXRpb24gaW4gSW1iYSwgeW91IGNhbiB1c2Ugb25lLXdheSBkZWNsYXJhdGl2ZSBiaW5kaW5nLFxcbmV2ZW4gZm9yIGFuaW1hdGlvbnMuIFdyaXRlIGFsbCB5b3VyIHZpZXdzIGluIGEgc3RyYWlnaHQtZm9yd2FyZCBsaW5lYXIgZmFzaGlvbiBhcyBpZiB5b3UgY291bGRcXG5yZXJlbmRlciB5b3VyIHdob2xlIGFwcGxpY2F0aW9uIG9uICoqZXZlcnkgc2luZ2xlKiogZGF0YS9zdGF0ZSBjaGFuZ2UuXCIpLmVuZCgpLFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdCh0Mi4kJGQgPSB0Mi4kJGQgfHwgdGFnJC4kZXhhbXBsZSgpLmZsYWcoJ2RhcmsnKS5zZXRIZWFkaW5nKFwiV29ybGQgY2xvY2tcIikuc2V0U3JjKCcvaG9tZS9leGFtcGxlcy9jbG9jay5pbWJhJykpLmVuZCgpLFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdCh0Mi4kJGUgPSB0Mi4kJGUgfHwgdGFnJC4kbWFya2VkKCkuZmxhZygnc2VjdGlvbicpLmZsYWcoJ21kJykpLnNldFRleHQoXCIjIyBFeHRlbmQgbmF0aXZlIHRhZ3NcXG5cXG5JbiBhZGRpdGlvbiB0byBkZWZpbmluZyBjdXN0b20gdGFncywgeW91IGNhbiBhbHNvIGV4dGVuZCBuYXRpdmUgdGFncywgb3IgaW5oZXJpdCBmcm9tIHRoZW0uXFxuQmluZGluZyB0byBkb20gZXZlbnRzIGlzIGFzIHNpbXBsZSBhcyBkZWZpbmluZyBtZXRob2RzIG9uIHlvdXIgdGFnczsgYWxsIGV2ZW50cyB3aWxsIGJlXFxuZWZmaWNpZW50bHkgZGVsZWdhdGVkIGFuZCBoYW5kbGVkIGJ5IEltYmEuIExldCdzIGRlZmluZSBhIHNpbXBsZSBza2V0Y2hwYWQuLi5cIikuZW5kKCksXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0KHQyLiQkZiA9IHQyLiQkZiB8fCB0YWckLiRleGFtcGxlKCkuZmxhZygnZGFyaycpLnNldEhlYWRpbmcoXCJDdXN0b20gY2FudmFzXCIpLnNldFNyYygnL2hvbWUvZXhhbXBsZXMvY2FudmFzLmltYmEnKSkuZW5kKCksXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0KHQzID0gdDIuJCRnPXQyLiQkZyB8fCB0YWckLiRmb290ZXIoKSkuc2V0Q29udGVudChcblx0XHRcdFx0XHRcdCh0NCA9IHQzLiQkYT10My4kJGEgfHwgdGFnJC4kbmF2KCkpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdFx0XHQodDQuJCRhID0gdDQuJCRhIHx8IHRhZyQuJGEoKS5mbGFnKCdidXR0b24nKS5mbGFnKCdodWdlJykuZmxhZygnbWFpbicpLnNldEhyZWYoJy9pbnN0YWxsJykpLnNldFRleHQoXCJJbnN0YWxsXCIpLmVuZCgpLFxuXHRcdFx0XHRcdFx0XHQodDQuJCRiID0gdDQuJCRiIHx8IHRhZyQuJGEoKS5mbGFnKCdidXR0b24nKS5mbGFnKCdodWdlJykuc2V0SHJlZignL2d1aWRlcycpKS5zZXRUZXh0KFwiTGVhcm4gbW9yZVwiKS5lbmQoKVxuXHRcdFx0XHRcdFx0XSwyKS5lbmQoKVxuXHRcdFx0XHRcdCwyKS5lbmQoKVxuXHRcdFx0XHRdLDIpLmVuZCgpXG5cdFx0XHRdLDIpLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0Ly8gZGVmIGF3YWtlblxuXHRcdC8vIFx0IyBhd2FrZW4gdGhlIHNuaXBwZXRzXG5cdFx0Ly8gXHRzY2hlZHVsZVxuXHRcdC8vIFx0Zm9yIGVsIGluICUoc25pcHBldClcblx0XHQvLyBcdFx0ZWxcblx0XHQvLyBcdHNlbGZcblx0XHRcblx0XHQvLyBkZWYgdGlja1xuXHRcdC8vIFx0bG9nICdob21lLnRpY2snXG5cdFx0Ly8gXHRzZWxmXG5cdFx0XG5cdFx0Ly8gZGVmIGFzc2VtYmxlXG5cdFx0Ly8gXHRyZXR1cm4gc2VsZiBpZiBJbWJhLmlzQ2xpZW50XG5cdFx0Ly8gXHRzdXBlclxuXHRcdC8vIFx0IyBmbGFnKCdzY29wZWQnLHJvdXRlci5zY29wZWQocm91dGUsc2VsZikpXG5cdFx0Ly8gXHQjIGZsYWcoJ3NlbGVjdGVkJyxyb3V0ZXIubWF0Y2gocm91dGUsc2VsZikpXG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy92aWV3cy9ob21lLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdHJlcXVpcmUoJy4vcGFnZScpO1xuXHRcblx0dmFyIERvYyA9IHJlcXVpcmUoJy4uL2FwcCcpLkRvYztcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdibG9nJywgJ3BhZ2UnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZG9jID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRpZiAodGhpcy5yb3V0ZXIoKS5zY29wZWQoJy9ibG9nJykpIHtcblx0XHRcdFx0cmV0dXJuIERvYy5nZXQodGhpcy5yb3V0ZXIoKS5wYXRoKCkpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubmF2ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDAsIHQxO1xuXHRcdFx0cmV0dXJuICh0MCA9IHRoaXMuX25hdj10aGlzLl9uYXYgfHwgdGFnJC4kbmF2bWVudSgpLnNldFJlZignbmF2Jyx0aGlzKSkuc2V0Q29udGVudChcblx0XHRcdFx0KHQxID0gdDAuJCRhPXQwLiQkYSB8fCB0YWckLiRkaXYoKS5mbGFnKCdjb250ZW50JykpLnNldENvbnRlbnQoXG5cdFx0XHRcdFx0KHQxLiQkYSA9IHQxLiQkYSB8fCB0YWckLiRoMSgpKS5zZXRUZXh0KFwiTm8gaXRlbXM/XCIpLmVuZCgpXG5cdFx0XHRcdCwyKS5lbmQoKVxuXHRcdFx0LDIpLmVuZCgpO1xuXHRcdH07XG5cdFx0dGFnLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDA7XG5cdFx0XHRyZXR1cm4gKHQwID0gdGhpcy5fYm9keT10aGlzLl9ib2R5IHx8IHRhZyQuJGRpdigpLnNldFJlZignYm9keScsdGhpcykuZmxhZygnbGlnaHQnKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdCh0aGlzLmRvYygpKSA/IChJbWJhLnN0YXRpYyhbXG5cdFx0XHRcdFx0KHQwLiQkYSA9IHQwLiQkYSB8fCB0YWckLiRoMSgpKS5zZXRUZXh0KFwiQmxvZ3Bvc3Q/XCIpLmVuZCgpLFxuXHRcdFx0XHRcdCh0MC4kJGIgPSB0MC4kJGIgfHwgdGFnJC4kYmxvZ3Bvc3QoKSkuc2V0T2JqZWN0KHRoaXMuZG9jKCkpLmVuZCgpXG5cdFx0XHRcdF0sMikpIDogdm9pZCgwKSxcblx0XHRcdFx0KHQwLiQkYyA9IHQwLiQkYyB8fCB0YWckLiRoNCgpKS5zZXRUZXh0KFwiTm8gcG9zdHNcIikuZW5kKClcblx0XHRcdF0sMSkuZW5kKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ2Jsb2dwb3N0JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIG9iamVjdF87XG5cdFx0XHRpZiAoIShvYmplY3RfID0gdGhpcy5vYmplY3QoKSkgJiYgb2JqZWN0Xy5yZWFkeSAgJiYgIG9iamVjdF8ucmVhZHkoKSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZygnbWQnKS5zZXRCb2R5KCh0aGlzLm9iamVjdCgpLmJvZHkoKSkpLnN5bmNlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRCb2R5ID0gZnVuY3Rpb24gKGJvZHkpe1xuXHRcdFx0aWYgKGJvZHkgIT0gdGhpcy5fYm9keSkge1xuXHRcdFx0XHR0aGlzLl9ib2R5ID0gYm9keTtcblx0XHRcdFx0dGhpcy5kb20oKS5pbm5lckhUTUwgPSBib2R5O1xuXHRcdFx0XHRpZiAoSW1iYS5pc0NsaWVudCgpKSB0aGlzLnJlYXdha2VuKCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlYXdha2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQocSQoJy5fc25pcHBldCcsdGhpcykpLCBsZW4gPSBhcnkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0YXJ5W2ldO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy92aWV3cy9ibG9nLmltYmFcbiAqKiBtb2R1bGUgaWQgPSA2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCl7XG5cdGZ1bmN0aW9uIGl0ZXIkKGEpeyByZXR1cm4gYSA/IChhLnRvQXJyYXkgPyBhLnRvQXJyYXkoKSA6IGEpIDogW107IH07XG5cdHJlcXVpcmUoJy4vcGFnZScpO1xuXHRcblx0ZnVuY3Rpb24gR3VpZGUocGF0aCl7XG5cdFx0dGhpcy5fcGF0aCA9IHBhdGg7XG5cdFx0dGhpcy5fcmVhZHkgPSBmYWxzZTtcblx0XHR0aGlzLmZldGNoKCk7XG5cdFx0dGhpcztcblx0fTtcblx0XG5cdHZhciBjYWNoZSA9IHt9O1xuXHRcblx0R3VpZGUuZ2V0ID0gZnVuY3Rpb24gKHBhdGgpe1xuXHRcdHZhciAkMTtcblx0XHR2YXIgY2FjaGUgPSBBUFAuY2FjaGUoKTtcblx0XHRyZXR1cm4gY2FjaGVbKCQxID0gJ2d1aWRlLScgKyBwYXRoKV0gfHwgKGNhY2hlWyQxXSA9IG5ldyB0aGlzKHBhdGgpKTtcblx0fTtcblx0XG5cdFxuXHRcblx0R3VpZGUucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3BhdGg7IH1cblx0R3VpZGUucHJvdG90eXBlLnNldFBhdGggPSBmdW5jdGlvbih2KXsgdGhpcy5fcGF0aCA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcblx0R3VpZGUucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX3JlYWR5O1xuXHR9O1xuXHRcblx0R3VpZGUucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGlmIChJbWJhLlNFUlZFUikge1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ2ZldGNoIEd1aWRlIG9uIHNlcnZlcicscGF0aFxuXHRcdFx0cmV0dXJuIEFQUC5mZXRjaERvY3VtZW50KHNlbGYuX3BhdGggKyAnLm1kJyxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cgJ2ZldGNoIEd1aWRlIG9uIHNlcnZlciBkb25lJyxwYXRoXG5cdFx0XHRcdHJldHVybiBzZWxmLmxvYWQocmVzKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHNlbGYuX3Byb21pc2UgfHwgKHNlbGYuX3Byb21pc2UgPSBBUFAuZmV0Y2hEb2N1bWVudChzZWxmLl9wYXRoICsgJy5tZCcsZnVuY3Rpb24ocmVzKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5sb2FkKHJlcyk7XG5cdFx0fSkpO1xuXHR9O1xuXHRcblx0R3VpZGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoZG9jKXtcblx0XHR0aGlzLl9vYmplY3QgPSBkb2M7XG5cdFx0dGhpcy5fbWV0YSA9IGRvYy5tZXRhIHx8IHt9O1xuXHRcdHRoaXMuX3JlYWR5ID0gdHJ1ZTtcblx0XHRJbWJhLmVtaXQodGhpcywncmVhZHknKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdEd1aWRlLnByb3RvdHlwZS50aXRsZSA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9vYmplY3QudGl0bGUgfHwgJ3BhdGgnO1xuXHR9O1xuXHRcblx0R3VpZGUucHJvdG90eXBlLnRvYyA9IGZ1bmN0aW9uICgpe1xuXHRcdHJldHVybiB0aGlzLl9vYmplY3QgJiYgdGhpcy5fb2JqZWN0LnRvY1swXTtcblx0fTtcblx0XG5cdEd1aWRlLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24gKCl7XG5cdFx0cmV0dXJuIHRoaXMuX29iamVjdCAmJiB0aGlzLl9vYmplY3QuYm9keTtcblx0fTtcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnZ3VpZGUtdG9jJywgJ3RvYycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50b2MgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3RvYzsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VG9jID0gZnVuY3Rpb24odil7IHRoaXMuX3RvYyA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubGV2ZWwgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdsZXZlbCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRMZXZlbCA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgnbGV2ZWwnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvdXRlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgncm91dGUnKTsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Um91dGUgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvdXRlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50b2MgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl90b2MgfHwgdGhpcy5vYmplY3QoKS50b2MoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucm91dGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiAoXCJcIiArICh0aGlzLm9iamVjdCgpLnBhdGgoKSkgKyBcIiNcIiArICh0aGlzLnRvYygpLnNsdWcpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy50b2dnbGVGbGFnKCdjb2xsYXBzZWQnKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDAsIHQxLCBzZWxmID0gdGhpcywgdDIsIHQzO1xuXHRcdFx0aWYgKCF0aGlzLm9iamVjdCgpLnJlYWR5KCkpIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcdFxuXHRcdFx0dGhpcy5yZXJvdXRlKCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmZsYWcoJ2VudHJ5Jykuc2V0TGV2ZWwoKHRoaXMudG9jKCkubGV2ZWwpKS5zZXRDaGlsZHJlbihbXG5cdFx0XHRcdHRoaXMudG9jKCkuY2hpbGRyZW4ubGVuZ3RoICYmIHRoaXMudG9jKCkubGV2ZWwgPCAyID8gKEltYmEuc3RhdGljKFtcblx0XHRcdFx0XHQodDAgPSB0aGlzLiRhPXRoaXMuJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygnaGVhZGVyJykuc2V0SGFuZGxlcigndGFwJywndG9nZ2xlJyx0aGlzKSkuc2V0Q29udGVudChcblx0XHRcdFx0XHRcdCh0MSA9IHQwLiQkYT10MC4kJGEgfHwgdGFnJC4kYSgpKS5zZXRIcmVmKHRoaXMucm91dGUoKSkuc2V0Q29udGVudCh0aGlzLnRvYygpLnRpdGxlLDMpLmVuZCgpXG5cdFx0XHRcdFx0LDIpLmVuZCgpLFxuXHRcdFx0XHRcdCh0MiA9IHNlbGYuJGI9c2VsZi4kYiB8fCB0YWckLiRkaXYoKS5mbGFnKCdjb250ZW50JykpLnNldENvbnRlbnQoXG5cdFx0XHRcdFx0XHQoZnVuY3Rpb24odDIpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYudG9jKCkuY2hpbGRyZW4pLCBsZW4gPSBhcnkubGVuZ3RoLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzLnB1c2goKHQyWyckJGEnICsgaV0gPSB0MlsnJCRhJyArIGldIHx8IHRhZyQuJGd1aWRlX3RvYygpKS5zZXRUb2MoYXJ5W2ldKS5zZXRPYmplY3Qoc2VsZi5vYmplY3QoKSkuZW5kKCkpO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHRcdFx0fSkodDIpXG5cdFx0XHRcdFx0LDMpLmVuZCgpXG5cdFx0XHRcdF0sMikpIDogKFxuXHRcdFx0XHRcdCh0MyA9IHNlbGYuJGM9c2VsZi4kYyB8fCB0YWckLiRhKCkpLnNldEhyZWYoc2VsZi5yb3V0ZSgpKS5zZXRDb250ZW50KHNlbGYudG9jKCkudGl0bGUsMykuZW5kKClcblx0XHRcdFx0KVxuXHRcdFx0XSwxKS5zeW5jZWQoKTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdFxuXHR0YWckLmRlZmluZVRhZygnZ3VpZGUnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgb2JqZWN0Xztcblx0XHRcdGlmICghKG9iamVjdF8gPSB0aGlzLm9iamVjdCgpKSAmJiBvYmplY3RfLnJlYWR5ICAmJiAgb2JqZWN0Xy5yZWFkeSgpKSB7IHJldHVybiB0aGlzIH07XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGFnKCdtZCcpLnNldEJvZHkoKHRoaXMub2JqZWN0KCkuYm9keSgpKSkuc3luY2VkKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldEJvZHkgPSBmdW5jdGlvbiAoYm9keSl7XG5cdFx0XHRpZiAoYm9keSAhPSB0aGlzLl9ib2R5KSB7XG5cdFx0XHRcdHRoaXMuX2JvZHkgPSBib2R5O1xuXHRcdFx0XHR0aGlzLmRvbSgpLmlubmVySFRNTCA9IGJvZHk7XG5cdFx0XHRcdGlmIChJbWJhLmlzQ2xpZW50KCkpIHRoaXMucmVhd2FrZW4oKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVhd2FrZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChxJCgnLl9zbmlwcGV0Jyx0aGlzKSksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRhcnlbaV07XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0cmV0dXJuIHRhZyQuZGVmaW5lVGFnKCdndWlkZXMnLCAncGFnZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5uYXYgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MCwgdDE7XG5cdFx0XHRyZXR1cm4gKHQwID0gdGhpcy5fbmF2PXRoaXMuX25hdiB8fCB0YWckLiRuYXZtZW51KCkuc2V0UmVmKCduYXYnLHRoaXMpKS5zZXRDb250ZW50KFxuXHRcdFx0XHQodDEgPSB0MC4kJGE9dDAuJCRhIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2NvbnRlbnQnKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0KHQxLiQkYSA9IHQxLiQkYSB8fCB0YWckLiRndWlkZV90b2MoKSkuc2V0T2JqZWN0KEd1aWRlLmdldCgnL2d1aWRlcycpKS5lbmQoKSxcblx0XHRcdFx0XHQodDEuJCRiID0gdDEuJCRiIHx8IHRhZyQuJGd1aWRlX3RvYygpKS5zZXRPYmplY3QoR3VpZGUuZ2V0KCcvZ3VpZGVzL2xhbmd1YWdlJykpLmVuZCgpXG5cdFx0XHRcdC8vIDxndWlkZS10b2NbR3VpZGUuZ2V0KCcvZ3VpZGVzL3RpcHMnKV0+XG5cdFx0XHRcdF0sMikuZW5kKClcblx0XHRcdCwyKS5lbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYm9keSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwO1xuXHRcdFx0cmV0dXJuICh0MCA9IHRoaXMuX2JvZHk9dGhpcy5fYm9keSB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ2JvZHknLHRoaXMpLmZsYWcoJ2xpZ2h0JykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHQodGhpcy5ndWlkZSgpKSA/ICgodDAuJCRhID0gdDAuJCRhIHx8IHRhZyQuJGd1aWRlKCkpLnNldE9iamVjdCh0aGlzLmd1aWRlKCkpLmVuZCgpKSA6IHZvaWQoMClcblx0XHRcdC8vIDxndWlkZUBkb2MubWQubCBzcmM9XCJ7cm91dGVyLnBhdGh9XCI+XG5cdFx0XHRdLDEpLmVuZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnJvdXRlID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0Ly8gbG9nICdvbnJvdXRlIGd1aWRlcycscm91dGVyLmhhc2hcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGUuaGFsdCgpO1xuXHRcdFx0XG5cdFx0XHR2YXIgc2Nyb2xsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbDtcblx0XHRcdFx0aWYgKGVsID0gc2VsZi5maXJzdCgnIycgKyBzZWxmLnJvdXRlcigpLmhhc2goKSkpIHtcblx0XHRcdFx0XHRlbC5kb20oKS5zY3JvbGxJbnRvVmlldyh0cnVlKTtcblx0XHRcdFx0XHRzZWxmLl9zY3JvbGxGcmVlemUgPSB3aW5kb3cuc2Nyb2xsWTtcblx0XHRcdFx0XHRyZXR1cm4gZWw7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChzZWxmLnJvdXRlcigpLmhhc2goKSkge1xuXHRcdFx0XHRzZWxmLnJlbmRlcigpO1xuXHRcdFx0XHRzY3JvbGwoKSB8fCBzZXRUaW1lb3V0KHNjcm9sbCwyMCxmdW5jdGlvbigpIHsgIH0pO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZ3VpZGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGlmICh0aGlzLnJvdXRlcigpLnNjb3BlZCgnL2d1aWRlcycpKSB7XG5cdFx0XHRcdHJldHVybiBHdWlkZS5nZXQodGhpcy5yb3V0ZXIoKS5wYXRoKCkpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXdha2VuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRpZiAoSW1iYS5pc0NsaWVudCgpKSB7XG5cdFx0XHRcdC8vIEBkb2MgPSAlJShndWlkZSlcblx0XHRcdFx0c2VsZi5zY2hlZHVsZSh7ZnBzOiAxfSk7XG5cdFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nICdjaGVjayBzY3JvbGxpbmcnXG5cdFx0XHRcdFx0cmV0dXJuIHNlbGYuc2Nyb2xsZWQoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNjcm9sbGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRpZiAoIXRoaXMuaGFzRmxhZygnc2NvcGVkJykpIHsgcmV0dXJuIH07XG5cdFx0XHRcblx0XHRcdHZhciBpdGVtcyA9IHEkKCdbaWRdJyx0aGlzKTtcblx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFxuXHRcdFx0Ly8gc2hvdWxkIHByb2JhYmx5IGNhY2hlIHRoZXNlIHBlcmlvZGljYWxseVxuXHRcdFx0dmFyIHNjcm9sbFRvcCA9IHdpbmRvdy5zY3JvbGxZO1xuXHRcdFx0dmFyIHdoID0gd2luZG93LmlubmVySGVpZ2h0O1xuXHRcdFx0dmFyIGRoID0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQ7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLl9zY3JvbGxGcmVlemUgPj0gMCkge1xuXHRcdFx0XHR2YXIgZGlmZiA9IE1hdGguYWJzKHNjcm9sbFRvcCAtIHRoaXMuX3Njcm9sbEZyZWV6ZSk7XG5cdFx0XHRcdGlmIChkaWZmIDwgNTApIHsgcmV0dXJuIHRoaXMgfTtcblx0XHRcdFx0dGhpcy5fc2Nyb2xsRnJlZXplID0gLTE7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR2YXIgc2Nyb2xsQm90dG9tID0gZGggLSAoc2Nyb2xsVG9wICsgd2gpO1xuXHRcdFx0XG5cdFx0XHQvLyBjb25zb2xlLmxvZyBzY3JvbGxUb3Asd2gsZGgsc2Nyb2xsQm90dG9tXG5cdFx0XHRcblx0XHRcdGlmIChzY3JvbGxCb3R0b20gPT0gMCkge1xuXHRcdFx0XHRtYXRjaCA9IGl0ZW1zLmxhc3QoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChpdGVtcyksIGxlbiA9IGFyeS5sZW5ndGgsIGl0ZW07IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdGl0ZW0gPSBhcnlbaV07XG5cdFx0XHRcdFx0dmFyIHQgPSAoaXRlbS5kb20oKS5vZmZzZXRUb3AgKyAzMCArIDYwKTsgLy8gaGFja1xuXHRcdFx0XHRcdHZhciBkaXN0ID0gc2Nyb2xsVG9wIC0gdDtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyBcIntpdGVtLmlkfSB7dH0ge2Rpc3R9XCJcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoZGlzdCA8IDApIHtcblx0XHRcdFx0XHRcdG1hdGNoID0gaXRlbTticmVhaztcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nIFwibWF0Y2ggaXMge21hdGNoLmlkfVwiXG5cdFx0XHRcdGlmICh0aGlzLl9oYXNoICE9IG1hdGNoLmlkKCkpIHtcblx0XHRcdFx0XHR0aGlzLl9oYXNoID0gbWF0Y2guaWQoKTtcblx0XHRcdFx0XHR0aGlzLnJvdXRlcigpLmdvKCcjJyArIHRoaXMuX2hhc2gse30sdHJ1ZSk7XG5cdFx0XHRcdFx0dGhpcy5yZW5kZXIoKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5yZW5kZXIoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXG59KSgpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy92aWV3cy9ndWlkZXMuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0ZnVuY3Rpb24gcGF0aFRvQW5jaG9yKHBhdGgpe1xuXHRcdHJldHVybiAnYXBpLScgKyBwYXRoLnJlcGxhY2UoL1xcLi9nLCdfJykucmVwbGFjZSgvXFwjL2csJ19fJyk7XG5cdH07XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYXBpLWRlc2MnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2V0SHRtbCA9IGZ1bmN0aW9uIChodG1sKXtcblx0XHRcdGlmIChodG1sICE9IHRoaXMuX2h0bWwpIHtcblx0XHRcdFx0dGhpcy5kb20oKS5pbm5lckhUTUwgPSB0aGlzLl9odG1sID0gaHRtbDtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdhcGktcmVmJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYXBpLWl0ZW0nKTtcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdhcGktcGF0aCcsICdzcGFuJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgb2JqZWN0Xztcblx0XHRcdHZhciBpdGVtcyA9IFtdO1xuXHRcdFx0aWYgKCh0eXBlb2YgKG9iamVjdF8gPSB0aGlzLm9iamVjdCgpKT09J3N0cmluZyd8fG9iamVjdF8gaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG5cdFx0XHRcdHRoaXMuc2V0SHRtbCh0aGlzLm9iamVjdCgpLnJlcGxhY2UoL1xcYihbXFx3XSt8XFwufFxcIylcXGIvZyxmdW5jdGlvbihtLGkpIHtcblx0XHRcdFx0XHRpZiAoaSA9PSAnLicgfHwgaSA9PSAnIycpIHtcblx0XHRcdFx0XHRcdHJldHVybiAoXCI8aT5cIiArIGkgKyBcIjwvaT5cIik7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpWzBdID09IGlbMF0udG9VcHBlckNhc2UoKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIChcIjxiIGNsYXNzPSdjb25zdCc+XCIgKyBpICsgXCI8L2I+XCIpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gKFwiPGIgY2xhc3M9J2lkJz5cIiArIGkgKyBcIjwvYj5cIik7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSkpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdHRhZyQuZGVmaW5lVGFnKCdhcGktbGluaycsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbmFtZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCduYW1lJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MDtcblx0XHRcdHJldHVybiB0aGlzLnNldENoaWxkcmVuKFtcblx0XHRcdFx0KHRoaXMuJGEgPSB0aGlzLiRhIHx8IHRhZyQuJGFwaV9wYXRoKCkuZmxhZygndmFsdWUnKSkuc2V0T2JqZWN0KHRoaXMub2JqZWN0KCkudmFsdWUpLmVuZCgpLFxuXHRcdFx0XHQodDAgPSB0aGlzLiRiPXRoaXMuJGIgfHwgdGFnJC4kc3BhbigpLmZsYWcoJ2Rlc2MnKSkuc2V0Q29udGVudCh0aGlzLm9iamVjdCgpLmRlc2MsMykuZW5kKClcblx0XHRcdF0sMikuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnYXBpLXJldHVybicsICdhcGktbGluaycpO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2FwaS1jbGFzcycsICdhcGktaXRlbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX29iamVjdCA9IHt3YXRjaDogJ3BhcnNlJyxuYW1lOiAnb2JqZWN0J307XG5cdFx0dGFnLnByb3RvdHlwZS5vYmplY3QgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX29iamVjdDsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0T2JqZWN0ID0gZnVuY3Rpb24odil7XG5cdFx0XHR2YXIgYSA9IHRoaXMub2JqZWN0KCk7XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5fb2JqZWN0ID0gdjsgfVxuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMucGFyc2UgJiYgdGhpcy5wYXJzZSh2LGEsdGhpcy5fX29iamVjdCkgfVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy5vYmplY3QoKVsnLiddKSwgbGVuID0gYXJ5Lmxlbmd0aCwgbSwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRtID0gYXJ5W2ldO1xuXHRcdFx0XHRpZiAoIW0uZGVzYykgeyBjb250aW51ZTsgfTtcblx0XHRcdFx0cmVzLnB1c2gobSk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5fc3RhdGljcyA9IHJlcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJCh0aGlzLm9iamVjdCgpWycjJ10pLCBsZW4gPSBhcnkubGVuZ3RoLCBtMSwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRtMSA9IGFyeVtpXTtcblx0XHRcdFx0aWYgKCFtMS5kZXNjKSB7IGNvbnRpbnVlOyB9O1xuXHRcdFx0XHRyZXMucHVzaChtMSk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5fbWV0aG9kcyA9IHJlcztcblx0XHRcdHRoaXMuX3Byb3BlcnRpZXMgPSBbXTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciB0MCwgdDEsIHQyLCB0MywgdDQsIHNlbGYgPSB0aGlzLCB0NSwgdDYsIHQ3O1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Q2hpbGRyZW4oW1xuXHRcdFx0XHQodGhpcy4kYSA9IHRoaXMuJGEgfHwgdGFnJC4kc3BhbigpLmZsYWcoJ3RvYy1hbmNob3InKSkuc2V0SWQocGF0aFRvQW5jaG9yKHRoaXMub2JqZWN0KCkubmFtZXBhdGgpKS5lbmQoKSxcblx0XHRcdFx0KHQwID0gdGhpcy4kYj10aGlzLiRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2hlYWRlcicpKS5zZXRDb250ZW50KCh0MSA9IHQwLiQkYT10MC4kJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygndGl0bGUnKSkuc2V0Q29udGVudCgodDEuJCRhID0gdDEuJCRhIHx8IHRhZyQuJGFwaV9wYXRoKCkpLnNldE9iamVjdCh0aGlzLm9iamVjdCgpLm5hbWVwYXRoKS5lbmQoKSwyKS5lbmQoKSwyKS5lbmQoKSxcblx0XHRcdFx0KHRoaXMuJGMgPSB0aGlzLiRjIHx8IHRhZyQuJGFwaV9kZXNjKCkpLnNldEh0bWwodGhpcy5vYmplY3QoKS5odG1sKS5lbmQoKSxcblx0XHRcdFx0KHRoaXMub2JqZWN0KCkuY3RvcikgPyAoXG5cdFx0XHRcdFx0KHQyID0gdGhpcy4kZD10aGlzLiRkIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2NvbnRlbnQnKS5mbGFnKCdjdG9yJykpLnNldENvbnRlbnQoXG5cdFx0XHRcdFx0XHQodDIuJCRhID0gdDIuJCRhIHx8IHRhZyQuJGFwaV9tZXRob2QoKSkuc2V0UGF0aCgodGhpcy5vYmplY3QoKS5uYW1lcGF0aCArICcubmV3JykpLnNldE9iamVjdCh0aGlzLm9iamVjdCgpLmN0b3IpLmVuZCgpXG5cdFx0XHRcdFx0LDIpLmVuZCgpXG5cdFx0XHRcdCkgOiB2b2lkKDApLFxuXHRcdFx0XHRcblx0XHRcdFx0KHQzID0gc2VsZi4kZT1zZWxmLiRlIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2NvbnRlbnQnKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0KHRoaXMuX3N0YXRpY3MubGVuZ3RoID4gMCkgPyAoXG5cdFx0XHRcdFx0XHQodDQgPSB0My4kJGE9dDMuJCRhIHx8IHRhZyQuJGRpdigpLmZsYWcoJ3NlY3Rpb24nKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0XHRcdCh0NC4kJGEgPSB0NC4kJGEgfHwgdGFnJC4kaDIoKS5mbGFnKCdoZWFkZXInKSkuc2V0VGV4dCgnU3RhdGljIE1ldGhvZHMnKS5lbmQoKSxcblx0XHRcdFx0XHRcdFx0KHQ1ID0gdDQuJCRiPXQ0LiQkYiB8fCB0YWckLiRkaXYoKS5mbGFnKCdjb250ZW50JykuZmxhZygnbGlzdCcpKS5zZXRDb250ZW50KChmdW5jdGlvbih0NSkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChzZWxmLl9zdGF0aWNzKSwgbGVuID0gYXJ5Lmxlbmd0aCwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzLnB1c2goKHQ1WyckJGEnICsgaV0gPSB0NVsnJCRhJyArIGldIHx8IHRhZyQuJGFwaV9tZXRob2QoKS5mbGFnKCdkb2MnKSkuc2V0SW5hbWUoc2VsZi5vYmplY3QoKS5uYW1lcGF0aCkuc2V0T2JqZWN0KGFyeVtpXSkuZW5kKCkpO1xuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0XHRcdFx0fSkodDUpLDMpLmVuZCgpXG5cdFx0XHRcdFx0XHRdLDIpLmVuZCgpXG5cdFx0XHRcdFx0KSA6IHZvaWQoMCksXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0KHNlbGYuX21ldGhvZHMubGVuZ3RoID4gMCkgPyAoXG5cdFx0XHRcdFx0XHQodDYgPSB0My4kJGI9dDMuJCRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ3NlY3Rpb24nKSkuc2V0Q29udGVudChbXG5cdFx0XHRcdFx0XHRcdCh0Ni4kJGEgPSB0Ni4kJGEgfHwgdGFnJC4kaDIoKS5mbGFnKCdoZWFkZXInKSkuc2V0VGV4dCgnSW5zdGFuY2UgTWV0aG9kcycpLmVuZCgpLFxuXHRcdFx0XHRcdFx0XHQodDcgPSB0Ni4kJGI9dDYuJCRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2NvbnRlbnQnKS5mbGFnKCdsaXN0JykpLnNldENvbnRlbnQoKGZ1bmN0aW9uKHQ3KSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGFyeSA9IGl0ZXIkKHNlbGYuX21ldGhvZHMpLCBsZW4gPSBhcnkubGVuZ3RoLCByZXMgPSBbXTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXMucHVzaCgodDdbJyQkYScgKyBpXSA9IHQ3WyckJGEnICsgaV0gfHwgdGFnJC4kYXBpX21ldGhvZCgpLmZsYWcoJ2RvYycpKS5zZXRJbmFtZShzZWxmLm9iamVjdCgpLmluYW1lKS5zZXRPYmplY3QoYXJ5W2ldKS5lbmQoKSk7XG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHRcdFx0XHR9KSh0NyksMykuZW5kKClcblx0XHRcdFx0XHRcdF0sMikuZW5kKClcblx0XHRcdFx0XHQpIDogdm9pZCgwKVxuXHRcdFx0XHRdLDEpLmVuZCgpXG5cdFx0XHRdLDEpLnN5bmNlZCgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2FwaS12YWx1ZScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBvYmplY3RfLCAkMTtcblx0XHRcdGlmICh0aGlzLm9iamVjdCgpLnR5cGUpIHtcblx0XHRcdFx0dGhpcy5mbGFnKHRoaXMub2JqZWN0KCkudHlwZSkuc2V0Q2hpbGRyZW4oXG5cdFx0XHRcdFx0dGhpcy5vYmplY3QoKS52YWx1ZVxuXHRcdFx0XHQsMykuc3luY2VkKCk7XG5cdFx0XHR9IGVsc2UgaWYgKCh0eXBlb2YgKG9iamVjdF8gPSB0aGlzLm9iamVjdCgpKT09J3N0cmluZyd8fG9iamVjdF8gaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG5cdFx0XHRcdHRoaXMuZmxhZygnc3RyJykuc2V0VGV4dCh0aGlzLm9iamVjdCgpKS5zeW5jZWQoKTtcblx0XHRcdH0gZWxzZSBpZiAoKHR5cGVvZiAoJDEgPSB0aGlzLm9iamVjdCgpKT09J251bWJlcid8fCQxIGluc3RhbmNlb2YgTnVtYmVyKSkge1xuXHRcdFx0XHR0aGlzLmZsYWcoJ251bScpLnNldFRleHQodGhpcy5vYmplY3QoKSkuc3luY2VkKCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2FwaS1wYXJhbScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5vYmplY3QoKS50eXBlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcywgdDAsIHQxO1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhZyhzZWxmLnR5cGUoKSkuc2V0Q2hpbGRyZW4oW1xuXHRcdFx0XHRzZWxmLnR5cGUoKSA9PSAnTmFtZWRQYXJhbXMnID8gKFxuXHRcdFx0XHRcdChmdW5jdGlvbihzZWxmKSB7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoc2VsZi5vYmplY3QoKS5ub2RlcyksIGxlbiA9IGFyeS5sZW5ndGgsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0cmVzLnB1c2goKHNlbGZbJyRhJyArIGldID0gc2VsZlsnJGEnICsgaV0gfHwgdGFnJC4kYXBpX3BhcmFtKCkpLnNldE9iamVjdChhcnlbaV0pLmVuZCgpKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHRcdH0pKHNlbGYpXG5cdFx0XHRcdCkgOiAoSW1iYS5zdGF0aWMoW1xuXHRcdFx0XHRcdCh0MCA9IHNlbGYuJGI9c2VsZi4kYiB8fCB0YWckLiRkaXYoKS5mbGFnKCduYW1lJykpLnNldENvbnRlbnQoc2VsZi5vYmplY3QoKS5uYW1lLDMpLmVuZCgpLFxuXHRcdFx0XHRcdChzZWxmLm9iamVjdCgpLmRlZmF1bHRzKSA/IChJbWJhLnN0YXRpYyhbXG5cdFx0XHRcdFx0XHQodDEgPSBzZWxmLiRjPXNlbGYuJGMgfHwgdGFnJC4kaSgpKS5zZXRDb250ZW50KFtzZWxmLnR5cGUoKSA9PSAnTmFtZWRQYXJhbScgPyAoJzogJykgOiAoJyA9ICcpXSwxKS5lbmQoKSxcblx0XHRcdFx0XHRcdChzZWxmLiRkID0gc2VsZi4kZCB8fCB0YWckLiRhcGlfdmFsdWUoKSkuc2V0T2JqZWN0KHNlbGYub2JqZWN0KCkuZGVmYXVsdHMpLmVuZCgpXG5cdFx0XHRcdFx0XSwyKSkgOiB2b2lkKDApXG5cdFx0XHRcdF0sMykpXG5cdFx0XHRdLDEpLnN5bmNlZCgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2FwaS1tZXRob2QnLCAnYXBpLWl0ZW0nLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuaW5hbWUgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX2luYW1lOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRJbmFtZSA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9pbmFtZSA9IHY7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fcGF0aDsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0UGF0aCA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9wYXRoID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50YWdzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDA7XG5cdFx0XHRyZXR1cm4gKHQwID0gdGhpcy5fdGFncz10aGlzLl90YWdzIHx8IHRhZyQuJGRpdigpLnNldFJlZigndGFncycsdGhpcykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHQodGhpcy5vYmplY3QoKS5kZXByZWNhdGVkKSA/IChcblx0XHRcdFx0XHQodDAuJCRhID0gdDAuJCRhIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2RlcHJlY2F0ZWQnKS5mbGFnKCdyZWQnKSkuc2V0VGV4dCgnTWV0aG9kIGlzIGRlcHJlY2F0ZWQnKS5lbmQoKVxuXHRcdFx0XHQpIDogdm9pZCgwKSxcblx0XHRcdFx0KHRoaXMub2JqZWN0KCkucmV0dXJuKSA/ICgodDAuJCRiID0gdDAuJCRiIHx8IHRhZyQuJGFwaV9yZXR1cm4oKS5zZXROYW1lKCdyZXR1cm5zJykpLnNldE9iamVjdCh0aGlzLm9iamVjdCgpLnJldHVybikuZW5kKCkpIDogdm9pZCgwKVxuXHRcdFx0XSwxKS5lbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuX3BhdGggfHwgKHRoaXMuaW5hbWUoKSArICcuJyArIHRoaXMub2JqZWN0KCkubmFtZSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNsdWcgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiBwYXRoVG9BbmNob3IodGhpcy5vYmplY3QoKS5uYW1lcGF0aCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwLCBzZWxmID0gdGhpcywgdDE7XG5cdFx0XHRyZXR1cm4gdGhpcy5mbGFnKCdkZXByZWNhdGVkJyx0aGlzLm9iamVjdCgpLmRlcHJlY2F0ZWQpLnNldENoaWxkcmVuKFtcblx0XHRcdFx0KHRoaXMuJGEgPSB0aGlzLiRhIHx8IHRhZyQuJHNwYW4oKS5mbGFnKCd0b2MtYW5jaG9yJykpLnNldElkKHRoaXMuc2x1ZygpKS5lbmQoKSxcblx0XHRcdFx0KHQwID0gc2VsZi4kYj1zZWxmLiRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2hlYWRlcicpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHQodDAuJCRhID0gdDAuJCRhIHx8IHRhZyQuJGFwaV9wYXRoKCkpLnNldE9iamVjdCh0aGlzLnBhdGgoKSkuZW5kKCksXG5cdFx0XHRcdFx0KHQxID0gdDAuJCRiPXQwLiQkYiB8fCB0YWckLiRkaXYoKS5mbGFnKCdwYXJhbXMnKSkuc2V0Q29udGVudCgoZnVuY3Rpb24odDEpIHtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBhcnkgPSBpdGVyJChzZWxmLm9iamVjdCgpLnBhcmFtcyksIGxlbiA9IGFyeS5sZW5ndGgsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0cmVzLnB1c2goKHQxWyckJGEnICsgaV0gPSB0MVsnJCRhJyArIGldIHx8IHRhZyQuJGFwaV9wYXJhbSgpKS5zZXRPYmplY3QoYXJ5W2ldKS5lbmQoKSk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0XHR9KSh0MSksMykuZW5kKCksXG5cdFx0XHRcdFx0KHQwLiQkYyA9IHQwLiQkYyB8fCB0YWckLiRkaXYoKS5mbGFnKCdncm93JykpLmVuZCgpXG5cdFx0XHRcdF0sMikuZW5kKCksXG5cdFx0XHRcdChzZWxmLiRjID0gc2VsZi4kYyB8fCB0YWckLiRhcGlfZGVzYygpLmZsYWcoJ21kJykpLnNldEh0bWwoc2VsZi5vYmplY3QoKS5odG1sKS5lbmQoKSxcblx0XHRcdFx0c2VsZi50YWdzKClcblx0XHRcdF0sMSkuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnZG9jLWxpbmsnLCAnYScsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMuc2V0SHJlZigoXCIvZG9jcyNcIiArIHBhdGhUb0FuY2hvcih0aGlzLm9iamVjdCgpLm5hbWVwYXRoKSkpLnNldENoaWxkcmVuKCh0aGlzLiRhID0gdGhpcy4kYSB8fCB0YWckLiRhcGlfcGF0aCgpKS5zZXRPYmplY3QodGhpcy5vYmplY3QoKS5uYW1lcGF0aCkuZW5kKCksMikuc3luY2VkKCk7XG5cdFx0XHRyZXR1cm4gdGFnLl9fc3VwZXJfXy5yZW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbnRhcCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGFnLl9fc3VwZXJfXy5vbnRhcC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gdGhpcy51cChxJCgnLl9kb2NzJyx0aGlzKSkucmVmb2N1cygpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2RvYy1ncm91cCcsICd0b2MnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub250YXAgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLnRvZ2dsZUZsYWcoJ2NvbGxhcHNlZCcpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdHJldHVybiB0YWckLmRlZmluZVRhZygnZG9jcycsICdwYWdlJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLl9fdmVyc2lvbiA9IHsnZGVmYXVsdCc6ICcwLjE0LjEnLG5hbWU6ICd2ZXJzaW9uJ307XG5cdFx0dGFnLnByb3RvdHlwZS52ZXJzaW9uID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92ZXJzaW9uOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWZXJzaW9uID0gZnVuY3Rpb24odil7IHRoaXMuX3ZlcnNpb24gPSB2OyByZXR1cm4gdGhpczsgfVxuXHRcdHRhZy5wcm90b3R5cGUuX3ZlcnNpb24gPSAnMC4xNC4xJztcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvb3RzID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9yb290czsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Um9vdHMgPSBmdW5jdGlvbih2KXsgdGhpcy5fcm9vdHMgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNyYyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIChcIi9hcGkvXCIgKyB0aGlzLnZlcnNpb24oKSArIFwiLmpzb25cIik7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmRvY3MgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl9kb2NzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hd2FrZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHRoaXMubG9hZCgpO1xuXHRcdFx0dGhpcy5zY2hlZHVsZSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmxvYWQoKTtcblx0XHRcdHJldHVybiB0YWcuX19zdXBlcl9fLmJ1aWxkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0aWYgKEltYmEuU0VSVkVSKSB7XG5cdFx0XHRcdC8vIHJldHVybiBzZWxmXG5cdFx0XHRcdEFQUC5mZXRjaERvY3VtZW50KHNlbGYuc3JjKCksZnVuY3Rpb24ocmVzKSB7XG5cdFx0XHRcdFx0c2VsZi5fZG9jcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzKSk7XG5cdFx0XHRcdFx0cmV0dXJuIHNlbGYuZ2VuZXJhdGUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBzZWxmO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHNlbGYuX3JlcXVlc3QgfHwgKHNlbGYuX3JlcXVlc3QgPSBBUFAuZmV0Y2hEb2N1bWVudChzZWxmLnNyYygpLGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0XHRET0NTID0gc2VsZi5fZG9jcyA9IHJlcztcblx0XHRcdFx0RE9DTUFQID0gc2VsZi5fZG9jcy5lbnRpdGllcztcblx0XHRcdFx0c2VsZi5nZW5lcmF0ZSgpO1xuXHRcdFx0XHRyZXR1cm4gc2VsZi5sb2FkZWQoKTtcblx0XHRcdH0pKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgZWw7XG5cdFx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdFx0Ly8gcmVhbGx5P1xuXHRcdFx0aWYgKGRvY3VtZW50LmxvY2F0aW9uLmhhc2gpIHtcblx0XHRcdFx0aWYgKGVsID0gdGhpcy5maXJzdChkb2N1bWVudC5sb2NhdGlvbi5oYXNoKSkge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nICdzaG91bGQgc2Nyb2xsIGhlcmU/IT8hPyEnLGVsXG5cdFx0XHRcdFx0ZWwuZG9tKCkuc2Nyb2xsSW50b1ZpZXcoKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVmb2N1cyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIGVsO1xuXHRcdFx0aWYgKGVsID0gdGhpcy5maXJzdChkb2N1bWVudC5sb2NhdGlvbi5oYXNoKSkge1xuXHRcdFx0XHRlbC5kb20oKS5zY3JvbGxJbnRvVmlldygpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbiAocGF0aCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb2NzKCkuZW50aXRpZXNbcGF0aF07XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLl9yb290cyA9IFtdO1xuXHRcdFx0dmFyIGVudHMgPSB0aGlzLl9kb2NzLmVudGl0aWVzO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBvID0gdGhpcy5kb2NzKCkuZW50aXRpZXMsIGl0ZW0sIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMobyksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdGl0ZW0gPSBvW2tleXNbaV1dO2lmIChpdGVtLnR5cGUgPT0gJ2NsYXNzJyB8fCBrZXlzW2ldID09ICdJbWJhJykge1xuXHRcdFx0XHRcdGl0ZW1bJy4nXSA9IChpdGVtWycuJ10gfHwgW10pLnNvcnQoKS5tYXAoZnVuY3Rpb24ocGF0aCkgeyByZXR1cm4gZW50c1twYXRoXTsgfSkuZmlsdGVyKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYudHlwZSA9PSAnbWV0aG9kJyAmJiB2LmRlc2M7IH0pO1xuXHRcdFx0XHRcdGl0ZW1bJyMnXSA9IChpdGVtWycjJ10gfHwgW10pLnNvcnQoKS5tYXAoZnVuY3Rpb24ocGF0aCkgeyByZXR1cm4gZW50c1twYXRoXTsgfSkuZmlsdGVyKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYudHlwZSA9PSAnbWV0aG9kJyAmJiB2LmRlc2M7IH0pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChpdGVtLmRlc2MpIHsgdGhpcy5fcm9vdHMucHVzaChpdGVtKSB9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGlmICghKHRoaXMuZG9jcygpKSkgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0cmV0dXJuIHRhZy5fX3N1cGVyX18ucmVuZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYm9keSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCB0MDtcblx0XHRcdHJldHVybiAodDAgPSBzZWxmLl9ib2R5PXNlbGYuX2JvZHkgfHwgdGFnJC4kZGl2KCkuc2V0UmVmKCdib2R5Jyx0aGlzKS5mbGFnKCdsaWdodCcpKS5zZXRDb250ZW50KFxuXHRcdFx0XHQoZnVuY3Rpb24odDApIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoc2VsZi5yb290cygpKSwgbGVuID0gYXJ5Lmxlbmd0aCwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0cmVzLnB1c2goKHQwWyckJGEnICsgaV0gPSB0MFsnJCRhJyArIGldIHx8IHRhZyQuJGFwaV9jbGFzcygpLmZsYWcoJ2RvYycpLmZsYWcoJ2wnKSkuc2V0T2JqZWN0KGFyeVtpXSkuZW5kKCkpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0fSkodDApXG5cdFx0XHQsMykuZW5kKCk7XG5cdFx0fTtcblx0XHR0YWcucHJvdG90eXBlLm5hdiA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIHQwLCBzZWxmID0gdGhpcywgdDE7XG5cdFx0XHRyZXR1cm4gKHQwID0gc2VsZi5fbmF2PXNlbGYuX25hdiB8fCB0YWckLiRuYXZtZW51KCkuc2V0UmVmKCduYXYnLHRoaXMpKS5zZXRDb250ZW50KFxuXHRcdFx0XHQodDEgPSB0MC4kJGE9dDAuJCRhIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2NvbnRlbnQnKSkuc2V0Q29udGVudChcblx0XHRcdFx0XHQoZnVuY3Rpb24odDEpIHtcblx0XHRcdFx0XHRcdHZhciB0MiwgdDMsIHQ0LCB0NSwgdDY7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQoc2VsZi5yb290cygpKSwgbGVuID0gYXJ5Lmxlbmd0aCwgcm9vdCwgcmVzID0gW107IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0XHRyb290ID0gYXJ5W2ldO1xuXHRcdFx0XHRcdFx0XHRyZXMucHVzaCgodDIgPSB0MVsnJCRhJyArIGldPXQxWyckJGEnICsgaV0gfHwgdGFnJC4kZG9jX2dyb3VwKCkuZmxhZygnY2xhc3MnKS5mbGFnKCdzZWN0aW9uJykuZmxhZygnY29tcGFjdCcpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHRcdFx0XHQodDMgPSB0Mi4kJGE9dDIuJCRhIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2hlYWRlcicpKS5zZXRDb250ZW50KCh0My4kJGEgPSB0My4kJGEgfHwgdGFnJC4kZG9jX2xpbmsoKS5mbGFnKCdjbGFzcycpKS5zZXRPYmplY3Qocm9vdCkuZW5kKCksMikuZW5kKCksXG5cdFx0XHRcdFx0XHRcdFx0KHQ0ID0gdDIuJCRiPXQyLiQkYiB8fCB0YWckLiRkaXYoKS5mbGFnKCdjb250ZW50JykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdFx0XHRcdFx0KHQ1ID0gdDQuJCRhPXQ0LiQkYSB8fCB0YWckLiRkaXYoKS5mbGFnKCdzdGF0aWMnKSkuc2V0Q29udGVudChcblx0XHRcdFx0XHRcdFx0XHRcdFx0KGZ1bmN0aW9uKHQ1KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHQ2O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwLCBpdGVtcyA9IGl0ZXIkKHJvb3RbJy4nXSksIGxlbl8gPSBpdGVtcy5sZW5ndGgsIG1ldGgsIHJlczEgPSBbXTsgaiA8IGxlbl87IGorKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWV0aCA9IGl0ZW1zW2pdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFtZXRoLmRlc2MpIHsgY29udGludWU7IH07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXMxLnB1c2goKHQ2ID0gdDVbJyQkYScgKyBqXT10NVsnJCRhJyArIGpdIHx8IHRhZyQuJGRpdigpLmZsYWcoJ2VudHJ5JykpLnNldENvbnRlbnQoKHQ2LiQkYSA9IHQ2LiQkYSB8fCB0YWckLiRkb2NfbGluaygpKS5zZXRPYmplY3QobWV0aCkuZW5kKCksMikuZW5kKCkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlczE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pKHQ1KVxuXHRcdFx0XHRcdFx0XHRcdFx0LDMpLmVuZCgpLFxuXHRcdFx0XHRcdFx0XHRcdFx0KHQ2ID0gdDQuJCRiPXQ0LiQkYiB8fCB0YWckLiRkaXYoKS5mbGFnKCdpbnN0YW5jZScpKS5zZXRDb250ZW50KFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoZnVuY3Rpb24odDYpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgdDc7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDAsIGl0ZW1zID0gaXRlciQocm9vdFsnIyddKSwgbGVuXyA9IGl0ZW1zLmxlbmd0aCwgbWV0aCwgcmVzMSA9IFtdOyBqIDwgbGVuXzsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtZXRoID0gaXRlbXNbal07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIW1ldGguZGVzYykgeyBjb250aW51ZTsgfTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlczEucHVzaCgodDcgPSB0NlsnJCRhJyArIGpdPXQ2WyckJGEnICsgal0gfHwgdGFnJC4kZGl2KCkuZmxhZygnZW50cnknKSkuc2V0Q29udGVudCgodDcuJCRhID0gdDcuJCRhIHx8IHRhZyQuJGRvY19saW5rKCkpLnNldE9iamVjdChtZXRoKS5lbmQoKSwyKS5lbmQoKSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzMTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSkodDYpXG5cdFx0XHRcdFx0XHRcdFx0XHQsMykuZW5kKClcblx0XHRcdFx0XHRcdFx0XHRdLDIpLmVuZCgpXG5cdFx0XHRcdFx0XHRcdF0sMikuZW5kKCkpO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdFx0fSkodDEpXG5cdFx0XHRcdCwzKS5lbmQoKVxuXHRcdFx0LDIpLmVuZCgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cbn0pKClcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZpZXdzL2RvY3MuaW1iYVxuICoqIG1vZHVsZSBpZCA9IDY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKXtcblx0ZnVuY3Rpb24gaXRlciQoYSl7IHJldHVybiBhID8gKGEudG9BcnJheSA/IGEudG9BcnJheSgpIDogYSkgOiBbXTsgfTtcblx0Ly8gZXh0ZXJucztcblx0XG5cdC8vIHZhciBobGpzID0gcmVxdWlyZSAnaGlnaGxpZ2h0LmpzJ1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ3Rvb2wnLCAnYnV0dG9uJywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmFjdGlvbiA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fYWN0aW9uOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRBY3Rpb24gPSBmdW5jdGlvbih2KXsgdGhpcy5fYWN0aW9uID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmZsYWcoJ3N5bScpLnN5bmNlZCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmNsaWNrID0gZnVuY3Rpb24gKGUpe1xuXHRcdFx0dGhpcy5sb2coJ2J1dHRvbiBjbGljaycsZSk7XG5cdFx0XHRyZXR1cm4gZS5oYWx0KCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9udG91Y2hzdGFydCA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHRoaXMubG9nKCd0b3VjaHN0YXJ0Jyk7XG5cdFx0XHR0cnVlO1xuXHRcdFx0cmV0dXJuIGUuZXZlbnQoKS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ3NuaXBwZXQtaGludCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWaWV3ID0gZnVuY3Rpb24odil7IHRoaXMuX3ZpZXcgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0VGV4dChcIkkgYW0gYSBoaW50ISFcIikuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnb3ZlcmxheXMnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fdmlldzsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0VmlldyA9IGZ1bmN0aW9uKHYpeyB0aGlzLl92aWV3ID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciByb290O1xuXHRcdFx0aWYgKHJvb3QgPSB0aGlzLnZpZXcoKS5fcm9vdCkge1xuXHRcdFx0XHR2YXIgbGVmdCA9IDAsdG9wID0gMCxlbCA9IHJvb3QuZG9tKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAoZWwgJiYgIWVsLmNvbnRhaW5zKHRoaXMuX2RvbSkpe1xuXHRcdFx0XHRcdGxlZnQgKz0gZWwub2Zmc2V0TGVmdDtcblx0XHRcdFx0XHR0b3AgKz0gZWwub2Zmc2V0VG9wIC0gZWwuc2Nyb2xsVG9wO1xuXHRcdFx0XHRcdGVsID0gZWwucGFyZW50Tm9kZTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuX2RvbS5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG5cdFx0XHRcdHRoaXMuX2RvbS5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnaGludC1sYWJlbCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRMYWJlbCA9IGZ1bmN0aW9uICh0ZXh0KXtcblx0XHRcdGlmICh0ZXh0ICE9IHRoaXMuX2xhYmVsKSB7XG5cdFx0XHRcdHRoaXMuX2xhYmVsID0gdGV4dDtcblx0XHRcdFx0dGhpcy5kb20oKS5pbm5lckhUTUwgPSB0ZXh0O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ292ZXJsYXktaGludCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24odil7IHRoaXMuc2V0QXR0cmlidXRlKCd0eXBlJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl92aWV3OyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRWaWV3ID0gZnVuY3Rpb24odil7IHRoaXMuX3ZpZXcgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLl9fcm93ID0ge3dhdGNoOiAncm93RGlkU2V0JyxuYW1lOiAncm93J307XG5cdFx0dGFnLnByb3RvdHlwZS5yb3cgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuX3JvdzsgfVxuXHRcdHRhZy5wcm90b3R5cGUuc2V0Um93ID0gZnVuY3Rpb24odil7XG5cdFx0XHR2YXIgYSA9IHRoaXMucm93KCk7XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5fcm93ID0gdjsgfVxuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMucm93RGlkU2V0ICYmIHRoaXMucm93RGlkU2V0KHYsYSx0aGlzLl9fcm93KSB9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuX19jb2wgPSB7d2F0Y2g6ICdjb2xEaWRTZXQnLG5hbWU6ICdjb2wnfTtcblx0XHR0YWcucHJvdG90eXBlLmNvbCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fY29sOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDb2wgPSBmdW5jdGlvbih2KXtcblx0XHRcdHZhciBhID0gdGhpcy5jb2woKTtcblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLl9jb2wgPSB2OyB9XG5cdFx0XHRpZih2ICE9IGEpIHsgdGhpcy5jb2xEaWRTZXQgJiYgdGhpcy5jb2xEaWRTZXQodixhLHRoaXMuX19jb2wpIH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX2xlbiA9IHt3YXRjaDogJ2xlbkRpZFNldCcsbmFtZTogJ2xlbid9O1xuXHRcdHRhZy5wcm90b3R5cGUubGVuID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9sZW47IH1cblx0XHR0YWcucHJvdG90eXBlLnNldExlbiA9IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGEgPSB0aGlzLmxlbigpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuX2xlbiA9IHY7IH1cblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLmxlbkRpZFNldCAmJiB0aGlzLmxlbkRpZFNldCh2LGEsdGhpcy5fX2xlbikgfVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJvd0RpZFNldCA9IGZ1bmN0aW9uIChuZXckLG9sZCl7XG5cdFx0XHR2YXIgdmFsID0gKFwiXCIgKyAodGhpcy5vYmplY3QoKS5yb3coKSAqIHRoaXMudmlldygpLmxpbmVIZWlnaHQoKSkgKyBcInB4XCIpO1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RvbS5zdHlsZS50b3AgPSB2YWw7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbERpZFNldCA9IGZ1bmN0aW9uIChuZXckLG9sZCl7XG5cdFx0XHR2YXIgdmFsID0gKFwiXCIgKyAodGhpcy5vYmplY3QoKS5jb2woKSAqIHRoaXMudmlldygpLmNoYXJXaWR0aCgpKSArIFwicHhcIik7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tLnN0eWxlLmxlZnQgPSB2YWw7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxlbkRpZFNldCA9IGZ1bmN0aW9uIChuZXckLG9sZCl7XG5cdFx0XHR2YXIgd2lkdGggPSAoXCJcIiArIChuZXckICogdGhpcy52aWV3KCkuY2hhcldpZHRoKCkpICsgXCJweFwiKTtcblx0XHRcdHJldHVybiB0aGlzLl9kb20uc3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAnaGludCBhdCcsb2JqZWN0LnJvd1xuXHRcdFx0dmFyIHJlZyA9IHRoaXMub2JqZWN0KCkucmVnaW9uKCk7XG5cdFx0XHRcblx0XHRcdGlmIChyZWcpIHtcblx0XHRcdFx0dGhpcy5zZXRSb3codGhpcy5vYmplY3QoKS5yb3coKSk7XG5cdFx0XHRcdHRoaXMuc2V0Q29sKHRoaXMub2JqZWN0KCkuY29sKCkpO1xuXHRcdFx0XHR0aGlzLnNldExlbihyZWcuc2l6ZSgpKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmZsYWcoJ3dhcm4nKS5mbGFnKCdnbG9iYWwnLCghcmVnKSkuc2V0VHlwZSgodGhpcy5vYmplY3QoKS50eXBlKCkpKS5zZXRDaGlsZHJlbihcblx0XHRcdFx0KHRoaXMuJGEgPSB0aGlzLiRhIHx8IHRhZyQuJGhpbnRfbGFiZWwoKS5mbGFnKCdsYWJlbCcpKS5zZXRMYWJlbCh0aGlzLm9iamVjdCgpLmxhYmVsKCkpLmVuZCgpXG5cdFx0XHQsMikuc3luY2VkKCk7XG5cdFx0fTtcblx0fSk7XG5cdFxuXHR0YWckLmRlZmluZVRhZygnanN2aWV3JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Q2hpbGRyZW4oKHRoaXMuX2NvZGUgPSB0aGlzLl9jb2RlIHx8IHRhZyQuJGNvZGUoKS5zZXRSZWYoJ2NvZGUnLHRoaXMpKS5lbmQoKSwyKS5zeW5jZWQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb2RlLGNiKXtcblx0XHRcdC8vIHNob3VsZCBjb21waWxlIGJhcmVcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGNvZGUgPSBjb2RlLnJlcGxhY2UoL1xcL1xcL1xcIyBzb3VyY2VNYXBwaW5nKC4qKSQvLCcnKTtcblx0XHRcdGNvZGUgPSBjb2RlLnJlcGxhY2UoL15cXChmdW5jdGlvblxcKFxcKVxce1xcbi8sJycpO1xuXHRcdFx0Y29kZSA9IGNvZGUucmVwbGFjZSgvXFxuP1xcfVxcKVxcKFxcKVxcbj8kLywnJyk7XG5cdFx0XHQvLyBjb2RlID0gY29kZS5yZXBsYWNlKC9eXFx0L21nLCcnKVxuXHRcdFx0dGhpcy5fY29kZS50ZXh0Q29udGVudCA9IGNvZGU7XG5cdFx0XHRcblx0XHRcdHRoaXMuZmxhZygnaHVnZScsY29kZS5sZW5ndGggPiAxMDAwKTtcblx0XHRcdFxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0aGxqcy5jb25maWd1cmUoe2NsYXNzUHJlZml4OiAnJ30pO1xuXHRcdFx0XHR2YXIgaGwgPSBobGpzLmhpZ2hsaWdodCgnamF2YXNjcmlwdCcsY29kZSk7XG5cdFx0XHRcdHNlbGYuX2NvZGUuc2V0SHRtbChobC52YWx1ZSk7XG5cdFx0XHRcdHJldHVybiBjYiAmJiBjYihzZWxmKTtcblx0XHRcdH0sMCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2NvbnNvbGUnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZWRpdG9yID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9lZGl0b3I7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEVkaXRvciA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9lZGl0b3IgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmVtcHR5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKHZhbCl7XG5cdFx0XHRjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLGFyZ3VtZW50cyk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmVkaXRvcigpKSB7XG5cdFx0XHRcdHRoaXMuZWRpdG9yKCkuZmxhZygnY29uc29sZScpO1xuXHRcdFx0fTtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdsb2dnaW5nIHZhbCcsdmFsXG5cdFx0XHRcblx0XHRcdGlmICh2YWwgPT0gdGhpcykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodmFsICYmIHZhbC5kb20pIHtcblx0XHRcdFx0dmFsID0gdmFsLmRvbSgpLm91dGVySFRNTDtcblx0XHRcdH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgT2JqZWN0KSB7XG5cdFx0XHRcdHZhbCA9IEpTT04uc3RyaW5naWZ5KHZhbCk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRpZiAodmFsICE9IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLmFwcGVuZCh0YWckLiRkaXYoKS5mbGFnKCdqc29uJykuc2V0Q29udGVudCh2YWwsMCkuZW5kKCkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0XG5cdC8vIHRoaXMgaXMgYmFzaWNhbGx5IGxpa2UgYW4gZWRpdG9yXG5cdHRhZyQuZGVmaW5lVGFnKCdzbmlwcGV0JywgZnVuY3Rpb24odGFnKXtcblx0XHRcblx0XHR2YXIgY291bnRlciA9IDA7XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5pbWJhID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9pbWJhOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRJbWJhID0gZnVuY3Rpb24odil7IHRoaXMuX2ltYmEgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbmZpZyA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5fY29uZmlnOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRDb25maWcgPSBmdW5jdGlvbih2KXsgdGhpcy5fY29uZmlnID0gdjsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX3NyYyA9IHt3YXRjaDogJ3JlbG9hZCcsbmFtZTogJ3NyYyd9O1xuXHRcdHRhZy5wcm90b3R5cGUuc3JjID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9zcmM7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFNyYyA9IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGEgPSB0aGlzLnNyYygpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuX3NyYyA9IHY7IH1cblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLnJlbG9hZCAmJiB0aGlzLnJlbG9hZCh2LGEsdGhpcy5fX3NyYykgfVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmhlYWRpbmcgPSBmdW5jdGlvbih2KXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdoZWFkaW5nJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEhlYWRpbmcgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2hlYWRpbmcnLHYpOyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uKHYpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2xheW91dCcpOyB9XG5cdFx0dGFnLnByb3RvdHlwZS5zZXRMYXlvdXQgPSBmdW5jdGlvbih2KXsgdGhpcy5zZXRBdHRyaWJ1dGUoJ2xheW91dCcsdik7IHJldHVybiB0aGlzOyB9O1xuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudGFiID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgndGFiJyk7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldFRhYiA9IGZ1bmN0aW9uKHYpeyB0aGlzLnNldEF0dHJpYnV0ZSgndGFiJyx2KTsgcmV0dXJuIHRoaXM7IH07XG5cdFx0XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5fX2FjdGl2ZSA9IHt3YXRjaDogJ2FjdGl2ZURpZFNldCcsbmFtZTogJ2FjdGl2ZSd9O1xuXHRcdHRhZy5wcm90b3R5cGUuYWN0aXZlID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9hY3RpdmU7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEFjdGl2ZSA9IGZ1bmN0aW9uKHYpe1xuXHRcdFx0dmFyIGEgPSB0aGlzLmFjdGl2ZSgpO1xuXHRcdFx0aWYodiAhPSBhKSB7IHRoaXMuX2FjdGl2ZSA9IHY7IH1cblx0XHRcdGlmKHYgIT0gYSkgeyB0aGlzLmFjdGl2ZURpZFNldCAmJiB0aGlzLmFjdGl2ZURpZFNldCh2LGEsdGhpcy5fX2FjdGl2ZSkgfVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgZG9tXztcblx0XHRcdHJldHVybiAoZG9tXyA9IHRoaXMuZG9tKCkpLmlkIHx8IChkb21fLmlkID0gKFwic25pcHBldFwiICsgKGNvdW50ZXIrKykpKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYWN0aXZlRGlkU2V0ID0gZnVuY3Rpb24gKGJvb2wpe1xuXHRcdFx0cmV0dXJuIGJvb2wgPyAodGhpcy5zY2hlZHVsZSh7ZnBzOiA2MH0pKSA6ICh0aGlzLnVuc2NoZWR1bGUoKSk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmlucHV0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gKHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQgfHwgdGFnJC4kaW1jYXB0b3IoKS5zZXRSZWYoJ2lucHV0Jyx0aGlzKSkuZW5kKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLl92aWV3IHx8ICh0aGlzLl92aWV3ID0gKHRoaXMuX3ZpZXcgPSB0aGlzLl92aWV3IHx8IHRhZyQuJGltdmlldygpLnNldFJlZigndmlldycsdGhpcykpLnNldElucHV0KHRoaXMuaW5wdXQoKSkuZW5kKCkpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIHQwLCB0MSwgdDIsIHQzLCB0NCwgdDU7XG5cdFx0XHRpZiAoSW1iYS5TRVJWRVIpIHtcblx0XHRcdFx0aWYgKHNlbGYuc3JjKCkgJiYgc2VsZi5zcmMoKS5tYXRjaCgvXFwuaW1iYSQvKSkge1xuXHRcdFx0XHRcdEFQUC5mZXRjaERvY3VtZW50KHNlbGYuc3JjKCksZnVuY3Rpb24ocmVzKSB7XG5cdFx0XHRcdFx0XHR2YXIgdl87XG5cdFx0XHRcdFx0XHRyZXR1cm4gKHNlbGYuc2V0SW1iYSh2XyA9IHJlcy5odG1sKSx2Xyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdC8vIHByZXJlbmRlciBzaGVsbFxuXHRcdFx0XHRzZWxmLnNldENoaWxkcmVuKFtcblx0XHRcdFx0XHQodDAgPSBzZWxmLl9tYWluPXNlbGYuX21haW4gfHwgdGFnJC4kc2VjdGlvbigpLnNldFJlZignbWFpbicsc2VsZikpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdFx0KHQxID0gc2VsZi5faGVhZGVyPXNlbGYuX2hlYWRlciB8fCB0YWckLiRoZWFkZXIoKS5zZXRSZWYoJ2hlYWRlcicsc2VsZikpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdFx0XHQodDIgPSB0MS4kJGE9dDEuJCRhIHx8IHRhZyQuJGRpdigpLmZsYWcoJ3RpdGxlJykuZmxhZygncGF0aCcpKS5zZXRDb250ZW50KHNlbGYuaGVhZGluZygpLDMpLmVuZCgpLFxuXHRcdFx0XHRcdFx0XHQodDMgPSB0MS4kJGI9dDEuJCRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ3Rvb2xzJykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdFx0XHRcdCh0My4kJGEgPSB0My4kJGEgfHwgdGFnJC4kdG9vbCgpLmZsYWcoJ3Jlc2V0Jykuc2V0VGl0bGUoJ3Jlc2V0Jykuc2V0SGFuZGxlcigndGFwJywncmVzZXQnLHNlbGYpKS5zZXRUZXh0KCdyZXNldCcpLmVuZCgpLFxuXHRcdFx0XHRcdFx0XHRcdCh0My4kJGIgPSB0My4kJGIgfHwgdGFnJC4kdG9vbCgpLmZsYWcoJ2pzJykuc2V0VGl0bGUoJ3Nob3cganMnKS5zZXRIYW5kbGVyKCd0YXAnLCd0b2dnbGVKUycsc2VsZikpLnNldFRleHQoJ3Nob3cganMnKS5lbmQoKSxcblx0XHRcdFx0XHRcdFx0XHQodDMuJCRjID0gdDMuJCRjIHx8IHRhZyQuJHRvb2woKS5mbGFnKCdydW4nKS5zZXRUaXRsZSgncnVuJykuc2V0SGFuZGxlcigndGFwJywncnVuJyxzZWxmKSkuc2V0VGV4dCgncnVuJykuZW5kKClcblx0XHRcdFx0XHRcdFx0XSwyKS5lbmQoKVxuXHRcdFx0XHRcdFx0XSwyKS5lbmQoKSxcblx0XHRcdFx0XHRcdCh0NCA9IHNlbGYuX3ZpZXc9c2VsZi5fdmlldyB8fCB0YWckLiRkaXYoKS5zZXRSZWYoJ3ZpZXcnLHNlbGYpKS5zZXRDb250ZW50KCh0NSA9IHQ0LiQkYT10NC4kJGEgfHwgdGFnJC4kY29kZSgpLmZsYWcoJ2ltYmFjb2RlJykpLmRhdGFzZXQoJ3NyYycsKHNlbGYuc3JjKCkpKS5zZXRDb250ZW50KHNlbGYuaW1iYSgpLDMpLmVuZCgpLDIpLmVuZCgpXG5cdFx0XHRcdFx0XSwyKS5lbmQoKSxcblx0XHRcdFx0XHQoc2VsZi5faW5zcGVjdG9yID0gc2VsZi5faW5zcGVjdG9yIHx8IHRhZyQuJGRpdigpLnNldFJlZignaW5zcGVjdG9yJyxzZWxmKSkuZW5kKClcblx0XHRcdFx0XSwyKS5zeW5jZWQoKTtcblx0XHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHR0YWcuX19zdXBlcl9fLmJ1aWxkLmFwcGx5KHNlbGYsYXJndW1lbnRzKTtcblx0XHRcdGlmIChzZWxmLnNyYygpKSB7IHJldHVybiBzZWxmLnJlbG9hZCgpIH07XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnNldENvbmZpZyA9IGZ1bmN0aW9uIChjZmcpe1xuXHRcdFx0dmFyIHZfO1xuXHRcdFx0aWYgKGNmZyAhPSB0aGlzLl9vcHRpb25zKSB7XG5cdFx0XHRcdHRoaXMuX29wdGlvbnMgPSBjZmc7XG5cdFx0XHRcdGlmIChjZmcudGl0bGUpIHsgKHRoaXMuc2V0SGVhZGluZyh2XyA9IGNmZy50aXRsZSksdl8pIH07XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvcHRzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY29wdHMgfHwgKHRoaXMuX2NvcHRzID0ge1xuXHRcdFx0XHRiYXJlOiBmYWxzZSxcblx0XHRcdFx0c3RhbmRhbG9uZTogZmFsc2UsXG5cdFx0XHRcdHNvdXJjZU1hcElubGluZTogdHJ1ZSxcblx0XHRcdFx0ZmlsZW5hbWU6IChcIlwiICsgdGhpcy5pZCgpICsgXCIuaW1iYVwiKSxcblx0XHRcdFx0dGFyZ2V0UGF0aDogKFwiXCIgKyB0aGlzLmlkKCkgKyBcIi5qc1wiKSxcblx0XHRcdFx0c291cmNlUGF0aDogKFwiXCIgKyB0aGlzLmlkKCkgKyBcIi5pbWJhXCIpXG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub3B0aW9uID0gZnVuY3Rpb24gKGtleSl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fb3B0aW9ucyA/ICh0aGlzLl9vcHRpb25zW2tleV0pIDogKG51bGwpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAobyl7XG5cdFx0XHR0aGlzLl9vcHRpb25zID0gbztcblx0XHRcdHJldHVybiB0aGlzLnJlbmRlcigpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hd2FrZW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBjb25maWcgPSB7fTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBjb2RlID0gcSQkKCcuaW1iYWNvZGUnLHRoaXMpLmRvbSgpLmlubmVySFRNTDtcblx0XHRcdH0gY2F0Y2ggKGUpIHsgfTtcblx0XHRcdFxuXHRcdFx0aWYgKGNvZGUpIHtcblx0XHRcdFx0Y29uZmlnLmh0bWwgPSBjb2RlO1xuXHRcdFx0XHR0aGlzLnZpZXcoKS5sb2FkKG51bGwse2h0bWw6IGNvZGV9KTtcblx0XHRcdFx0dGhpcy5jb25maWd1cmUoY29uZmlnKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvZGUsbyl7XG5cdFx0XHRpZihvID09PSB1bmRlZmluZWQpIG8gPSB7fTtcblx0XHRcdGlmIChjb2RlIHx8IG8uaHRtbCkgeyB0aGlzLnZpZXcoKS5sb2FkKGNvZGUsbykgfTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb2RlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy52aWV3KCkuY29kZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKGNvZGUsbyxibGspe1xuXHRcdFx0Ly8gY2FjaGUgbGF0ZXN0IGNvbXBpbGF0aW9uIC0gcmV0dXJuP1xuXHRcdFx0aWYoYmxrPT11bmRlZmluZWQgJiYgdHlwZW9mIG8gPT0gJ2Z1bmN0aW9uJykgYmxrID0gbyxvID0gdGhpcy5jb3B0cygpO1xuXHRcdFx0aWYobz09dW5kZWZpbmVkKSBvID0gdGhpcy5jb3B0cygpO1xuXHRcdFx0cmV0dXJuIFNjcmltYmxhLndvcmtlcigpLmNvbXBpbGUoY29kZSxvLGJsayk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm92ZXJsYXlzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQodGhpcy52aWV3KCkuaGludHMoKSksIGxlbiA9IGFyeS5sZW5ndGgsIGhpbnQsIHJlcyA9IFtdOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0aGludCA9IGFyeVtpXTtcblx0XHRcdFx0aWYgKCFoaW50LmFjdGl2ZSgpKSB7IGNvbnRpbnVlOyB9O1xuXHRcdFx0XHRyZXMucHVzaCgodGhpc1snXycgKyAnaGludCcgKyBpXSA9IHRoaXNbJ18nICsgJ2hpbnQnICsgaV0gfHwgdGFnJC4kb3ZlcmxheV9oaW50KCkpLnNldFZpZXcodGhpcy52aWV3KCkpLnNldE9iamVjdChoaW50KS5lbmQoKSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUudG9nZ2xlSlMgPSBmdW5jdGlvbiAoKXtcblx0XHRcdGlmICh0aGlzLnRhYigpICE9ICdqcycpIHtcblx0XHRcdFx0dGhpcy5zaG93anMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuc2V0VGFiKCdpbWJhJyk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9uaW5wdXRmb2N1cyA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdFZJRVcgPSB0aGlzOyAvLyBoYWNrXG5cdFx0XHR0aGlzLmZsYWcoJ2ZvY3VzJyk7XG5cdFx0XHRyZXR1cm4gKHRoaXMuc2V0QWN0aXZlKHRydWUpLHRydWUpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmlucHV0Ymx1ciA9IGZ1bmN0aW9uIChlKXtcblx0XHRcdHRoaXMudW5mbGFnKCdmb2N1cycpO1xuXHRcdFx0dmFyIHJlbCA9IGUuZXZlbnQoKS5yZWxhdGVkVGFyZ2V0O1xuXHRcdFx0aWYgKCEocmVsICYmIHRoaXMuZG9tKCkuY29udGFpbnMocmVsKSkpIHtcblx0XHRcdFx0dGhpcy51bmZsYWcoJ2ZvY3VzJyk7XG5cdFx0XHRcdHRoaXMuc2V0QWN0aXZlKGZhbHNlKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgdDAsIHQxLCB0MiwgdDMsIHQ0LCB0NTtcblx0XHRcdGlmIChJbWJhLlNFUlZFUikgeyByZXR1cm4gdGhpcyB9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDaGlsZHJlbihbXG5cdFx0XHRcdHRoaXMuX2lucHV0LFxuXHRcdFx0XHQodDAgPSB0aGlzLl9tYWluPXRoaXMuX21haW4gfHwgdGFnJC4kc2VjdGlvbigpLnNldFJlZignbWFpbicsdGhpcykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdCh0MSA9IHRoaXMuX2hlYWRlcj10aGlzLl9oZWFkZXIgfHwgdGFnJC4kaGVhZGVyKCkuc2V0UmVmKCdoZWFkZXInLHRoaXMpKS5zZXRDb250ZW50KFtcblx0XHRcdFx0XHRcdCh0MiA9IHQxLiQkYT10MS4kJGEgfHwgdGFnJC4kZGl2KCkuZmxhZygndGl0bGUnKS5mbGFnKCdwYXRoJykpLnNldENvbnRlbnQodGhpcy5oZWFkaW5nKCksMykuZW5kKCksXG5cdFx0XHRcdFx0XHQodDMgPSB0MS4kJGI9dDEuJCRiIHx8IHRhZyQuJGRpdigpLmZsYWcoJ3Rvb2xzJykpLnNldENvbnRlbnQoW1xuXHRcdFx0XHRcdFx0XHQodDMuJCRhID0gdDMuJCRhIHx8IHRhZyQuJHRvb2woKS5mbGFnKCdyZXNldCcpLnNldFRpdGxlKCdyZXNldCcpLnNldEhhbmRsZXIoJ3RhcCcsJ3Jlc2V0Jyx0aGlzKSkuc2V0VGV4dCgncmVzZXQnKS5lbmQoKSxcblx0XHRcdFx0XHRcdFx0KHQzLiQkYiA9IHQzLiQkYiB8fCB0YWckLiR0b29sKCkuZmxhZygnanMnKS5zZXRUaXRsZSgnc2hvdyBqcycpLnNldEhhbmRsZXIoJ3RhcCcsJ3RvZ2dsZUpTJyx0aGlzKSkuc2V0VGV4dCgnc2hvdyBqcycpLmVuZCgpLFxuXHRcdFx0XHRcdFx0XHQodDMuJCRjID0gdDMuJCRjIHx8IHRhZyQuJHRvb2woKS5mbGFnKCdydW4nKS5zZXRUaXRsZSgncnVuJykuc2V0SGFuZGxlcigndGFwJywncnVuJyx0aGlzKSkuc2V0VGV4dCgncnVuJykuZW5kKClcblx0XHRcdFx0XHRcdF0sMikuZW5kKClcblx0XHRcdFx0XHRdLDIpLmVuZCgpLFxuXHRcdFx0XHRcdCh0NCA9IHRoaXMuX292ZXJsYXlzPXRoaXMuX292ZXJsYXlzIHx8IHRhZyQuJG92ZXJsYXlzKCkuc2V0UmVmKCdvdmVybGF5cycsdGhpcykpLnNldFZpZXcodGhpcy52aWV3KCkpLnNldENvbnRlbnQodGhpcy5vdmVybGF5cygpLDMpLmVuZCgpLFxuXHRcdFx0XHRcdCh0aGlzLl9qc3ZpZXcgPSB0aGlzLl9qc3ZpZXcgfHwgdGFnJC4kanN2aWV3KCkuc2V0UmVmKCdqc3ZpZXcnLHRoaXMpKS5lbmQoKSxcblx0XHRcdFx0XHR0aGlzLl92aWV3LmVuZCgpLFxuXHRcdFx0XHRcdCh0aGlzLl9jb25zb2xlID0gdGhpcy5fY29uc29sZSB8fCB0YWckLiRjb25zb2xlKCkuc2V0UmVmKCdjb25zb2xlJyx0aGlzKS5mbGFnKCdkYXJrJykpLnNldEVkaXRvcih0aGlzKS5lbmQoKVxuXHRcdFx0XHRdLDEpLmVuZCgpLFxuXHRcdFx0XHQodDUgPSB0aGlzLl9pbnNwZWN0b3I9dGhpcy5faW5zcGVjdG9yIHx8IHRhZyQuJGRpdigpLnNldFJlZignaW5zcGVjdG9yJyx0aGlzKSkuc2V0Q29udGVudCh0aGlzLnBsYXlncm91bmQoKSwzKS5lbmQoKVxuXHRcdFx0XSwxKS5zeW5jZWQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2FuZGJveCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuICh0aGlzLl9zYW5kYm94ID0gdGhpcy5fc2FuZGJveCB8fCB0YWckLiRzYW5kYm94KCkuc2V0UmVmKCdzYW5kYm94Jyx0aGlzKS5mbGFnKCdwbGF5Z3JvdW5kJykpLnNldEVkaXRvcih0aGlzKS5lbmQoKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucGxheWdyb3VuZCA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMuc2FuZGJveCgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5yZWxvYWQgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGlmICghc2VsZi5fYnVpbHQpIHsgcmV0dXJuIH07XG5cdFx0XHRcblx0XHRcdGlmIChERVBTW3NlbGYuc3JjKCldKSB7XG5cdFx0XHRcdHZhciByZXMgPSBERVBTW3NlbGYuc3JjKCldO1xuXHRcdFx0XHRzZWxmLnZpZXcoKS5sb2FkKG51bGwse2h0bWw6IHJlcy5odG1sLGZpbGVuYW1lOiBzZWxmLnNyYygpfSk7XG5cdFx0XHRcdGlmIChzZWxmLmF1dG9ydW4oKSkge1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLnJ1bigpOyB9LDUwKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHQvLyBnZXQgaW1iYSBkb2N1bWVudD8hP1xuXHRcdFx0QVBQLmZldGNoRG9jdW1lbnQoc2VsZi5zcmMoKSxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0c2VsZi52aWV3KCkubG9hZChyZXMuYm9keSx7ZmlsZW5hbWU6IHNlbGYuc3JjKCl9KTtcblx0XHRcdFx0aWYgKHNlbGYuYXV0b3J1bigpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLnJ1bigpOyB9LDUwKTtcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLm9ucnVuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5ydW4oKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuYXV0b3J1biA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmVkaXRlZGFzeW5jID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLmZsYWcoJ2RpcnR5Jyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25zYXZlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR0aGlzLnZpZXcoKS5oaW50cygpLmNsZWFyKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5ydW4oKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoZSl7XG5cdFx0XHR0aGlzLl9jb25zb2xlLnJlc2V0KCk7XG5cdFx0XHRpZiAodGhpcy5fb3B0aW9ucy5odG1sKSB7XG5cdFx0XHRcdHRoaXMudmlldygpLmxvYWQobnVsbCx7aHRtbDogdGhpcy5fb3B0aW9ucy5odG1sfSk7XG5cdFx0XHR9O1xuXHRcdFx0aWYgKGUpIHtcblx0XHRcdFx0ZS5jYW5jZWwoKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLnVuZmxhZygnZGlydHknKTtcblx0XHRcdHRoaXMudmlldygpLmNhcmV0KCkubm9ybWFsaXplKCkuZGlydHkoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHNlbGYuZmxhZygncnVubmluZycpO1xuXHRcdFx0c2VsZi5jb21waWxlKHNlbGYuY29kZSgpLHNlbGYuY29wdHMoKSxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0c2VsZi52aWV3KCkuaGludHMoKS5yZW0oZnVuY3Rpb24oaGludCkgeyByZXR1cm4gaGludC5ncm91cCgpID09ICdydW50aW1lJzsgfSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocmVzLmRhdGEgJiYgcmVzLmRhdGEuY29kZSkge1xuXHRcdFx0XHRcdC8vIEBqc3ZpZXcubG9hZChyZXM6ZGF0YTpjb2RlKSBpZiByZXM6ZGF0YVxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2VsZi5fc2FuZGJveC5ydW4ocmVzLmRhdGEpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiBjb25zb2xlLmxvZygnZXJyb3InKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuc2hvd2pzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR2YXIgbyA9IHtiYXJlOiB0cnVlLHN0YW5kYWxvbmU6IGZhbHNlLGZpbGVuYW1lOiAnYS5pbWJhJ307XG5cdFx0XHRcblx0XHRcdHJldHVybiBzZWxmLmNvbXBpbGUoc2VsZi5jb2RlKCksbyxmdW5jdGlvbihyZXMpIHtcblx0XHRcdFx0aWYgKHJlcy5kYXRhICYmIHJlcy5kYXRhLmNvZGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi5fanN2aWV3LmxvYWQocmVzLmRhdGEuY29kZSxmdW5jdGlvbigpIHsgdmFyIHZfO1xuXHRcdFx0XHRcdHJldHVybiAoc2VsZi5zZXRUYWIodl8gPSAnanMnKSx2Xyk7IH0pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJlcy5kYXRhICYmIHJlcy5kYXRhLmVycm9yKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbnNvbGUubG9nKCdoYXMgZXJyb3InKTtcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ydW5FcnJvciA9IGZ1bmN0aW9uIChvKXtcblx0XHRcdG8udHlwZSA9ICdlcnJvcic7XG5cdFx0XHRvLmdyb3VwID0gJ3J1bnRpbWUnO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cgJ3J1bkVycm9yJyxvXG5cdFx0XHQvLyBvbmx5IHNob3cgZXJyb3IgaWYgd2UgaGF2ZSBhIGxpbmUgYW5kIGNvbHVtblxuXHRcdFx0cmV0dXJuIHRoaXMudmlldygpLmhpbnRzKCkuYWRkKG8pLmFjdGl2YXRlKCk7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJ1bkxvZyA9IGZ1bmN0aW9uIChvKXtcblx0XHRcdG8udHlwZSA9ICdsb2cnO1xuXHRcdFx0by5ncm91cCA9ICdydW50aW1lJztcblx0XHRcdG8ubWVzc2FnZSB8fCAoby5tZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoby5wYXJhbXNbMF0pKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nICdydW5Mb2cnLG9cblx0XHRcdFxuXHRcdFx0aWYgKG8ubnIgIT0gbnVsbCAmJiAhby5sb2MpIHtcblx0XHRcdFx0dmFyIGxvZ3MgPSB0aGlzLnZpZXcoKS5maW5kKCcuaWRlbnRpZmllci5sb2csLmlkZW50aWZpZXJbbmFtZT1cImxvZ1wiXScpLnRvQXJyYXkoKTtcblx0XHRcdFx0dmFyIG5vZGUgPSBsb2dzW28ubnJdO1xuXHRcdFx0XHRcblx0XHRcdFx0by5ub2RlID0gbm9kZTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChub2RlKSB7XG5cdFx0XHRcdFx0dmFyIHJlZyA9IG5vZGUucmVnaW9uKCk7IC8vIG5vZGUubmV4dCA/IG5vZGUubmV4dC5yZWdpb24gOiBcblx0XHRcdFx0XHRjb25zb2xlLmxvZygnZm91bmQgbG9jISEnLG5vZGUscmVnKTtcblx0XHRcdFx0XHQvLyBsZXQgY29sID0gdmlldy5idWZmZXIubGluZShyZWcucm93KVs6bGVuZ3RoXVxuXHRcdFx0XHRcdG8ubG9jID0gcmVnLmVuZEF0TGluZSgpLmNvbGxhcHNlKCk7IC8vIHtsaW5lOiByZWcucm93LCBjb2x1bW46IGNvbH0gIyAgcmVnLnRvSlNPTiAjIHtsaW5lOiByZWcucm93LCBjb2x1bW46IDEwMH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBvOmxvYyA9IGxvZ3Nbbzpucl0ucmVnaW9uLnRvSlNPTlxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0aGlzLnZpZXcoKS5oaW50cygpLmFkZChvKS5hY3RpdmF0ZSgpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ydW5SZXN1bHQgPSBmdW5jdGlvbiAobyl7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyAncnVuUmVzdWx0JyxvXG5cdFx0XHR0aGlzLmZsYWcoJ3JlcGwnLCEhbyk7XG5cdFx0XHR0aGlzLl9jb25zb2xlLmxvZyhvKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pO1xuXHRcblx0dGFnJC5kZWZpbmVUYWcoJ2V4YW1wbGUnLCAnc25pcHBldCcsIGZ1bmN0aW9uKHRhZyl7XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5hdXRvcnVuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHR9KTtcblx0XG5cdGlmICghSW1iYS5TRVJWRVIpIHtcblx0XHRJbWJhLkV2ZW50LlBST0NFU1NJTkc7XG5cdFx0XG5cdFx0XG5cdFx0XHRcblx0XHRcdHZhciBwcmV2ID0gSW1iYS5FdmVudC5wcm90b3R5cGUucHJvY2Vzcztcblx0XHRcdFxuXHRcdFx0SW1iYS5FdmVudC5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0XHRJbWJhLkV2ZW50LlBST0NFU1NJTkcgPSB0aGlzO1xuXHRcdFx0XHRyZXR1cm4gcHJldi5jYWxsKHRoaXMpO1xuXHRcdFx0fTtcblx0XHRcblx0fTtcblx0XG5cdFxuXHRyZXR1cm4gdGFnJC5kZWZpbmVUYWcoJ3NhbmRib3gnLCBmdW5jdGlvbih0YWcpe1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUuZWRpdG9yID0gZnVuY3Rpb24odil7IHJldHVybiB0aGlzLl9lZGl0b3I7IH1cblx0XHR0YWcucHJvdG90eXBlLnNldEVkaXRvciA9IGZ1bmN0aW9uKHYpeyB0aGlzLl9lZGl0b3IgPSB2OyByZXR1cm4gdGhpczsgfTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmNvbnNvbGUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVybiB0aGlzLmVkaXRvcigpLl9jb25zb2xlO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24gKG1zZyx1cmwsbGluZSxjb2wsZXJyKXtcblx0XHRcdFxuXHRcdFx0dmFyIHN0YWNrXztcblx0XHRcdGlmICh1cmwubWF0Y2goL3NuaXBwZXQoXFxkKylcXC4oaW1iYXxqcykvKSkge1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGlkID0gdXJsLnNwbGl0KCcuJykuc2hpZnQoKTtcblx0XHRcdFx0dmFyIHNuaXBwZXQgPSB0YWckd3JhcChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHNuaXBwZXQpIHtcblx0XHRcdFx0XHRzbmlwcGV0LnBsYXlncm91bmQoKS5vbmVycm9yKG1zZywnJyxsaW5lLGNvbCxlcnIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAodXJsID09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdC8vIHNhZmFyaT9cblx0XHRcdFx0dmFyIGV2ID0gSW1iYS5FdmVudC5QUk9DRVNTSU5HO1xuXHRcdFx0XHRjb25zb2xlLmxvZygnbGFzdCBldmVudCB0YXJnZXQnLGV2ICYmIGV2LnRhcmdldCgpKTtcblx0XHRcdFx0aWYgKGV2ICYmIGV2LnRhcmdldCgpKSB7XG5cdFx0XHRcdFx0c25pcHBldCA9IGV2LnRhcmdldCgpLmNsb3Nlc3QocSQoJy5fc25pcHBldCcsdGhpcykpO1xuXHRcdFx0XHRcdGlmIChzbmlwcGV0KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc25pcHBldC5wbGF5Z3JvdW5kKCkub25lcnJvcihtc2csJycsbGluZSxjb2wsZXJyKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y29uc29sZS5sb2coJ2NhdWdodCB0aGUgZXJyb3IgaGVyZSEhIScsYXJndW1lbnRzLHRoaXMpO1xuXHRcdFx0dmFyIGxvY3MgPSBbXTtcblx0XHRcdFxuXHRcdFx0ZXJyICYmIChzdGFja18gPSBlcnIuc3RhY2spICYmIHN0YWNrXy5yZXBsYWNlICAmJiAgc3RhY2tfLnJlcGxhY2UoLyhcXDxhbm9ueW1vdXNcXD58c25pcHBldFxcZCtcXC5pbWJhKVxcOihcXGQrKTooXFxkKykvZyxmdW5jdGlvbihtLHNvdXJjZSxsaW5lLGNvbCkge1xuXHRcdFx0XHRsb2NzLnB1c2goe2xpbmU6IHBhcnNlSW50KGxpbmUpLGNvbHVtbjogcGFyc2VJbnQoY29sKX0pO1xuXHRcdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRsb2NzLnB1c2goe2xpbmU6IGxpbmUsY29sdW1uOiBjb2x9KTtcblx0XHRcdFxuXHRcdFx0aWYgKGxvY3NbMF0pIHtcblx0XHRcdFx0dmFyIG1hcCA9IHRoaXMub2JqZWN0KCkuc291cmNlbWFwO1xuXHRcdFx0XHR2YXIgY29uc3VtZXIgPSBTY3JpbWJsYS5Tb3VyY2VNYXAuU291cmNlTWFwQ29uc3VtZXIobWFwKTtcblx0XHRcdFx0dmFyIGxvYyA9IGNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3IobG9jc1swXSk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdvcmlnaW5hbCBsb2NhdGlvbiBpcycsbG9jKTtcblx0XHRcdFx0dGhpcy5lZGl0b3IoKS5ydW5FcnJvcih7bWVzc2FnZTogbXNnLGxvYzogbG9jfSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUub25sb2cgPSBmdW5jdGlvbiAobnIscGFycyl7XG5cdFx0XHR0aGlzLmVkaXRvcigpLnJ1bkxvZyh7bnI6IG5yLHBhcmFtczogcGFyc30pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHR0YWcucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYXJ5ID0gaXRlciQocSQoJy5zY2hlZHVsZWRfJyx0aGlzKSksIGxlbiA9IGFyeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRhcnlbaV0udW5zY2hlZHVsZSgpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0YWcuX19zdXBlcl9fLmVtcHR5LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHRhZy5wcm90b3R5cGUucHJlc2VudCA9IGZ1bmN0aW9uIChyZXMpe1xuXHRcdFx0dmFyIG5vZGU7XG5cdFx0XHRpZiAocmVzICYmIChyZXMucHJvdG90eXBlIGluc3RhbmNlb2YgSW1iYS5UYWcpKSB7XG5cdFx0XHRcdG5vZGUgPSBuZXcgcmVzKHJlcy5jcmVhdGVOb2RlKCkpO1xuXHRcdFx0fSBlbHNlIGlmIChyZXMgaW5zdGFuY2VvZiBJbWJhLlRhZykge1xuXHRcdFx0XHRub2RlID0gcmVzO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKG5vZGUpIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZChub2RlKTtcblx0XHRcdFx0bm9kZS5lbmQoKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmNvbnNvbGUoKS5sb2cobm9kZSB8fCByZXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0dGFnLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoc3JjKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciBjb2RlID0gc3JjLmNvZGU7XG5cdFx0XHRpZiAoIWNvZGUpIHsgcmV0dXJuIHNlbGYgfTtcblx0XHRcdFxuXHRcdFx0c2VsZi5fb2JqZWN0ID0gc3JjO1xuXHRcdFx0XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR3aW5kb3cub25lcnJvciA9IGZ1bmN0aW9uKG1zZyx1cmwsbGluZSxjb2wsZXJyKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ2NhdWdodCBlcnJvcicsbXNnLHVybCxsaW5lLGNvbCxlcnIsdGhpcyk7XG5cdFx0XHRcdFx0cmV0dXJuIHNlbGYub25lcnJvcihtc2csdXJsLGxpbmUsY29sLGVycik7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRjb2RlID0gY29kZSArICdcXG4vLyMgc291cmNlVVJMPScgKyBzZWxmLmVkaXRvcigpLmlkKCkgKyAnLmltYmEnO1xuXHRcdFx0XHR2YXIgdGFnJCA9IEltYmEuVEFHUy5fX2Nsb25lKCk7XG5cdFx0XHRcdHZhciBjb25zb2xlID0gc2VsZi5jb25zb2xlKCk7XG5cdFx0XHRcdHZhciByZXMgPSBldmFsKGNvZGUpO1xuXHRcdFx0XHRzZWxmLnByZXNlbnQocmVzKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0c2VsZi5sb2coJ2ltbWVkaWF0ZSBlcnJvciBpbiBldmFsLWlubGluZScsZSk7XG5cdFx0XHRcdHNlbGYub25lcnJvcihlLm1lc3NhZ2UsJycsZS5saW5lTnIgfHwgZS5saW5lIHx8IDAsZS5jb2x1bW4sZSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHR9KTtcblxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvdmlld3Mvc25pcHBldC5pbWJhXG4gKiogbW9kdWxlIGlkID0gNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=